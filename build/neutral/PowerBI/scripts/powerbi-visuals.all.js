(function(window, undefined) {
    var Globalize, regexHex, regexInfinity, regexParseFloat, regexTrim, arrayIndexOf, endsWith, extend, isArray, isFunction, isObject, startsWith, trim, truncate, zeroPad, appendPreOrPostMatch, expandFormat, formatDate, formatNumber, getTokenRegExp, getEra, getEraYear, parseExact, parseNegativePattern;
    Globalize = function(cultureSelector) {
        return new Globalize.prototype.init(cultureSelector);
    };
    if (typeof require !== "undefined" && typeof exports !== "undefined" && typeof module !== "undefined") {
        module.exports = Globalize;
    } else {
        window.Globalize = Globalize;
    }
    Globalize.cultures = {};
    Globalize.prototype = {
        constructor: Globalize,
        init: function(cultureSelector) {
            this.cultures = Globalize.cultures;
            this.cultureSelector = cultureSelector;
            return this;
        }
    };
    Globalize.prototype.init.prototype = Globalize.prototype;
    Globalize.cultures["default"] = {
        name: "en",
        englishName: "English",
        nativeName: "English",
        isRTL: false,
        language: "en",
        numberFormat: {
            pattern: [ "-n" ],
            decimals: 2,
            ",": ",",
            ".": ".",
            groupSizes: [ 3 ],
            "+": "+",
            "-": "-",
            NaN: "NaN",
            negativeInfinity: "-Infinity",
            positiveInfinity: "Infinity",
            percent: {
                pattern: [ "-n %", "n %" ],
                decimals: 2,
                groupSizes: [ 3 ],
                ",": ",",
                ".": ".",
                symbol: "%"
            },
            currency: {
                pattern: [ "($n)", "$n" ],
                decimals: 2,
                groupSizes: [ 3 ],
                ",": ",",
                ".": ".",
                symbol: "$"
            }
        },
        calendars: {
            standard: {
                name: "Gregorian_USEnglish",
                "/": "/",
                ":": ":",
                firstDay: 0,
                days: {
                    names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                    namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                    namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
                },
                months: {
                    names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
                },
                AM: [ "AM", "am", "AM" ],
                PM: [ "PM", "pm", "PM" ],
                eras: [ {
                    name: "A.D.",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 2029,
                patterns: {
                    d: "M/d/yyyy",
                    D: "dddd, MMMM dd, yyyy",
                    t: "h:mm tt",
                    T: "h:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy h:mm tt",
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    M: "MMMM dd",
                    Y: "yyyy MMMM",
                    S: "yyyy'-'MM'-'dd'T'HH':'mm':'ss"
                }
            }
        },
        messages: {}
    };
    Globalize.cultures["default"].calendar = Globalize.cultures["default"].calendars.standard;
    Globalize.cultures.en = Globalize.cultures["default"];
    Globalize.cultureSelector = "en";
    regexHex = /^0x[a-f0-9]+$/i;
    regexInfinity = /^[+\-]?infinity$/i;
    regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
    regexTrim = /^\s+|\s+$/g;
    arrayIndexOf = function(array, item) {
        if (array.indexOf) {
            return array.indexOf(item);
        }
        for (var i = 0, length = array.length; i < length; i++) {
            if (array[i] === item) {
                return i;
            }
        }
        return -1;
    };
    endsWith = function(value, pattern) {
        return value.substr(value.length - pattern.length) === pattern;
    };
    extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i = 2;
        }
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (isObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];
                        } else {
                            clone = src && isObject(src) ? src : {};
                        }
                        target[name] = extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    isFunction = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Function]";
    };
    isObject = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
    };
    startsWith = function(value, pattern) {
        return value.indexOf(pattern) === 0;
    };
    trim = function(value) {
        return (value + "").replace(regexTrim, "");
    };
    truncate = function(value) {
        if (isNaN(value)) {
            return NaN;
        }
        return Math[value < 0 ? "ceil" : "floor"](value);
    };
    zeroPad = function(str, count, left) {
        var l;
        for (l = str.length; l < count; l += 1) {
            str = left ? "0" + str : str + "0";
        }
        return str;
    };
    appendPreOrPostMatch = function(preMatch, strings) {
        var quoteCount = 0, escaped = false;
        for (var i = 0, il = preMatch.length; i < il; i++) {
            var c = preMatch.charAt(i);
            switch (c) {
              case "'":
                if (escaped) {
                    strings.push("'");
                } else {
                    quoteCount++;
                }
                escaped = false;
                break;

              case "\\":
                if (escaped) {
                    strings.push("\\");
                }
                escaped = !escaped;
                break;

              default:
                strings.push(c);
                escaped = false;
                break;
            }
        }
        return quoteCount;
    };
    expandFormat = function(cal, format) {
        format = format || "F";
        var pattern, patterns = cal.patterns, len = format.length;
        if (len === 1) {
            pattern = patterns[format];
            if (!pattern) {
                throw "Invalid date format string '" + format + "'.";
            }
            format = pattern;
        } else if (len === 2 && format.charAt(0) === "%") {
            format = format.charAt(1);
        }
        return format;
    };
    formatDate = function(value, format, culture) {
        var cal = culture.calendar, convert = cal.convert, ret;
        if (!format || !format.length || format === "i") {
            if (culture && culture.name.length) {
                if (convert) {
                    ret = formatDate(value, cal.patterns.F, culture);
                } else {
                    var eraDate = new Date(value.getTime()), era = getEra(value, cal.eras);
                    eraDate.setFullYear(getEraYear(value, cal, era));
                    ret = eraDate.toLocaleString();
                }
            } else {
                ret = value.toString();
            }
            return ret;
        }
        var eras = cal.eras, sortable = format === "s";
        format = expandFormat(cal, format);
        ret = [];
        var hour, zeros = [ "0", "00", "000" ], foundDay, checkedDay, dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g, quoteCount = 0, tokenRegExp = getTokenRegExp(), converted;
        function padZeros(num, c) {
            var r, s = num + "";
            if (c > 1 && s.length < c) {
                r = zeros[c - 2] + s;
                return r.substr(r.length - c, c);
            } else {
                r = s;
            }
            return r;
        }
        function hasDay() {
            if (foundDay || checkedDay) {
                return foundDay;
            }
            foundDay = dayPartRegExp.test(format);
            checkedDay = true;
            return foundDay;
        }
        function getPart(date, part) {
            if (converted) {
                return converted[part];
            }
            switch (part) {
              case 0:
                return date.getFullYear();

              case 1:
                return date.getMonth();

              case 2:
                return date.getDate();

              default:
                throw "Invalid part value " + part;
            }
        }
        if (!sortable && convert) {
            converted = convert.fromGregorian(value);
        }
        for (;;) {
            var index = tokenRegExp.lastIndex, ar = tokenRegExp.exec(format);
            var preMatch = format.slice(index, ar ? ar.index : format.length);
            quoteCount += appendPreOrPostMatch(preMatch, ret);
            if (!ar) {
                break;
            }
            if (quoteCount % 2) {
                ret.push(ar[0]);
                continue;
            }
            var current = ar[0], clength = current.length;
            switch (current) {
              case "ddd":
              case "dddd":
                var names = clength === 3 ? cal.days.namesAbbr : cal.days.names;
                ret.push(names[value.getDay()]);
                break;

              case "d":
              case "dd":
                foundDay = true;
                ret.push(padZeros(getPart(value, 2), clength));
                break;

              case "MMM":
              case "MMMM":
                var part = getPart(value, 1);
                ret.push(cal.monthsGenitive && hasDay() ? cal.monthsGenitive[clength === 3 ? "namesAbbr" : "names"][part] : cal.months[clength === 3 ? "namesAbbr" : "names"][part]);
                break;

              case "M":
              case "MM":
                ret.push(padZeros(getPart(value, 1) + 1, clength));
                break;

              case "y":
              case "yy":
              case "yyyy":
                part = converted ? converted[0] : getEraYear(value, cal, getEra(value, eras), sortable);
                if (clength < 4) {
                    part = part % 100;
                }
                ret.push(padZeros(part, clength));
                break;

              case "h":
              case "hh":
                hour = value.getHours() % 12;
                if (hour === 0) hour = 12;
                ret.push(padZeros(hour, clength));
                break;

              case "H":
              case "HH":
                ret.push(padZeros(value.getHours(), clength));
                break;

              case "m":
              case "mm":
                ret.push(padZeros(value.getMinutes(), clength));
                break;

              case "s":
              case "ss":
                ret.push(padZeros(value.getSeconds(), clength));
                break;

              case "t":
              case "tt":
                part = value.getHours() < 12 ? cal.AM ? cal.AM[0] : " " : cal.PM ? cal.PM[0] : " ";
                ret.push(clength === 1 ? part.charAt(0) : part);
                break;

              case "f":
              case "ff":
              case "fff":
                ret.push(padZeros(value.getMilliseconds(), 3).substr(0, clength));
                break;

              case "z":
              case "zz":
                hour = value.getTimezoneOffset() / 60;
                ret.push((hour <= 0 ? "+" : "-") + padZeros(Math.floor(Math.abs(hour)), clength));
                break;

              case "zzz":
                hour = value.getTimezoneOffset() / 60;
                ret.push((hour <= 0 ? "+" : "-") + padZeros(Math.floor(Math.abs(hour)), 2) + ":" + padZeros(Math.abs(value.getTimezoneOffset() % 60), 2));
                break;

              case "g":
              case "gg":
                if (cal.eras) {
                    ret.push(cal.eras[getEra(value, eras)].name);
                }
                break;

              case "/":
                ret.push(cal["/"]);
                break;

              default:
                throw "Invalid date format pattern '" + current + "'.";
            }
        }
        return ret.join("");
    };
    (function() {
        var expandNumber;
        expandNumber = function(number, precision, formatInfo) {
            var groupSizes = formatInfo.groupSizes, curSize = groupSizes[0], curGroupIndex = 1, factor = Math.pow(10, precision), rounded = Math.round(number * factor) / factor;
            if (!isFinite(rounded)) {
                rounded = number;
            }
            number = rounded;
            var numberString = number + "", right = "", split = numberString.split(/e/i), exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
            numberString = split[0];
            split = numberString.split(".");
            numberString = split[0];
            right = split.length > 1 ? split[1] : "";
            var l;
            if (exponent > 0) {
                right = zeroPad(right, exponent, false);
                numberString += right.slice(0, exponent);
                right = right.substr(exponent);
            } else if (exponent < 0) {
                exponent = -exponent;
                numberString = zeroPad(numberString, exponent + 1, true);
                right = numberString.slice(-exponent, numberString.length) + right;
                numberString = numberString.slice(0, -exponent);
            }
            if (precision > 0) {
                right = formatInfo["."] + (right.length > precision ? right.slice(0, precision) : zeroPad(right, precision));
            } else {
                right = "";
            }
            var stringIndex = numberString.length - 1, sep = formatInfo[","], ret = "";
            while (stringIndex >= 0) {
                if (curSize === 0 || curSize > stringIndex) {
                    return numberString.slice(0, stringIndex + 1) + (ret.length ? sep + ret + right : right);
                }
                ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + (ret.length ? sep + ret : "");
                stringIndex -= curSize;
                if (curGroupIndex < groupSizes.length) {
                    curSize = groupSizes[curGroupIndex];
                    curGroupIndex++;
                }
            }
            return numberString.slice(0, stringIndex + 1) + sep + ret + right;
        };
        formatNumber = function(value, format, culture) {
            if (!isFinite(value)) {
                if (value === Infinity) {
                    return culture.numberFormat.positiveInfinity;
                }
                if (value === -Infinity) {
                    return culture.numberFormat.negativeInfinity;
                }
                return culture.numberFormat["NaN"];
            }
            if (!format || format === "i") {
                return culture.name.length ? value.toLocaleString() : value.toString();
            }
            format = format || "D";
            var nf = culture.numberFormat, number = Math.abs(value), precision = -1, pattern;
            if (format.length > 1) precision = parseInt(format.slice(1), 10);
            var current = format.charAt(0).toUpperCase(), formatInfo;
            switch (current) {
              case "D":
                pattern = "n";
                number = truncate(number);
                if (precision !== -1) {
                    number = zeroPad("" + number, precision, true);
                }
                if (value < 0) number = "-" + number;
                break;

              case "N":
                formatInfo = nf;

              case "C":
                formatInfo = formatInfo || nf.currency;

              case "P":
                formatInfo = formatInfo || nf.percent;
                pattern = value < 0 ? formatInfo.pattern[0] : formatInfo.pattern[1] || "n";
                if (precision === -1) precision = formatInfo.decimals;
                number = expandNumber(number * (current === "P" ? 100 : 1), precision, formatInfo);
                break;

              default:
                throw "Bad number format specifier: " + current;
            }
            var patternParts = /n|\$|-|%/g, ret = "";
            for (;;) {
                var index = patternParts.lastIndex, ar = patternParts.exec(pattern);
                ret += pattern.slice(index, ar ? ar.index : pattern.length);
                if (!ar) {
                    break;
                }
                switch (ar[0]) {
                  case "n":
                    ret += number;
                    break;

                  case "$":
                    ret += nf.currency.symbol;
                    break;

                  case "-":
                    if (/[1-9]/.test(number)) {
                        ret += nf["-"];
                    }
                    break;

                  case "%":
                    ret += nf.percent.symbol;
                    break;
                }
            }
            return ret;
        };
    })();
    getTokenRegExp = function() {
        return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;
    };
    getEra = function(date, eras) {
        if (!eras) return 0;
        var start, ticks = date.getTime();
        for (var i = 0, l = eras.length; i < l; i++) {
            start = eras[i].start;
            if (start === null || ticks >= start) {
                return i;
            }
        }
        return 0;
    };
    getEraYear = function(date, cal, era, sortable) {
        var year = date.getFullYear();
        if (!sortable && cal.eras) {
            year -= cal.eras[era].offset;
        }
        return year;
    };
    (function() {
        var expandYear, getDayIndex, getMonthIndex, getParseRegExp, outOfRange, toUpper, toUpperArray;
        expandYear = function(cal, year) {
            if (year < 100) {
                var now = new Date(), era = getEra(now), curr = getEraYear(now, cal, era), twoDigitYearMax = cal.twoDigitYearMax;
                twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax;
                year += curr - curr % 100;
                if (year > twoDigitYearMax) {
                    year -= 100;
                }
            }
            return year;
        };
        getDayIndex = function(cal, value, abbr) {
            var ret, days = cal.days, upperDays = cal._upperDays;
            if (!upperDays) {
                cal._upperDays = upperDays = [ toUpperArray(days.names), toUpperArray(days.namesAbbr), toUpperArray(days.namesShort) ];
            }
            value = toUpper(value);
            if (abbr) {
                ret = arrayIndexOf(upperDays[1], value);
                if (ret === -1) {
                    ret = arrayIndexOf(upperDays[2], value);
                }
            } else {
                ret = arrayIndexOf(upperDays[0], value);
            }
            return ret;
        };
        getMonthIndex = function(cal, value, abbr) {
            var months = cal.months, monthsGen = cal.monthsGenitive || cal.months, upperMonths = cal._upperMonths, upperMonthsGen = cal._upperMonthsGen;
            if (!upperMonths) {
                cal._upperMonths = upperMonths = [ toUpperArray(months.names), toUpperArray(months.namesAbbr) ];
                cal._upperMonthsGen = upperMonthsGen = [ toUpperArray(monthsGen.names), toUpperArray(monthsGen.namesAbbr) ];
            }
            value = toUpper(value);
            var i = arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value);
            if (i < 0) {
                i = arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value);
            }
            return i;
        };
        getParseRegExp = function(cal, format) {
            var re = cal._parseRegExp;
            if (!re) {
                cal._parseRegExp = re = {};
            } else {
                var reFormat = re[format];
                if (reFormat) {
                    return reFormat;
                }
            }
            var expFormat = expandFormat(cal, format).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1"), regexp = [ "^" ], groups = [], index = 0, quoteCount = 0, tokenRegExp = getTokenRegExp(), match;
            while ((match = tokenRegExp.exec(expFormat)) !== null) {
                var preMatch = expFormat.slice(index, match.index);
                index = tokenRegExp.lastIndex;
                quoteCount += appendPreOrPostMatch(preMatch, regexp);
                if (quoteCount % 2) {
                    regexp.push(match[0]);
                    continue;
                }
                var m = match[0], len = m.length, add;
                switch (m) {
                  case "dddd":
                  case "ddd":
                  case "MMMM":
                  case "MMM":
                  case "gg":
                  case "g":
                    add = "(\\D+)";
                    break;

                  case "tt":
                  case "t":
                    add = "(\\D*)";
                    break;

                  case "yyyy":
                  case "fff":
                  case "ff":
                  case "f":
                    add = "(\\d{" + len + "})";
                    break;

                  case "dd":
                  case "d":
                  case "MM":
                  case "M":
                  case "yy":
                  case "y":
                  case "HH":
                  case "H":
                  case "hh":
                  case "h":
                  case "mm":
                  case "m":
                  case "ss":
                  case "s":
                    add = "(\\d\\d?)";
                    break;

                  case "zzz":
                    add = "([+-]?\\d\\d?:\\d{2})";
                    break;

                  case "zz":
                  case "z":
                    add = "([+-]?\\d\\d?)";
                    break;

                  case "/":
                    add = "(\\/)";
                    break;

                  default:
                    throw "Invalid date format pattern '" + m + "'.";
                }
                if (add) {
                    regexp.push(add);
                }
                groups.push(match[0]);
            }
            appendPreOrPostMatch(expFormat.slice(index), regexp);
            regexp.push("$");
            var regexpStr = regexp.join("").replace(/\s+/g, "\\s+"), parseRegExp = {
                regExp: regexpStr,
                groups: groups
            };
            return re[format] = parseRegExp;
        };
        outOfRange = function(value, low, high) {
            return value < low || value > high;
        };
        toUpper = function(value) {
            return value.split(" ").join(" ").toUpperCase();
        };
        toUpperArray = function(arr) {
            var results = [];
            for (var i = 0, l = arr.length; i < l; i++) {
                results[i] = toUpper(arr[i]);
            }
            return results;
        };
        parseExact = function(value, format, culture) {
            value = trim(value);
            var cal = culture.calendar, parseInfo = getParseRegExp(cal, format), match = new RegExp(parseInfo.regExp).exec(value);
            if (match === null) {
                return null;
            }
            var groups = parseInfo.groups, era = null, year = null, month = null, date = null, weekDay = null, hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null, pmHour = false;
            for (var j = 0, jl = groups.length; j < jl; j++) {
                var matchGroup = match[j + 1];
                if (matchGroup) {
                    var current = groups[j], clength = current.length, matchInt = parseInt(matchGroup, 10);
                    switch (current) {
                      case "dd":
                      case "d":
                        date = matchInt;
                        if (outOfRange(date, 1, 31)) return null;
                        break;

                      case "MMM":
                      case "MMMM":
                        month = getMonthIndex(cal, matchGroup, clength === 3);
                        if (outOfRange(month, 0, 11)) return null;
                        break;

                      case "M":
                      case "MM":
                        month = matchInt - 1;
                        if (outOfRange(month, 0, 11)) return null;
                        break;

                      case "y":
                      case "yy":
                      case "yyyy":
                        year = clength < 4 ? expandYear(cal, matchInt) : matchInt;
                        if (outOfRange(year, 0, 9999)) return null;
                        break;

                      case "h":
                      case "hh":
                        hour = matchInt;
                        if (hour === 12) hour = 0;
                        if (outOfRange(hour, 0, 11)) return null;
                        break;

                      case "H":
                      case "HH":
                        hour = matchInt;
                        if (outOfRange(hour, 0, 23)) return null;
                        break;

                      case "m":
                      case "mm":
                        min = matchInt;
                        if (outOfRange(min, 0, 59)) return null;
                        break;

                      case "s":
                      case "ss":
                        sec = matchInt;
                        if (outOfRange(sec, 0, 59)) return null;
                        break;

                      case "tt":
                      case "t":
                        pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]);
                        if (!pmHour && (!cal.AM || matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2])) return null;
                        break;

                      case "f":
                      case "ff":
                      case "fff":
                        msec = matchInt * Math.pow(10, 3 - clength);
                        if (outOfRange(msec, 0, 999)) return null;
                        break;

                      case "ddd":
                      case "dddd":
                        weekDay = getDayIndex(cal, matchGroup, clength === 3);
                        if (outOfRange(weekDay, 0, 6)) return null;
                        break;

                      case "zzz":
                        var offsets = matchGroup.split(/:/);
                        if (offsets.length !== 2) return null;
                        hourOffset = parseInt(offsets[0], 10);
                        if (outOfRange(hourOffset, -12, 13)) return null;
                        var minOffset = parseInt(offsets[1], 10);
                        if (outOfRange(minOffset, 0, 59)) return null;
                        tzMinOffset = hourOffset * 60 + (startsWith(matchGroup, "-") ? -minOffset : minOffset);
                        break;

                      case "z":
                      case "zz":
                        hourOffset = matchInt;
                        if (outOfRange(hourOffset, -12, 13)) return null;
                        tzMinOffset = hourOffset * 60;
                        break;

                      case "g":
                      case "gg":
                        var eraName = matchGroup;
                        if (!eraName || !cal.eras) return null;
                        eraName = trim(eraName.toLowerCase());
                        for (var i = 0, l = cal.eras.length; i < l; i++) {
                            if (eraName === cal.eras[i].name.toLowerCase()) {
                                era = i;
                                break;
                            }
                        }
                        if (era === null) return null;
                        break;
                    }
                }
            }
            var result = new Date(), defaultYear, convert = cal.convert;
            defaultYear = convert ? convert.fromGregorian(result)[0] : result.getFullYear();
            if (year === null) {
                year = defaultYear;
            } else if (cal.eras) {
                year += cal.eras[era || 0].offset;
            }
            if (month === null) {
                month = 0;
            }
            if (date === null) {
                date = 1;
            }
            if (convert) {
                result = convert.toGregorian(year, month, date);
                if (result === null) return null;
            } else {
                result.setFullYear(year, month, date);
                if (result.getDate() !== date) return null;
                if (weekDay !== null && result.getDay() !== weekDay) {
                    return null;
                }
            }
            if (pmHour && hour < 12) {
                hour += 12;
            }
            result.setHours(hour, min, sec, msec);
            if (tzMinOffset !== null) {
                var adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset());
                result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60);
            }
            return result;
        };
    })();
    parseNegativePattern = function(value, nf, negativePattern) {
        var neg = nf["-"], pos = nf["+"], ret;
        switch (negativePattern) {
          case "n -":
            neg = " " + neg;
            pos = " " + pos;

          case "n-":
            if (endsWith(value, neg)) {
                ret = [ "-", value.substr(0, value.length - neg.length) ];
            } else if (endsWith(value, pos)) {
                ret = [ "+", value.substr(0, value.length - pos.length) ];
            }
            break;

          case "- n":
            neg += " ";
            pos += " ";

          case "-n":
            if (startsWith(value, neg)) {
                ret = [ "-", value.substr(neg.length) ];
            } else if (startsWith(value, pos)) {
                ret = [ "+", value.substr(pos.length) ];
            }
            break;

          case "(n)":
            if (startsWith(value, "(") && endsWith(value, ")")) {
                ret = [ "-", value.substr(1, value.length - 2) ];
            }
            break;
        }
        return ret || [ "", value ];
    };
    Globalize.prototype.findClosestCulture = function(cultureSelector) {
        return Globalize.findClosestCulture.call(this, cultureSelector);
    };
    Globalize.prototype.format = function(value, format, cultureSelector) {
        return Globalize.format.call(this, value, format, cultureSelector);
    };
    Globalize.prototype.localize = function(key, cultureSelector) {
        return Globalize.localize.call(this, key, cultureSelector);
    };
    Globalize.prototype.parseInt = function(value, radix, cultureSelector) {
        return Globalize.parseInt.call(this, value, radix, cultureSelector);
    };
    Globalize.prototype.parseFloat = function(value, radix, cultureSelector) {
        return Globalize.parseFloat.call(this, value, radix, cultureSelector);
    };
    Globalize.prototype.culture = function(cultureSelector) {
        return Globalize.culture.call(this, cultureSelector);
    };
    Globalize.addCultureInfo = function(cultureName, baseCultureName, info) {
        var base = {}, isNew = false;
        if (typeof cultureName !== "string") {
            info = cultureName;
            cultureName = this.culture().name;
            base = this.cultures[cultureName];
        } else if (typeof baseCultureName !== "string") {
            info = baseCultureName;
            isNew = this.cultures[cultureName] == null;
            base = this.cultures[cultureName] || this.cultures["default"];
        } else {
            isNew = true;
            base = this.cultures[baseCultureName];
        }
        this.cultures[cultureName] = extend(true, {}, base, info);
        if (isNew) {
            this.cultures[cultureName].calendar = this.cultures[cultureName].calendars.standard;
        }
    };
    Globalize.findClosestCulture = function(name) {
        var match;
        if (!name) {
            return this.findClosestCulture(this.cultureSelector) || this.cultures["default"];
        }
        if (typeof name === "string") {
            name = name.split(",");
        }
        if (isArray(name)) {
            var lang, cultures = this.cultures, list = name, i, l = list.length, prioritized = [];
            for (i = 0; i < l; i++) {
                name = trim(list[i]);
                var pri, parts = name.split(";");
                lang = trim(parts[0]);
                if (parts.length === 1) {
                    pri = 1;
                } else {
                    name = trim(parts[1]);
                    if (name.indexOf("q=") === 0) {
                        name = name.substr(2);
                        pri = parseFloat(name);
                        pri = isNaN(pri) ? 0 : pri;
                    } else {
                        pri = 1;
                    }
                }
                prioritized.push({
                    lang: lang,
                    pri: pri
                });
            }
            prioritized.sort(function(a, b) {
                if (a.pri < b.pri) {
                    return 1;
                } else if (a.pri > b.pri) {
                    return -1;
                }
                return 0;
            });
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                match = cultures[lang];
                if (match) {
                    return match;
                }
            }
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                do {
                    var index = lang.lastIndexOf("-");
                    if (index === -1) {
                        break;
                    }
                    lang = lang.substr(0, index);
                    match = cultures[lang];
                    if (match) {
                        return match;
                    }
                } while (1);
            }
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                for (var cultureKey in cultures) {
                    var culture = cultures[cultureKey];
                    if (culture.language == lang) {
                        return culture;
                    }
                }
            }
        } else if (typeof name === "object") {
            return name;
        }
        return match || null;
    };
    Globalize.format = function(value, format, cultureSelector) {
        var culture = this.findClosestCulture(cultureSelector);
        if (value instanceof Date) {
            value = formatDate(value, format, culture);
        } else if (typeof value === "number") {
            value = formatNumber(value, format, culture);
        }
        return value;
    };
    Globalize.localize = function(key, cultureSelector) {
        return this.findClosestCulture(cultureSelector).messages[key] || this.cultures["default"].messages[key];
    };
    Globalize.parseDate = function(value, formats, culture) {
        culture = this.findClosestCulture(culture);
        var date, prop, patterns;
        if (formats) {
            if (typeof formats === "string") {
                formats = [ formats ];
            }
            if (formats.length) {
                for (var i = 0, l = formats.length; i < l; i++) {
                    var format = formats[i];
                    if (format) {
                        date = parseExact(value, format, culture);
                        if (date) {
                            break;
                        }
                    }
                }
            }
        } else {
            patterns = culture.calendar.patterns;
            for (prop in patterns) {
                date = parseExact(value, patterns[prop], culture);
                if (date) {
                    break;
                }
            }
        }
        return date || null;
    };
    Globalize.parseInt = function(value, radix, cultureSelector) {
        return truncate(Globalize.parseFloat(value, radix, cultureSelector));
    };
    Globalize.parseFloat = function(value, radix, cultureSelector) {
        if (typeof radix !== "number") {
            cultureSelector = radix;
            radix = 10;
        }
        var culture = this.findClosestCulture(cultureSelector);
        var ret = NaN, nf = culture.numberFormat;
        if (value.indexOf(culture.numberFormat.currency.symbol) > -1) {
            value = value.replace(culture.numberFormat.currency.symbol, "");
            value = value.replace(culture.numberFormat.currency["."], culture.numberFormat["."]);
        }
        if (value.indexOf(culture.numberFormat.percent.symbol) > -1) {
            value = value.replace(culture.numberFormat.percent.symbol, "");
        }
        value = value.replace(/ /g, "");
        if (regexInfinity.test(value)) {
            ret = parseFloat(value);
        } else if (!radix && regexHex.test(value)) {
            ret = parseInt(value, 16);
        } else {
            var signInfo = parseNegativePattern(value, nf, nf.pattern[0]), sign = signInfo[0], num = signInfo[1];
            if (sign === "" && nf.pattern[0] !== "(n)") {
                signInfo = parseNegativePattern(value, nf, "(n)");
                sign = signInfo[0];
                num = signInfo[1];
            }
            if (sign === "" && nf.pattern[0] !== "-n") {
                signInfo = parseNegativePattern(value, nf, "-n");
                sign = signInfo[0];
                num = signInfo[1];
            }
            sign = sign || "+";
            var exponent, intAndFraction, exponentPos = num.indexOf("e");
            if (exponentPos < 0) exponentPos = num.indexOf("E");
            if (exponentPos < 0) {
                intAndFraction = num;
                exponent = null;
            } else {
                intAndFraction = num.substr(0, exponentPos);
                exponent = num.substr(exponentPos + 1);
            }
            var integer, fraction, decSep = nf["."], decimalPos = intAndFraction.indexOf(decSep);
            if (decimalPos < 0) {
                integer = intAndFraction;
                fraction = null;
            } else {
                integer = intAndFraction.substr(0, decimalPos);
                fraction = intAndFraction.substr(decimalPos + decSep.length);
            }
            var groupSep = nf[","];
            integer = integer.split(groupSep).join("");
            var altGroupSep = groupSep.replace(/\u00A0/g, " ");
            if (groupSep !== altGroupSep) {
                integer = integer.split(altGroupSep).join("");
            }
            var p = sign + integer;
            if (fraction !== null) {
                p += "." + fraction;
            }
            if (exponent !== null) {
                var expSignInfo = parseNegativePattern(exponent, nf, "-n");
                p += "e" + (expSignInfo[0] || "+") + expSignInfo[1];
            }
            if (regexParseFloat.test(p)) {
                ret = parseFloat(p);
            }
        }
        return ret;
    };
    Globalize.culture = function(cultureSelector) {
        if (typeof cultureSelector !== "undefined") {
            this.cultureSelector = cultureSelector;
        }
        return this.findClosestCulture(cultureSelector) || this.cultures["default"];
    };
})(this);

(function(window, undefined) {
    var Globalize;
    if (typeof require !== "undefined" && typeof exports !== "undefined" && typeof module !== "undefined") {
        Globalize = require("globalize");
    } else {
        Globalize = window.Globalize;
    }
    Globalize.addCultureInfo("ar", "default", {
        name: "ar",
        englishName: "Arabic",
        nativeName: "العربية",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ر.س.‏"
            }
        },
        calendars: {
            standard: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("bg", "default", {
        name: "bg",
        englishName: "Bulgarian",
        nativeName: "български",
        language: "bg",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "- безкрайност",
            positiveInfinity: "+ безкрайност",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "лв."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "неделя", "понеделник", "вторник", "сряда", "четвъртък", "петък", "събота" ],
                    namesAbbr: [ "нед", "пон", "вт", "ср", "четв", "пет", "съб" ],
                    namesShort: [ "н", "п", "в", "с", "ч", "п", "с" ]
                },
                months: {
                    names: [ "януари", "февруари", "март", "април", "май", "юни", "юли", "август", "септември", "октомври", "ноември", "декември", "" ],
                    namesAbbr: [ "ян", "февр", "март", "апр", "май", "юни", "юли", "авг", "септ", "окт", "ноември", "дек", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "след новата ера",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy 'г.'",
                    D: "dd MMMM yyyy 'г.'",
                    t: "HH:mm 'ч.'",
                    T: "HH:mm:ss 'ч.'",
                    f: "dd MMMM yyyy 'г.' HH:mm 'ч.'",
                    F: "dd MMMM yyyy 'г.' HH:mm:ss 'ч.'",
                    M: "dd MMMM",
                    Y: "MMMM yyyy 'г.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("ca", "default", {
        name: "ca",
        englishName: "Catalan",
        nativeName: "català",
        language: "ca",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinit",
            positiveInfinity: "Infinit",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte" ],
                    namesAbbr: [ "dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds." ],
                    namesShort: [ "dg", "dl", "dt", "dc", "dj", "dv", "ds" ]
                },
                months: {
                    names: [ "gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre", "" ],
                    namesAbbr: [ "gen", "feb", "març", "abr", "maig", "juny", "jul", "ag", "set", "oct", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' / 'MMMM' / 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' / 'MMMM' / 'yyyy HH:mm",
                    F: "dddd, d' / 'MMMM' / 'yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' / 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-Hans", "default", {
        name: "zh-Hans",
        englishName: "Chinese (Simplified)",
        nativeName: "中文(简体)",
        language: "zh-Hans",
        numberFormat: {
            NaN: "非数字",
            negativeInfinity: "负无穷大",
            positiveInfinity: "正无穷大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("cs", "default", {
        name: "cs",
        englishName: "Czech",
        nativeName: "čeština",
        language: "cs",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Není číslo",
            negativeInfinity: "-nekonečno",
            positiveInfinity: "+nekonečno",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Kč"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "neděle", "pondělí", "úterý", "středa", "čtvrtek", "pátek", "sobota" ],
                    namesAbbr: [ "ne", "po", "út", "st", "čt", "pá", "so" ],
                    namesShort: [ "ne", "po", "út", "st", "čt", "pá", "so" ]
                },
                months: {
                    names: [ "leden", "únor", "březen", "duben", "květen", "červen", "červenec", "srpen", "září", "říjen", "listopad", "prosinec", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                monthsGenitive: {
                    names: [ "ledna", "února", "března", "dubna", "května", "června", "července", "srpna", "září", "října", "listopadu", "prosince", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "dop.", "dop.", "DOP." ],
                PM: [ "odp.", "odp.", "ODP." ],
                eras: [ {
                    name: "n. l.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("da", "default", {
        name: "da",
        englishName: "Danish",
        nativeName: "dansk",
        language: "da",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag" ],
                    namesAbbr: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ],
                    namesShort: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ]
                },
                months: {
                    names: [ "januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("de", "default", {
        name: "de",
        englishName: "German",
        nativeName: "Deutsch",
        language: "de",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("el", "default", {
        name: "el",
        englishName: "Greek",
        nativeName: "Ελληνικά",
        language: "el",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "μη αριθμός",
            negativeInfinity: "-Άπειρο",
            positiveInfinity: "Άπειρο",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο" ],
                    namesAbbr: [ "Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ" ],
                    namesShort: [ "Κυ", "Δε", "Τρ", "Τε", "Πε", "Πα", "Σά" ]
                },
                months: {
                    names: [ "Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος", "" ],
                    namesAbbr: [ "Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαϊ", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ", "" ]
                },
                monthsGenitive: {
                    names: [ "Ιανουαρίου", "Φεβρουαρίου", "Μαρτίου", "Απριλίου", "Μαΐου", "Ιουνίου", "Ιουλίου", "Αυγούστου", "Σεπτεμβρίου", "Οκτωβρίου", "Νοεμβρίου", "Δεκεμβρίου", "" ],
                    namesAbbr: [ "Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαϊ", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ", "" ]
                },
                AM: [ "πμ", "πμ", "ΠΜ" ],
                PM: [ "μμ", "μμ", "ΜΜ" ],
                eras: [ {
                    name: "μ.Χ.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd, d MMMM yyyy",
                    f: "dddd, d MMMM yyyy h:mm tt",
                    F: "dddd, d MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es", "default", {
        name: "es",
        englishName: "Spanish",
        nativeName: "español",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fi", "default", {
        name: "fi",
        englishName: "Finnish",
        nativeName: "suomi",
        language: "fi",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai" ],
                    namesAbbr: [ "su", "ma", "ti", "ke", "to", "pe", "la" ],
                    namesShort: [ "su", "ma", "ti", "ke", "to", "pe", "la" ]
                },
                months: {
                    names: [ "tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu", "" ],
                    namesAbbr: [ "tammi", "helmi", "maalis", "huhti", "touko", "kesä", "heinä", "elo", "syys", "loka", "marras", "joulu", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM'ta 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM'ta 'yyyy H:mm",
                    F: "d. MMMM'ta 'yyyy H:mm:ss",
                    M: "d. MMMM'ta'",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr", "default", {
        name: "fr",
        englishName: "French",
        nativeName: "français",
        language: "fr",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("he", "default", {
        name: "he",
        englishName: "Hebrew",
        nativeName: "עברית",
        language: "he",
        isRTL: true,
        numberFormat: {
            NaN: "לא מספר",
            negativeInfinity: "אינסוף שלילי",
            positiveInfinity: "אינסוף חיובי",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "₪"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "יום ראשון", "יום שני", "יום שלישי", "יום רביעי", "יום חמישי", "יום שישי", "שבת" ],
                    namesAbbr: [ "יום א", "יום ב", "יום ג", "יום ד", "יום ה", "יום ו", "שבת" ],
                    namesShort: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ]
                },
                months: {
                    names: [ "ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר", "" ],
                    namesAbbr: [ "ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ", "" ]
                },
                eras: [ {
                    name: "לספירה",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd dd MMMM yyyy HH:mm",
                    F: "dddd dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            },
            Hebrew: {
                name: "Hebrew",
                "/": " ",
                days: {
                    names: [ "יום ראשון", "יום שני", "יום שלישי", "יום רביעי", "יום חמישי", "יום שישי", "שבת" ],
                    namesAbbr: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ],
                    namesShort: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ]
                },
                months: {
                    names: [ "תשרי", "חשון", "כסלו", "טבת", "שבט", "אדר", "אדר ב", "ניסן", "אייר", "סיון", "תמוז", "אב", "אלול" ],
                    namesAbbr: [ "תשרי", "חשון", "כסלו", "טבת", "שבט", "אדר", "אדר ב", "ניסן", "אייר", "סיון", "תמוז", "אב", "אלול" ]
                },
                eras: [ {
                    name: "C.E.",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 5790,
                patterns: {
                    d: "dd MMMM yyyy",
                    D: "dddd dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd dd MMMM yyyy HH:mm",
                    F: "dddd dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hu", "default", {
        name: "hu",
        englishName: "Hungarian",
        nativeName: "magyar",
        language: "hu",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "nem szám",
            negativeInfinity: "negatív végtelen",
            positiveInfinity: "végtelen",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Ft"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat" ],
                    namesAbbr: [ "V", "H", "K", "Sze", "Cs", "P", "Szo" ],
                    namesShort: [ "V", "H", "K", "Sze", "Cs", "P", "Szo" ]
                },
                months: {
                    names: [ "január", "február", "március", "április", "május", "június", "július", "augusztus", "szeptember", "október", "november", "december", "" ],
                    namesAbbr: [ "jan.", "febr.", "márc.", "ápr.", "máj.", "jún.", "júl.", "aug.", "szept.", "okt.", "nov.", "dec.", "" ]
                },
                AM: [ "de.", "de.", "DE." ],
                PM: [ "du.", "du.", "DU." ],
                eras: [ {
                    name: "i.sz.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy.MM.dd.",
                    D: "yyyy. MMMM d.",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy. MMMM d. H:mm",
                    F: "yyyy. MMMM d. H:mm:ss",
                    M: "MMMM d.",
                    Y: "yyyy. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("is", "default", {
        name: "is",
        englishName: "Icelandic",
        nativeName: "íslenska",
        language: "is",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                decimals: 0,
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sunnudagur", "mánudagur", "þriðjudagur", "miðvikudagur", "fimmtudagur", "föstudagur", "laugardagur" ],
                    namesAbbr: [ "sun.", "mán.", "þri.", "mið.", "fim.", "fös.", "lau." ],
                    namesShort: [ "su", "má", "þr", "mi", "fi", "fö", "la" ]
                },
                months: {
                    names: [ "janúar", "febrúar", "mars", "apríl", "maí", "júní", "júlí", "ágúst", "september", "október", "nóvember", "desember", "" ],
                    namesAbbr: [ "jan.", "feb.", "mar.", "apr.", "maí", "jún.", "júl.", "ágú.", "sep.", "okt.", "nóv.", "des.", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("it", "default", {
        name: "it",
        englishName: "Italian",
        nativeName: "italiano",
        language: "it",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "Non un numero reale",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domenica", "lunedì", "martedì", "mercoledì", "giovedì", "venerdì", "sabato" ],
                    namesAbbr: [ "dom", "lun", "mar", "mer", "gio", "ven", "sab" ],
                    namesShort: [ "do", "lu", "ma", "me", "gi", "ve", "sa" ]
                },
                months: {
                    names: [ "gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre", "" ],
                    namesAbbr: [ "gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ja", "default", {
        name: "ja",
        englishName: "Japanese",
        nativeName: "日本語",
        language: "ja",
        numberFormat: {
            NaN: "NaN (非数値)",
            negativeInfinity: "-∞",
            positiveInfinity: "+∞",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                decimals: 0,
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日" ],
                    namesAbbr: [ "日", "月", "火", "水", "木", "金", "土" ],
                    namesShort: [ "日", "月", "火", "水", "木", "金", "土" ]
                },
                months: {
                    names: [ "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "午前", "午前", "午前" ],
                PM: [ "午後", "午後", "午後" ],
                eras: [ {
                    name: "西暦",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            },
            Japanese: {
                name: "Japanese",
                days: {
                    names: [ "日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日" ],
                    namesAbbr: [ "日", "月", "火", "水", "木", "金", "土" ],
                    namesShort: [ "日", "月", "火", "水", "木", "金", "土" ]
                },
                months: {
                    names: [ "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "午前", "午前", "午前" ],
                PM: [ "午後", "午後", "午後" ],
                eras: [ {
                    name: "平成",
                    start: null,
                    offset: 1867
                }, {
                    name: "昭和",
                    start: -18121536e5,
                    offset: 1911
                }, {
                    name: "大正",
                    start: -13576032e5,
                    offset: 1925
                }, {
                    name: "明治",
                    start: 6002208e4,
                    offset: 1988
                } ],
                twoDigitYearMax: 99,
                patterns: {
                    d: "gg y/M/d",
                    D: "gg y'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "gg y'年'M'月'd'日' H:mm",
                    F: "gg y'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "gg y'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("ko", "default", {
        name: "ko",
        englishName: "Korean",
        nativeName: "한국어",
        language: "ko",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                decimals: 0,
                symbol: "₩"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일" ],
                    namesAbbr: [ "일", "월", "화", "수", "목", "금", "토" ],
                    namesShort: [ "일", "월", "화", "수", "목", "금", "토" ]
                },
                months: {
                    names: [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "오전", "오전", "오전" ],
                PM: [ "오후", "오후", "오후" ],
                eras: [ {
                    name: "서기",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy'년' M'월' d'일' dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "yyyy'년' M'월' d'일' dddd tt h:mm",
                    F: "yyyy'년' M'월' d'일' dddd tt h:mm:ss",
                    M: "M'월' d'일'",
                    Y: "yyyy'년' M'월'"
                }
            },
            Korean: {
                name: "Korean",
                "/": "-",
                days: {
                    names: [ "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일" ],
                    namesAbbr: [ "일", "월", "화", "수", "목", "금", "토" ],
                    namesShort: [ "일", "월", "화", "수", "목", "금", "토" ]
                },
                months: {
                    names: [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "오전", "오전", "오전" ],
                PM: [ "오후", "오후", "오후" ],
                eras: [ {
                    name: "단기",
                    start: null,
                    offset: -2333
                } ],
                twoDigitYearMax: 4362,
                patterns: {
                    d: "gg yyyy-MM-dd",
                    D: "gg yyyy'년' M'월' d'일' dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "gg yyyy'년' M'월' d'일' dddd tt h:mm",
                    F: "gg yyyy'년' M'월' d'일' dddd tt h:mm:ss",
                    M: "M'월' d'일'",
                    Y: "gg yyyy'년' M'월'"
                }
            }
        }
    });
    Globalize.addCultureInfo("nl", "default", {
        name: "nl",
        englishName: "Dutch",
        nativeName: "Nederlands",
        language: "nl",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag" ],
                    namesAbbr: [ "zo", "ma", "di", "wo", "do", "vr", "za" ],
                    namesShort: [ "zo", "ma", "di", "wo", "do", "vr", "za" ]
                },
                months: {
                    names: [ "januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d-M-yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd d MMMM yyyy H:mm",
                    F: "dddd d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("no", "default", {
        name: "no",
        englishName: "Norwegian",
        nativeName: "norsk",
        language: "no",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag" ],
                    namesAbbr: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ],
                    namesShort: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("pl", "default", {
        name: "pl",
        englishName: "Polish",
        nativeName: "polski",
        language: "pl",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "nie jest liczbą",
            negativeInfinity: "-nieskończoność",
            positiveInfinity: "+nieskończoność",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "zł"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota" ],
                    namesAbbr: [ "N", "Pn", "Wt", "Śr", "Cz", "Pt", "So" ],
                    namesShort: [ "N", "Pn", "Wt", "Śr", "Cz", "Pt", "So" ]
                },
                months: {
                    names: [ "styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień", "" ],
                    namesAbbr: [ "sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "paź", "lis", "gru", "" ]
                },
                monthsGenitive: {
                    names: [ "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "września", "października", "listopada", "grudnia", "" ],
                    namesAbbr: [ "sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "paź", "lis", "gru", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("pt", "default", {
        name: "pt",
        englishName: "Portuguese",
        nativeName: "Português",
        language: "pt",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NaN (Não é um número)",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "R$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado" ],
                    namesAbbr: [ "dom", "seg", "ter", "qua", "qui", "sex", "sáb" ],
                    namesShort: [ "D", "S", "T", "Q", "Q", "S", "S" ]
                },
                months: {
                    names: [ "janeiro", "fevereiro", "março", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro", "" ],
                    namesAbbr: [ "jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' de 'MMMM' de 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' de 'MMMM' de 'yyyy HH:mm",
                    F: "dddd, d' de 'MMMM' de 'yyyy HH:mm:ss",
                    M: "dd' de 'MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("rm", "default", {
        name: "rm",
        englishName: "Romansh",
        nativeName: "Rumantsch",
        language: "rm",
        numberFormat: {
            ",": "'",
            NaN: "betg def.",
            negativeInfinity: "-infinit",
            positiveInfinity: "+infinit",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "fr."
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dumengia", "glindesdi", "mardi", "mesemna", "gievgia", "venderdi", "sonda" ],
                    namesAbbr: [ "du", "gli", "ma", "me", "gie", "ve", "so" ],
                    namesShort: [ "du", "gli", "ma", "me", "gie", "ve", "so" ]
                },
                months: {
                    names: [ "schaner", "favrer", "mars", "avrigl", "matg", "zercladur", "fanadur", "avust", "settember", "october", "november", "december", "" ],
                    namesAbbr: [ "schan", "favr", "mars", "avr", "matg", "zercl", "fan", "avust", "sett", "oct", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "s. Cr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d MMMM yyyy HH:mm",
                    F: "dddd, d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ro", "default", {
        name: "ro",
        englishName: "Romanian",
        nativeName: "română",
        language: "ro",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "lei"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "duminică", "luni", "marţi", "miercuri", "joi", "vineri", "sâmbătă" ],
                    namesAbbr: [ "D", "L", "Ma", "Mi", "J", "V", "S" ],
                    namesShort: [ "D", "L", "Ma", "Mi", "J", "V", "S" ]
                },
                months: {
                    names: [ "ianuarie", "februarie", "martie", "aprilie", "mai", "iunie", "iulie", "august", "septembrie", "octombrie", "noiembrie", "decembrie", "" ],
                    namesAbbr: [ "ian.", "feb.", "mar.", "apr.", "mai.", "iun.", "iul.", "aug.", "sep.", "oct.", "nov.", "dec.", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ru", "default", {
        name: "ru",
        englishName: "Russian",
        nativeName: "русский",
        language: "ru",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота" ],
                    namesAbbr: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                    namesShort: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
                },
                months: {
                    names: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                monthsGenitive: {
                    names: [ "января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря", "" ],
                    namesAbbr: [ "янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy 'г.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'г.' H:mm",
                    F: "d MMMM yyyy 'г.' H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hr", "default", {
        name: "hr",
        englishName: "Croatian",
        nativeName: "hrvatski",
        language: "hr",
        numberFormat: {
            pattern: [ "- n" ],
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kn"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "siječanj", "veljača", "ožujak", "travanj", "svibanj", "lipanj", "srpanj", "kolovoz", "rujan", "listopad", "studeni", "prosinac", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                monthsGenitive: {
                    names: [ "siječnja", "veljače", "ožujka", "travnja", "svibnja", "lipnja", "srpnja", "kolovoza", "rujna", "listopada", "studenog", "prosinca", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy.",
                    D: "d. MMMM yyyy.",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy. H:mm",
                    F: "d. MMMM yyyy. H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sk", "default", {
        name: "sk",
        englishName: "Slovak",
        nativeName: "slovenčina",
        language: "sk",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Nie je číslo",
            negativeInfinity: "-nekonečno",
            positiveInfinity: "+nekonečno",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "nedeľa", "pondelok", "utorok", "streda", "štvrtok", "piatok", "sobota" ],
                    namesAbbr: [ "ne", "po", "ut", "st", "št", "pi", "so" ],
                    namesShort: [ "ne", "po", "ut", "st", "št", "pi", "so" ]
                },
                months: {
                    names: [ "január", "február", "marec", "apríl", "máj", "jún", "júl", "august", "september", "október", "november", "december", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                monthsGenitive: {
                    names: [ "januára", "februára", "marca", "apríla", "mája", "júna", "júla", "augusta", "septembra", "októbra", "novembra", "decembra", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. l.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sq", "default", {
        name: "sq",
        englishName: "Albanian",
        nativeName: "shqipe",
        language: "sq",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-infinit",
            positiveInfinity: "infinit",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": ".",
                ".": ",",
                symbol: "Lek"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "e diel", "e hënë", "e martë", "e mërkurë", "e enjte", "e premte", "e shtunë" ],
                    namesAbbr: [ "Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Sht" ],
                    namesShort: [ "Di", "Hë", "Ma", "Më", "En", "Pr", "Sh" ]
                },
                months: {
                    names: [ "janar", "shkurt", "mars", "prill", "maj", "qershor", "korrik", "gusht", "shtator", "tetor", "nëntor", "dhjetor", "" ],
                    namesAbbr: [ "Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gsh", "Sht", "Tet", "Nën", "Dhj", "" ]
                },
                AM: [ "PD", "pd", "PD" ],
                PM: [ "MD", "md", "MD" ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy-MM-dd",
                    t: "h:mm.tt",
                    T: "h:mm:ss.tt",
                    f: "yyyy-MM-dd h:mm.tt",
                    F: "yyyy-MM-dd h:mm:ss.tt",
                    Y: "yyyy-MM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sv", "default", {
        name: "sv",
        englishName: "Swedish",
        nativeName: "svenska",
        language: "sv",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag" ],
                    namesAbbr: [ "sö", "må", "ti", "on", "to", "fr", "lö" ],
                    namesShort: [ "sö", "må", "ti", "on", "to", "fr", "lö" ]
                },
                months: {
                    names: [ "januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "'den 'd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "'den 'd MMMM yyyy HH:mm",
                    F: "'den 'd MMMM yyyy HH:mm:ss",
                    M: "'den 'd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("th", "default", {
        name: "th",
        englishName: "Thai",
        nativeName: "ไทย",
        language: "th",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "฿"
            }
        },
        calendars: {
            standard: {
                name: "ThaiBuddhist",
                firstDay: 1,
                days: {
                    names: [ "อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์" ],
                    namesAbbr: [ "อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส." ],
                    namesShort: [ "อ", "จ", "อ", "พ", "พ", "ศ", "ส" ]
                },
                months: {
                    names: [ "มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม", "" ],
                    namesAbbr: [ "ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค.", "" ]
                },
                eras: [ {
                    name: "พ.ศ.",
                    start: null,
                    offset: -543
                } ],
                twoDigitYearMax: 2572,
                patterns: {
                    d: "d/M/yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            },
            Gregorian_Localized: {
                firstDay: 1,
                days: {
                    names: [ "อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์" ],
                    namesAbbr: [ "อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส." ],
                    namesShort: [ "อ", "จ", "อ", "พ", "พ", "ศ", "ส" ]
                },
                months: {
                    names: [ "มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม", "" ],
                    namesAbbr: [ "ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค.", "" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "'วัน'dddd'ที่' d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "'วัน'dddd'ที่' d MMMM yyyy H:mm",
                    F: "'วัน'dddd'ที่' d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tr", "default", {
        name: "tr",
        englishName: "Turkish",
        nativeName: "Türkçe",
        language: "tr",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "TL"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi" ],
                    namesAbbr: [ "Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt" ],
                    namesShort: [ "Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct" ]
                },
                months: {
                    names: [ "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık", "" ],
                    namesAbbr: [ "Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dd MMMM yyyy dddd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy dddd HH:mm",
                    F: "dd MMMM yyyy dddd HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ur", "default", {
        name: "ur",
        englishName: "Urdu",
        nativeName: "اُردو",
        language: "ur",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "$n-", "$n" ],
                symbol: "Rs"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "اتوار", "پير", "منگل", "بدھ", "جمعرات", "جمعه", "هفته" ],
                    namesAbbr: [ "اتوار", "پير", "منگل", "بدھ", "جمعرات", "جمعه", "هفته" ],
                    namesShort: [ "ا", "پ", "م", "ب", "ج", "ج", "ه" ]
                },
                months: {
                    names: [ "جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر", "" ],
                    namesAbbr: [ "جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر", "" ]
                },
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    f: "dd MMMM, yyyy h:mm tt",
                    F: "dd MMMM, yyyy h:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            }
        }
    });
    Globalize.addCultureInfo("id", "default", {
        name: "id",
        englishName: "Indonesian",
        nativeName: "Bahasa Indonesia",
        language: "id",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                decimals: 0,
                ",": ".",
                ".": ",",
                symbol: "Rp"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu" ],
                    namesAbbr: [ "Minggu", "Sen", "Sel", "Rabu", "Kamis", "Jumat", "Sabtu" ],
                    namesShort: [ "M", "S", "S", "R", "K", "J", "S" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "Nopember", "Desember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agust", "Sep", "Okt", "Nop", "Des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM yyyy H:mm",
                    F: "dd MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("uk", "default", {
        name: "uk",
        englishName: "Ukrainian",
        nativeName: "українська",
        language: "uk",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-безмежність",
            positiveInfinity: "безмежність",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "₴"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "неділя", "понеділок", "вівторок", "середа", "четвер", "п'ятниця", "субота" ],
                    namesAbbr: [ "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                    namesShort: [ "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
                },
                months: {
                    names: [ "Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень", "" ],
                    namesAbbr: [ "Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру", "" ]
                },
                monthsGenitive: {
                    names: [ "січня", "лютого", "березня", "квітня", "травня", "червня", "липня", "серпня", "вересня", "жовтня", "листопада", "грудня", "" ],
                    namesAbbr: [ "січ", "лют", "бер", "кві", "тра", "чер", "лип", "сер", "вер", "жов", "лис", "гру", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy' р.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy' р.' H:mm",
                    F: "d MMMM yyyy' р.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy' р.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("be", "default", {
        name: "be",
        englishName: "Belarusian",
        nativeName: "Беларускі",
        language: "be",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "нядзеля", "панядзелак", "аўторак", "серада", "чацвер", "пятніца", "субота" ],
                    namesAbbr: [ "нд", "пн", "аў", "ср", "чц", "пт", "сб" ],
                    namesShort: [ "нд", "пн", "аў", "ср", "чц", "пт", "сб" ]
                },
                months: {
                    names: [ "Студзень", "Люты", "Сакавік", "Красавік", "Май", "Чэрвень", "Ліпень", "Жнівень", "Верасень", "Кастрычнік", "Лістапад", "Снежань", "" ],
                    namesAbbr: [ "Сту", "Лют", "Сак", "Кра", "Май", "Чэр", "Ліп", "Жні", "Вер", "Кас", "Ліс", "Сне", "" ]
                },
                monthsGenitive: {
                    names: [ "студзеня", "лютага", "сакавіка", "красавіка", "мая", "чэрвеня", "ліпеня", "жніўня", "верасня", "кастрычніка", "лістапада", "снежня", "" ],
                    namesAbbr: [ "Сту", "Лют", "Сак", "Кра", "Май", "Чэр", "Ліп", "Жні", "Вер", "Кас", "Ліс", "Сне", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sl", "default", {
        name: "sl",
        englishName: "Slovenian",
        nativeName: "slovenski",
        language: "sl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-neskončnost",
            positiveInfinity: "neskončnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljek", "torek", "sreda", "četrtek", "petek", "sobota" ],
                    namesAbbr: [ "ned", "pon", "tor", "sre", "čet", "pet", "sob" ],
                    namesShort: [ "ne", "po", "to", "sr", "če", "pe", "so" ]
                },
                months: {
                    names: [ "januar", "februar", "marec", "april", "maj", "junij", "julij", "avgust", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("et", "default", {
        name: "et",
        englishName: "Estonian",
        nativeName: "eesti",
        language: "et",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "avaldamatu",
            negativeInfinity: "miinuslõpmatus",
            positiveInfinity: "plusslõpmatus",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pühapäev", "esmaspäev", "teisipäev", "kolmapäev", "neljapäev", "reede", "laupäev" ],
                    namesAbbr: [ "P", "E", "T", "K", "N", "R", "L" ],
                    namesShort: [ "P", "E", "T", "K", "N", "R", "L" ]
                },
                months: {
                    names: [ "jaanuar", "veebruar", "märts", "aprill", "mai", "juuni", "juuli", "august", "september", "oktoober", "november", "detsember", "" ],
                    namesAbbr: [ "jaan", "veebr", "märts", "apr", "mai", "juuni", "juuli", "aug", "sept", "okt", "nov", "dets", "" ]
                },
                AM: [ "EL", "el", "EL" ],
                PM: [ "PL", "pl", "PL" ],
                patterns: {
                    d: "d.MM.yyyy",
                    D: "d. MMMM yyyy'. a.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy'. a.' H:mm",
                    F: "d. MMMM yyyy'. a.' H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy'. a.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("lv", "default", {
        name: "lv",
        englishName: "Latvian",
        nativeName: "latviešu",
        language: "lv",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-bezgalība",
            positiveInfinity: "bezgalība",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "Ls"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "svētdiena", "pirmdiena", "otrdiena", "trešdiena", "ceturtdiena", "piektdiena", "sestdiena" ],
                    namesAbbr: [ "sv", "pr", "ot", "tr", "ce", "pk", "se" ],
                    namesShort: [ "sv", "pr", "ot", "tr", "ce", "pk", "se" ]
                },
                months: {
                    names: [ "janvāris", "februāris", "marts", "aprīlis", "maijs", "jūnijs", "jūlijs", "augusts", "septembris", "oktobris", "novembris", "decembris", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jūn", "jūl", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "janvārī", "februārī", "martā", "aprīlī", "maijā", "jūnijā", "jūlijā", "augustā", "septembrī", "oktobrī", "novembrī", "decembrī", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jūn", "jūl", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy.MM.dd.",
                    D: "dddd, yyyy'. gada 'd. MMMM",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, yyyy'. gada 'd. MMMM H:mm",
                    F: "dddd, yyyy'. gada 'd. MMMM H:mm:ss",
                    M: "d. MMMM",
                    Y: "yyyy. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("lt", "default", {
        name: "lt",
        englishName: "Lithuanian",
        nativeName: "lietuvių",
        language: "lt",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-begalybė",
            positiveInfinity: "begalybė",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Lt"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sekmadienis", "pirmadienis", "antradienis", "trečiadienis", "ketvirtadienis", "penktadienis", "šeštadienis" ],
                    namesAbbr: [ "Sk", "Pr", "An", "Tr", "Kt", "Pn", "Št" ],
                    namesShort: [ "S", "P", "A", "T", "K", "Pn", "Š" ]
                },
                months: {
                    names: [ "sausis", "vasaris", "kovas", "balandis", "gegužė", "birželis", "liepa", "rugpjūtis", "rugsėjis", "spalis", "lapkritis", "gruodis", "" ],
                    namesAbbr: [ "Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd", "" ]
                },
                monthsGenitive: {
                    names: [ "sausio", "vasario", "kovo", "balandžio", "gegužės", "birželio", "liepos", "rugpjūčio", "rugsėjo", "spalio", "lapkričio", "gruodžio", "" ],
                    namesAbbr: [ "Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy.MM.dd",
                    D: "yyyy 'm.' MMMM d 'd.'",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'm.' MMMM d 'd.' HH:mm",
                    F: "yyyy 'm.' MMMM d 'd.' HH:mm:ss",
                    M: "MMMM d 'd.'",
                    Y: "yyyy 'm.' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("tg", "default", {
        name: "tg",
        englishName: "Tajik",
        nativeName: "Тоҷикӣ",
        language: "tg",
        numberFormat: {
            ",": " ",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ";",
                symbol: "т.р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                days: {
                    names: [ "Яш", "Душанбе", "Сешанбе", "Чоршанбе", "Панҷшанбе", "Ҷумъа", "Шанбе" ],
                    namesAbbr: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ],
                    namesShort: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ]
                },
                months: {
                    names: [ "Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "январи", "феврали", "марти", "апрели", "маи", "июни", "июли", "августи", "сентябри", "октябри", "ноябри", "декабри", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fa", "default", {
        name: "fa",
        englishName: "Persian",
        nativeName: "فارسى",
        language: "fa",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            currency: {
                pattern: [ "$n-", "$ n" ],
                ".": "/",
                symbol: "ريال"
            }
        },
        calendars: {
            standard: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "يكشنبه", "دوشنبه", "سه شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "يكشنبه", "دوشنبه", "سه شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "ژانويه", "فوريه", "مارس", "آوريل", "مى", "ژوئن", "ژوئيه", "اوت", "سپتامبر", "اُكتبر", "نوامبر", "دسامبر", "" ],
                    namesAbbr: [ "ژانويه", "فوريه", "مارس", "آوريل", "مى", "ژوئن", "ژوئيه", "اوت", "سپتامبر", "اُكتبر", "نوامبر", "دسامبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "yyyy/MM/dd",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "yyyy/MM/dd hh:mm tt",
                    F: "yyyy/MM/dd hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("vi", "default", {
        name: "vi",
        englishName: "Vietnamese",
        nativeName: "Tiếng Việt",
        language: "vi",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "₫"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Chủ Nhật", "Thứ Hai", "Thứ Ba", "Thứ Tư", "Thứ Năm", "Thứ Sáu", "Thứ Bảy" ],
                    namesAbbr: [ "CN", "Hai", "Ba", "Tư", "Năm", "Sáu", "Bảy" ],
                    namesShort: [ "C", "H", "B", "T", "N", "S", "B" ]
                },
                months: {
                    names: [ "Tháng Giêng", "Tháng Hai", "Tháng Ba", "Tháng Tư", "Tháng Năm", "Tháng Sáu", "Tháng Bảy", "Tháng Tám", "Tháng Chín", "Tháng Mười", "Tháng Mười Một", "Tháng Mười Hai", "" ],
                    namesAbbr: [ "Thg1", "Thg2", "Thg3", "Thg4", "Thg5", "Thg6", "Thg7", "Thg8", "Thg9", "Thg10", "Thg11", "Thg12", "" ]
                },
                AM: [ "SA", "sa", "SA" ],
                PM: [ "CH", "ch", "CH" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    f: "dd MMMM yyyy h:mm tt",
                    F: "dd MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hy", "default", {
        name: "hy",
        englishName: "Armenian",
        nativeName: "Հայերեն",
        language: "hy",
        numberFormat: {
            currency: {
                pattern: [ "-n $", "n $" ],
                symbol: "դր."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "ՈՒրբաթ", "Շաբաթ" ],
                    namesAbbr: [ "Կիր", "Երկ", "Երք", "Չրք", "Հնգ", "ՈՒր", "Շբթ" ],
                    namesShort: [ "Կ", "Ե", "Ե", "Չ", "Հ", "Ո", "Շ" ]
                },
                months: {
                    names: [ "Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր", "" ],
                    namesAbbr: [ "ՀՆՎ", "ՓՏՎ", "ՄՐՏ", "ԱՊՐ", "ՄՅՍ", "ՀՆՍ", "ՀԼՍ", "ՕԳՍ", "ՍԵՊ", "ՀՈԿ", "ՆՈՅ", "ԴԵԿ", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM, yyyy H:mm",
                    F: "d MMMM, yyyy H:mm:ss",
                    M: "d MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("az", "default", {
        name: "az",
        englishName: "Azeri",
        nativeName: "Azərbaycan­ılı",
        language: "az",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "man."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə" ],
                    namesAbbr: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ],
                    namesShort: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ]
                },
                months: {
                    names: [ "Yanvar", "Fevral", "Mart", "Aprel", "May", "İyun", "İyul", "Avgust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                monthsGenitive: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("eu", "default", {
        name: "eu",
        englishName: "Basque",
        nativeName: "euskara",
        language: "eu",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "EdZ",
            negativeInfinity: "-Infinitu",
            positiveInfinity: "Infinitu",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "igandea", "astelehena", "asteartea", "asteazkena", "osteguna", "ostirala", "larunbata" ],
                    namesAbbr: [ "ig.", "al.", "as.", "az.", "og.", "or.", "lr." ],
                    namesShort: [ "ig", "al", "as", "az", "og", "or", "lr" ]
                },
                months: {
                    names: [ "urtarrila", "otsaila", "martxoa", "apirila", "maiatza", "ekaina", "uztaila", "abuztua", "iraila", "urria", "azaroa", "abendua", "" ],
                    namesAbbr: [ "urt.", "ots.", "mar.", "api.", "mai.", "eka.", "uzt.", "abu.", "ira.", "urr.", "aza.", "abe.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dddd, yyyy.'eko' MMMM'k 'd",
                    t: "HH:mm",
                    T: "H:mm:ss",
                    f: "dddd, yyyy.'eko' MMMM'k 'd HH:mm",
                    F: "dddd, yyyy.'eko' MMMM'k 'd H:mm:ss",
                    Y: "yyyy.'eko' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("hsb", "default", {
        name: "hsb",
        englishName: "Upper Sorbian",
        nativeName: "hornjoserbšćina",
        language: "hsb",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "njedefinowane",
            negativeInfinity: "-njekónčne",
            positiveInfinity: "+njekónčne",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "njedźela", "póndźela", "wutora", "srjeda", "štwórtk", "pjatk", "sobota" ],
                    namesAbbr: [ "nje", "pón", "wut", "srj", "štw", "pja", "sob" ],
                    namesShort: [ "n", "p", "w", "s", "š", "p", "s" ]
                },
                months: {
                    names: [ "januar", "februar", "měrc", "apryl", "meja", "junij", "julij", "awgust", "september", "oktober", "nowember", "december", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "mej", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "januara", "februara", "měrca", "apryla", "meje", "junija", "julija", "awgusta", "septembra", "oktobra", "nowembra", "decembra", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "mej", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "po Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "dddd, 'dnja' d. MMMM yyyy",
                    t: "H.mm 'hodź.'",
                    T: "H:mm:ss",
                    f: "dddd, 'dnja' d. MMMM yyyy H.mm 'hodź.'",
                    F: "dddd, 'dnja' d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mk", "default", {
        name: "mk",
        englishName: "Macedonian (FYROM)",
        nativeName: "македонски јазик",
        language: "mk",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "ден."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота" ],
                    namesAbbr: [ "нед", "пон", "втр", "срд", "чет", "пет", "саб" ],
                    namesShort: [ "не", "по", "вт", "ср", "че", "пе", "са" ]
                },
                months: {
                    names: [ "јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември", "" ],
                    namesAbbr: [ "јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, dd MMMM yyyy HH:mm",
                    F: "dddd, dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tn", "default", {
        name: "tn",
        englishName: "Setswana",
        nativeName: "Setswana",
        language: "tn",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Latshipi", "Mosupologo", "Labobedi", "Laboraro", "Labone", "Labotlhano", "Lamatlhatso" ],
                    namesAbbr: [ "Ltp.", "Mos.", "Lbd.", "Lbr.", "Lbn.", "Lbt.", "Lmt." ],
                    namesShort: [ "Lp", "Ms", "Lb", "Lr", "Ln", "Lt", "Lm" ]
                },
                months: {
                    names: [ "Ferikgong", "Tlhakole", "Mopitloe", "Moranang", "Motsheganong", "Seetebosigo", "Phukwi", "Phatwe", "Lwetse", "Diphalane", "Ngwanatsele", "Sedimothole", "" ],
                    namesAbbr: [ "Fer.", "Tlhak.", "Mop.", "Mor.", "Motsh.", "Seet.", "Phukw.", "Phatw.", "Lwets.", "Diph.", "Ngwan.", "Sed.", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("xh", "default", {
        name: "xh",
        englishName: "isiXhosa",
        nativeName: "isiXhosa",
        language: "xh",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "iCawa", "uMvulo", "uLwesibini", "uLwesithathu", "uLwesine", "uLwesihlanu", "uMgqibelo" ],
                    namesShort: [ "Ca", "Mv", "Lb", "Lt", "Ln", "Lh", "Mg" ]
                },
                months: {
                    names: [ "Mqungu", "Mdumba", "Kwindla", "Tshazimpuzi", "Canzibe", "Silimela", "Khala", "Thupha", "Msintsi", "Dwarha", "Nkanga", "Mnga", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zu", "default", {
        name: "zu",
        englishName: "isiZulu",
        nativeName: "isiZulu",
        language: "zu",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "iSonto", "uMsombuluko", "uLwesibili", "uLwesithathu", "uLwesine", "uLwesihlanu", "uMgqibelo" ],
                    namesAbbr: [ "Son.", "Mso.", "Bi.", "Tha.", "Ne.", "Hla.", "Mgq." ]
                },
                months: {
                    names: [ "uMasingana", "uNhlolanja", "uNdasa", "uMbaso", "uNhlaba", "uNhlangulana", "uNtulikazi", "uNcwaba", "uMandulo", "uMfumfu", "uLwezi", "uZibandlela", "" ],
                    namesAbbr: [ "Mas.", "Nhlo.", "Nda.", "Mba.", "Nhla.", "Nhlang.", "Ntu.", "Ncwa.", "Man.", "Mfu.", "Lwe.", "Zib.", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("af", "default", {
        name: "af",
        englishName: "Afrikaans",
        nativeName: "Afrikaans",
        language: "af",
        numberFormat: {
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Sondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrydag", "Saterdag" ],
                    namesAbbr: [ "Son", "Maan", "Dins", "Woen", "Dond", "Vry", "Sat" ],
                    namesShort: [ "So", "Ma", "Di", "Wo", "Do", "Vr", "Sa" ]
                },
                months: {
                    names: [ "Januarie", "Februarie", "Maart", "April", "Mei", "Junie", "Julie", "Augustus", "September", "Oktober", "November", "Desember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ka", "default", {
        name: "ka",
        englishName: "Georgian",
        nativeName: "ქართული",
        language: "ka",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Lari"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი" ],
                    namesAbbr: [ "კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი" ],
                    namesShort: [ "კ", "ო", "ს", "ო", "ხ", "პ", "შ" ]
                },
                months: {
                    names: [ "იანვარი", "თებერვალი", "მარტი", "აპრილი", "მაისი", "ივნისი", "ივლისი", "აგვისტო", "სექტემბერი", "ოქტომბერი", "ნოემბერი", "დეკემბერი", "" ],
                    namesAbbr: [ "იან", "თებ", "მარ", "აპრ", "მაის", "ივნ", "ივლ", "აგვ", "სექ", "ოქტ", "ნოემ", "დეკ", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "yyyy 'წლის' dd MM, dddd",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'წლის' dd MM, dddd H:mm",
                    F: "yyyy 'წლის' dd MM, dddd H:mm:ss",
                    M: "dd MM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fo", "default", {
        name: "fo",
        englishName: "Faroese",
        nativeName: "føroyskt",
        language: "fo",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "sunnudagur", "mánadagur", "týsdagur", "mikudagur", "hósdagur", "fríggjadagur", "leygardagur" ],
                    namesAbbr: [ "sun", "mán", "týs", "mik", "hós", "frí", "leyg" ],
                    namesShort: [ "su", "má", "tý", "mi", "hó", "fr", "ley" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "apríl", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hi", "default", {
        name: "hi",
        englishName: "Hindi",
        nativeName: "हिंदी",
        language: "hi",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "रविवार", "सोमवार", "मंगलवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "रवि.", "सोम.", "मंगल.", "बुध.", "गुरु.", "शुक्र.", "शनि." ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ],
                    namesAbbr: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ]
                },
                AM: [ "पूर्वाह्न", "पूर्वाह्न", "पूर्वाह्न" ],
                PM: [ "अपराह्न", "अपराह्न", "अपराह्न" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mt", "default", {
        name: "mt",
        englishName: "Maltese",
        nativeName: "Malti",
        language: "mt",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Il-Ħadd", "It-Tnejn", "It-Tlieta", "L-Erbgħa", "Il-Ħamis", "Il-Ġimgħa", "Is-Sibt" ],
                    namesAbbr: [ "Ħad", "Tne", "Tli", "Erb", "Ħam", "Ġim", "Sib" ],
                    namesShort: [ "I", "I", "I", "L", "I", "I", "I" ]
                },
                months: {
                    names: [ "Jannar", "Frar", "Marzu", "April", "Mejju", "Ġunju", "Lulju", "Awissu", "Settembru", "Ottubru", "Novembru", "Diċembru", "" ],
                    namesAbbr: [ "Jan", "Fra", "Mar", "Apr", "Mej", "Ġun", "Lul", "Awi", "Set", "Ott", "Nov", "Diċ", "" ]
                },
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' ta\\' 'MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' ta\\' 'MMMM yyyy HH:mm",
                    F: "dddd, d' ta\\' 'MMMM yyyy HH:mm:ss",
                    M: "d' ta\\' 'MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("se", "default", {
        name: "se",
        englishName: "Sami (Northern)",
        nativeName: "davvisámegiella",
        language: "se",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sotnabeaivi", "vuossárga", "maŋŋebárga", "gaskavahkku", "duorastat", "bearjadat", "lávvardat" ],
                    namesAbbr: [ "sotn", "vuos", "maŋ", "gask", "duor", "bear", "láv" ],
                    namesShort: [ "s", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ođđajagemánnu", "guovvamánnu", "njukčamánnu", "cuoŋománnu", "miessemánnu", "geassemánnu", "suoidnemánnu", "borgemánnu", "čakčamánnu", "golggotmánnu", "skábmamánnu", "juovlamánnu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđajagimánu", "guovvamánu", "njukčamánu", "cuoŋománu", "miessemánu", "geassemánu", "suoidnemánu", "borgemánu", "čakčamánu", "golggotmánu", "skábmamánu", "juovlamánu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ga", "default", {
        name: "ga",
        englishName: "Irish",
        nativeName: "Gaeilge",
        language: "ga",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn" ],
                    namesAbbr: [ "Domh", "Luan", "Máir", "Céad", "Déar", "Aoi", "Sath" ],
                    namesShort: [ "Do", "Lu", "Má", "Cé", "De", "Ao", "Sa" ]
                },
                months: {
                    names: [ "Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig", "" ],
                    namesAbbr: [ "Ean", "Feabh", "Már", "Aib", "Bealt", "Meith", "Iúil", "Lún", "M.Fómh", "D.Fómh", "Samh", "Noll", "" ]
                },
                AM: [ "r.n.", "r.n.", "R.N." ],
                PM: [ "i.n.", "i.n.", "I.N." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ms", "default", {
        name: "ms",
        englishName: "Malay",
        nativeName: "Bahasa Melayu",
        language: "ms",
        numberFormat: {
            currency: {
                decimals: 0,
                symbol: "RM"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesAbbr: [ "Ahad", "Isnin", "Sel", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesShort: [ "A", "I", "S", "R", "K", "J", "S" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogos", "Sept", "Okt", "Nov", "Dis", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM yyyy H:mm",
                    F: "dd MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kk", "default", {
        name: "kk",
        englishName: "Kazakh",
        nativeName: "Қазақ",
        language: "kk",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                ",": " ",
                ".": "-",
                symbol: "Т"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Жексенбі", "Дүйсенбі", "Сейсенбі", "Сәрсенбі", "Бейсенбі", "Жұма", "Сенбі" ],
                    namesAbbr: [ "Жк", "Дс", "Сс", "Ср", "Бс", "Жм", "Сн" ],
                    namesShort: [ "Жк", "Дс", "Сс", "Ср", "Бс", "Жм", "Сн" ]
                },
                months: {
                    names: [ "қаңтар", "ақпан", "наурыз", "сәуір", "мамыр", "маусым", "шілде", "тамыз", "қыркүйек", "қазан", "қараша", "желтоқсан", "" ],
                    namesAbbr: [ "Қаң", "Ақп", "Нау", "Сәу", "Мам", "Мау", "Шіл", "Там", "Қыр", "Қаз", "Қар", "Жел", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy 'ж.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'ж.' H:mm",
                    F: "d MMMM yyyy 'ж.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ky", "default", {
        name: "ky",
        englishName: "Kyrgyz",
        nativeName: "Кыргыз",
        language: "ky",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": "-",
                symbol: "сом"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Жекшемби", "Дүйшөмбү", "Шейшемби", "Шаршемби", "Бейшемби", "Жума", "Ишемби" ],
                    namesAbbr: [ "Жш", "Дш", "Шш", "Шр", "Бш", "Жм", "Иш" ],
                    namesShort: [ "Жш", "Дш", "Шш", "Шр", "Бш", "Жм", "Иш" ]
                },
                months: {
                    names: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d'-'MMMM yyyy'-ж.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d'-'MMMM yyyy'-ж.' H:mm",
                    F: "d'-'MMMM yyyy'-ж.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy'-ж.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("sw", "default", {
        name: "sw",
        englishName: "Kiswahili",
        nativeName: "Kiswahili",
        language: "sw",
        numberFormat: {
            currency: {
                symbol: "S"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Jumapili", "Jumatatu", "Jumanne", "Jumatano", "Alhamisi", "Ijumaa", "Jumamosi" ],
                    namesAbbr: [ "Jumap.", "Jumat.", "Juman.", "Jumat.", "Alh.", "Iju.", "Jumam." ],
                    namesShort: [ "P", "T", "N", "T", "A", "I", "M" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Machi", "Aprili", "Mei", "Juni", "Julai", "Agosti", "Septemba", "Oktoba", "Novemba", "Decemba", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ago", "Sep", "Okt", "Nov", "Dec", "" ]
                }
            }
        }
    });
    Globalize.addCultureInfo("tk", "default", {
        name: "tk",
        englishName: "Turkmen",
        nativeName: "türkmençe",
        language: "tk",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-üznüksizlik",
            positiveInfinity: "üznüksizlik",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "m."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Duşenbe", "Sişenbe", "Çarşenbe", "Penşenbe", "Anna", "Şenbe", "Ýekşenbe" ],
                    namesAbbr: [ "Db", "Sb", "Çb", "Pb", "An", "Şb", "Ýb" ],
                    namesShort: [ "D", "S", "Ç", "P", "A", "Ş", "Ý" ]
                },
                months: {
                    names: [ "Ýanwar", "Fewral", "Mart", "Aprel", "Maý", "lýun", "lýul", "Awgust", "Sentýabr", "Oktýabr", "Noýabr", "Dekabr", "" ],
                    namesAbbr: [ "Ýan", "Few", "Mart", "Apr", "Maý", "lýun", "lýul", "Awg", "Sen", "Okt", "Not", "Dek", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "yyyy 'ý.' MMMM d",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'ý.' MMMM d H:mm",
                    F: "yyyy 'ý.' MMMM d H:mm:ss",
                    Y: "yyyy 'ý.' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("uz", "default", {
        name: "uz",
        englishName: "Uzbek",
        nativeName: "U'zbek",
        language: "uz",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                decimals: 0,
                ",": " ",
                ".": ",",
                symbol: "so'm"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "yakshanba", "dushanba", "seshanba", "chorshanba", "payshanba", "juma", "shanba" ],
                    namesAbbr: [ "yak.", "dsh.", "sesh.", "chr.", "psh.", "jm.", "sh." ],
                    namesShort: [ "ya", "d", "s", "ch", "p", "j", "sh" ]
                },
                months: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM yyyy",
                    D: "yyyy 'yil' d-MMMM",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'yil' d-MMMM HH:mm",
                    F: "yyyy 'yil' d-MMMM HH:mm:ss",
                    M: "d-MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tt", "default", {
        name: "tt",
        englishName: "Tatar",
        nativeName: "Татар",
        language: "tt",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Якшәмбе", "Дүшәмбе", "Сишәмбе", "Чәршәмбе", "Пәнҗешәмбе", "Җомга", "Шимбә" ],
                    namesAbbr: [ "Якш", "Дүш", "Сиш", "Чәрш", "Пәнҗ", "Җом", "Шим" ],
                    namesShort: [ "Я", "Д", "С", "Ч", "П", "Җ", "Ш" ]
                },
                months: {
                    names: [ "Гыйнвар", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "Гыйн.", "Фев.", "Мар.", "Апр.", "Май", "Июнь", "Июль", "Авг.", "Сен.", "Окт.", "Нояб.", "Дек.", "" ]
                },
                monthsGenitive: {
                    names: [ "Гыйнварның", "Февральнең", "Мартның", "Апрельнең", "Майның", "Июньнең", "Июльнең", "Августның", "Сентябрьның", "Октябрьның", "Ноябрьның", "Декабрьның", "" ],
                    namesAbbr: [ "Гыйн.-ның", "Фев.-нең", "Мар.-ның", "Апр.-нең", "Майның", "Июньнең", "Июльнең", "Авг.-ның", "Сен.-ның", "Окт.-ның", "Нояб.-ның", "Дек.-ның", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bn", "default", {
        name: "bn",
        englishName: "Bengali",
        nativeName: "বাংলা",
        language: "bn",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                pattern: [ "-%n", "%n" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "টা"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                ":": ".",
                firstDay: 1,
                days: {
                    names: [ "রবিবার", "সোমবার", "মঙ্গলবার", "বুধবার", "বৃহস্পতিবার", "শুক্রবার", "শনিবার" ],
                    namesAbbr: [ "রবি.", "সোম.", "মঙ্গল.", "বুধ.", "বৃহস্পতি.", "শুক্র.", "শনি." ],
                    namesShort: [ "র", "স", "ম", "ব", "ব", "শ", "শ" ]
                },
                months: {
                    names: [ "জানুয়ারী", "ফেব্রুয়ারী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগস্ট", "সেপ্টেম্বর", "অক্টোবর", "নভেম্বর", "ডিসেম্বর", "" ],
                    namesAbbr: [ "জানু.", "ফেব্রু.", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগ.", "সেপ্টে.", "অক্টো.", "নভে.", "ডিসে.", "" ]
                },
                AM: [ "পুর্বাহ্ন", "পুর্বাহ্ন", "পুর্বাহ্ন" ],
                PM: [ "অপরাহ্ন", "অপরাহ্ন", "অপরাহ্ন" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH.mm",
                    T: "HH.mm.ss",
                    f: "dd MMMM yyyy HH.mm",
                    F: "dd MMMM yyyy HH.mm.ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("pa", "default", {
        name: "pa",
        englishName: "Punjabi",
        nativeName: "ਪੰਜਾਬੀ",
        language: "pa",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ਰੁ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ਐਤਵਾਰ", "ਸੋਮਵਾਰ", "ਮੰਗਲਵਾਰ", "ਬੁੱਧਵਾਰ", "ਵੀਰਵਾਰ", "ਸ਼ੁੱਕਰਵਾਰ", "ਸ਼ਨਿੱਚਰਵਾਰ" ],
                    namesAbbr: [ "ਐਤ.", "ਸੋਮ.", "ਮੰਗਲ.", "ਬੁੱਧ.", "ਵੀਰ.", "ਸ਼ੁਕਰ.", "ਸ਼ਨਿੱਚਰ." ],
                    namesShort: [ "ਐ", "ਸ", "ਮ", "ਬ", "ਵ", "ਸ਼", "ਸ਼" ]
                },
                months: {
                    names: [ "ਜਨਵਰੀ", "ਫ਼ਰਵਰੀ", "ਮਾਰਚ", "ਅਪ੍ਰੈਲ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾਈ", "ਅਗਸਤ", "ਸਤੰਬਰ", "ਅਕਤੂਬਰ", "ਨਵੰਬਰ", "ਦਸੰਬਰ", "" ],
                    namesAbbr: [ "ਜਨਵਰੀ", "ਫ਼ਰਵਰੀ", "ਮਾਰਚ", "ਅਪ੍ਰੈਲ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾਈ", "ਅਗਸਤ", "ਸਤੰਬਰ", "ਅਕਤੂਬਰ", "ਨਵੰਬਰ", "ਦਸੰਬਰ", "" ]
                },
                AM: [ "ਸਵੇਰ", "ਸਵੇਰ", "ਸਵੇਰ" ],
                PM: [ "ਸ਼ਾਮ", "ਸ਼ਾਮ", "ਸ਼ਾਮ" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy dddd",
                    t: "tt hh:mm",
                    T: "tt hh:mm:ss",
                    f: "dd MMMM yyyy dddd tt hh:mm",
                    F: "dd MMMM yyyy dddd tt hh:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("gu", "default", {
        name: "gu",
        englishName: "Gujarati",
        nativeName: "ગુજરાતી",
        language: "gu",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "રૂ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "રવિવાર", "સોમવાર", "મંગળવાર", "બુધવાર", "ગુરુવાર", "શુક્રવાર", "શનિવાર" ],
                    namesAbbr: [ "રવિ", "સોમ", "મંગળ", "બુધ", "ગુરુ", "શુક્ર", "શનિ" ],
                    namesShort: [ "ર", "સ", "મ", "બ", "ગ", "શ", "શ" ]
                },
                months: {
                    names: [ "જાન્યુઆરી", "ફેબ્રુઆરી", "માર્ચ", "એપ્રિલ", "મે", "જૂન", "જુલાઈ", "ઑગસ્ટ", "સપ્ટેમ્બર", "ઑક્ટ્બર", "નવેમ્બર", "ડિસેમ્બર", "" ],
                    namesAbbr: [ "જાન્યુ", "ફેબ્રુ", "માર્ચ", "એપ્રિલ", "મે", "જૂન", "જુલાઈ", "ઑગસ્ટ", "સપ્ટે", "ઑક્ટો", "નવે", "ડિસે", "" ]
                },
                AM: [ "પૂર્વ મધ્યાહ્ન", "પૂર્વ મધ્યાહ્ન", "પૂર્વ મધ્યાહ્ન" ],
                PM: [ "ઉત્તર મધ્યાહ્ન", "ઉત્તર મધ્યાહ્ન", "ઉત્તર મધ્યાહ્ન" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("or", "default", {
        name: "or",
        englishName: "Oriya",
        nativeName: "ଓଡ଼ିଆ",
        language: "or",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ଟ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "ରବିବାର", "ସୋମବାର", "ମଙ୍ଗଳବାର", "ବୁଧବାର", "ଗୁରୁବାର", "ଶୁକ୍ରବାର", "ଶନିବାର" ],
                    namesAbbr: [ "ରବି.", "ସୋମ.", "ମଙ୍ଗଳ.", "ବୁଧ.", "ଗୁରୁ.", "ଶୁକ୍ର.", "ଶନି." ],
                    namesShort: [ "ର", "ସୋ", "ମ", "ବୁ", "ଗୁ", "ଶୁ", "ଶ" ]
                },
                months: {
                    names: [ "ଜାନୁୟାରୀ", "ଫ୍ରେବୃୟାରୀ", "ମାର୍ଚ୍ଚ", "ଏପ୍ରିଲ୍‌", "ମେ", "ଜୁନ୍‌", "ଜୁଲାଇ", "ଅଗଷ୍ଟ", "ସେପ୍ଟେମ୍ବର", "ଅକ୍ଟୋବର", "ନଭେମ୍ବର", "(ଡିସେମ୍ବର", "" ],
                    namesAbbr: [ "ଜାନୁୟାରୀ", "ଫ୍ରେବୃୟାରୀ", "ମାର୍ଚ୍ଚ", "ଏପ୍ରିଲ୍‌", "ମେ", "ଜୁନ୍‌", "ଜୁଲାଇ", "ଅଗଷ୍ଟ", "ସେପ୍ଟେମ୍ବର", "ଅକ୍ଟୋବର", "ନଭେମ୍ବର", "(ଡିସେମ୍ବର", "" ]
                },
                eras: [ {
                    name: "ଖ୍ରୀଷ୍ଟାବ୍ଦ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ta", "default", {
        name: "ta",
        englishName: "Tamil",
        nativeName: "தமிழ்",
        language: "ta",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ரூ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ஞாயிற்றுக்கிழமை", "திங்கள்கிழமை", "செவ்வாய்கிழமை", "புதன்கிழமை", "வியாழக்கிழமை", "வெள்ளிக்கிழமை", "சனிக்கிழமை" ],
                    namesAbbr: [ "ஞாயிறு", "திங்கள்", "செவ்வாய்", "புதன்", "வியாழன்", "வெள்ளி", "சனி" ],
                    namesShort: [ "ஞா", "தி", "செ", "பு", "வி", "வெ", "ச" ]
                },
                months: {
                    names: [ "ஜனவரி", "பிப்ரவரி", "மார்ச்", "ஏப்ரல்", "மே", "ஜூன்", "ஜூலை", "ஆகஸ்ட்", "செப்டம்பர்", "அக்டோபர்", "நவம்பர்", "டிசம்பர்", "" ],
                    namesAbbr: [ "ஜனவரி", "பிப்ரவரி", "மார்ச்", "ஏப்ரல்", "மே", "ஜூன்", "ஜூலை", "ஆகஸ்ட்", "செப்டம்பர்", "அக்டோபர்", "நவம்பர்", "டிசம்பர்", "" ]
                },
                AM: [ "காலை", "காலை", "காலை" ],
                PM: [ "மாலை", "மாலை", "மாலை" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("te", "default", {
        name: "te",
        englishName: "Telugu",
        nativeName: "తెలుగు",
        language: "te",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "రూ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ఆదివారం", "సోమవారం", "మంగళవారం", "బుధవారం", "గురువారం", "శుక్రవారం", "శనివారం" ],
                    namesAbbr: [ "ఆది.", "సోమ.", "మంగళ.", "బుధ.", "గురు.", "శుక్ర.", "శని." ],
                    namesShort: [ "ఆ", "సో", "మం", "బు", "గు", "శు", "శ" ]
                },
                months: {
                    names: [ "జనవరి", "ఫిబ్రవరి", "మార్చి", "ఏప్రిల్", "మే", "జూన్", "జూలై", "ఆగస్టు", "సెప్టెంబర్", "అక్టోబర్", "నవంబర్", "డిసెంబర్", "" ],
                    namesAbbr: [ "జనవరి", "ఫిబ్రవరి", "మార్చి", "ఏప్రిల్", "మే", "జూన్", "జూలై", "ఆగస్టు", "సెప్టెంబర్", "అక్టోబర్", "నవంబర్", "డిసెంబర్", "" ]
                },
                AM: [ "పూర్వాహ్న", "పూర్వాహ్న", "పూర్వాహ్న" ],
                PM: [ "అపరాహ్న", "అపరాహ్న", "అపరాహ్న" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("kn", "default", {
        name: "kn",
        englishName: "Kannada",
        nativeName: "ಕನ್ನಡ",
        language: "kn",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ರೂ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ಭಾನುವಾರ", "ಸೋಮವಾರ", "ಮಂಗಳವಾರ", "ಬುಧವಾರ", "ಗುರುವಾರ", "ಶುಕ್ರವಾರ", "ಶನಿವಾರ" ],
                    namesAbbr: [ "ಭಾನು.", "ಸೋಮ.", "ಮಂಗಳ.", "ಬುಧ.", "ಗುರು.", "ಶುಕ್ರ.", "ಶನಿ." ],
                    namesShort: [ "ರ", "ಸ", "ಮ", "ಬ", "ಗ", "ಶ", "ಶ" ]
                },
                months: {
                    names: [ "ಜನವರಿ", "ಫೆಬ್ರವರಿ", "ಮಾರ್ಚ್", "ಎಪ್ರಿಲ್", "ಮೇ", "ಜೂನ್", "ಜುಲೈ", "ಆಗಸ್ಟ್", "ಸೆಪ್ಟಂಬರ್", "ಅಕ್ಟೋಬರ್", "ನವೆಂಬರ್", "ಡಿಸೆಂಬರ್", "" ],
                    namesAbbr: [ "ಜನವರಿ", "ಫೆಬ್ರವರಿ", "ಮಾರ್ಚ್", "ಎಪ್ರಿಲ್", "ಮೇ", "ಜೂನ್", "ಜುಲೈ", "ಆಗಸ್ಟ್", "ಸೆಪ್ಟಂಬರ್", "ಅಕ್ಟೋಬರ್", "ನವೆಂಬರ್", "ಡಿಸೆಂಬರ್", "" ]
                },
                AM: [ "ಪೂರ್ವಾಹ್ನ", "ಪೂರ್ವಾಹ್ನ", "ಪೂರ್ವಾಹ್ನ" ],
                PM: [ "ಅಪರಾಹ್ನ", "ಅಪರಾಹ್ನ", "ಅಪರಾಹ್ನ" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ml", "default", {
        name: "ml",
        englishName: "Malayalam",
        nativeName: "മലയാളം",
        language: "ml",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                pattern: [ "-%n", "%n" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ക"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                ":": ".",
                firstDay: 1,
                days: {
                    names: [ "ഞായറാഴ്ച", "തിങ്കളാഴ്ച", "ചൊവ്വാഴ്ച", "ബുധനാഴ്ച", "വ്യാഴാഴ്ച", "വെള്ളിയാഴ്ച", "ശനിയാഴ്ച" ],
                    namesAbbr: [ "ഞായർ.", "തിങ്കൾ.", "ചൊവ്വ.", "ബുധൻ.", "വ്യാഴം.", "വെള്ളി.", "ശനി." ],
                    namesShort: [ "ഞ", "ത", "ച", "ബ", "വ", "വെ", "ശ" ]
                },
                months: {
                    names: [ "ജനുവരി", "ഫെബ്റുവരി", "മാറ്ച്ച്", "ഏപ്റില്", "മെയ്", "ജൂണ്", "ജൂലൈ", "ഓഗസ്ററ്", "സെപ്ററംബറ്", "ഒക്ടോബറ്", "നവംബറ്", "ഡിസംബറ്", "" ],
                    namesAbbr: [ "ജനുവരി", "ഫെബ്റുവരി", "മാറ്ച്ച്", "ഏപ്റില്", "മെയ്", "ജൂണ്", "ജൂലൈ", "ഓഗസ്ററ്", "സെപ്ററംബറ്", "ഒക്ടോബറ്", "നവംബറ്", "ഡിസംബറ്", "" ]
                },
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH.mm",
                    T: "HH.mm.ss",
                    f: "dd MMMM yyyy HH.mm",
                    F: "dd MMMM yyyy HH.mm.ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("as", "default", {
        name: "as",
        englishName: "Assamese",
        nativeName: "অসমীয়া",
        language: "as",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            NaN: "nan",
            negativeInfinity: "-infinity",
            positiveInfinity: "infinity",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "n$" ],
                groupSizes: [ 3, 2 ],
                symbol: "ট"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "সোমবাৰ", "মঙ্গলবাৰ", "বুধবাৰ", "বৃহস্পতিবাৰ", "শুক্রবাৰ", "শনিবাৰ", "ৰবিবাৰ" ],
                    namesAbbr: [ "সোম.", "মঙ্গল.", "বুধ.", "বৃহ.", "শুক্র.", "শনি.", "ৰবি." ],
                    namesShort: [ "সো", "ম", "বু", "বৃ", "শু", "শ", "র" ]
                },
                months: {
                    names: [ "জানুৱাৰী", "ফেব্রুৱাৰী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগষ্ট", "চেপ্টেম্বর", "অক্টোবর", "নবেম্বর", "ডিচেম্বর", "" ],
                    namesAbbr: [ "জানু", "ফেব্রু", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগষ্ট", "চেপ্টে", "অক্টো", "নবে", "ডিচে", "" ]
                },
                AM: [ "ৰাতিপু", "ৰাতিপু", "ৰাতিপু" ],
                PM: [ "আবেলি", "আবেলি", "আবেলি" ],
                eras: [ {
                    name: "খ্রীষ্টাব্দ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "yyyy,MMMM dd, dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "yyyy,MMMM dd, dddd tt h:mm",
                    F: "yyyy,MMMM dd, dddd tt h:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM,yy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mr", "default", {
        name: "mr",
        englishName: "Marathi",
        nativeName: "मराठी",
        language: "mr",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "रविवार", "सोमवार", "मंगळवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "रवि.", "सोम.", "मंगळ.", "बुध.", "गुरु.", "शुक्र.", "शनि." ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोव्हेंबर", "डिसेंबर", "" ],
                    namesAbbr: [ "जाने.", "फेब्रु.", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टें.", "ऑक्टो.", "नोव्हें.", "डिसें.", "" ]
                },
                AM: [ "म.पू.", "म.पू.", "म.पू." ],
                PM: [ "म.नं.", "म.नं.", "म.नं." ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sa", "default", {
        name: "sa",
        englishName: "Sanskrit",
        nativeName: "संस्कृत",
        language: "sa",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "रविवासरः", "सोमवासरः", "मङ्गलवासरः", "बुधवासरः", "गुरुवासरः", "शुक्रवासरः", "शनिवासरः" ],
                    namesAbbr: [ "रविवासरः", "सोमवासरः", "मङ्गलवासरः", "बुधवासरः", "गुरुवासरः", "शुक्रवासरः", "शनिवासरः" ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ],
                    namesAbbr: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ]
                },
                AM: [ "पूर्वाह्न", "पूर्वाह्न", "पूर्वाह्न" ],
                PM: [ "अपराह्न", "अपराह्न", "अपराह्न" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy dddd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy dddd HH:mm",
                    F: "dd MMMM yyyy dddd HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mn", "default", {
        name: "mn",
        englishName: "Mongolian",
        nativeName: "Монгол хэл",
        language: "mn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "₮"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Ням", "Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба" ],
                    namesAbbr: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ],
                    namesShort: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ]
                },
                months: {
                    names: [ "1 дүгээр сар", "2 дугаар сар", "3 дугаар сар", "4 дүгээр сар", "5 дугаар сар", "6 дугаар сар", "7 дугаар сар", "8 дугаар сар", "9 дүгээр сар", "10 дугаар сар", "11 дүгээр сар", "12 дугаар сар", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                monthsGenitive: {
                    names: [ "1 дүгээр сарын", "2 дугаар сарын", "3 дугаар сарын", "4 дүгээр сарын", "5 дугаар сарын", "6 дугаар сарын", "7 дугаар сарын", "8 дугаар сарын", "9 дүгээр сарын", "10 дугаар сарын", "11 дүгээр сарын", "12 дугаар сарын", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yy.MM.dd",
                    D: "yyyy 'оны' MMMM d",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'оны' MMMM d H:mm",
                    F: "yyyy 'оны' MMMM d H:mm:ss",
                    M: "d MMMM",
                    Y: "yyyy 'он' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("bo", "default", {
        name: "bo",
        englishName: "Tibetan",
        nativeName: "བོད་ཡིག",
        language: "bo",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ཨང་ཀི་མིན་པ།",
            negativeInfinity: "མོ་གྲངས་ཚད་མེད་ཆུང་བ།",
            positiveInfinity: "ཕོ་གྲངས་ཚད་མེད་ཆེ་བ།",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "གཟའ་ཉི་མ།", "གཟའ་ཟླ་བ།", "གཟའ་མིག་དམར།", "གཟའ་ལྷག་པ།", "གཟའ་ཕུར་བུ།", "གཟའ་པ་སངས།", "གཟའ་སྤེན་པ།" ],
                    namesAbbr: [ "ཉི་མ།", "ཟླ་བ།", "མིག་དམར།", "ལྷག་པ།", "ཕུར་བུ།", "པ་སངས།", "སྤེན་པ།" ],
                    namesShort: [ "༧", "༡", "༢", "༣", "༤", "༥", "༦" ]
                },
                months: {
                    names: [ "སྤྱི་ཟླ་དང་པོ།", "སྤྱི་ཟླ་གཉིས་པ།", "སྤྱི་ཟླ་གསུམ་པ།", "སྤྱི་ཟླ་བཞི་པ།", "སྤྱི་ཟླ་ལྔ་པ།", "སྤྱི་ཟླ་དྲུག་པ།", "སྤྱི་ཟླ་བདུན་པ།", "སྤྱི་ཟླ་བརྒྱད་པ།", "སྤྱི་ཟླ་དགུ་པ།", "སྤྱི་ཟླ་བཅུ་པོ།", "སྤྱི་ཟླ་བཅུ་གཅིག་པ།", "སྤྱི་ཟླ་བཅུ་གཉིས་པ།", "" ],
                    namesAbbr: [ "ཟླ་ ༡", "ཟླ་ ༢", "ཟླ་ ༣", "ཟླ་ ༤", "ཟླ་ ༥", "ཟླ་ ༦", "ཟླ་ ༧", "ཟླ་ ༨", "ཟླ་ ༩", "ཟླ་ ༡༠", "ཟླ་ ༡༡", "ཟླ་ ༡༢", "" ]
                },
                AM: [ "སྔ་དྲོ", "སྔ་དྲོ", "སྔ་དྲོ" ],
                PM: [ "ཕྱི་དྲོ", "ཕྱི་དྲོ", "ཕྱི་དྲོ" ],
                eras: [ {
                    name: "སྤྱི་ལོ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ལོའི་ཟླ' M'ཚེས' d",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy'ལོའི་ཟླ' M'ཚེས' d HH:mm",
                    F: "yyyy'ལོའི་ཟླ' M'ཚེས' d HH:mm:ss",
                    M: "'ཟླ་' M'ཚེས'd",
                    Y: "yyyy.M"
                }
            }
        }
    });
    Globalize.addCultureInfo("cy", "default", {
        name: "cy",
        englishName: "Welsh",
        nativeName: "Cymraeg",
        language: "cy",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "£"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn" ],
                    namesAbbr: [ "Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad" ],
                    namesShort: [ "Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa" ]
                },
                months: {
                    names: [ "Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr", "" ],
                    namesAbbr: [ "Ion", "Chwe", "Maw", "Ebr", "Mai", "Meh", "Gor", "Aws", "Med", "Hyd", "Tach", "Rhag", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("km", "default", {
        name: "km",
        englishName: "Khmer",
        nativeName: "ខ្មែរ",
        language: "km",
        numberFormat: {
            pattern: [ "- n" ],
            groupSizes: [ 3, 0 ],
            NaN: "NAN",
            negativeInfinity: "-- អនន្ត",
            positiveInfinity: "អនន្ត",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                symbol: "៛"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "ថ្ងៃអាទិត្យ", "ថ្ងៃច័ន្ទ", "ថ្ងៃអង្គារ", "ថ្ងៃពុធ", "ថ្ងៃព្រហស្បតិ៍", "ថ្ងៃសុក្រ", "ថ្ងៃសៅរ៍" ],
                    namesAbbr: [ "អាទិ.", "ច.", "អ.", "ពុ", "ព្រហ.", "សុ.", "ស." ],
                    namesShort: [ "អា", "ច", "អ", "ពុ", "ព្", "សុ", "ស" ]
                },
                months: {
                    names: [ "មករា", "កុម្ភៈ", "មិនា", "មេសា", "ឧសភា", "មិថុនា", "កក្កដា", "សីហា", "កញ្ញា", "តុលា", "វិច្ឆិកា", "ធ្នូ", "" ],
                    namesAbbr: [ "១", "២", "៣", "៤", "៥", "៦", "៧", "៨", "៩", "១០", "១១", "១២", "" ]
                },
                AM: [ "ព្រឹក", "ព្រឹក", "ព្រឹក" ],
                PM: [ "ល្ងាច", "ល្ងាច", "ល្ងាច" ],
                eras: [ {
                    name: "មុនគ.ស.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "d MMMM yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy H:mm tt",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "'ថ្ងៃទី' dd 'ខែ' MM",
                    Y: "'ខែ' MM 'ឆ្នាំ' yyyy"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ព្រឹក", "ព្រឹក", "ព្រឹក" ],
                PM: [ "ល្ងាច", "ល្ងាច", "ល្ងាច" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm tt",
                    F: "dddd, MMMM dd, yyyy HH:mm:ss"
                }
            }
        }
    });
    Globalize.addCultureInfo("lo", "default", {
        name: "lo",
        englishName: "Lao",
        nativeName: "ລາວ",
        language: "lo",
        numberFormat: {
            pattern: [ "(n)" ],
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "(n$)", "n$" ],
                groupSizes: [ 3, 0 ],
                symbol: "₭"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "ວັນອາທິດ", "ວັນຈັນ", "ວັນອັງຄານ", "ວັນພຸດ", "ວັນພະຫັດ", "ວັນສຸກ", "ວັນເສົາ" ],
                    namesAbbr: [ "ອາທິດ", "ຈັນ", "ອັງຄານ", "ພຸດ", "ພະຫັດ", "ສຸກ", "ເສົາ" ],
                    namesShort: [ "ອ", "ຈ", "ອ", "ພ", "ພ", "ສ", "ເ" ]
                },
                months: {
                    names: [ "ມັງກອນ", "ກຸມພາ", "ມີນາ", "ເມສາ", "ພຶດສະພາ", "ມິຖຸນາ", "ກໍລະກົດ", "ສິງຫາ", "ກັນຍາ", "ຕຸລາ", "ພະຈິກ", "ທັນວາ", "" ],
                    namesAbbr: [ "ມັງກອນ", "ກຸມພາ", "ມີນາ", "ເມສາ", "ພຶດສະພາ", "ມິຖຸນາ", "ກໍລະກົດ", "ສິງຫາ", "ກັນຍາ", "ຕຸລາ", "ພະຈິກ", "ທັນວາ", "" ]
                },
                AM: [ "ເຊົ້າ", "ເຊົ້າ", "ເຊົ້າ" ],
                PM: [ "ແລງ", "ແລງ", "ແລງ" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy H:mm tt",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gl", "default", {
        name: "gl",
        englishName: "Galician",
        nativeName: "galego",
        language: "gl",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "luns", "martes", "mércores", "xoves", "venres", "sábado" ],
                    namesAbbr: [ "dom", "luns", "mar", "mér", "xov", "ven", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mé", "xo", "ve", "sá" ]
                },
                months: {
                    names: [ "xaneiro", "febreiro", "marzo", "abril", "maio", "xuño", "xullo", "agosto", "setembro", "outubro", "novembro", "decembro", "" ],
                    namesAbbr: [ "xan", "feb", "mar", "abr", "maio", "xuñ", "xull", "ago", "set", "out", "nov", "dec", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kok", "default", {
        name: "kok",
        englishName: "Konkani",
        nativeName: "कोंकणी",
        language: "kok",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "आयतार", "सोमार", "मंगळार", "बुधवार", "बिरेस्तार", "सुक्रार", "शेनवार" ],
                    namesAbbr: [ "आय.", "सोम.", "मंगळ.", "बुध.", "बिरे.", "सुक्र.", "शेन." ],
                    namesShort: [ "आ", "स", "म", "ब", "ब", "स", "श" ]
                },
                months: {
                    names: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोवेम्बर", "डिसेंबर", "" ],
                    namesAbbr: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोवेम्बर", "डिसेंबर", "" ]
                },
                AM: [ "म.पू.", "म.पू.", "म.पू." ],
                PM: [ "म.नं.", "म.नं.", "म.नं." ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("syr", "default", {
        name: "syr",
        englishName: "Syriac",
        nativeName: "ܣܘܪܝܝܐ",
        language: "syr",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ل.س.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "ܚܕ ܒܫܒܐ", "ܬܪܝܢ ܒܫܒܐ", "ܬܠܬܐ ܒܫܒܐ", "ܐܪܒܥܐ ܒܫܒܐ", "ܚܡܫܐ ܒܫܒܐ", "ܥܪܘܒܬܐ", "ܫܒܬܐ" ],
                    namesAbbr: [ "܏ܐ ܏ܒܫ", "܏ܒ ܏ܒܫ", "܏ܓ ܏ܒܫ", "܏ܕ ܏ܒܫ", "܏ܗ ܏ܒܫ", "܏ܥܪܘܒ", "܏ܫܒ" ],
                    namesShort: [ "ܐ", "ܒ", "ܓ", "ܕ", "ܗ", "ܥ", "ܫ" ]
                },
                months: {
                    names: [ "ܟܢܘܢ ܐܚܪܝ", "ܫܒܛ", "ܐܕܪ", "ܢܝܣܢ", "ܐܝܪ", "ܚܙܝܪܢ", "ܬܡܘܙ", "ܐܒ", "ܐܝܠܘܠ", "ܬܫܪܝ ܩܕܝܡ", "ܬܫܪܝ ܐܚܪܝ", "ܟܢܘܢ ܩܕܝܡ", "" ],
                    namesAbbr: [ "܏ܟܢ ܏ܒ", "ܫܒܛ", "ܐܕܪ", "ܢܝܣܢ", "ܐܝܪ", "ܚܙܝܪܢ", "ܬܡܘܙ", "ܐܒ", "ܐܝܠܘܠ", "܏ܬܫ ܏ܐ", "܏ܬܫ ܏ܒ", "܏ܟܢ ܏ܐ", "" ]
                },
                AM: [ "ܩ.ܛ", "ܩ.ܛ", "ܩ.ܛ" ],
                PM: [ "ܒ.ܛ", "ܒ.ܛ", "ܒ.ܛ" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("si", "default", {
        name: "si",
        englishName: "Sinhala",
        nativeName: "සිංහල",
        language: "si",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            negativeInfinity: "-අනන්තය",
            positiveInfinity: "අනන්තය",
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                symbol: "රු."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ඉරිදා", "සඳුදා", "අඟහරුවාදා", "බදාදා", "බ්‍රහස්පතින්දා", "සිකුරාදා", "සෙනසුරාදා" ],
                    namesAbbr: [ "ඉරිදා", "සඳුදා", "කුජදා", "බුදදා", "ගුරුදා", "කිවිදා", "ශනිදා" ],
                    namesShort: [ "ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ" ]
                },
                months: {
                    names: [ "ජනවාරි", "පෙබරවාරි", "මාර්තු", "අ‌ප්‍රේල්", "මැයි", "ජූනි", "ජූලි", "අ‌ගෝස්තු", "සැප්තැම්බර්", "ඔක්තෝබර්", "නොවැම්බර්", "දෙසැම්බර්", "" ],
                    namesAbbr: [ "ජන.", "පෙබ.", "මාර්තු.", "අප්‍රේල්.", "මැයි.", "ජූනි.", "ජූලි.", "අගෝ.", "සැප්.", "ඔක්.", "නොවැ.", "දෙසැ.", "" ]
                },
                AM: [ "පෙ.ව.", "පෙ.ව.", "පෙ.ව." ],
                PM: [ "ප.ව.", "ප.ව.", "ප.ව." ],
                eras: [ {
                    name: "ක්‍රි.ව.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy MMMM' මස 'dd' වැනිදා 'dddd",
                    f: "yyyy MMMM' මස 'dd' වැනිදා 'dddd h:mm tt",
                    F: "yyyy MMMM' මස 'dd' වැනිදා 'dddd h:mm:ss tt",
                    Y: "yyyy MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("iu", "default", {
        name: "iu",
        englishName: "Inuktitut",
        nativeName: "Inuktitut",
        language: "iu",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Naattiinguja", "Naggajjau", "Aippiq", "Pingatsiq", "Sitammiq", "Tallirmiq", "Sivataarvik" ],
                    namesAbbr: [ "Nat", "Nag", "Aip", "Pi", "Sit", "Tal", "Siv" ],
                    namesShort: [ "N", "N", "A", "P", "S", "T", "S" ]
                },
                months: {
                    names: [ "Jaannuari", "Viivvuari", "Maatsi", "Iipuri", "Mai", "Juuni", "Julai", "Aaggiisi", "Sitipiri", "Utupiri", "Nuvipiri", "Tisipiri", "" ],
                    namesAbbr: [ "Jan", "Viv", "Mas", "Ipu", "Mai", "Jun", "Jul", "Agi", "Sii", "Uut", "Nuv", "Tis", "" ]
                },
                patterns: {
                    d: "d/MM/yyyy",
                    D: "ddd, MMMM dd,yyyy",
                    f: "ddd, MMMM dd,yyyy h:mm tt",
                    F: "ddd, MMMM dd,yyyy h:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("am", "default", {
        name: "am",
        englishName: "Amharic",
        nativeName: "አማርኛ",
        language: "am",
        numberFormat: {
            decimals: 1,
            groupSizes: [ 3, 0 ],
            NaN: "NAN",
            percent: {
                pattern: [ "-n%", "n%" ],
                decimals: 1,
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "ETB"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "እሑድ", "ሰኞ", "ማክሰኞ", "ረቡዕ", "ሐሙስ", "ዓርብ", "ቅዳሜ" ],
                    namesAbbr: [ "እሑድ", "ሰኞ", "ማክሰ", "ረቡዕ", "ሐሙስ", "ዓርብ", "ቅዳሜ" ],
                    namesShort: [ "እ", "ሰ", "ማ", "ረ", "ሐ", "ዓ", "ቅ" ]
                },
                months: {
                    names: [ "ጃንዩወሪ", "ፌብሩወሪ", "ማርች", "ኤፕረል", "ሜይ", "ጁን", "ጁላይ", "ኦገስት", "ሴፕቴምበር", "ኦክተውበር", "ኖቬምበር", "ዲሴምበር", "" ],
                    namesAbbr: [ "ጃንዩ", "ፌብሩ", "ማርች", "ኤፕረ", "ሜይ", "ጁን", "ጁላይ", "ኦገስ", "ሴፕቴ", "ኦክተ", "ኖቬም", "ዲሴም", "" ]
                },
                AM: [ "ጡዋት", "ጡዋት", "ጡዋት" ],
                PM: [ "ከሰዓት", "ከሰዓት", "ከሰዓት" ],
                eras: [ {
                    name: "ዓመተ  ምሕረት",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd '፣' MMMM d 'ቀን' yyyy",
                    f: "dddd '፣' MMMM d 'ቀን' yyyy h:mm tt",
                    F: "dddd '፣' MMMM d 'ቀን' yyyy h:mm:ss tt",
                    M: "MMMM d ቀን",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tzm", "default", {
        name: "tzm",
        englishName: "Tamazight",
        nativeName: "Tamazight",
        language: "tzm",
        numberFormat: {
            pattern: [ "n-" ],
            ",": ".",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                symbol: "DZD"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 6,
                days: {
                    names: [ "Acer", "Arime", "Aram", "Ahad", "Amhadh", "Sem", "Sedh" ],
                    namesAbbr: [ "Ace", "Ari", "Ara", "Aha", "Amh", "Sem", "Sed" ],
                    namesShort: [ "Ac", "Ar", "Ar", "Ah", "Am", "Se", "Se" ]
                },
                months: {
                    names: [ "Yenayer", "Furar", "Maghres", "Yebrir", "Mayu", "Yunyu", "Yulyu", "Ghuct", "Cutenber", "Ktuber", "Wambir", "Dujanbir", "" ],
                    namesAbbr: [ "Yen", "Fur", "Mag", "Yeb", "May", "Yun", "Yul", "Ghu", "Cut", "Ktu", "Wam", "Duj", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ne", "default", {
        name: "ne",
        englishName: "Nepali",
        nativeName: "नेपाली",
        language: "ne",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            NaN: "nan",
            negativeInfinity: "-infinity",
            positiveInfinity: "infinity",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "आइतवार", "सोमवार", "मङ्गलवार", "बुधवार", "बिहीवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "आइत", "सोम", "मङ्गल", "बुध", "बिही", "शुक्र", "शनि" ],
                    namesShort: [ "आ", "सो", "म", "बु", "बि", "शु", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फेब्रुअरी", "मार्च", "अप्रिल", "मे", "जून", "जुलाई", "अगस्त", "सेप्टेम्बर", "अक्टोबर", "नोभेम्बर", "डिसेम्बर", "" ],
                    namesAbbr: [ "जन", "फेब", "मार्च", "अप्रिल", "मे", "जून", "जुलाई", "अग", "सेप्ट", "अक्ट", "नोभ", "डिस", "" ]
                },
                AM: [ "विहानी", "विहानी", "विहानी" ],
                PM: [ "बेलुकी", "बेलुकी", "बेलुकी" ],
                eras: [ {
                    name: "a.d.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    Y: "MMMM,yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fy", "default", {
        name: "fy",
        englishName: "Frisian",
        nativeName: "Frysk",
        language: "fy",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "Snein", "Moandei", "Tiisdei", "Woansdei", "Tongersdei", "Freed", "Sneon" ],
                    namesAbbr: [ "Sn", "Mo", "Ti", "Wo", "To", "Fr", "Sn" ],
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                months: {
                    names: [ "jannewaris", "febrewaris", "maart", "april", "maaie", "juny", "july", "augustus", "septimber", "oktober", "novimber", "desimber", "" ],
                    namesAbbr: [ "jann", "febr", "mrt", "apr", "maaie", "jun", "jul", "aug", "sept", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d-M-yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd d MMMM yyyy H:mm",
                    F: "dddd d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ps", "default", {
        name: "ps",
        englishName: "Pashto",
        nativeName: "پښتو",
        language: "ps",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            ",": "،",
            ".": ",",
            NaN: "غ ع",
            negativeInfinity: "-∞",
            positiveInfinity: "∞",
            percent: {
                pattern: [ "%n-", "%n" ],
                ",": "،",
                ".": ","
            },
            currency: {
                pattern: [ "$n-", "$n" ],
                ",": "٬",
                ".": "٫",
                symbol: "؋"
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګا ښزمرى", "زمرى", "وږى", "تله", "لړم", "لنڈ ۍ", "مرغومى", "" ],
                    namesAbbr: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګا ښ", "زمرى", "وږى", "تله", "لړم", "لنڈ ۍ", "مرغومى", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "ل.ه",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy, dd, MMMM, dddd",
                    f: "yyyy, dd, MMMM, dddd h:mm tt",
                    F: "yyyy, dd, MMMM, dddd h:mm:ss tt",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fil", "default", {
        name: "fil",
        englishName: "Filipino",
        nativeName: "Filipino",
        language: "fil",
        numberFormat: {
            currency: {
                symbol: "PhP"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Linggo", "Lunes", "Martes", "Mierkoles", "Huebes", "Biernes", "Sabado" ],
                    namesAbbr: [ "Lin", "Lun", "Mar", "Mier", "Hueb", "Bier", "Saba" ],
                    namesShort: [ "L", "L", "M", "M", "H", "B", "S" ]
                },
                months: {
                    names: [ "Enero", "Pebrero", "Marso", "Abril", "Mayo", "Hunyo", "Hulyo", "Agosto", "Septyembre", "Oktubre", "Nobyembre", "Disyembre", "" ],
                    namesAbbr: [ "En", "Peb", "Mar", "Abr", "Mayo", "Hun", "Hul", "Agos", "Sept", "Okt", "Nob", "Dis", "" ]
                },
                eras: [ {
                    name: "Anno Domini",
                    start: null,
                    offset: 0
                } ]
            }
        }
    });
    Globalize.addCultureInfo("dv", "default", {
        name: "dv",
        englishName: "Divehi",
        nativeName: "ދިވެހިބަސް",
        language: "dv",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "n $-", "n $" ],
                symbol: "ރ."
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                days: {
                    names: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesAbbr: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesShort: [ "އާ", "ހޯ", "އަ", "ބު", "ބު", "ހު", "ހޮ" ]
                },
                months: {
                    names: [ "މުޙައްރަމް", "ޞަފަރު", "ރަބީޢުލްއައްވަލް", "ރަބީޢުލްއާޚިރު", "ޖުމާދަލްއޫލާ", "ޖުމާދަލްއާޚިރާ", "ރަޖަބް", "ޝަޢްބާން", "ރަމަޟާން", "ޝައްވާލް", "ޛުލްޤަޢިދާ", "ޛުލްޙިއްޖާ", "" ],
                    namesAbbr: [ "މުޙައްރަމް", "ޞަފަރު", "ރަބީޢުލްއައްވަލް", "ރަބީޢުލްއާޚިރު", "ޖުމާދަލްއޫލާ", "ޖުމާދަލްއާޚިރާ", "ރަޖަބް", "ޝަޢްބާން", "ރަމަޟާން", "ޝައްވާލް", "ޛުލްޤަޢިދާ", "ޛުލްޙިއްޖާ", "" ]
                },
                AM: [ "މކ", "މކ", "މކ" ],
                PM: [ "މފ", "މފ", "މފ" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd/MM/yyyy HH:mm",
                    F: "dd/MM/yyyy HH:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                days: {
                    names: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesAbbr: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesShort: [ "އާ", "ހޯ", "އަ", "ބު", "ބު", "ހު", "ހޮ" ]
                },
                months: {
                    names: [ "ޖަނަވަރީ", "ފެބްރުއަރީ", "މާޗް", "އޭޕްރިލް", "މެއި", "ޖޫން", "ޖުލައި", "އޯގަސްޓް", "ސެޕްޓެމްބަރ", "އޮކްޓޯބަރ", "ނޮވެމްބަރ", "ޑިސެމްބަރ", "" ],
                    namesAbbr: [ "ޖަނަވަރީ", "ފެބްރުއަރީ", "މާޗް", "އޭޕްރިލް", "މެއި", "ޖޫން", "ޖުލައި", "އޯގަސްޓް", "ސެޕްޓެމްބަރ", "އޮކްޓޯބަރ", "ނޮވެމްބަރ", "ޑިސެމްބަރ", "" ]
                },
                AM: [ "މކ", "މކ", "މކ" ],
                PM: [ "މފ", "މފ", "މފ" ],
                eras: [ {
                    name: "މީލާދީ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yy",
                    D: "ddd, yyyy MMMM dd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "ddd, yyyy MMMM dd HH:mm",
                    F: "ddd, yyyy MMMM dd HH:mm:ss",
                    Y: "yyyy, MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ha", "default", {
        name: "ha",
        englishName: "Hausa",
        nativeName: "Hausa",
        language: "ha",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Lahadi", "Litinin", "Talata", "Laraba", "Alhamis", "Juma'a", "Asabar" ],
                    namesAbbr: [ "Lah", "Lit", "Tal", "Lar", "Alh", "Jum", "Asa" ],
                    namesShort: [ "L", "L", "T", "L", "A", "J", "A" ]
                },
                months: {
                    names: [ "Januwaru", "Febreru", "Maris", "Afrilu", "Mayu", "Yuni", "Yuli", "Agusta", "Satumba", "Oktocba", "Nuwamba", "Disamba", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Afr", "May", "Yun", "Yul", "Agu", "Sat", "Okt", "Nuw", "Dis", "" ]
                },
                AM: [ "Safe", "safe", "SAFE" ],
                PM: [ "Yamma", "yamma", "YAMMA" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("yo", "default", {
        name: "yo",
        englishName: "Yoruba",
        nativeName: "Yoruba",
        language: "yo",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Aiku", "Aje", "Isegun", "Ojo'ru", "Ojo'bo", "Eti", "Abameta" ],
                    namesAbbr: [ "Aik", "Aje", "Ise", "Ojo", "Ojo", "Eti", "Aba" ],
                    namesShort: [ "A", "A", "I", "O", "O", "E", "A" ]
                },
                months: {
                    names: [ "Osu kinni", "Osu keji", "Osu keta", "Osu kerin", "Osu karun", "Osu kefa", "Osu keje", "Osu kejo", "Osu kesan", "Osu kewa", "Osu kokanla", "Osu keresi", "" ],
                    namesAbbr: [ "kin.", "kej.", "ket.", "ker.", "kar.", "kef.", "kej.", "kej.", "kes.", "kew.", "kok.", "ker.", "" ]
                },
                AM: [ "Owuro", "owuro", "OWURO" ],
                PM: [ "Ale", "ale", "ALE" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("quz", "default", {
        name: "quz",
        englishName: "Quechua",
        nativeName: "runasimi",
        language: "quz",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "$b"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "intichaw", "killachaw", "atipachaw", "quyllurchaw", "Ch' askachaw", "Illapachaw", "k'uychichaw" ],
                    namesAbbr: [ "int", "kil", "ati", "quy", "Ch'", "Ill", "k'u" ],
                    namesShort: [ "d", "k", "a", "m", "h", "b", "k" ]
                },
                months: {
                    names: [ "Qulla puquy", "Hatun puquy", "Pauqar waray", "ayriwa", "Aymuray", "Inti raymi", "Anta Sitwa", "Qhapaq Sitwa", "Uma raymi", "Kantaray", "Ayamarq'a", "Kapaq Raymi", "" ],
                    namesAbbr: [ "Qul", "Hat", "Pau", "ayr", "Aym", "Int", "Ant", "Qha", "Uma", "Kan", "Aya", "Kap", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("nso", "default", {
        name: "nso",
        englishName: "Sesotho sa Leboa",
        nativeName: "Sesotho sa Leboa",
        language: "nso",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Lamorena", "Mošupologo", "Labobedi", "Laboraro", "Labone", "Labohlano", "Mokibelo" ],
                    namesAbbr: [ "Lam", "Moš", "Lbb", "Lbr", "Lbn", "Lbh", "Mok" ],
                    namesShort: [ "L", "M", "L", "L", "L", "L", "M" ]
                },
                months: {
                    names: [ "Pherekgong", "Hlakola", "Mopitlo", "Moranang", "Mosegamanye", "Ngoatobošego", "Phuphu", "Phato", "Lewedi", "Diphalana", "Dibatsela", "Manthole", "" ],
                    namesAbbr: [ "Pher", "Hlak", "Mop", "Mor", "Mos", "Ngwat", "Phup", "Phat", "Lew", "Dip", "Dib", "Man", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ba", "default", {
        name: "ba",
        englishName: "Bashkir",
        nativeName: "Башҡорт",
        language: "ba",
        numberFormat: {
            ",": " ",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ",",
                symbol: "һ."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Йәкшәмбе", "Дүшәмбе", "Шишәмбе", "Шаршамбы", "Кесаҙна", "Йома", "Шәмбе" ],
                    namesAbbr: [ "Йш", "Дш", "Шш", "Шр", "Кс", "Йм", "Шб" ],
                    namesShort: [ "Йш", "Дш", "Шш", "Шр", "Кс", "Йм", "Шб" ]
                },
                months: {
                    names: [ "ғинуар", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь", "" ],
                    namesAbbr: [ "ғин", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d MMMM yyyy 'й'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'й' H:mm",
                    F: "d MMMM yyyy 'й' H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("lb", "default", {
        name: "lb",
        englishName: "Luxembourgish",
        nativeName: "Lëtzebuergesch",
        language: "lb",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "n. num.",
            negativeInfinity: "-onendlech",
            positiveInfinity: "+onendlech",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sonndeg", "Méindeg", "Dënschdeg", "Mëttwoch", "Donneschdeg", "Freideg", "Samschdeg" ],
                    namesAbbr: [ "Son", "Méi", "Dën", "Mët", "Don", "Fre", "Sam" ],
                    namesShort: [ "So", "Mé", "Dë", "Më", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "Mäerz", "Abrëll", "Mee", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mäe", "Abr", "Mee", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kl", "default", {
        name: "kl",
        englishName: "Greenlandic",
        nativeName: "kalaallisut",
        language: "kl",
        numberFormat: {
            ",": ".",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                groupSizes: [ 3, 0 ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 0 ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "sapaat", "ataasinngorneq", "marlunngorneq", "pingasunngorneq", "sisamanngorneq", "tallimanngorneq", "arfininngorneq" ],
                    namesAbbr: [ "sap", "ata", "mar", "ping", "sis", "tal", "arf" ],
                    namesShort: [ "sa", "at", "ma", "pi", "si", "ta", "ar" ]
                },
                months: {
                    names: [ "januari", "februari", "martsi", "apriili", "maaji", "juni", "juli", "aggusti", "septembari", "oktobari", "novembari", "decembari", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ig", "default", {
        name: "ig",
        englishName: "Igbo",
        nativeName: "Igbo",
        language: "ig",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Aiku", "Aje", "Isegun", "Ojo'ru", "Ojo'bo", "Eti", "Abameta" ],
                    namesAbbr: [ "Aik", "Aje", "Ise", "Ojo", "Ojo", "Eti", "Aba" ],
                    namesShort: [ "A", "A", "I", "O", "O", "E", "A" ]
                },
                months: {
                    names: [ "Onwa mbu", "Onwa ibua", "Onwa ato", "Onwa ano", "Onwa ise", "Onwa isi", "Onwa asa", "Onwa asato", "Onwa itolu", "Onwa iri", "Onwa iri n'ofu", "Onwa iri n'ibua", "" ],
                    namesAbbr: [ "mbu.", "ibu.", "ato.", "ano.", "ise", "isi", "asa", "asa.", "ito.", "iri.", "n'of.", "n'ib.", "" ]
                },
                AM: [ "Ututu", "ututu", "UTUTU" ],
                PM: [ "Efifie", "efifie", "EFIFIE" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ii", "default", {
        name: "ii",
        englishName: "Yi",
        nativeName: "ꆈꌠꁱꂷ",
        language: "ii",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ꌗꂷꀋꉬ",
            negativeInfinity: "ꀄꊭꌐꀋꉆ",
            positiveInfinity: "ꈤꇁꑖꀋꉬ",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "ꑭꆏꑍ", "ꆏꊂ꒔", "ꆏꊂꑍ", "ꆏꊂꌕ", "ꆏꊂꇖ", "ꆏꊂꉬ", "ꆏꊂꃘ" ],
                    namesAbbr: [ "ꑭꆏ", "ꆏ꒔", "ꆏꑍ", "ꆏꌕ", "ꆏꇖ", "ꆏꉬ", "ꆏꃘ" ],
                    namesShort: [ "ꆏ", "꒔", "ꑍ", "ꌕ", "ꇖ", "ꉬ", "ꃘ" ]
                },
                months: {
                    names: [ "ꋍꆪ", "ꑍꆪ", "ꌕꆪ", "ꇖꆪ", "ꉬꆪ", "ꃘꆪ", "ꏃꆪ", "ꉆꆪ", "ꈬꆪ", "ꊰꆪ", "ꊯꊪꆪ", "ꊰꑋꆪ", "" ],
                    namesAbbr: [ "ꋍꆪ", "ꑍꆪ", "ꌕꆪ", "ꇖꆪ", "ꉬꆪ", "ꃘꆪ", "ꏃꆪ", "ꉆꆪ", "ꈬꆪ", "ꊰꆪ", "ꊯꊪꆪ", "ꊰꑋꆪ", "" ]
                },
                AM: [ "ꂵꆪꈌꈐ", "ꂵꆪꈌꈐ", "ꂵꆪꈌꈐ" ],
                PM: [ "ꂵꆪꈌꉈ", "ꂵꆪꈌꉈ", "ꂵꆪꈌꉈ" ],
                eras: [ {
                    name: "ꇬꑼ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ꈎ' M'ꆪ' d'ꑍ'",
                    t: "tt h:mm",
                    T: "H:mm:ss",
                    f: "yyyy'ꈎ' M'ꆪ' d'ꑍ' tt h:mm",
                    F: "yyyy'ꈎ' M'ꆪ' d'ꑍ' H:mm:ss",
                    M: "M'ꆪ' d'ꑍ'",
                    Y: "yyyy'ꈎ' M'ꆪ'"
                }
            }
        }
    });
    Globalize.addCultureInfo("arn", "default", {
        name: "arn",
        englishName: "Mapudungun",
        nativeName: "Mapudungun",
        language: "arn",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("moh", "default", {
        name: "moh",
        englishName: "Mohawk",
        nativeName: "Kanien'kéha",
        language: "moh",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Awentatokentì:ke", "Awentataón'ke", "Ratironhia'kehronòn:ke", "Soséhne", "Okaristiiáhne", "Ronwaia'tanentaktonhne", "Entákta" ],
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                months: {
                    names: [ "Tsothohrkó:Wa", "Enniska", "Enniskó:Wa", "Onerahtókha", "Onerahtohkó:Wa", "Ohiari:Ha", "Ohiarihkó:Wa", "Seskéha", "Seskehkó:Wa", "Kenténha", "Kentenhkó:Wa", "Tsothóhrha", "" ]
                }
            }
        }
    });
    Globalize.addCultureInfo("br", "default", {
        name: "br",
        englishName: "Breton",
        nativeName: "brezhoneg",
        language: "br",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "NkN",
            negativeInfinity: "-Anfin",
            positiveInfinity: "+Anfin",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sul", "Lun", "Meurzh", "Merc'her", "Yaou", "Gwener", "Sadorn" ],
                    namesAbbr: [ "Sul", "Lun", "Meu.", "Mer.", "Yaou", "Gwe.", "Sad." ],
                    namesShort: [ "Su", "Lu", "Mz", "Mc", "Ya", "Gw", "Sa" ]
                },
                months: {
                    names: [ "Genver", "C'hwevrer", "Meurzh", "Ebrel", "Mae", "Mezheven", "Gouere", "Eost", "Gwengolo", "Here", "Du", "Kerzu", "" ],
                    namesAbbr: [ "Gen.", "C'hwe.", "Meur.", "Ebr.", "Mae", "Mezh.", "Goue.", "Eost", "Gwen.", "Here", "Du", "Kzu", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "g. J.-K.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ug", "default", {
        name: "ug",
        englishName: "Uyghur",
        nativeName: "ئۇيغۇرچە",
        language: "ug",
        isRTL: true,
        numberFormat: {
            NaN: "سان ئەمەس",
            negativeInfinity: "مەنپىي چەكسىزلىك",
            positiveInfinity: "مۇسبەت چەكسىزلىك",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "يەكشەنبە", "دۈشەنبە", "سەيشەنبە", "چارشەنبە", "پەيشەنبە", "جۈمە", "شەنبە" ],
                    namesAbbr: [ "يە", "دۈ", "سە", "چا", "پە", "جۈ", "شە" ],
                    namesShort: [ "ي", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي", "" ],
                    namesAbbr: [ "1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي", "" ]
                },
                AM: [ "چۈشتىن بۇرۇن", "چۈشتىن بۇرۇن", "چۈشتىن بۇرۇن" ],
                PM: [ "چۈشتىن كېيىن", "چۈشتىن كېيىن", "چۈشتىن كېيىن" ],
                eras: [ {
                    name: "مىلادى",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-M-d",
                    D: "yyyy-'يىلى' MMMM d-'كۈنى،'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy-'يىلى' MMMM d-'كۈنى،' H:mm",
                    F: "yyyy-'يىلى' MMMM d-'كۈنى،' H:mm:ss",
                    M: "MMMM d'-كۈنى'",
                    Y: "yyyy-'يىلى' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mi", "default", {
        name: "mi",
        englishName: "Maori",
        nativeName: "Reo Māori",
        language: "mi",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Rātapu", "Rāhina", "Rātū", "Rāapa", "Rāpare", "Rāmere", "Rāhoroi" ],
                    namesAbbr: [ "Ta", "Hi", "Tū", "Apa", "Pa", "Me", "Ho" ],
                    namesShort: [ "Ta", "Hi", "Tū", "Aa", "Pa", "Me", "Ho" ]
                },
                months: {
                    names: [ "Kohi-tātea", "Hui-tanguru", "Poutū-te-rangi", "Paenga-whāwhā", "Haratua", "Pipiri", "Hōngongoi", "Here-turi-kōkā", "Mahuru", "Whiringa-ā-nuku", "Whiringa-ā-rangi", "Hakihea", "" ],
                    namesAbbr: [ "Kohi", "Hui", "Pou", "Pae", "Hara", "Pipi", "Hōngo", "Here", "Mahu", "Nuku", "Rangi", "Haki", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd MMMM, yyyy",
                    f: "dddd, dd MMMM, yyyy h:mm tt",
                    F: "dddd, dd MMMM, yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM, yy"
                }
            }
        }
    });
    Globalize.addCultureInfo("oc", "default", {
        name: "oc",
        englishName: "Occitan",
        nativeName: "Occitan",
        language: "oc",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numeric",
            negativeInfinity: "-Infinit",
            positiveInfinity: "+Infinit",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimenge", "diluns", "dimars", "dimècres", "dijòus", "divendres", "dissabte" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mèc.", "jòu.", "ven.", "sab." ],
                    namesShort: [ "di", "lu", "ma", "mè", "jò", "ve", "sa" ]
                },
                months: {
                    names: [ "genier", "febrier", "març", "abril", "mai", "junh", "julh", "agost", "setembre", "octobre", "novembre", "desembre", "" ],
                    namesAbbr: [ "gen.", "feb.", "mar.", "abr.", "mai.", "jun.", "jul.", "ag.", "set.", "oct.", "nov.", "des.", "" ]
                },
                monthsGenitive: {
                    names: [ "de genier", "de febrier", "de març", "d'abril", "de mai", "de junh", "de julh", "d'agost", "de setembre", "d'octobre", "de novembre", "de desembre", "" ],
                    namesAbbr: [ "gen.", "feb.", "mar.", "abr.", "mai.", "jun.", "jul.", "ag.", "set.", "oct.", "nov.", "des.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "après Jèsus-Crist",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd,' lo 'd MMMM' de 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd,' lo 'd MMMM' de 'yyyy HH:mm",
                    F: "dddd,' lo 'd MMMM' de 'yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("co", "default", {
        name: "co",
        englishName: "Corsican",
        nativeName: "Corsu",
        language: "co",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Mica numericu",
            negativeInfinity: "-Infinitu",
            positiveInfinity: "+Infinitu",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dumenica", "luni", "marti", "mercuri", "ghjovi", "venderi", "sabbatu" ],
                    namesAbbr: [ "dum.", "lun.", "mar.", "mer.", "ghj.", "ven.", "sab." ],
                    namesShort: [ "du", "lu", "ma", "me", "gh", "ve", "sa" ]
                },
                months: {
                    names: [ "ghjennaghju", "ferraghju", "marzu", "aprile", "maghju", "ghjunghju", "lugliu", "aostu", "settembre", "ottobre", "nuvembre", "dicembre", "" ],
                    namesAbbr: [ "ghje", "ferr", "marz", "apri", "magh", "ghju", "lugl", "aost", "sett", "otto", "nuve", "dice", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "dopu J-C",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gsw", "default", {
        name: "gsw",
        englishName: "Alsatian",
        nativeName: "Elsässisch",
        language: "gsw",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Ohne Nummer",
            negativeInfinity: "-Unendlich",
            positiveInfinity: "+Unendlich",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sundàà", "Mondàà", "Dienschdàà", "Mittwuch", "Dunnerschdàà", "Fridàà", "Sàmschdàà" ],
                    namesAbbr: [ "Su.", "Mo.", "Di.", "Mi.", "Du.", "Fr.", "Sà." ],
                    namesShort: [ "Su", "Mo", "Di", "Mi", "Du", "Fr", "Sà" ]
                },
                months: {
                    names: [ "Jänner", "Feverje", "März", "Àpril", "Mai", "Jüni", "Jüli", "Augscht", "September", "Oktower", "Nowember", "Dezember", "" ],
                    namesAbbr: [ "Jän.", "Fev.", "März", "Apr.", "Mai", "Jüni", "Jüli", "Aug.", "Sept.", "Okt.", "Now.", "Dez.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "Vor J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sah", "default", {
        name: "sah",
        englishName: "Yakut",
        nativeName: "саха",
        language: "sah",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "NAN",
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "с."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "баскыһыанньа", "бэнидиэнньик", "оптуорунньук", "сэрэдэ", "чэппиэр", "бээтинсэ", "субуота" ],
                    namesAbbr: [ "Бс", "Бн", "Оп", "Ср", "Чп", "Бт", "Сб" ],
                    namesShort: [ "Бс", "Бн", "Оп", "Ср", "Чп", "Бт", "Сб" ]
                },
                months: {
                    names: [ "Тохсунньу", "Олунньу", "Кулун тутар", "Муус устар", "Ыам ыйа", "Бэс ыйа", "От ыйа", "Атырдьах ыйа", "Балаҕан ыйа", "Алтынньы", "Сэтинньи", "Ахсынньы", "" ],
                    namesAbbr: [ "тхс", "олн", "кул", "мст", "ыам", "бэс", "отй", "атр", "блҕ", "алт", "стн", "ахс", "" ]
                },
                monthsGenitive: {
                    names: [ "тохсунньу", "олунньу", "кулун тутар", "муус устар", "ыам ыйын", "бэс ыйын", "от ыйын", "атырдьах ыйын", "балаҕан ыйын", "алтынньы", "сэтинньи", "ахсынньы", "" ],
                    namesAbbr: [ "тхс", "олн", "кул", "мст", "ыам", "бэс", "отй", "атр", "блҕ", "алт", "стн", "ахс", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "MM.dd.yyyy",
                    D: "MMMM d yyyy 'с.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d yyyy 'с.' H:mm",
                    F: "MMMM d yyyy 'с.' H:mm:ss",
                    Y: "MMMM yyyy 'с.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("qut", "default", {
        name: "qut",
        englishName: "K'iche",
        nativeName: "K'iche",
        language: "qut",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                symbol: "Q"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "juq'ij", "kaq'ij", "oxq'ij", "kajq'ij", "joq'ij", "waqq'ij", "wuqq'ij" ],
                    namesAbbr: [ "juq", "kaq", "oxq", "kajq", "joq", "waqq", "wuqq" ],
                    namesShort: [ "ju", "ka", "ox", "ka", "jo", "wa", "wu" ]
                },
                months: {
                    names: [ "nab'e ik'", "ukab' ik'", "rox ik'", "ukaj ik'", "uro' ik'", "uwaq ik'", "uwuq ik'", "uwajxaq ik'", "ub'elej ik'", "ulaj ik'", "ujulaj ik'", "ukab'laj ik'", "" ],
                    namesAbbr: [ "nab'e", "ukab", "rox", "ukaj", "uro", "uwaq", "uwuq", "uwajxaq", "ub'elej", "ulaj", "ujulaj", "ukab'laj", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("rw", "default", {
        name: "rw",
        englishName: "Kinyarwanda",
        nativeName: "Kinyarwanda",
        language: "rw",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "RWF"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Ku wa mbere", "Ku wa kabiri", "Ku wa gatatu", "Ku wa kane", "Ku wa gatanu", "Ku wa gatandatu", "Ku cyumweru" ],
                    namesAbbr: [ "mbe.", "kab.", "gat.", "kan.", "gat.", "gat.", "cyu." ],
                    namesShort: [ "mb", "ka", "ga", "ka", "ga", "ga", "cy" ]
                },
                months: {
                    names: [ "Mutarama", "Gashyantare", "Werurwe", "Mata", "Gicurasi", "Kamena", "Nyakanga", "Kanama", "Nzeli", "Ukwakira", "Ugushyingo", "Ukuboza", "" ],
                    namesAbbr: [ "Mut", "Gas", "Wer", "Mat", "Gic", "Kam", "Nya", "Kan", "Nze", "Ukwa", "Ugu", "Uku", "" ]
                },
                AM: [ "saa moya z.m.", "saa moya z.m.", "SAA MOYA Z.M." ],
                PM: [ "saa moya z.n.", "saa moya z.n.", "SAA MOYA Z.N." ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ]
            }
        }
    });
    Globalize.addCultureInfo("wo", "default", {
        name: "wo",
        englishName: "Wolof",
        nativeName: "Wolof",
        language: "wo",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "XOF"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("prs", "default", {
        name: "prs",
        englishName: "Dari",
        nativeName: "درى",
        language: "prs",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            ",": ".",
            ".": ",",
            NaN: "غ ع",
            negativeInfinity: "-∞",
            positiveInfinity: "∞",
            percent: {
                pattern: [ "%n-", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$n-", "$n" ],
                symbol: "؋"
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                firstDay: 5,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                firstDay: 5,
                days: {
                    names: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګاښ", "زمرى", "وږى", "تله", "لړم", "ليندۍ", "مرغومى", "" ],
                    namesAbbr: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګاښ", "زمرى", "وږى", "تله", "لړم", "ليندۍ", "مرغومى", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "ل.ه",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy, dd, MMMM, dddd",
                    f: "yyyy, dd, MMMM, dddd h:mm tt",
                    F: "yyyy, dd, MMMM, dddd h:mm:ss tt",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gd", "default", {
        name: "gd",
        englishName: "Scottish Gaelic",
        nativeName: "Gàidhlig",
        language: "gd",
        numberFormat: {
            negativeInfinity: "-Neo-chrìochnachd",
            positiveInfinity: "Neo-chrìochnachd",
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "£"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ],
                    namesAbbr: [ "Dòm", "Lua", "Mài", "Cia", "Ard", "Hao", "Sat" ],
                    namesShort: [ "D", "L", "M", "C", "A", "H", "S" ]
                },
                months: {
                    names: [ "Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd", "" ],
                    namesAbbr: [ "Fao", "Gea", "Màr", "Gib", "Cèi", "Ògm", "Iuc", "Lùn", "Sul", "Dàm", "Sam", "Dùb", "" ]
                },
                AM: [ "m", "m", "M" ],
                PM: [ "f", "f", "F" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-SA", "default", {
        name: "ar-SA",
        englishName: "Arabic (Saudi Arabia)",
        nativeName: "العربية (المملكة العربية السعودية)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ر.س.‏"
            }
        },
        calendars: {
            standard: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("bg-BG", "default", {
        name: "bg-BG",
        englishName: "Bulgarian (Bulgaria)",
        nativeName: "български (България)",
        language: "bg",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "- безкрайност",
            positiveInfinity: "+ безкрайност",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "лв."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "неделя", "понеделник", "вторник", "сряда", "четвъртък", "петък", "събота" ],
                    namesAbbr: [ "нед", "пон", "вт", "ср", "четв", "пет", "съб" ],
                    namesShort: [ "н", "п", "в", "с", "ч", "п", "с" ]
                },
                months: {
                    names: [ "януари", "февруари", "март", "април", "май", "юни", "юли", "август", "септември", "октомври", "ноември", "декември", "" ],
                    namesAbbr: [ "ян", "февр", "март", "апр", "май", "юни", "юли", "авг", "септ", "окт", "ноември", "дек", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "след новата ера",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy 'г.'",
                    D: "dd MMMM yyyy 'г.'",
                    t: "HH:mm 'ч.'",
                    T: "HH:mm:ss 'ч.'",
                    f: "dd MMMM yyyy 'г.' HH:mm 'ч.'",
                    F: "dd MMMM yyyy 'г.' HH:mm:ss 'ч.'",
                    M: "dd MMMM",
                    Y: "MMMM yyyy 'г.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("ca-ES", "default", {
        name: "ca-ES",
        englishName: "Catalan (Catalan)",
        nativeName: "català (català)",
        language: "ca",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinit",
            positiveInfinity: "Infinit",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte" ],
                    namesAbbr: [ "dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds." ],
                    namesShort: [ "dg", "dl", "dt", "dc", "dj", "dv", "ds" ]
                },
                months: {
                    names: [ "gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre", "" ],
                    namesAbbr: [ "gen", "feb", "març", "abr", "maig", "juny", "jul", "ag", "set", "oct", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' / 'MMMM' / 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' / 'MMMM' / 'yyyy HH:mm",
                    F: "dddd, d' / 'MMMM' / 'yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' / 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-TW", "default", {
        name: "zh-TW",
        englishName: "Chinese (Traditional, Taiwan)",
        nativeName: "中文(台灣)",
        language: "zh-CHT",
        numberFormat: {
            NaN: "不是一個數字",
            negativeInfinity: "負無窮大",
            positiveInfinity: "正無窮大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "NT$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "西元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "tt hh:mm",
                    T: "tt hh:mm:ss",
                    f: "yyyy'年'M'月'd'日' tt hh:mm",
                    F: "yyyy'年'M'月'd'日' tt hh:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            },
            Taiwan: {
                name: "Taiwan",
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "",
                    start: null,
                    offset: 1911
                } ],
                twoDigitYearMax: 99,
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "tt hh:mm",
                    T: "tt hh:mm:ss",
                    f: "yyyy'年'M'月'd'日' tt hh:mm",
                    F: "yyyy'年'M'月'd'日' tt hh:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("cs-CZ", "default", {
        name: "cs-CZ",
        englishName: "Czech (Czech Republic)",
        nativeName: "čeština (Česká republika)",
        language: "cs",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Není číslo",
            negativeInfinity: "-nekonečno",
            positiveInfinity: "+nekonečno",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Kč"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "neděle", "pondělí", "úterý", "středa", "čtvrtek", "pátek", "sobota" ],
                    namesAbbr: [ "ne", "po", "út", "st", "čt", "pá", "so" ],
                    namesShort: [ "ne", "po", "út", "st", "čt", "pá", "so" ]
                },
                months: {
                    names: [ "leden", "únor", "březen", "duben", "květen", "červen", "červenec", "srpen", "září", "říjen", "listopad", "prosinec", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                monthsGenitive: {
                    names: [ "ledna", "února", "března", "dubna", "května", "června", "července", "srpna", "září", "října", "listopadu", "prosince", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "dop.", "dop.", "DOP." ],
                PM: [ "odp.", "odp.", "ODP." ],
                eras: [ {
                    name: "n. l.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("da-DK", "default", {
        name: "da-DK",
        englishName: "Danish (Denmark)",
        nativeName: "dansk (Danmark)",
        language: "da",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag" ],
                    namesAbbr: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ],
                    namesShort: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ]
                },
                months: {
                    names: [ "januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("de-DE", "default", {
        name: "de-DE",
        englishName: "German (Germany)",
        nativeName: "Deutsch (Deutschland)",
        language: "de",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("el-GR", "default", {
        name: "el-GR",
        englishName: "Greek (Greece)",
        nativeName: "Ελληνικά (Ελλάδα)",
        language: "el",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "μη αριθμός",
            negativeInfinity: "-Άπειρο",
            positiveInfinity: "Άπειρο",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο" ],
                    namesAbbr: [ "Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ" ],
                    namesShort: [ "Κυ", "Δε", "Τρ", "Τε", "Πε", "Πα", "Σά" ]
                },
                months: {
                    names: [ "Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος", "" ],
                    namesAbbr: [ "Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαϊ", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ", "" ]
                },
                monthsGenitive: {
                    names: [ "Ιανουαρίου", "Φεβρουαρίου", "Μαρτίου", "Απριλίου", "Μαΐου", "Ιουνίου", "Ιουλίου", "Αυγούστου", "Σεπτεμβρίου", "Οκτωβρίου", "Νοεμβρίου", "Δεκεμβρίου", "" ],
                    namesAbbr: [ "Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαϊ", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ", "" ]
                },
                AM: [ "πμ", "πμ", "ΠΜ" ],
                PM: [ "μμ", "μμ", "ΜΜ" ],
                eras: [ {
                    name: "μ.Χ.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd, d MMMM yyyy",
                    f: "dddd, d MMMM yyyy h:mm tt",
                    F: "dddd, d MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-US", "default", {
        name: "en-US",
        englishName: "English (United States)"
    });
    Globalize.addCultureInfo("fi-FI", "default", {
        name: "fi-FI",
        englishName: "Finnish (Finland)",
        nativeName: "suomi (Suomi)",
        language: "fi",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai" ],
                    namesAbbr: [ "su", "ma", "ti", "ke", "to", "pe", "la" ],
                    namesShort: [ "su", "ma", "ti", "ke", "to", "pe", "la" ]
                },
                months: {
                    names: [ "tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu", "" ],
                    namesAbbr: [ "tammi", "helmi", "maalis", "huhti", "touko", "kesä", "heinä", "elo", "syys", "loka", "marras", "joulu", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM'ta 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM'ta 'yyyy H:mm",
                    F: "d. MMMM'ta 'yyyy H:mm:ss",
                    M: "d. MMMM'ta'",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-FR", "default", {
        name: "fr-FR",
        englishName: "French (France)",
        nativeName: "français (France)",
        language: "fr",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("he-IL", "default", {
        name: "he-IL",
        englishName: "Hebrew (Israel)",
        nativeName: "עברית (ישראל)",
        language: "he",
        isRTL: true,
        numberFormat: {
            NaN: "לא מספר",
            negativeInfinity: "אינסוף שלילי",
            positiveInfinity: "אינסוף חיובי",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "₪"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "יום ראשון", "יום שני", "יום שלישי", "יום רביעי", "יום חמישי", "יום שישי", "שבת" ],
                    namesAbbr: [ "יום א", "יום ב", "יום ג", "יום ד", "יום ה", "יום ו", "שבת" ],
                    namesShort: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ]
                },
                months: {
                    names: [ "ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר", "" ],
                    namesAbbr: [ "ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ", "" ]
                },
                eras: [ {
                    name: "לספירה",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd dd MMMM yyyy HH:mm",
                    F: "dddd dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            },
            Hebrew: {
                name: "Hebrew",
                "/": " ",
                days: {
                    names: [ "יום ראשון", "יום שני", "יום שלישי", "יום רביעי", "יום חמישי", "יום שישי", "שבת" ],
                    namesAbbr: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ],
                    namesShort: [ "א", "ב", "ג", "ד", "ה", "ו", "ש" ]
                },
                months: {
                    names: [ "תשרי", "חשון", "כסלו", "טבת", "שבט", "אדר", "אדר ב", "ניסן", "אייר", "סיון", "תמוז", "אב", "אלול" ],
                    namesAbbr: [ "תשרי", "חשון", "כסלו", "טבת", "שבט", "אדר", "אדר ב", "ניסן", "אייר", "סיון", "תמוז", "אב", "אלול" ]
                },
                eras: [ {
                    name: "C.E.",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 5790,
                patterns: {
                    d: "dd MMMM yyyy",
                    D: "dddd dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd dd MMMM yyyy HH:mm",
                    F: "dddd dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hu-HU", "default", {
        name: "hu-HU",
        englishName: "Hungarian (Hungary)",
        nativeName: "magyar (Magyarország)",
        language: "hu",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "nem szám",
            negativeInfinity: "negatív végtelen",
            positiveInfinity: "végtelen",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Ft"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat" ],
                    namesAbbr: [ "V", "H", "K", "Sze", "Cs", "P", "Szo" ],
                    namesShort: [ "V", "H", "K", "Sze", "Cs", "P", "Szo" ]
                },
                months: {
                    names: [ "január", "február", "március", "április", "május", "június", "július", "augusztus", "szeptember", "október", "november", "december", "" ],
                    namesAbbr: [ "jan.", "febr.", "márc.", "ápr.", "máj.", "jún.", "júl.", "aug.", "szept.", "okt.", "nov.", "dec.", "" ]
                },
                AM: [ "de.", "de.", "DE." ],
                PM: [ "du.", "du.", "DU." ],
                eras: [ {
                    name: "i.sz.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy.MM.dd.",
                    D: "yyyy. MMMM d.",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy. MMMM d. H:mm",
                    F: "yyyy. MMMM d. H:mm:ss",
                    M: "MMMM d.",
                    Y: "yyyy. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("is-IS", "default", {
        name: "is-IS",
        englishName: "Icelandic (Iceland)",
        nativeName: "íslenska (Ísland)",
        language: "is",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                decimals: 0,
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sunnudagur", "mánudagur", "þriðjudagur", "miðvikudagur", "fimmtudagur", "föstudagur", "laugardagur" ],
                    namesAbbr: [ "sun.", "mán.", "þri.", "mið.", "fim.", "fös.", "lau." ],
                    namesShort: [ "su", "má", "þr", "mi", "fi", "fö", "la" ]
                },
                months: {
                    names: [ "janúar", "febrúar", "mars", "apríl", "maí", "júní", "júlí", "ágúst", "september", "október", "nóvember", "desember", "" ],
                    namesAbbr: [ "jan.", "feb.", "mar.", "apr.", "maí", "jún.", "júl.", "ágú.", "sep.", "okt.", "nóv.", "des.", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("it-IT", "default", {
        name: "it-IT",
        englishName: "Italian (Italy)",
        nativeName: "italiano (Italia)",
        language: "it",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "Non un numero reale",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domenica", "lunedì", "martedì", "mercoledì", "giovedì", "venerdì", "sabato" ],
                    namesAbbr: [ "dom", "lun", "mar", "mer", "gio", "ven", "sab" ],
                    namesShort: [ "do", "lu", "ma", "me", "gi", "ve", "sa" ]
                },
                months: {
                    names: [ "gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre", "" ],
                    namesAbbr: [ "gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ja-JP", "default", {
        name: "ja-JP",
        englishName: "Japanese (Japan)",
        nativeName: "日本語 (日本)",
        language: "ja",
        numberFormat: {
            NaN: "NaN (非数値)",
            negativeInfinity: "-∞",
            positiveInfinity: "+∞",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                decimals: 0,
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日" ],
                    namesAbbr: [ "日", "月", "火", "水", "木", "金", "土" ],
                    namesShort: [ "日", "月", "火", "水", "木", "金", "土" ]
                },
                months: {
                    names: [ "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "午前", "午前", "午前" ],
                PM: [ "午後", "午後", "午後" ],
                eras: [ {
                    name: "西暦",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            },
            Japanese: {
                name: "Japanese",
                days: {
                    names: [ "日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日" ],
                    namesAbbr: [ "日", "月", "火", "水", "木", "金", "土" ],
                    namesShort: [ "日", "月", "火", "水", "木", "金", "土" ]
                },
                months: {
                    names: [ "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "午前", "午前", "午前" ],
                PM: [ "午後", "午後", "午後" ],
                eras: [ {
                    name: "平成",
                    start: null,
                    offset: 1867
                }, {
                    name: "昭和",
                    start: -18121536e5,
                    offset: 1911
                }, {
                    name: "大正",
                    start: -13576032e5,
                    offset: 1925
                }, {
                    name: "明治",
                    start: 6002208e4,
                    offset: 1988
                } ],
                twoDigitYearMax: 99,
                patterns: {
                    d: "gg y/M/d",
                    D: "gg y'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "gg y'年'M'月'd'日' H:mm",
                    F: "gg y'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "gg y'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("ko-KR", "default", {
        name: "ko-KR",
        englishName: "Korean (Korea)",
        nativeName: "한국어 (대한민국)",
        language: "ko",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                decimals: 0,
                symbol: "₩"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일" ],
                    namesAbbr: [ "일", "월", "화", "수", "목", "금", "토" ],
                    namesShort: [ "일", "월", "화", "수", "목", "금", "토" ]
                },
                months: {
                    names: [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "오전", "오전", "오전" ],
                PM: [ "오후", "오후", "오후" ],
                eras: [ {
                    name: "서기",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy'년' M'월' d'일' dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "yyyy'년' M'월' d'일' dddd tt h:mm",
                    F: "yyyy'년' M'월' d'일' dddd tt h:mm:ss",
                    M: "M'월' d'일'",
                    Y: "yyyy'년' M'월'"
                }
            },
            Korean: {
                name: "Korean",
                "/": "-",
                days: {
                    names: [ "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일" ],
                    namesAbbr: [ "일", "월", "화", "수", "목", "금", "토" ],
                    namesShort: [ "일", "월", "화", "수", "목", "금", "토" ]
                },
                months: {
                    names: [ "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: [ "오전", "오전", "오전" ],
                PM: [ "오후", "오후", "오후" ],
                eras: [ {
                    name: "단기",
                    start: null,
                    offset: -2333
                } ],
                twoDigitYearMax: 4362,
                patterns: {
                    d: "gg yyyy-MM-dd",
                    D: "gg yyyy'년' M'월' d'일' dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "gg yyyy'년' M'월' d'일' dddd tt h:mm",
                    F: "gg yyyy'년' M'월' d'일' dddd tt h:mm:ss",
                    M: "M'월' d'일'",
                    Y: "gg yyyy'년' M'월'"
                }
            }
        }
    });
    Globalize.addCultureInfo("nl-NL", "default", {
        name: "nl-NL",
        englishName: "Dutch (Netherlands)",
        nativeName: "Nederlands (Nederland)",
        language: "nl",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag" ],
                    namesAbbr: [ "zo", "ma", "di", "wo", "do", "vr", "za" ],
                    namesShort: [ "zo", "ma", "di", "wo", "do", "vr", "za" ]
                },
                months: {
                    names: [ "januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d-M-yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd d MMMM yyyy H:mm",
                    F: "dddd d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("nb-NO", "default", {
        name: "nb-NO",
        englishName: "Norwegian, Bokmål (Norway)",
        nativeName: "norsk, bokmål (Norge)",
        language: "nb",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag" ],
                    namesAbbr: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ],
                    namesShort: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("pl-PL", "default", {
        name: "pl-PL",
        englishName: "Polish (Poland)",
        nativeName: "polski (Polska)",
        language: "pl",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "nie jest liczbą",
            negativeInfinity: "-nieskończoność",
            positiveInfinity: "+nieskończoność",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "zł"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota" ],
                    namesAbbr: [ "N", "Pn", "Wt", "Śr", "Cz", "Pt", "So" ],
                    namesShort: [ "N", "Pn", "Wt", "Śr", "Cz", "Pt", "So" ]
                },
                months: {
                    names: [ "styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień", "" ],
                    namesAbbr: [ "sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "paź", "lis", "gru", "" ]
                },
                monthsGenitive: {
                    names: [ "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "września", "października", "listopada", "grudnia", "" ],
                    namesAbbr: [ "sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "paź", "lis", "gru", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("pt-BR", "default", {
        name: "pt-BR",
        englishName: "Portuguese (Brazil)",
        nativeName: "Português (Brasil)",
        language: "pt",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NaN (Não é um número)",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "R$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado" ],
                    namesAbbr: [ "dom", "seg", "ter", "qua", "qui", "sex", "sáb" ],
                    namesShort: [ "D", "S", "T", "Q", "Q", "S", "S" ]
                },
                months: {
                    names: [ "janeiro", "fevereiro", "março", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro", "" ],
                    namesAbbr: [ "jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' de 'MMMM' de 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' de 'MMMM' de 'yyyy HH:mm",
                    F: "dddd, d' de 'MMMM' de 'yyyy HH:mm:ss",
                    M: "dd' de 'MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("rm-CH", "default", {
        name: "rm-CH",
        englishName: "Romansh (Switzerland)",
        nativeName: "Rumantsch (Svizra)",
        language: "rm",
        numberFormat: {
            ",": "'",
            NaN: "betg def.",
            negativeInfinity: "-infinit",
            positiveInfinity: "+infinit",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "fr."
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dumengia", "glindesdi", "mardi", "mesemna", "gievgia", "venderdi", "sonda" ],
                    namesAbbr: [ "du", "gli", "ma", "me", "gie", "ve", "so" ],
                    namesShort: [ "du", "gli", "ma", "me", "gie", "ve", "so" ]
                },
                months: {
                    names: [ "schaner", "favrer", "mars", "avrigl", "matg", "zercladur", "fanadur", "avust", "settember", "october", "november", "december", "" ],
                    namesAbbr: [ "schan", "favr", "mars", "avr", "matg", "zercl", "fan", "avust", "sett", "oct", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "s. Cr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d MMMM yyyy HH:mm",
                    F: "dddd, d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ro-RO", "default", {
        name: "ro-RO",
        englishName: "Romanian (Romania)",
        nativeName: "română (România)",
        language: "ro",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "lei"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "duminică", "luni", "marţi", "miercuri", "joi", "vineri", "sâmbătă" ],
                    namesAbbr: [ "D", "L", "Ma", "Mi", "J", "V", "S" ],
                    namesShort: [ "D", "L", "Ma", "Mi", "J", "V", "S" ]
                },
                months: {
                    names: [ "ianuarie", "februarie", "martie", "aprilie", "mai", "iunie", "iulie", "august", "septembrie", "octombrie", "noiembrie", "decembrie", "" ],
                    namesAbbr: [ "ian.", "feb.", "mar.", "apr.", "mai.", "iun.", "iul.", "aug.", "sep.", "oct.", "nov.", "dec.", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ru-RU", "default", {
        name: "ru-RU",
        englishName: "Russian (Russia)",
        nativeName: "русский (Россия)",
        language: "ru",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота" ],
                    namesAbbr: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                    namesShort: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
                },
                months: {
                    names: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                monthsGenitive: {
                    names: [ "января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря", "" ],
                    namesAbbr: [ "янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy 'г.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'г.' H:mm",
                    F: "d MMMM yyyy 'г.' H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hr-HR", "default", {
        name: "hr-HR",
        englishName: "Croatian (Croatia)",
        nativeName: "hrvatski (Hrvatska)",
        language: "hr",
        numberFormat: {
            pattern: [ "- n" ],
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kn"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "siječanj", "veljača", "ožujak", "travanj", "svibanj", "lipanj", "srpanj", "kolovoz", "rujan", "listopad", "studeni", "prosinac", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                monthsGenitive: {
                    names: [ "siječnja", "veljače", "ožujka", "travnja", "svibnja", "lipnja", "srpnja", "kolovoza", "rujna", "listopada", "studenog", "prosinca", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy.",
                    D: "d. MMMM yyyy.",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy. H:mm",
                    F: "d. MMMM yyyy. H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sk-SK", "default", {
        name: "sk-SK",
        englishName: "Slovak (Slovakia)",
        nativeName: "slovenčina (Slovenská republika)",
        language: "sk",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Nie je číslo",
            negativeInfinity: "-nekonečno",
            positiveInfinity: "+nekonečno",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "nedeľa", "pondelok", "utorok", "streda", "štvrtok", "piatok", "sobota" ],
                    namesAbbr: [ "ne", "po", "ut", "st", "št", "pi", "so" ],
                    namesShort: [ "ne", "po", "ut", "st", "št", "pi", "so" ]
                },
                months: {
                    names: [ "január", "február", "marec", "apríl", "máj", "jún", "júl", "august", "september", "október", "november", "december", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                monthsGenitive: {
                    names: [ "januára", "februára", "marca", "apríla", "mája", "júna", "júla", "augusta", "septembra", "októbra", "novembra", "decembra", "" ],
                    namesAbbr: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. l.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sq-AL", "default", {
        name: "sq-AL",
        englishName: "Albanian (Albania)",
        nativeName: "shqipe (Shqipëria)",
        language: "sq",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-infinit",
            positiveInfinity: "infinit",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": ".",
                ".": ",",
                symbol: "Lek"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "e diel", "e hënë", "e martë", "e mërkurë", "e enjte", "e premte", "e shtunë" ],
                    namesAbbr: [ "Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Sht" ],
                    namesShort: [ "Di", "Hë", "Ma", "Më", "En", "Pr", "Sh" ]
                },
                months: {
                    names: [ "janar", "shkurt", "mars", "prill", "maj", "qershor", "korrik", "gusht", "shtator", "tetor", "nëntor", "dhjetor", "" ],
                    namesAbbr: [ "Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gsh", "Sht", "Tet", "Nën", "Dhj", "" ]
                },
                AM: [ "PD", "pd", "PD" ],
                PM: [ "MD", "md", "MD" ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy-MM-dd",
                    t: "h:mm.tt",
                    T: "h:mm:ss.tt",
                    f: "yyyy-MM-dd h:mm.tt",
                    F: "yyyy-MM-dd h:mm:ss.tt",
                    Y: "yyyy-MM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sv-SE", "default", {
        name: "sv-SE",
        englishName: "Swedish (Sweden)",
        nativeName: "svenska (Sverige)",
        language: "sv",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag" ],
                    namesAbbr: [ "sö", "må", "ti", "on", "to", "fr", "lö" ],
                    namesShort: [ "sö", "må", "ti", "on", "to", "fr", "lö" ]
                },
                months: {
                    names: [ "januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "'den 'd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "'den 'd MMMM yyyy HH:mm",
                    F: "'den 'd MMMM yyyy HH:mm:ss",
                    M: "'den 'd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("th-TH", "default", {
        name: "th-TH",
        englishName: "Thai (Thailand)",
        nativeName: "ไทย (ไทย)",
        language: "th",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "฿"
            }
        },
        calendars: {
            standard: {
                name: "ThaiBuddhist",
                firstDay: 1,
                days: {
                    names: [ "อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์" ],
                    namesAbbr: [ "อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส." ],
                    namesShort: [ "อ", "จ", "อ", "พ", "พ", "ศ", "ส" ]
                },
                months: {
                    names: [ "มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม", "" ],
                    namesAbbr: [ "ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค.", "" ]
                },
                eras: [ {
                    name: "พ.ศ.",
                    start: null,
                    offset: -543
                } ],
                twoDigitYearMax: 2572,
                patterns: {
                    d: "d/M/yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            },
            Gregorian_Localized: {
                firstDay: 1,
                days: {
                    names: [ "อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์" ],
                    namesAbbr: [ "อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส." ],
                    namesShort: [ "อ", "จ", "อ", "พ", "พ", "ศ", "ส" ]
                },
                months: {
                    names: [ "มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม", "" ],
                    namesAbbr: [ "ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค.", "" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "'วัน'dddd'ที่' d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "'วัน'dddd'ที่' d MMMM yyyy H:mm",
                    F: "'วัน'dddd'ที่' d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tr-TR", "default", {
        name: "tr-TR",
        englishName: "Turkish (Turkey)",
        nativeName: "Türkçe (Türkiye)",
        language: "tr",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "TL"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi" ],
                    namesAbbr: [ "Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt" ],
                    namesShort: [ "Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct" ]
                },
                months: {
                    names: [ "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık", "" ],
                    namesAbbr: [ "Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dd MMMM yyyy dddd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy dddd HH:mm",
                    F: "dd MMMM yyyy dddd HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ur-PK", "default", {
        name: "ur-PK",
        englishName: "Urdu (Islamic Republic of Pakistan)",
        nativeName: "اُردو (پاکستان)",
        language: "ur",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "$n-", "$n" ],
                symbol: "Rs"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "اتوار", "پير", "منگل", "بدھ", "جمعرات", "جمعه", "هفته" ],
                    namesAbbr: [ "اتوار", "پير", "منگل", "بدھ", "جمعرات", "جمعه", "هفته" ],
                    namesShort: [ "ا", "پ", "م", "ب", "ج", "ج", "ه" ]
                },
                months: {
                    names: [ "جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر", "" ],
                    namesAbbr: [ "جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر", "" ]
                },
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    f: "dd MMMM, yyyy h:mm tt",
                    F: "dd MMMM, yyyy h:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            }
        }
    });
    Globalize.addCultureInfo("id-ID", "default", {
        name: "id-ID",
        englishName: "Indonesian (Indonesia)",
        nativeName: "Bahasa Indonesia (Indonesia)",
        language: "id",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                decimals: 0,
                ",": ".",
                ".": ",",
                symbol: "Rp"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu" ],
                    namesAbbr: [ "Minggu", "Sen", "Sel", "Rabu", "Kamis", "Jumat", "Sabtu" ],
                    namesShort: [ "M", "S", "S", "R", "K", "J", "S" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "Nopember", "Desember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agust", "Sep", "Okt", "Nop", "Des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM yyyy H:mm",
                    F: "dd MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("uk-UA", "default", {
        name: "uk-UA",
        englishName: "Ukrainian (Ukraine)",
        nativeName: "українська (Україна)",
        language: "uk",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-безмежність",
            positiveInfinity: "безмежність",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "₴"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "неділя", "понеділок", "вівторок", "середа", "четвер", "п'ятниця", "субота" ],
                    namesAbbr: [ "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                    namesShort: [ "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ]
                },
                months: {
                    names: [ "Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень", "" ],
                    namesAbbr: [ "Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру", "" ]
                },
                monthsGenitive: {
                    names: [ "січня", "лютого", "березня", "квітня", "травня", "червня", "липня", "серпня", "вересня", "жовтня", "листопада", "грудня", "" ],
                    namesAbbr: [ "січ", "лют", "бер", "кві", "тра", "чер", "лип", "сер", "вер", "жов", "лис", "гру", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy' р.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy' р.' H:mm",
                    F: "d MMMM yyyy' р.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy' р.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("be-BY", "default", {
        name: "be-BY",
        englishName: "Belarusian (Belarus)",
        nativeName: "Беларускі (Беларусь)",
        language: "be",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "нядзеля", "панядзелак", "аўторак", "серада", "чацвер", "пятніца", "субота" ],
                    namesAbbr: [ "нд", "пн", "аў", "ср", "чц", "пт", "сб" ],
                    namesShort: [ "нд", "пн", "аў", "ср", "чц", "пт", "сб" ]
                },
                months: {
                    names: [ "Студзень", "Люты", "Сакавік", "Красавік", "Май", "Чэрвень", "Ліпень", "Жнівень", "Верасень", "Кастрычнік", "Лістапад", "Снежань", "" ],
                    namesAbbr: [ "Сту", "Лют", "Сак", "Кра", "Май", "Чэр", "Ліп", "Жні", "Вер", "Кас", "Ліс", "Сне", "" ]
                },
                monthsGenitive: {
                    names: [ "студзеня", "лютага", "сакавіка", "красавіка", "мая", "чэрвеня", "ліпеня", "жніўня", "верасня", "кастрычніка", "лістапада", "снежня", "" ],
                    namesAbbr: [ "Сту", "Лют", "Сак", "Кра", "Май", "Чэр", "Ліп", "Жні", "Вер", "Кас", "Ліс", "Сне", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sl-SI", "default", {
        name: "sl-SI",
        englishName: "Slovenian (Slovenia)",
        nativeName: "slovenski (Slovenija)",
        language: "sl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-neskončnost",
            positiveInfinity: "neskončnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljek", "torek", "sreda", "četrtek", "petek", "sobota" ],
                    namesAbbr: [ "ned", "pon", "tor", "sre", "čet", "pet", "sob" ],
                    namesShort: [ "ne", "po", "to", "sr", "če", "pe", "so" ]
                },
                months: {
                    names: [ "januar", "februar", "marec", "april", "maj", "junij", "julij", "avgust", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("et-EE", "default", {
        name: "et-EE",
        englishName: "Estonian (Estonia)",
        nativeName: "eesti (Eesti)",
        language: "et",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "avaldamatu",
            negativeInfinity: "miinuslõpmatus",
            positiveInfinity: "plusslõpmatus",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pühapäev", "esmaspäev", "teisipäev", "kolmapäev", "neljapäev", "reede", "laupäev" ],
                    namesAbbr: [ "P", "E", "T", "K", "N", "R", "L" ],
                    namesShort: [ "P", "E", "T", "K", "N", "R", "L" ]
                },
                months: {
                    names: [ "jaanuar", "veebruar", "märts", "aprill", "mai", "juuni", "juuli", "august", "september", "oktoober", "november", "detsember", "" ],
                    namesAbbr: [ "jaan", "veebr", "märts", "apr", "mai", "juuni", "juuli", "aug", "sept", "okt", "nov", "dets", "" ]
                },
                AM: [ "EL", "el", "EL" ],
                PM: [ "PL", "pl", "PL" ],
                patterns: {
                    d: "d.MM.yyyy",
                    D: "d. MMMM yyyy'. a.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy'. a.' H:mm",
                    F: "d. MMMM yyyy'. a.' H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy'. a.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("lv-LV", "default", {
        name: "lv-LV",
        englishName: "Latvian (Latvia)",
        nativeName: "latviešu (Latvija)",
        language: "lv",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-bezgalība",
            positiveInfinity: "bezgalība",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "Ls"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "svētdiena", "pirmdiena", "otrdiena", "trešdiena", "ceturtdiena", "piektdiena", "sestdiena" ],
                    namesAbbr: [ "sv", "pr", "ot", "tr", "ce", "pk", "se" ],
                    namesShort: [ "sv", "pr", "ot", "tr", "ce", "pk", "se" ]
                },
                months: {
                    names: [ "janvāris", "februāris", "marts", "aprīlis", "maijs", "jūnijs", "jūlijs", "augusts", "septembris", "oktobris", "novembris", "decembris", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jūn", "jūl", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "janvārī", "februārī", "martā", "aprīlī", "maijā", "jūnijā", "jūlijā", "augustā", "septembrī", "oktobrī", "novembrī", "decembrī", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jūn", "jūl", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy.MM.dd.",
                    D: "dddd, yyyy'. gada 'd. MMMM",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, yyyy'. gada 'd. MMMM H:mm",
                    F: "dddd, yyyy'. gada 'd. MMMM H:mm:ss",
                    M: "d. MMMM",
                    Y: "yyyy. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("lt-LT", "default", {
        name: "lt-LT",
        englishName: "Lithuanian (Lithuania)",
        nativeName: "lietuvių (Lietuva)",
        language: "lt",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-begalybė",
            positiveInfinity: "begalybė",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Lt"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sekmadienis", "pirmadienis", "antradienis", "trečiadienis", "ketvirtadienis", "penktadienis", "šeštadienis" ],
                    namesAbbr: [ "Sk", "Pr", "An", "Tr", "Kt", "Pn", "Št" ],
                    namesShort: [ "S", "P", "A", "T", "K", "Pn", "Š" ]
                },
                months: {
                    names: [ "sausis", "vasaris", "kovas", "balandis", "gegužė", "birželis", "liepa", "rugpjūtis", "rugsėjis", "spalis", "lapkritis", "gruodis", "" ],
                    namesAbbr: [ "Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd", "" ]
                },
                monthsGenitive: {
                    names: [ "sausio", "vasario", "kovo", "balandžio", "gegužės", "birželio", "liepos", "rugpjūčio", "rugsėjo", "spalio", "lapkričio", "gruodžio", "" ],
                    namesAbbr: [ "Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy.MM.dd",
                    D: "yyyy 'm.' MMMM d 'd.'",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'm.' MMMM d 'd.' HH:mm",
                    F: "yyyy 'm.' MMMM d 'd.' HH:mm:ss",
                    M: "MMMM d 'd.'",
                    Y: "yyyy 'm.' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("tg-Cyrl-TJ", "default", {
        name: "tg-Cyrl-TJ",
        englishName: "Tajik (Cyrillic, Tajikistan)",
        nativeName: "Тоҷикӣ (Тоҷикистон)",
        language: "tg-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ";",
                symbol: "т.р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                days: {
                    names: [ "Яш", "Душанбе", "Сешанбе", "Чоршанбе", "Панҷшанбе", "Ҷумъа", "Шанбе" ],
                    namesAbbr: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ],
                    namesShort: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ]
                },
                months: {
                    names: [ "Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "январи", "феврали", "марти", "апрели", "маи", "июни", "июли", "августи", "сентябри", "октябри", "ноябри", "декабри", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fa-IR", "default", {
        name: "fa-IR",
        englishName: "Persian",
        nativeName: "فارسى (ایران)",
        language: "fa",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            currency: {
                pattern: [ "$n-", "$ n" ],
                ".": "/",
                symbol: "ريال"
            }
        },
        calendars: {
            standard: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "يكشنبه", "دوشنبه", "سه شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "يكشنبه", "دوشنبه", "سه شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "ژانويه", "فوريه", "مارس", "آوريل", "مى", "ژوئن", "ژوئيه", "اوت", "سپتامبر", "اُكتبر", "نوامبر", "دسامبر", "" ],
                    namesAbbr: [ "ژانويه", "فوريه", "مارس", "آوريل", "مى", "ژوئن", "ژوئيه", "اوت", "سپتامبر", "اُكتبر", "نوامبر", "دسامبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "yyyy/MM/dd",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "yyyy/MM/dd hh:mm tt",
                    F: "yyyy/MM/dd hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ق.ظ", "ق.ظ", "ق.ظ" ],
                PM: [ "ب.ظ", "ب.ظ", "ب.ظ" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("vi-VN", "default", {
        name: "vi-VN",
        englishName: "Vietnamese (Vietnam)",
        nativeName: "Tiếng Việt (Việt Nam)",
        language: "vi",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "₫"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Chủ Nhật", "Thứ Hai", "Thứ Ba", "Thứ Tư", "Thứ Năm", "Thứ Sáu", "Thứ Bảy" ],
                    namesAbbr: [ "CN", "Hai", "Ba", "Tư", "Năm", "Sáu", "Bảy" ],
                    namesShort: [ "C", "H", "B", "T", "N", "S", "B" ]
                },
                months: {
                    names: [ "Tháng Giêng", "Tháng Hai", "Tháng Ba", "Tháng Tư", "Tháng Năm", "Tháng Sáu", "Tháng Bảy", "Tháng Tám", "Tháng Chín", "Tháng Mười", "Tháng Mười Một", "Tháng Mười Hai", "" ],
                    namesAbbr: [ "Thg1", "Thg2", "Thg3", "Thg4", "Thg5", "Thg6", "Thg7", "Thg8", "Thg9", "Thg10", "Thg11", "Thg12", "" ]
                },
                AM: [ "SA", "sa", "SA" ],
                PM: [ "CH", "ch", "CH" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    f: "dd MMMM yyyy h:mm tt",
                    F: "dd MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hy-AM", "default", {
        name: "hy-AM",
        englishName: "Armenian (Armenia)",
        nativeName: "Հայերեն (Հայաստան)",
        language: "hy",
        numberFormat: {
            currency: {
                pattern: [ "-n $", "n $" ],
                symbol: "դր."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "ՈՒրբաթ", "Շաբաթ" ],
                    namesAbbr: [ "Կիր", "Երկ", "Երք", "Չրք", "Հնգ", "ՈՒր", "Շբթ" ],
                    namesShort: [ "Կ", "Ե", "Ե", "Չ", "Հ", "Ո", "Շ" ]
                },
                months: {
                    names: [ "Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր", "" ],
                    namesAbbr: [ "ՀՆՎ", "ՓՏՎ", "ՄՐՏ", "ԱՊՐ", "ՄՅՍ", "ՀՆՍ", "ՀԼՍ", "ՕԳՍ", "ՍԵՊ", "ՀՈԿ", "ՆՈՅ", "ԴԵԿ", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM, yyyy H:mm",
                    F: "d MMMM, yyyy H:mm:ss",
                    M: "d MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("az-Latn-AZ", "default", {
        name: "az-Latn-AZ",
        englishName: "Azeri (Latin, Azerbaijan)",
        nativeName: "Azərbaycan­ılı (Azərbaycan)",
        language: "az-Latn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "man."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə" ],
                    namesAbbr: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ],
                    namesShort: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ]
                },
                months: {
                    names: [ "Yanvar", "Fevral", "Mart", "Aprel", "May", "İyun", "İyul", "Avgust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                monthsGenitive: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("eu-ES", "default", {
        name: "eu-ES",
        englishName: "Basque (Basque)",
        nativeName: "euskara (euskara)",
        language: "eu",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "EdZ",
            negativeInfinity: "-Infinitu",
            positiveInfinity: "Infinitu",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "igandea", "astelehena", "asteartea", "asteazkena", "osteguna", "ostirala", "larunbata" ],
                    namesAbbr: [ "ig.", "al.", "as.", "az.", "og.", "or.", "lr." ],
                    namesShort: [ "ig", "al", "as", "az", "og", "or", "lr" ]
                },
                months: {
                    names: [ "urtarrila", "otsaila", "martxoa", "apirila", "maiatza", "ekaina", "uztaila", "abuztua", "iraila", "urria", "azaroa", "abendua", "" ],
                    namesAbbr: [ "urt.", "ots.", "mar.", "api.", "mai.", "eka.", "uzt.", "abu.", "ira.", "urr.", "aza.", "abe.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dddd, yyyy.'eko' MMMM'k 'd",
                    t: "HH:mm",
                    T: "H:mm:ss",
                    f: "dddd, yyyy.'eko' MMMM'k 'd HH:mm",
                    F: "dddd, yyyy.'eko' MMMM'k 'd H:mm:ss",
                    Y: "yyyy.'eko' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("hsb-DE", "default", {
        name: "hsb-DE",
        englishName: "Upper Sorbian (Germany)",
        nativeName: "hornjoserbšćina (Němska)",
        language: "hsb",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "njedefinowane",
            negativeInfinity: "-njekónčne",
            positiveInfinity: "+njekónčne",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "njedźela", "póndźela", "wutora", "srjeda", "štwórtk", "pjatk", "sobota" ],
                    namesAbbr: [ "nje", "pón", "wut", "srj", "štw", "pja", "sob" ],
                    namesShort: [ "n", "p", "w", "s", "š", "p", "s" ]
                },
                months: {
                    names: [ "januar", "februar", "měrc", "apryl", "meja", "junij", "julij", "awgust", "september", "oktober", "nowember", "december", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "mej", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "januara", "februara", "měrca", "apryla", "meje", "junija", "julija", "awgusta", "septembra", "oktobra", "nowembra", "decembra", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "mej", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "po Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "dddd, 'dnja' d. MMMM yyyy",
                    t: "H.mm 'hodź.'",
                    T: "H:mm:ss",
                    f: "dddd, 'dnja' d. MMMM yyyy H.mm 'hodź.'",
                    F: "dddd, 'dnja' d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mk-MK", "default", {
        name: "mk-MK",
        englishName: "Macedonian (Former Yugoslav Republic of Macedonia)",
        nativeName: "македонски јазик (Македонија)",
        language: "mk",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "ден."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота" ],
                    namesAbbr: [ "нед", "пон", "втр", "срд", "чет", "пет", "саб" ],
                    namesShort: [ "не", "по", "вт", "ср", "че", "пе", "са" ]
                },
                months: {
                    names: [ "јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември", "" ],
                    namesAbbr: [ "јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, dd MMMM yyyy HH:mm",
                    F: "dddd, dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tn-ZA", "default", {
        name: "tn-ZA",
        englishName: "Setswana (South Africa)",
        nativeName: "Setswana (Aforika Borwa)",
        language: "tn",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Latshipi", "Mosupologo", "Labobedi", "Laboraro", "Labone", "Labotlhano", "Lamatlhatso" ],
                    namesAbbr: [ "Ltp.", "Mos.", "Lbd.", "Lbr.", "Lbn.", "Lbt.", "Lmt." ],
                    namesShort: [ "Lp", "Ms", "Lb", "Lr", "Ln", "Lt", "Lm" ]
                },
                months: {
                    names: [ "Ferikgong", "Tlhakole", "Mopitloe", "Moranang", "Motsheganong", "Seetebosigo", "Phukwi", "Phatwe", "Lwetse", "Diphalane", "Ngwanatsele", "Sedimothole", "" ],
                    namesAbbr: [ "Fer.", "Tlhak.", "Mop.", "Mor.", "Motsh.", "Seet.", "Phukw.", "Phatw.", "Lwets.", "Diph.", "Ngwan.", "Sed.", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("xh-ZA", "default", {
        name: "xh-ZA",
        englishName: "isiXhosa (South Africa)",
        nativeName: "isiXhosa (uMzantsi Afrika)",
        language: "xh",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "iCawa", "uMvulo", "uLwesibini", "uLwesithathu", "uLwesine", "uLwesihlanu", "uMgqibelo" ],
                    namesShort: [ "Ca", "Mv", "Lb", "Lt", "Ln", "Lh", "Mg" ]
                },
                months: {
                    names: [ "Mqungu", "Mdumba", "Kwindla", "Tshazimpuzi", "Canzibe", "Silimela", "Khala", "Thupha", "Msintsi", "Dwarha", "Nkanga", "Mnga", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zu-ZA", "default", {
        name: "zu-ZA",
        englishName: "isiZulu (South Africa)",
        nativeName: "isiZulu (iNingizimu Afrika)",
        language: "zu",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "iSonto", "uMsombuluko", "uLwesibili", "uLwesithathu", "uLwesine", "uLwesihlanu", "uMgqibelo" ],
                    namesAbbr: [ "Son.", "Mso.", "Bi.", "Tha.", "Ne.", "Hla.", "Mgq." ]
                },
                months: {
                    names: [ "uMasingana", "uNhlolanja", "uNdasa", "uMbaso", "uNhlaba", "uNhlangulana", "uNtulikazi", "uNcwaba", "uMandulo", "uMfumfu", "uLwezi", "uZibandlela", "" ],
                    namesAbbr: [ "Mas.", "Nhlo.", "Nda.", "Mba.", "Nhla.", "Nhlang.", "Ntu.", "Ncwa.", "Man.", "Mfu.", "Lwe.", "Zib.", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("af-ZA", "default", {
        name: "af-ZA",
        englishName: "Afrikaans (South Africa)",
        nativeName: "Afrikaans (Suid Afrika)",
        language: "af",
        numberFormat: {
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Sondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrydag", "Saterdag" ],
                    namesAbbr: [ "Son", "Maan", "Dins", "Woen", "Dond", "Vry", "Sat" ],
                    namesShort: [ "So", "Ma", "Di", "Wo", "Do", "Vr", "Sa" ]
                },
                months: {
                    names: [ "Januarie", "Februarie", "Maart", "April", "Mei", "Junie", "Julie", "Augustus", "September", "Oktober", "November", "Desember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ka-GE", "default", {
        name: "ka-GE",
        englishName: "Georgian (Georgia)",
        nativeName: "ქართული (საქართველო)",
        language: "ka",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "Lari"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი" ],
                    namesAbbr: [ "კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი" ],
                    namesShort: [ "კ", "ო", "ს", "ო", "ხ", "პ", "შ" ]
                },
                months: {
                    names: [ "იანვარი", "თებერვალი", "მარტი", "აპრილი", "მაისი", "ივნისი", "ივლისი", "აგვისტო", "სექტემბერი", "ოქტომბერი", "ნოემბერი", "დეკემბერი", "" ],
                    namesAbbr: [ "იან", "თებ", "მარ", "აპრ", "მაის", "ივნ", "ივლ", "აგვ", "სექ", "ოქტ", "ნოემ", "დეკ", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "yyyy 'წლის' dd MM, dddd",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'წლის' dd MM, dddd H:mm",
                    F: "yyyy 'წლის' dd MM, dddd H:mm:ss",
                    M: "dd MM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fo-FO", "default", {
        name: "fo-FO",
        englishName: "Faroese (Faroe Islands)",
        nativeName: "føroyskt (Føroyar)",
        language: "fo",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "sunnudagur", "mánadagur", "týsdagur", "mikudagur", "hósdagur", "fríggjadagur", "leygardagur" ],
                    namesAbbr: [ "sun", "mán", "týs", "mik", "hós", "frí", "leyg" ],
                    namesShort: [ "su", "má", "tý", "mi", "hó", "fr", "ley" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "apríl", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hi-IN", "default", {
        name: "hi-IN",
        englishName: "Hindi (India)",
        nativeName: "हिंदी (भारत)",
        language: "hi",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "रविवार", "सोमवार", "मंगलवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "रवि.", "सोम.", "मंगल.", "बुध.", "गुरु.", "शुक्र.", "शनि." ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ],
                    namesAbbr: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ]
                },
                AM: [ "पूर्वाह्न", "पूर्वाह्न", "पूर्वाह्न" ],
                PM: [ "अपराह्न", "अपराह्न", "अपराह्न" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mt-MT", "default", {
        name: "mt-MT",
        englishName: "Maltese (Malta)",
        nativeName: "Malti (Malta)",
        language: "mt",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Il-Ħadd", "It-Tnejn", "It-Tlieta", "L-Erbgħa", "Il-Ħamis", "Il-Ġimgħa", "Is-Sibt" ],
                    namesAbbr: [ "Ħad", "Tne", "Tli", "Erb", "Ħam", "Ġim", "Sib" ],
                    namesShort: [ "I", "I", "I", "L", "I", "I", "I" ]
                },
                months: {
                    names: [ "Jannar", "Frar", "Marzu", "April", "Mejju", "Ġunju", "Lulju", "Awissu", "Settembru", "Ottubru", "Novembru", "Diċembru", "" ],
                    namesAbbr: [ "Jan", "Fra", "Mar", "Apr", "Mej", "Ġun", "Lul", "Awi", "Set", "Ott", "Nov", "Diċ", "" ]
                },
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, d' ta\\' 'MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' ta\\' 'MMMM yyyy HH:mm",
                    F: "dddd, d' ta\\' 'MMMM yyyy HH:mm:ss",
                    M: "d' ta\\' 'MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("se-NO", "default", {
        name: "se-NO",
        englishName: "Sami, Northern (Norway)",
        nativeName: "davvisámegiella (Norga)",
        language: "se",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sotnabeaivi", "vuossárga", "maŋŋebárga", "gaskavahkku", "duorastat", "bearjadat", "lávvardat" ],
                    namesAbbr: [ "sotn", "vuos", "maŋ", "gask", "duor", "bear", "láv" ],
                    namesShort: [ "s", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ođđajagemánnu", "guovvamánnu", "njukčamánnu", "cuoŋománnu", "miessemánnu", "geassemánnu", "suoidnemánnu", "borgemánnu", "čakčamánnu", "golggotmánnu", "skábmamánnu", "juovlamánnu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđajagimánu", "guovvamánu", "njukčamánu", "cuoŋománu", "miessemánu", "geassemánu", "suoidnemánu", "borgemánu", "čakčamánu", "golggotmánu", "skábmamánu", "juovlamánu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ms-MY", "default", {
        name: "ms-MY",
        englishName: "Malay (Malaysia)",
        nativeName: "Bahasa Melayu (Malaysia)",
        language: "ms",
        numberFormat: {
            currency: {
                decimals: 0,
                symbol: "RM"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesAbbr: [ "Ahad", "Isnin", "Sel", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesShort: [ "A", "I", "S", "R", "K", "J", "S" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogos", "Sept", "Okt", "Nov", "Dis", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM yyyy H:mm",
                    F: "dd MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kk-KZ", "default", {
        name: "kk-KZ",
        englishName: "Kazakh (Kazakhstan)",
        nativeName: "Қазақ (Қазақстан)",
        language: "kk",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                ",": " ",
                ".": "-",
                symbol: "Т"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Жексенбі", "Дүйсенбі", "Сейсенбі", "Сәрсенбі", "Бейсенбі", "Жұма", "Сенбі" ],
                    namesAbbr: [ "Жк", "Дс", "Сс", "Ср", "Бс", "Жм", "Сн" ],
                    namesShort: [ "Жк", "Дс", "Сс", "Ср", "Бс", "Жм", "Сн" ]
                },
                months: {
                    names: [ "қаңтар", "ақпан", "наурыз", "сәуір", "мамыр", "маусым", "шілде", "тамыз", "қыркүйек", "қазан", "қараша", "желтоқсан", "" ],
                    namesAbbr: [ "Қаң", "Ақп", "Нау", "Сәу", "Мам", "Мау", "Шіл", "Там", "Қыр", "Қаз", "Қар", "Жел", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy 'ж.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'ж.' H:mm",
                    F: "d MMMM yyyy 'ж.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ky-KG", "default", {
        name: "ky-KG",
        englishName: "Kyrgyz (Kyrgyzstan)",
        nativeName: "Кыргыз (Кыргызстан)",
        language: "ky",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": "-",
                symbol: "сом"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Жекшемби", "Дүйшөмбү", "Шейшемби", "Шаршемби", "Бейшемби", "Жума", "Ишемби" ],
                    namesAbbr: [ "Жш", "Дш", "Шш", "Шр", "Бш", "Жм", "Иш" ],
                    namesShort: [ "Жш", "Дш", "Шш", "Шр", "Бш", "Жм", "Иш" ]
                },
                months: {
                    names: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d'-'MMMM yyyy'-ж.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d'-'MMMM yyyy'-ж.' H:mm",
                    F: "d'-'MMMM yyyy'-ж.' H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy'-ж.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("sw-KE", "default", {
        name: "sw-KE",
        englishName: "Kiswahili (Kenya)",
        nativeName: "Kiswahili (Kenya)",
        language: "sw",
        numberFormat: {
            currency: {
                symbol: "S"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Jumapili", "Jumatatu", "Jumanne", "Jumatano", "Alhamisi", "Ijumaa", "Jumamosi" ],
                    namesAbbr: [ "Jumap.", "Jumat.", "Juman.", "Jumat.", "Alh.", "Iju.", "Jumam." ],
                    namesShort: [ "P", "T", "N", "T", "A", "I", "M" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Machi", "Aprili", "Mei", "Juni", "Julai", "Agosti", "Septemba", "Oktoba", "Novemba", "Decemba", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ago", "Sep", "Okt", "Nov", "Dec", "" ]
                }
            }
        }
    });
    Globalize.addCultureInfo("tk-TM", "default", {
        name: "tk-TM",
        englishName: "Turkmen (Turkmenistan)",
        nativeName: "türkmençe (Türkmenistan)",
        language: "tk",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-üznüksizlik",
            positiveInfinity: "üznüksizlik",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "m."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Duşenbe", "Sişenbe", "Çarşenbe", "Penşenbe", "Anna", "Şenbe", "Ýekşenbe" ],
                    namesAbbr: [ "Db", "Sb", "Çb", "Pb", "An", "Şb", "Ýb" ],
                    namesShort: [ "D", "S", "Ç", "P", "A", "Ş", "Ý" ]
                },
                months: {
                    names: [ "Ýanwar", "Fewral", "Mart", "Aprel", "Maý", "lýun", "lýul", "Awgust", "Sentýabr", "Oktýabr", "Noýabr", "Dekabr", "" ],
                    namesAbbr: [ "Ýan", "Few", "Mart", "Apr", "Maý", "lýun", "lýul", "Awg", "Sen", "Okt", "Not", "Dek", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "yyyy 'ý.' MMMM d",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'ý.' MMMM d H:mm",
                    F: "yyyy 'ý.' MMMM d H:mm:ss",
                    Y: "yyyy 'ý.' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("uz-Latn-UZ", "default", {
        name: "uz-Latn-UZ",
        englishName: "Uzbek (Latin, Uzbekistan)",
        nativeName: "U'zbek (U'zbekiston Respublikasi)",
        language: "uz-Latn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                decimals: 0,
                ",": " ",
                ".": ",",
                symbol: "so'm"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "yakshanba", "dushanba", "seshanba", "chorshanba", "payshanba", "juma", "shanba" ],
                    namesAbbr: [ "yak.", "dsh.", "sesh.", "chr.", "psh.", "jm.", "sh." ],
                    namesShort: [ "ya", "d", "s", "ch", "p", "j", "sh" ]
                },
                months: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM yyyy",
                    D: "yyyy 'yil' d-MMMM",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'yil' d-MMMM HH:mm",
                    F: "yyyy 'yil' d-MMMM HH:mm:ss",
                    M: "d-MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tt-RU", "default", {
        name: "tt-RU",
        englishName: "Tatar (Russia)",
        nativeName: "Татар (Россия)",
        language: "tt",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Якшәмбе", "Дүшәмбе", "Сишәмбе", "Чәршәмбе", "Пәнҗешәмбе", "Җомга", "Шимбә" ],
                    namesAbbr: [ "Якш", "Дүш", "Сиш", "Чәрш", "Пәнҗ", "Җом", "Шим" ],
                    namesShort: [ "Я", "Д", "С", "Ч", "П", "Җ", "Ш" ]
                },
                months: {
                    names: [ "Гыйнвар", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь", "" ],
                    namesAbbr: [ "Гыйн.", "Фев.", "Мар.", "Апр.", "Май", "Июнь", "Июль", "Авг.", "Сен.", "Окт.", "Нояб.", "Дек.", "" ]
                },
                monthsGenitive: {
                    names: [ "Гыйнварның", "Февральнең", "Мартның", "Апрельнең", "Майның", "Июньнең", "Июльнең", "Августның", "Сентябрьның", "Октябрьның", "Ноябрьның", "Декабрьның", "" ],
                    namesAbbr: [ "Гыйн.-ның", "Фев.-нең", "Мар.-ның", "Апр.-нең", "Майның", "Июньнең", "Июльнең", "Авг.-ның", "Сен.-ның", "Окт.-ның", "Нояб.-ның", "Дек.-ның", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bn-IN", "default", {
        name: "bn-IN",
        englishName: "Bengali (India)",
        nativeName: "বাংলা (ভারত)",
        language: "bn",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                pattern: [ "-%n", "%n" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "টা"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                ":": ".",
                firstDay: 1,
                days: {
                    names: [ "রবিবার", "সোমবার", "মঙ্গলবার", "বুধবার", "বৃহস্পতিবার", "শুক্রবার", "শনিবার" ],
                    namesAbbr: [ "রবি.", "সোম.", "মঙ্গল.", "বুধ.", "বৃহস্পতি.", "শুক্র.", "শনি." ],
                    namesShort: [ "র", "স", "ম", "ব", "ব", "শ", "শ" ]
                },
                months: {
                    names: [ "জানুয়ারী", "ফেব্রুয়ারী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগস্ট", "সেপ্টেম্বর", "অক্টোবর", "নভেম্বর", "ডিসেম্বর", "" ],
                    namesAbbr: [ "জানু.", "ফেব্রু.", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগ.", "সেপ্টে.", "অক্টো.", "নভে.", "ডিসে.", "" ]
                },
                AM: [ "পুর্বাহ্ন", "পুর্বাহ্ন", "পুর্বাহ্ন" ],
                PM: [ "অপরাহ্ন", "অপরাহ্ন", "অপরাহ্ন" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH.mm",
                    T: "HH.mm.ss",
                    f: "dd MMMM yyyy HH.mm",
                    F: "dd MMMM yyyy HH.mm.ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("pa-IN", "default", {
        name: "pa-IN",
        englishName: "Punjabi (India)",
        nativeName: "ਪੰਜਾਬੀ (ਭਾਰਤ)",
        language: "pa",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ਰੁ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ਐਤਵਾਰ", "ਸੋਮਵਾਰ", "ਮੰਗਲਵਾਰ", "ਬੁੱਧਵਾਰ", "ਵੀਰਵਾਰ", "ਸ਼ੁੱਕਰਵਾਰ", "ਸ਼ਨਿੱਚਰਵਾਰ" ],
                    namesAbbr: [ "ਐਤ.", "ਸੋਮ.", "ਮੰਗਲ.", "ਬੁੱਧ.", "ਵੀਰ.", "ਸ਼ੁਕਰ.", "ਸ਼ਨਿੱਚਰ." ],
                    namesShort: [ "ਐ", "ਸ", "ਮ", "ਬ", "ਵ", "ਸ਼", "ਸ਼" ]
                },
                months: {
                    names: [ "ਜਨਵਰੀ", "ਫ਼ਰਵਰੀ", "ਮਾਰਚ", "ਅਪ੍ਰੈਲ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾਈ", "ਅਗਸਤ", "ਸਤੰਬਰ", "ਅਕਤੂਬਰ", "ਨਵੰਬਰ", "ਦਸੰਬਰ", "" ],
                    namesAbbr: [ "ਜਨਵਰੀ", "ਫ਼ਰਵਰੀ", "ਮਾਰਚ", "ਅਪ੍ਰੈਲ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾਈ", "ਅਗਸਤ", "ਸਤੰਬਰ", "ਅਕਤੂਬਰ", "ਨਵੰਬਰ", "ਦਸੰਬਰ", "" ]
                },
                AM: [ "ਸਵੇਰ", "ਸਵੇਰ", "ਸਵੇਰ" ],
                PM: [ "ਸ਼ਾਮ", "ਸ਼ਾਮ", "ਸ਼ਾਮ" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy dddd",
                    t: "tt hh:mm",
                    T: "tt hh:mm:ss",
                    f: "dd MMMM yyyy dddd tt hh:mm",
                    F: "dd MMMM yyyy dddd tt hh:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("gu-IN", "default", {
        name: "gu-IN",
        englishName: "Gujarati (India)",
        nativeName: "ગુજરાતી (ભારત)",
        language: "gu",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "રૂ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "રવિવાર", "સોમવાર", "મંગળવાર", "બુધવાર", "ગુરુવાર", "શુક્રવાર", "શનિવાર" ],
                    namesAbbr: [ "રવિ", "સોમ", "મંગળ", "બુધ", "ગુરુ", "શુક્ર", "શનિ" ],
                    namesShort: [ "ર", "સ", "મ", "બ", "ગ", "શ", "શ" ]
                },
                months: {
                    names: [ "જાન્યુઆરી", "ફેબ્રુઆરી", "માર્ચ", "એપ્રિલ", "મે", "જૂન", "જુલાઈ", "ઑગસ્ટ", "સપ્ટેમ્બર", "ઑક્ટ્બર", "નવેમ્બર", "ડિસેમ્બર", "" ],
                    namesAbbr: [ "જાન્યુ", "ફેબ્રુ", "માર્ચ", "એપ્રિલ", "મે", "જૂન", "જુલાઈ", "ઑગસ્ટ", "સપ્ટે", "ઑક્ટો", "નવે", "ડિસે", "" ]
                },
                AM: [ "પૂર્વ મધ્યાહ્ન", "પૂર્વ મધ્યાહ્ન", "પૂર્વ મધ્યાહ્ન" ],
                PM: [ "ઉત્તર મધ્યાહ્ન", "ઉત્તર મધ્યાહ્ન", "ઉત્તર મધ્યાહ્ન" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("or-IN", "default", {
        name: "or-IN",
        englishName: "Oriya (India)",
        nativeName: "ଓଡ଼ିଆ (ଭାରତ)",
        language: "or",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ଟ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "ରବିବାର", "ସୋମବାର", "ମଙ୍ଗଳବାର", "ବୁଧବାର", "ଗୁରୁବାର", "ଶୁକ୍ରବାର", "ଶନିବାର" ],
                    namesAbbr: [ "ରବି.", "ସୋମ.", "ମଙ୍ଗଳ.", "ବୁଧ.", "ଗୁରୁ.", "ଶୁକ୍ର.", "ଶନି." ],
                    namesShort: [ "ର", "ସୋ", "ମ", "ବୁ", "ଗୁ", "ଶୁ", "ଶ" ]
                },
                months: {
                    names: [ "ଜାନୁୟାରୀ", "ଫ୍ରେବୃୟାରୀ", "ମାର୍ଚ୍ଚ", "ଏପ୍ରିଲ୍‌", "ମେ", "ଜୁନ୍‌", "ଜୁଲାଇ", "ଅଗଷ୍ଟ", "ସେପ୍ଟେମ୍ବର", "ଅକ୍ଟୋବର", "ନଭେମ୍ବର", "(ଡିସେମ୍ବର", "" ],
                    namesAbbr: [ "ଜାନୁୟାରୀ", "ଫ୍ରେବୃୟାରୀ", "ମାର୍ଚ୍ଚ", "ଏପ୍ରିଲ୍‌", "ମେ", "ଜୁନ୍‌", "ଜୁଲାଇ", "ଅଗଷ୍ଟ", "ସେପ୍ଟେମ୍ବର", "ଅକ୍ଟୋବର", "ନଭେମ୍ବର", "(ଡିସେମ୍ବର", "" ]
                },
                eras: [ {
                    name: "ଖ୍ରୀଷ୍ଟାବ୍ଦ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ta-IN", "default", {
        name: "ta-IN",
        englishName: "Tamil (India)",
        nativeName: "தமிழ் (இந்தியா)",
        language: "ta",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ரூ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ஞாயிற்றுக்கிழமை", "திங்கள்கிழமை", "செவ்வாய்கிழமை", "புதன்கிழமை", "வியாழக்கிழமை", "வெள்ளிக்கிழமை", "சனிக்கிழமை" ],
                    namesAbbr: [ "ஞாயிறு", "திங்கள்", "செவ்வாய்", "புதன்", "வியாழன்", "வெள்ளி", "சனி" ],
                    namesShort: [ "ஞா", "தி", "செ", "பு", "வி", "வெ", "ச" ]
                },
                months: {
                    names: [ "ஜனவரி", "பிப்ரவரி", "மார்ச்", "ஏப்ரல்", "மே", "ஜூன்", "ஜூலை", "ஆகஸ்ட்", "செப்டம்பர்", "அக்டோபர்", "நவம்பர்", "டிசம்பர்", "" ],
                    namesAbbr: [ "ஜனவரி", "பிப்ரவரி", "மார்ச்", "ஏப்ரல்", "மே", "ஜூன்", "ஜூலை", "ஆகஸ்ட்", "செப்டம்பர்", "அக்டோபர்", "நவம்பர்", "டிசம்பர்", "" ]
                },
                AM: [ "காலை", "காலை", "காலை" ],
                PM: [ "மாலை", "மாலை", "மாலை" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("te-IN", "default", {
        name: "te-IN",
        englishName: "Telugu (India)",
        nativeName: "తెలుగు (భారత దేశం)",
        language: "te",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "రూ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ఆదివారం", "సోమవారం", "మంగళవారం", "బుధవారం", "గురువారం", "శుక్రవారం", "శనివారం" ],
                    namesAbbr: [ "ఆది.", "సోమ.", "మంగళ.", "బుధ.", "గురు.", "శుక్ర.", "శని." ],
                    namesShort: [ "ఆ", "సో", "మం", "బు", "గు", "శు", "శ" ]
                },
                months: {
                    names: [ "జనవరి", "ఫిబ్రవరి", "మార్చి", "ఏప్రిల్", "మే", "జూన్", "జూలై", "ఆగస్టు", "సెప్టెంబర్", "అక్టోబర్", "నవంబర్", "డిసెంబర్", "" ],
                    namesAbbr: [ "జనవరి", "ఫిబ్రవరి", "మార్చి", "ఏప్రిల్", "మే", "జూన్", "జూలై", "ఆగస్టు", "సెప్టెంబర్", "అక్టోబర్", "నవంబర్", "డిసెంబర్", "" ]
                },
                AM: [ "పూర్వాహ్న", "పూర్వాహ్న", "పూర్వాహ్న" ],
                PM: [ "అపరాహ్న", "అపరాహ్న", "అపరాహ్న" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("kn-IN", "default", {
        name: "kn-IN",
        englishName: "Kannada (India)",
        nativeName: "ಕನ್ನಡ (ಭಾರತ)",
        language: "kn",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ರೂ"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ಭಾನುವಾರ", "ಸೋಮವಾರ", "ಮಂಗಳವಾರ", "ಬುಧವಾರ", "ಗುರುವಾರ", "ಶುಕ್ರವಾರ", "ಶನಿವಾರ" ],
                    namesAbbr: [ "ಭಾನು.", "ಸೋಮ.", "ಮಂಗಳ.", "ಬುಧ.", "ಗುರು.", "ಶುಕ್ರ.", "ಶನಿ." ],
                    namesShort: [ "ರ", "ಸ", "ಮ", "ಬ", "ಗ", "ಶ", "ಶ" ]
                },
                months: {
                    names: [ "ಜನವರಿ", "ಫೆಬ್ರವರಿ", "ಮಾರ್ಚ್", "ಎಪ್ರಿಲ್", "ಮೇ", "ಜೂನ್", "ಜುಲೈ", "ಆಗಸ್ಟ್", "ಸೆಪ್ಟಂಬರ್", "ಅಕ್ಟೋಬರ್", "ನವೆಂಬರ್", "ಡಿಸೆಂಬರ್", "" ],
                    namesAbbr: [ "ಜನವರಿ", "ಫೆಬ್ರವರಿ", "ಮಾರ್ಚ್", "ಎಪ್ರಿಲ್", "ಮೇ", "ಜೂನ್", "ಜುಲೈ", "ಆಗಸ್ಟ್", "ಸೆಪ್ಟಂಬರ್", "ಅಕ್ಟೋಬರ್", "ನವೆಂಬರ್", "ಡಿಸೆಂಬರ್", "" ]
                },
                AM: [ "ಪೂರ್ವಾಹ್ನ", "ಪೂರ್ವಾಹ್ನ", "ಪೂರ್ವಾಹ್ನ" ],
                PM: [ "ಅಪರಾಹ್ನ", "ಅಪರಾಹ್ನ", "ಅಪರಾಹ್ನ" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ml-IN", "default", {
        name: "ml-IN",
        englishName: "Malayalam (India)",
        nativeName: "മലയാളം (ഭാരതം)",
        language: "ml",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                pattern: [ "-%n", "%n" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "ക"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                ":": ".",
                firstDay: 1,
                days: {
                    names: [ "ഞായറാഴ്ച", "തിങ്കളാഴ്ച", "ചൊവ്വാഴ്ച", "ബുധനാഴ്ച", "വ്യാഴാഴ്ച", "വെള്ളിയാഴ്ച", "ശനിയാഴ്ച" ],
                    namesAbbr: [ "ഞായർ.", "തിങ്കൾ.", "ചൊവ്വ.", "ബുധൻ.", "വ്യാഴം.", "വെള്ളി.", "ശനി." ],
                    namesShort: [ "ഞ", "ത", "ച", "ബ", "വ", "വെ", "ശ" ]
                },
                months: {
                    names: [ "ജനുവരി", "ഫെബ്റുവരി", "മാറ്ച്ച്", "ഏപ്റില്", "മെയ്", "ജൂണ്", "ജൂലൈ", "ഓഗസ്ററ്", "സെപ്ററംബറ്", "ഒക്ടോബറ്", "നവംബറ്", "ഡിസംബറ്", "" ],
                    namesAbbr: [ "ജനുവരി", "ഫെബ്റുവരി", "മാറ്ച്ച്", "ഏപ്റില്", "മെയ്", "ജൂണ്", "ജൂലൈ", "ഓഗസ്ററ്", "സെപ്ററംബറ്", "ഒക്ടോബറ്", "നവംബറ്", "ഡിസംബറ്", "" ]
                },
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH.mm",
                    T: "HH.mm.ss",
                    f: "dd MMMM yyyy HH.mm",
                    F: "dd MMMM yyyy HH.mm.ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("as-IN", "default", {
        name: "as-IN",
        englishName: "Assamese (India)",
        nativeName: "অসমীয়া (ভাৰত)",
        language: "as",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            NaN: "nan",
            negativeInfinity: "-infinity",
            positiveInfinity: "infinity",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "n$" ],
                groupSizes: [ 3, 2 ],
                symbol: "ট"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "সোমবাৰ", "মঙ্গলবাৰ", "বুধবাৰ", "বৃহস্পতিবাৰ", "শুক্রবাৰ", "শনিবাৰ", "ৰবিবাৰ" ],
                    namesAbbr: [ "সোম.", "মঙ্গল.", "বুধ.", "বৃহ.", "শুক্র.", "শনি.", "ৰবি." ],
                    namesShort: [ "সো", "ম", "বু", "বৃ", "শু", "শ", "র" ]
                },
                months: {
                    names: [ "জানুৱাৰী", "ফেব্রুৱাৰী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগষ্ট", "চেপ্টেম্বর", "অক্টোবর", "নবেম্বর", "ডিচেম্বর", "" ],
                    namesAbbr: [ "জানু", "ফেব্রু", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগষ্ট", "চেপ্টে", "অক্টো", "নবে", "ডিচে", "" ]
                },
                AM: [ "ৰাতিপু", "ৰাতিপু", "ৰাতিপু" ],
                PM: [ "আবেলি", "আবেলি", "আবেলি" ],
                eras: [ {
                    name: "খ্রীষ্টাব্দ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "yyyy,MMMM dd, dddd",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "yyyy,MMMM dd, dddd tt h:mm",
                    F: "yyyy,MMMM dd, dddd tt h:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM,yy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mr-IN", "default", {
        name: "mr-IN",
        englishName: "Marathi (India)",
        nativeName: "मराठी (भारत)",
        language: "mr",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "रविवार", "सोमवार", "मंगळवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "रवि.", "सोम.", "मंगळ.", "बुध.", "गुरु.", "शुक्र.", "शनि." ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोव्हेंबर", "डिसेंबर", "" ],
                    namesAbbr: [ "जाने.", "फेब्रु.", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टें.", "ऑक्टो.", "नोव्हें.", "डिसें.", "" ]
                },
                AM: [ "म.पू.", "म.पू.", "म.पू." ],
                PM: [ "म.नं.", "म.नं.", "म.नं." ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sa-IN", "default", {
        name: "sa-IN",
        englishName: "Sanskrit (India)",
        nativeName: "संस्कृत (भारतम्)",
        language: "sa",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "रविवासरः", "सोमवासरः", "मङ्गलवासरः", "बुधवासरः", "गुरुवासरः", "शुक्रवासरः", "शनिवासरः" ],
                    namesAbbr: [ "रविवासरः", "सोमवासरः", "मङ्गलवासरः", "बुधवासरः", "गुरुवासरः", "शुक्रवासरः", "शनिवासरः" ],
                    namesShort: [ "र", "स", "म", "ब", "ग", "श", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ],
                    namesAbbr: [ "जनवरी", "फरवरी", "मार्च", "अप्रैल", "मई", "जून", "जुलाई", "अगस्त", "सितम्बर", "अक्तूबर", "नवम्बर", "दिसम्बर", "" ]
                },
                AM: [ "पूर्वाह्न", "पूर्वाह्न", "पूर्वाह्न" ],
                PM: [ "अपराह्न", "अपराह्न", "अपराह्न" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy dddd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy dddd HH:mm",
                    F: "dd MMMM yyyy dddd HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mn-MN", "default", {
        name: "mn-MN",
        englishName: "Mongolian (Cyrillic, Mongolia)",
        nativeName: "Монгол хэл (Монгол улс)",
        language: "mn-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "₮"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Ням", "Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба" ],
                    namesAbbr: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ],
                    namesShort: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ]
                },
                months: {
                    names: [ "1 дүгээр сар", "2 дугаар сар", "3 дугаар сар", "4 дүгээр сар", "5 дугаар сар", "6 дугаар сар", "7 дугаар сар", "8 дугаар сар", "9 дүгээр сар", "10 дугаар сар", "11 дүгээр сар", "12 дугаар сар", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                monthsGenitive: {
                    names: [ "1 дүгээр сарын", "2 дугаар сарын", "3 дугаар сарын", "4 дүгээр сарын", "5 дугаар сарын", "6 дугаар сарын", "7 дугаар сарын", "8 дугаар сарын", "9 дүгээр сарын", "10 дугаар сарын", "11 дүгээр сарын", "12 дугаар сарын", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yy.MM.dd",
                    D: "yyyy 'оны' MMMM d",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'оны' MMMM d H:mm",
                    F: "yyyy 'оны' MMMM d H:mm:ss",
                    M: "d MMMM",
                    Y: "yyyy 'он' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("bo-CN", "default", {
        name: "bo-CN",
        englishName: "Tibetan (PRC)",
        nativeName: "བོད་ཡིག (ཀྲུང་ཧྭ་མི་དམངས་སྤྱི་མཐུན་རྒྱལ་ཁབ།)",
        language: "bo",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ཨང་ཀི་མིན་པ།",
            negativeInfinity: "མོ་གྲངས་ཚད་མེད་ཆུང་བ།",
            positiveInfinity: "ཕོ་གྲངས་ཚད་མེད་ཆེ་བ།",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "གཟའ་ཉི་མ།", "གཟའ་ཟླ་བ།", "གཟའ་མིག་དམར།", "གཟའ་ལྷག་པ།", "གཟའ་ཕུར་བུ།", "གཟའ་པ་སངས།", "གཟའ་སྤེན་པ།" ],
                    namesAbbr: [ "ཉི་མ།", "ཟླ་བ།", "མིག་དམར།", "ལྷག་པ།", "ཕུར་བུ།", "པ་སངས།", "སྤེན་པ།" ],
                    namesShort: [ "༧", "༡", "༢", "༣", "༤", "༥", "༦" ]
                },
                months: {
                    names: [ "སྤྱི་ཟླ་དང་པོ།", "སྤྱི་ཟླ་གཉིས་པ།", "སྤྱི་ཟླ་གསུམ་པ།", "སྤྱི་ཟླ་བཞི་པ།", "སྤྱི་ཟླ་ལྔ་པ།", "སྤྱི་ཟླ་དྲུག་པ།", "སྤྱི་ཟླ་བདུན་པ།", "སྤྱི་ཟླ་བརྒྱད་པ།", "སྤྱི་ཟླ་དགུ་པ།", "སྤྱི་ཟླ་བཅུ་པོ།", "སྤྱི་ཟླ་བཅུ་གཅིག་པ།", "སྤྱི་ཟླ་བཅུ་གཉིས་པ།", "" ],
                    namesAbbr: [ "ཟླ་ ༡", "ཟླ་ ༢", "ཟླ་ ༣", "ཟླ་ ༤", "ཟླ་ ༥", "ཟླ་ ༦", "ཟླ་ ༧", "ཟླ་ ༨", "ཟླ་ ༩", "ཟླ་ ༡༠", "ཟླ་ ༡༡", "ཟླ་ ༡༢", "" ]
                },
                AM: [ "སྔ་དྲོ", "སྔ་དྲོ", "སྔ་དྲོ" ],
                PM: [ "ཕྱི་དྲོ", "ཕྱི་དྲོ", "ཕྱི་དྲོ" ],
                eras: [ {
                    name: "སྤྱི་ལོ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ལོའི་ཟླ' M'ཚེས' d",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy'ལོའི་ཟླ' M'ཚེས' d HH:mm",
                    F: "yyyy'ལོའི་ཟླ' M'ཚེས' d HH:mm:ss",
                    M: "'ཟླ་' M'ཚེས'd",
                    Y: "yyyy.M"
                }
            }
        }
    });
    Globalize.addCultureInfo("cy-GB", "default", {
        name: "cy-GB",
        englishName: "Welsh (United Kingdom)",
        nativeName: "Cymraeg (y Deyrnas Unedig)",
        language: "cy",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "£"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn" ],
                    namesAbbr: [ "Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad" ],
                    namesShort: [ "Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa" ]
                },
                months: {
                    names: [ "Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr", "" ],
                    namesAbbr: [ "Ion", "Chwe", "Maw", "Ebr", "Mai", "Meh", "Gor", "Aws", "Med", "Hyd", "Tach", "Rhag", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("km-KH", "default", {
        name: "km-KH",
        englishName: "Khmer (Cambodia)",
        nativeName: "ខ្មែរ (កម្ពុជា)",
        language: "km",
        numberFormat: {
            pattern: [ "- n" ],
            groupSizes: [ 3, 0 ],
            NaN: "NAN",
            negativeInfinity: "-- អនន្ត",
            positiveInfinity: "អនន្ត",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                symbol: "៛"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "ថ្ងៃអាទិត្យ", "ថ្ងៃច័ន្ទ", "ថ្ងៃអង្គារ", "ថ្ងៃពុធ", "ថ្ងៃព្រហស្បតិ៍", "ថ្ងៃសុក្រ", "ថ្ងៃសៅរ៍" ],
                    namesAbbr: [ "អាទិ.", "ច.", "អ.", "ពុ", "ព្រហ.", "សុ.", "ស." ],
                    namesShort: [ "អា", "ច", "អ", "ពុ", "ព្", "សុ", "ស" ]
                },
                months: {
                    names: [ "មករា", "កុម្ភៈ", "មិនា", "មេសា", "ឧសភា", "មិថុនា", "កក្កដា", "សីហា", "កញ្ញា", "តុលា", "វិច្ឆិកា", "ធ្នូ", "" ],
                    namesAbbr: [ "១", "២", "៣", "៤", "៥", "៦", "៧", "៨", "៩", "១០", "១១", "១២", "" ]
                },
                AM: [ "ព្រឹក", "ព្រឹក", "ព្រឹក" ],
                PM: [ "ល្ងាច", "ល្ងាច", "ល្ងាច" ],
                eras: [ {
                    name: "មុនគ.ស.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "d MMMM yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy H:mm tt",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "'ថ្ងៃទី' dd 'ខែ' MM",
                    Y: "'ខែ' MM 'ឆ្នាំ' yyyy"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ព្រឹក", "ព្រឹក", "ព្រឹក" ],
                PM: [ "ល្ងាច", "ល្ងាច", "ល្ងាច" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm tt",
                    F: "dddd, MMMM dd, yyyy HH:mm:ss"
                }
            }
        }
    });
    Globalize.addCultureInfo("lo-LA", "default", {
        name: "lo-LA",
        englishName: "Lao (Lao P.D.R.)",
        nativeName: "ລາວ (ສ.ປ.ປ. ລາວ)",
        language: "lo",
        numberFormat: {
            pattern: [ "(n)" ],
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "(n$)", "n$" ],
                groupSizes: [ 3, 0 ],
                symbol: "₭"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "ວັນອາທິດ", "ວັນຈັນ", "ວັນອັງຄານ", "ວັນພຸດ", "ວັນພະຫັດ", "ວັນສຸກ", "ວັນເສົາ" ],
                    namesAbbr: [ "ອາທິດ", "ຈັນ", "ອັງຄານ", "ພຸດ", "ພະຫັດ", "ສຸກ", "ເສົາ" ],
                    namesShort: [ "ອ", "ຈ", "ອ", "ພ", "ພ", "ສ", "ເ" ]
                },
                months: {
                    names: [ "ມັງກອນ", "ກຸມພາ", "ມີນາ", "ເມສາ", "ພຶດສະພາ", "ມິຖຸນາ", "ກໍລະກົດ", "ສິງຫາ", "ກັນຍາ", "ຕຸລາ", "ພະຈິກ", "ທັນວາ", "" ],
                    namesAbbr: [ "ມັງກອນ", "ກຸມພາ", "ມີນາ", "ເມສາ", "ພຶດສະພາ", "ມິຖຸນາ", "ກໍລະກົດ", "ສິງຫາ", "ກັນຍາ", "ຕຸລາ", "ພະຈິກ", "ທັນວາ", "" ]
                },
                AM: [ "ເຊົ້າ", "ເຊົ້າ", "ເຊົ້າ" ],
                PM: [ "ແລງ", "ແລງ", "ແລງ" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm tt",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy H:mm tt",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gl-ES", "default", {
        name: "gl-ES",
        englishName: "Galician (Galician)",
        nativeName: "galego (galego)",
        language: "gl",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "luns", "martes", "mércores", "xoves", "venres", "sábado" ],
                    namesAbbr: [ "dom", "luns", "mar", "mér", "xov", "ven", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mé", "xo", "ve", "sá" ]
                },
                months: {
                    names: [ "xaneiro", "febreiro", "marzo", "abril", "maio", "xuño", "xullo", "agosto", "setembro", "outubro", "novembro", "decembro", "" ],
                    namesAbbr: [ "xan", "feb", "mar", "abr", "maio", "xuñ", "xull", "ago", "set", "out", "nov", "dec", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kok-IN", "default", {
        name: "kok-IN",
        englishName: "Konkani (India)",
        nativeName: "कोंकणी (भारत)",
        language: "kok",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "आयतार", "सोमार", "मंगळार", "बुधवार", "बिरेस्तार", "सुक्रार", "शेनवार" ],
                    namesAbbr: [ "आय.", "सोम.", "मंगळ.", "बुध.", "बिरे.", "सुक्र.", "शेन." ],
                    namesShort: [ "आ", "स", "म", "ब", "ब", "स", "श" ]
                },
                months: {
                    names: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोवेम्बर", "डिसेंबर", "" ],
                    namesAbbr: [ "जानेवारी", "फेब्रुवारी", "मार्च", "एप्रिल", "मे", "जून", "जुलै", "ऑगस्ट", "सप्टेंबर", "ऑक्टोबर", "नोवेम्बर", "डिसेंबर", "" ]
                },
                AM: [ "म.पू.", "म.पू.", "म.पू." ],
                PM: [ "म.नं.", "म.नं.", "म.नं." ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("syr-SY", "default", {
        name: "syr-SY",
        englishName: "Syriac (Syria)",
        nativeName: "ܣܘܪܝܝܐ (سوريا)",
        language: "syr",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ل.س.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "ܚܕ ܒܫܒܐ", "ܬܪܝܢ ܒܫܒܐ", "ܬܠܬܐ ܒܫܒܐ", "ܐܪܒܥܐ ܒܫܒܐ", "ܚܡܫܐ ܒܫܒܐ", "ܥܪܘܒܬܐ", "ܫܒܬܐ" ],
                    namesAbbr: [ "܏ܐ ܏ܒܫ", "܏ܒ ܏ܒܫ", "܏ܓ ܏ܒܫ", "܏ܕ ܏ܒܫ", "܏ܗ ܏ܒܫ", "܏ܥܪܘܒ", "܏ܫܒ" ],
                    namesShort: [ "ܐ", "ܒ", "ܓ", "ܕ", "ܗ", "ܥ", "ܫ" ]
                },
                months: {
                    names: [ "ܟܢܘܢ ܐܚܪܝ", "ܫܒܛ", "ܐܕܪ", "ܢܝܣܢ", "ܐܝܪ", "ܚܙܝܪܢ", "ܬܡܘܙ", "ܐܒ", "ܐܝܠܘܠ", "ܬܫܪܝ ܩܕܝܡ", "ܬܫܪܝ ܐܚܪܝ", "ܟܢܘܢ ܩܕܝܡ", "" ],
                    namesAbbr: [ "܏ܟܢ ܏ܒ", "ܫܒܛ", "ܐܕܪ", "ܢܝܣܢ", "ܐܝܪ", "ܚܙܝܪܢ", "ܬܡܘܙ", "ܐܒ", "ܐܝܠܘܠ", "܏ܬܫ ܏ܐ", "܏ܬܫ ܏ܒ", "܏ܟܢ ܏ܐ", "" ]
                },
                AM: [ "ܩ.ܛ", "ܩ.ܛ", "ܩ.ܛ" ],
                PM: [ "ܒ.ܛ", "ܒ.ܛ", "ܒ.ܛ" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("si-LK", "default", {
        name: "si-LK",
        englishName: "Sinhala (Sri Lanka)",
        nativeName: "සිංහල (ශ්‍රී ලංකා)",
        language: "si",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            negativeInfinity: "-අනන්තය",
            positiveInfinity: "අනන්තය",
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                symbol: "රු."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ඉරිදා", "සඳුදා", "අඟහරුවාදා", "බදාදා", "බ්‍රහස්පතින්දා", "සිකුරාදා", "සෙනසුරාදා" ],
                    namesAbbr: [ "ඉරිදා", "සඳුදා", "කුජදා", "බුදදා", "ගුරුදා", "කිවිදා", "ශනිදා" ],
                    namesShort: [ "ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ" ]
                },
                months: {
                    names: [ "ජනවාරි", "පෙබරවාරි", "මාර්තු", "අ‌ප්‍රේල්", "මැයි", "ජූනි", "ජූලි", "අ‌ගෝස්තු", "සැප්තැම්බර්", "ඔක්තෝබර්", "නොවැම්බර්", "දෙසැම්බර්", "" ],
                    namesAbbr: [ "ජන.", "පෙබ.", "මාර්තු.", "අප්‍රේල්.", "මැයි.", "ජූනි.", "ජූලි.", "අගෝ.", "සැප්.", "ඔක්.", "නොවැ.", "දෙසැ.", "" ]
                },
                AM: [ "පෙ.ව.", "පෙ.ව.", "පෙ.ව." ],
                PM: [ "ප.ව.", "ප.ව.", "ප.ව." ],
                eras: [ {
                    name: "ක්‍රි.ව.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "yyyy MMMM' මස 'dd' වැනිදා 'dddd",
                    f: "yyyy MMMM' මස 'dd' වැනිදා 'dddd h:mm tt",
                    F: "yyyy MMMM' මස 'dd' වැනිදා 'dddd h:mm:ss tt",
                    Y: "yyyy MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("iu-Cans-CA", "default", {
        name: "iu-Cans-CA",
        englishName: "Inuktitut (Syllabics, Canada)",
        nativeName: "ᐃᓄᒃᑎᑐᑦ (ᑲᓇᑕᒥ)",
        language: "iu-Cans",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "ᓈᑦᑏᖑᔭ", "ᓇᒡᒐᔾᔭᐅ", "ᐊᐃᑉᐱᖅ", "ᐱᖓᑦᓯᖅ", "ᓯᑕᒻᒥᖅ", "ᑕᓪᓕᕐᒥᖅ", "ᓯᕙᑖᕐᕕᒃ" ],
                    namesAbbr: [ "ᓈᑦᑏ", "ᓇᒡᒐ", "ᐊᐃᑉᐱ", "ᐱᖓᑦᓯ", "ᓯᑕ", "ᑕᓪᓕ", "ᓯᕙᑖᕐᕕᒃ" ],
                    namesShort: [ "ᓈ", "ᓇ", "ᐊ", "ᐱ", "ᓯ", "ᑕ", "ᓯ" ]
                },
                months: {
                    names: [ "ᔮᓐᓄᐊᕆ", "ᕖᕝᕗᐊᕆ", "ᒫᑦᓯ", "ᐄᐳᕆ", "ᒪᐃ", "ᔫᓂ", "ᔪᓚᐃ", "ᐋᒡᒌᓯ", "ᓯᑎᐱᕆ", "ᐅᑐᐱᕆ", "ᓄᕕᐱᕆ", "ᑎᓯᐱᕆ", "" ],
                    namesAbbr: [ "ᔮᓐᓄ", "ᕖᕝᕗ", "ᒫᑦᓯ", "ᐄᐳᕆ", "ᒪᐃ", "ᔫᓂ", "ᔪᓚᐃ", "ᐋᒡᒌ", "ᓯᑎᐱ", "ᐅᑐᐱ", "ᓄᕕᐱ", "ᑎᓯᐱ", "" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd,MMMM dd,yyyy",
                    f: "dddd,MMMM dd,yyyy h:mm tt",
                    F: "dddd,MMMM dd,yyyy h:mm:ss tt",
                    Y: "MMMM,yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("am-ET", "default", {
        name: "am-ET",
        englishName: "Amharic (Ethiopia)",
        nativeName: "አማርኛ (ኢትዮጵያ)",
        language: "am",
        numberFormat: {
            decimals: 1,
            groupSizes: [ 3, 0 ],
            NaN: "NAN",
            percent: {
                pattern: [ "-n%", "n%" ],
                decimals: 1,
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "ETB"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "እሑድ", "ሰኞ", "ማክሰኞ", "ረቡዕ", "ሐሙስ", "ዓርብ", "ቅዳሜ" ],
                    namesAbbr: [ "እሑድ", "ሰኞ", "ማክሰ", "ረቡዕ", "ሐሙስ", "ዓርብ", "ቅዳሜ" ],
                    namesShort: [ "እ", "ሰ", "ማ", "ረ", "ሐ", "ዓ", "ቅ" ]
                },
                months: {
                    names: [ "ጃንዩወሪ", "ፌብሩወሪ", "ማርች", "ኤፕረል", "ሜይ", "ጁን", "ጁላይ", "ኦገስት", "ሴፕቴምበር", "ኦክተውበር", "ኖቬምበር", "ዲሴምበር", "" ],
                    namesAbbr: [ "ጃንዩ", "ፌብሩ", "ማርች", "ኤፕረ", "ሜይ", "ጁን", "ጁላይ", "ኦገስ", "ሴፕቴ", "ኦክተ", "ኖቬም", "ዲሴም", "" ]
                },
                AM: [ "ጡዋት", "ጡዋት", "ጡዋት" ],
                PM: [ "ከሰዓት", "ከሰዓት", "ከሰዓት" ],
                eras: [ {
                    name: "ዓመተ  ምሕረት",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd '፣' MMMM d 'ቀን' yyyy",
                    f: "dddd '፣' MMMM d 'ቀን' yyyy h:mm tt",
                    F: "dddd '፣' MMMM d 'ቀን' yyyy h:mm:ss tt",
                    M: "MMMM d ቀን",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ne-NP", "default", {
        name: "ne-NP",
        englishName: "Nepali (Nepal)",
        nativeName: "नेपाली (नेपाल)",
        language: "ne",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            NaN: "nan",
            negativeInfinity: "-infinity",
            positiveInfinity: "infinity",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "रु"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "आइतवार", "सोमवार", "मङ्गलवार", "बुधवार", "बिहीवार", "शुक्रवार", "शनिवार" ],
                    namesAbbr: [ "आइत", "सोम", "मङ्गल", "बुध", "बिही", "शुक्र", "शनि" ],
                    namesShort: [ "आ", "सो", "म", "बु", "बि", "शु", "श" ]
                },
                months: {
                    names: [ "जनवरी", "फेब्रुअरी", "मार्च", "अप्रिल", "मे", "जून", "जुलाई", "अगस्त", "सेप्टेम्बर", "अक्टोबर", "नोभेम्बर", "डिसेम्बर", "" ],
                    namesAbbr: [ "जन", "फेब", "मार्च", "अप्रिल", "मे", "जून", "जुलाई", "अग", "सेप्ट", "अक्ट", "नोभ", "डिस", "" ]
                },
                AM: [ "विहानी", "विहानी", "विहानी" ],
                PM: [ "बेलुकी", "बेलुकी", "बेलुकी" ],
                eras: [ {
                    name: "a.d.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    Y: "MMMM,yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fy-NL", "default", {
        name: "fy-NL",
        englishName: "Frisian (Netherlands)",
        nativeName: "Frysk (Nederlân)",
        language: "fy",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "Snein", "Moandei", "Tiisdei", "Woansdei", "Tongersdei", "Freed", "Sneon" ],
                    namesAbbr: [ "Sn", "Mo", "Ti", "Wo", "To", "Fr", "Sn" ],
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                months: {
                    names: [ "jannewaris", "febrewaris", "maart", "april", "maaie", "juny", "july", "augustus", "septimber", "oktober", "novimber", "desimber", "" ],
                    namesAbbr: [ "jann", "febr", "mrt", "apr", "maaie", "jun", "jul", "aug", "sept", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d-M-yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd d MMMM yyyy H:mm",
                    F: "dddd d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ps-AF", "default", {
        name: "ps-AF",
        englishName: "Pashto (Afghanistan)",
        nativeName: "پښتو (افغانستان)",
        language: "ps",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            ",": "،",
            ".": ",",
            NaN: "غ ع",
            negativeInfinity: "-∞",
            positiveInfinity: "∞",
            percent: {
                pattern: [ "%n-", "%n" ],
                ",": "،",
                ".": ","
            },
            currency: {
                pattern: [ "$n-", "$n" ],
                ",": "٬",
                ".": "٫",
                symbol: "؋"
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                firstDay: 6,
                days: {
                    names: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګا ښزمرى", "زمرى", "وږى", "تله", "لړم", "لنڈ ۍ", "مرغومى", "" ],
                    namesAbbr: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګا ښ", "زمرى", "وږى", "تله", "لړم", "لنڈ ۍ", "مرغومى", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "ل.ه",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy, dd, MMMM, dddd",
                    f: "yyyy, dd, MMMM, dddd h:mm tt",
                    F: "yyyy, dd, MMMM, dddd h:mm:ss tt",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fil-PH", "default", {
        name: "fil-PH",
        englishName: "Filipino (Philippines)",
        nativeName: "Filipino (Pilipinas)",
        language: "fil",
        numberFormat: {
            currency: {
                symbol: "PhP"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Linggo", "Lunes", "Martes", "Mierkoles", "Huebes", "Biernes", "Sabado" ],
                    namesAbbr: [ "Lin", "Lun", "Mar", "Mier", "Hueb", "Bier", "Saba" ],
                    namesShort: [ "L", "L", "M", "M", "H", "B", "S" ]
                },
                months: {
                    names: [ "Enero", "Pebrero", "Marso", "Abril", "Mayo", "Hunyo", "Hulyo", "Agosto", "Septyembre", "Oktubre", "Nobyembre", "Disyembre", "" ],
                    namesAbbr: [ "En", "Peb", "Mar", "Abr", "Mayo", "Hun", "Hul", "Agos", "Sept", "Okt", "Nob", "Dis", "" ]
                },
                eras: [ {
                    name: "Anno Domini",
                    start: null,
                    offset: 0
                } ]
            }
        }
    });
    Globalize.addCultureInfo("dv-MV", "default", {
        name: "dv-MV",
        englishName: "Divehi (Maldives)",
        nativeName: "ދިވެހިބަސް (ދިވެހި ރާއްޖެ)",
        language: "dv",
        isRTL: true,
        numberFormat: {
            currency: {
                pattern: [ "n $-", "n $" ],
                symbol: "ރ."
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                days: {
                    names: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesAbbr: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesShort: [ "އާ", "ހޯ", "އަ", "ބު", "ބު", "ހު", "ހޮ" ]
                },
                months: {
                    names: [ "މުޙައްރަމް", "ޞަފަރު", "ރަބީޢުލްއައްވަލް", "ރަބީޢުލްއާޚިރު", "ޖުމާދަލްއޫލާ", "ޖުމާދަލްއާޚިރާ", "ރަޖަބް", "ޝަޢްބާން", "ރަމަޟާން", "ޝައްވާލް", "ޛުލްޤަޢިދާ", "ޛުލްޙިއްޖާ", "" ],
                    namesAbbr: [ "މުޙައްރަމް", "ޞަފަރު", "ރަބީޢުލްއައްވަލް", "ރަބީޢުލްއާޚިރު", "ޖުމާދަލްއޫލާ", "ޖުމާދަލްއާޚިރާ", "ރަޖަބް", "ޝަޢްބާން", "ރަމަޟާން", "ޝައްވާލް", "ޛުލްޤަޢިދާ", "ޛުލްޙިއްޖާ", "" ]
                },
                AM: [ "މކ", "މކ", "މކ" ],
                PM: [ "މފ", "މފ", "މފ" ],
                eras: [ {
                    name: "ހިޖްރީ",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd/MM/yyyy HH:mm",
                    F: "dd/MM/yyyy HH:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                days: {
                    names: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesAbbr: [ "އާދީއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ],
                    namesShort: [ "އާ", "ހޯ", "އަ", "ބު", "ބު", "ހު", "ހޮ" ]
                },
                months: {
                    names: [ "ޖަނަވަރީ", "ފެބްރުއަރީ", "މާޗް", "އޭޕްރިލް", "މެއި", "ޖޫން", "ޖުލައި", "އޯގަސްޓް", "ސެޕްޓެމްބަރ", "އޮކްޓޯބަރ", "ނޮވެމްބަރ", "ޑިސެމްބަރ", "" ],
                    namesAbbr: [ "ޖަނަވަރީ", "ފެބްރުއަރީ", "މާޗް", "އޭޕްރިލް", "މެއި", "ޖޫން", "ޖުލައި", "އޯގަސްޓް", "ސެޕްޓެމްބަރ", "އޮކްޓޯބަރ", "ނޮވެމްބަރ", "ޑިސެމްބަރ", "" ]
                },
                AM: [ "މކ", "މކ", "މކ" ],
                PM: [ "މފ", "މފ", "މފ" ],
                eras: [ {
                    name: "މީލާދީ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yy",
                    D: "ddd, yyyy MMMM dd",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "ddd, yyyy MMMM dd HH:mm",
                    F: "ddd, yyyy MMMM dd HH:mm:ss",
                    Y: "yyyy, MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ha-Latn-NG", "default", {
        name: "ha-Latn-NG",
        englishName: "Hausa (Latin, Nigeria)",
        nativeName: "Hausa (Nigeria)",
        language: "ha-Latn",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Lahadi", "Litinin", "Talata", "Laraba", "Alhamis", "Juma'a", "Asabar" ],
                    namesAbbr: [ "Lah", "Lit", "Tal", "Lar", "Alh", "Jum", "Asa" ],
                    namesShort: [ "L", "L", "T", "L", "A", "J", "A" ]
                },
                months: {
                    names: [ "Januwaru", "Febreru", "Maris", "Afrilu", "Mayu", "Yuni", "Yuli", "Agusta", "Satumba", "Oktocba", "Nuwamba", "Disamba", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Afr", "May", "Yun", "Yul", "Agu", "Sat", "Okt", "Nuw", "Dis", "" ]
                },
                AM: [ "Safe", "safe", "SAFE" ],
                PM: [ "Yamma", "yamma", "YAMMA" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("yo-NG", "default", {
        name: "yo-NG",
        englishName: "Yoruba (Nigeria)",
        nativeName: "Yoruba (Nigeria)",
        language: "yo",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Aiku", "Aje", "Isegun", "Ojo'ru", "Ojo'bo", "Eti", "Abameta" ],
                    namesAbbr: [ "Aik", "Aje", "Ise", "Ojo", "Ojo", "Eti", "Aba" ],
                    namesShort: [ "A", "A", "I", "O", "O", "E", "A" ]
                },
                months: {
                    names: [ "Osu kinni", "Osu keji", "Osu keta", "Osu kerin", "Osu karun", "Osu kefa", "Osu keje", "Osu kejo", "Osu kesan", "Osu kewa", "Osu kokanla", "Osu keresi", "" ],
                    namesAbbr: [ "kin.", "kej.", "ket.", "ker.", "kar.", "kef.", "kej.", "kej.", "kes.", "kew.", "kok.", "ker.", "" ]
                },
                AM: [ "Owuro", "owuro", "OWURO" ],
                PM: [ "Ale", "ale", "ALE" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("quz-BO", "default", {
        name: "quz-BO",
        englishName: "Quechua (Bolivia)",
        nativeName: "runasimi (Qullasuyu)",
        language: "quz",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "$b"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "intichaw", "killachaw", "atipachaw", "quyllurchaw", "Ch' askachaw", "Illapachaw", "k'uychichaw" ],
                    namesAbbr: [ "int", "kil", "ati", "quy", "Ch'", "Ill", "k'u" ],
                    namesShort: [ "d", "k", "a", "m", "h", "b", "k" ]
                },
                months: {
                    names: [ "Qulla puquy", "Hatun puquy", "Pauqar waray", "ayriwa", "Aymuray", "Inti raymi", "Anta Sitwa", "Qhapaq Sitwa", "Uma raymi", "Kantaray", "Ayamarq'a", "Kapaq Raymi", "" ],
                    namesAbbr: [ "Qul", "Hat", "Pau", "ayr", "Aym", "Int", "Ant", "Qha", "Uma", "Kan", "Aya", "Kap", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("nso-ZA", "default", {
        name: "nso-ZA",
        englishName: "Sesotho sa Leboa (South Africa)",
        nativeName: "Sesotho sa Leboa (Afrika Borwa)",
        language: "nso",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Lamorena", "Mošupologo", "Labobedi", "Laboraro", "Labone", "Labohlano", "Mokibelo" ],
                    namesAbbr: [ "Lam", "Moš", "Lbb", "Lbr", "Lbn", "Lbh", "Mok" ],
                    namesShort: [ "L", "M", "L", "L", "L", "L", "M" ]
                },
                months: {
                    names: [ "Pherekgong", "Hlakola", "Mopitlo", "Moranang", "Mosegamanye", "Ngoatobošego", "Phuphu", "Phato", "Lewedi", "Diphalana", "Dibatsela", "Manthole", "" ],
                    namesAbbr: [ "Pher", "Hlak", "Mop", "Mor", "Mos", "Ngwat", "Phup", "Phat", "Lew", "Dip", "Dib", "Man", "" ]
                },
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ba-RU", "default", {
        name: "ba-RU",
        englishName: "Bashkir (Russia)",
        nativeName: "Башҡорт (Россия)",
        language: "ba",
        numberFormat: {
            ",": " ",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ",",
                symbol: "һ."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Йәкшәмбе", "Дүшәмбе", "Шишәмбе", "Шаршамбы", "Кесаҙна", "Йома", "Шәмбе" ],
                    namesAbbr: [ "Йш", "Дш", "Шш", "Шр", "Кс", "Йм", "Шб" ],
                    namesShort: [ "Йш", "Дш", "Шш", "Шр", "Кс", "Йм", "Шб" ]
                },
                months: {
                    names: [ "ғинуар", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь", "" ],
                    namesAbbr: [ "ғин", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d MMMM yyyy 'й'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy 'й' H:mm",
                    F: "d MMMM yyyy 'й' H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("lb-LU", "default", {
        name: "lb-LU",
        englishName: "Luxembourgish (Luxembourg)",
        nativeName: "Lëtzebuergesch (Luxembourg)",
        language: "lb",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "n. num.",
            negativeInfinity: "-onendlech",
            positiveInfinity: "+onendlech",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sonndeg", "Méindeg", "Dënschdeg", "Mëttwoch", "Donneschdeg", "Freideg", "Samschdeg" ],
                    namesAbbr: [ "Son", "Méi", "Dën", "Mët", "Don", "Fre", "Sam" ],
                    namesShort: [ "So", "Mé", "Dë", "Më", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "Mäerz", "Abrëll", "Mee", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mäe", "Abr", "Mee", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("kl-GL", "default", {
        name: "kl-GL",
        englishName: "Greenlandic (Greenland)",
        nativeName: "kalaallisut (Kalaallit Nunaat)",
        language: "kl",
        numberFormat: {
            ",": ".",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                groupSizes: [ 3, 0 ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 0 ],
                ",": ".",
                ".": ",",
                symbol: "kr."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "sapaat", "ataasinngorneq", "marlunngorneq", "pingasunngorneq", "sisamanngorneq", "tallimanngorneq", "arfininngorneq" ],
                    namesAbbr: [ "sap", "ata", "mar", "ping", "sis", "tal", "arf" ],
                    namesShort: [ "sa", "at", "ma", "pi", "si", "ta", "ar" ]
                },
                months: {
                    names: [ "januari", "februari", "martsi", "apriili", "maaji", "juni", "juli", "aggusti", "septembari", "oktobari", "novembari", "decembari", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ig-NG", "default", {
        name: "ig-NG",
        englishName: "Igbo (Nigeria)",
        nativeName: "Igbo (Nigeria)",
        language: "ig",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Aiku", "Aje", "Isegun", "Ojo'ru", "Ojo'bo", "Eti", "Abameta" ],
                    namesAbbr: [ "Aik", "Aje", "Ise", "Ojo", "Ojo", "Eti", "Aba" ],
                    namesShort: [ "A", "A", "I", "O", "O", "E", "A" ]
                },
                months: {
                    names: [ "Onwa mbu", "Onwa ibua", "Onwa ato", "Onwa ano", "Onwa ise", "Onwa isi", "Onwa asa", "Onwa asato", "Onwa itolu", "Onwa iri", "Onwa iri n'ofu", "Onwa iri n'ibua", "" ],
                    namesAbbr: [ "mbu.", "ibu.", "ato.", "ano.", "ise", "isi", "asa", "asa.", "ito.", "iri.", "n'of.", "n'ib.", "" ]
                },
                AM: [ "Ututu", "ututu", "UTUTU" ],
                PM: [ "Efifie", "efifie", "EFIFIE" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ii-CN", "default", {
        name: "ii-CN",
        englishName: "Yi (PRC)",
        nativeName: "ꆈꌠꁱꂷ (ꍏꉸꏓꂱꇭꉼꇩ)",
        language: "ii",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ꌗꂷꀋꉬ",
            negativeInfinity: "ꀄꊭꌐꀋꉆ",
            positiveInfinity: "ꈤꇁꑖꀋꉬ",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "ꑭꆏꑍ", "ꆏꊂ꒔", "ꆏꊂꑍ", "ꆏꊂꌕ", "ꆏꊂꇖ", "ꆏꊂꉬ", "ꆏꊂꃘ" ],
                    namesAbbr: [ "ꑭꆏ", "ꆏ꒔", "ꆏꑍ", "ꆏꌕ", "ꆏꇖ", "ꆏꉬ", "ꆏꃘ" ],
                    namesShort: [ "ꆏ", "꒔", "ꑍ", "ꌕ", "ꇖ", "ꉬ", "ꃘ" ]
                },
                months: {
                    names: [ "ꋍꆪ", "ꑍꆪ", "ꌕꆪ", "ꇖꆪ", "ꉬꆪ", "ꃘꆪ", "ꏃꆪ", "ꉆꆪ", "ꈬꆪ", "ꊰꆪ", "ꊯꊪꆪ", "ꊰꑋꆪ", "" ],
                    namesAbbr: [ "ꋍꆪ", "ꑍꆪ", "ꌕꆪ", "ꇖꆪ", "ꉬꆪ", "ꃘꆪ", "ꏃꆪ", "ꉆꆪ", "ꈬꆪ", "ꊰꆪ", "ꊯꊪꆪ", "ꊰꑋꆪ", "" ]
                },
                AM: [ "ꂵꆪꈌꈐ", "ꂵꆪꈌꈐ", "ꂵꆪꈌꈐ" ],
                PM: [ "ꂵꆪꈌꉈ", "ꂵꆪꈌꉈ", "ꂵꆪꈌꉈ" ],
                eras: [ {
                    name: "ꇬꑼ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ꈎ' M'ꆪ' d'ꑍ'",
                    t: "tt h:mm",
                    T: "H:mm:ss",
                    f: "yyyy'ꈎ' M'ꆪ' d'ꑍ' tt h:mm",
                    F: "yyyy'ꈎ' M'ꆪ' d'ꑍ' H:mm:ss",
                    M: "M'ꆪ' d'ꑍ'",
                    Y: "yyyy'ꈎ' M'ꆪ'"
                }
            }
        }
    });
    Globalize.addCultureInfo("arn-CL", "default", {
        name: "arn-CL",
        englishName: "Mapudungun (Chile)",
        nativeName: "Mapudungun (Chile)",
        language: "arn",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("moh-CA", "default", {
        name: "moh-CA",
        englishName: "Mohawk (Mohawk)",
        nativeName: "Kanien'kéha",
        language: "moh",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Awentatokentì:ke", "Awentataón'ke", "Ratironhia'kehronòn:ke", "Soséhne", "Okaristiiáhne", "Ronwaia'tanentaktonhne", "Entákta" ],
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                months: {
                    names: [ "Tsothohrkó:Wa", "Enniska", "Enniskó:Wa", "Onerahtókha", "Onerahtohkó:Wa", "Ohiari:Ha", "Ohiarihkó:Wa", "Seskéha", "Seskehkó:Wa", "Kenténha", "Kentenhkó:Wa", "Tsothóhrha", "" ]
                }
            }
        }
    });
    Globalize.addCultureInfo("br-FR", "default", {
        name: "br-FR",
        englishName: "Breton (France)",
        nativeName: "brezhoneg (Frañs)",
        language: "br",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "NkN",
            negativeInfinity: "-Anfin",
            positiveInfinity: "+Anfin",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sul", "Lun", "Meurzh", "Merc'her", "Yaou", "Gwener", "Sadorn" ],
                    namesAbbr: [ "Sul", "Lun", "Meu.", "Mer.", "Yaou", "Gwe.", "Sad." ],
                    namesShort: [ "Su", "Lu", "Mz", "Mc", "Ya", "Gw", "Sa" ]
                },
                months: {
                    names: [ "Genver", "C'hwevrer", "Meurzh", "Ebrel", "Mae", "Mezheven", "Gouere", "Eost", "Gwengolo", "Here", "Du", "Kerzu", "" ],
                    namesAbbr: [ "Gen.", "C'hwe.", "Meur.", "Ebr.", "Mae", "Mezh.", "Goue.", "Eost", "Gwen.", "Here", "Du", "Kzu", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "g. J.-K.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ug-CN", "default", {
        name: "ug-CN",
        englishName: "Uyghur (PRC)",
        nativeName: "ئۇيغۇرچە (جۇڭخۇا خەلق جۇمھۇرىيىتى)",
        language: "ug",
        isRTL: true,
        numberFormat: {
            NaN: "سان ئەمەس",
            negativeInfinity: "مەنپىي چەكسىزلىك",
            positiveInfinity: "مۇسبەت چەكسىزلىك",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "يەكشەنبە", "دۈشەنبە", "سەيشەنبە", "چارشەنبە", "پەيشەنبە", "جۈمە", "شەنبە" ],
                    namesAbbr: [ "يە", "دۈ", "سە", "چا", "پە", "جۈ", "شە" ],
                    namesShort: [ "ي", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي", "" ],
                    namesAbbr: [ "1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي", "" ]
                },
                AM: [ "چۈشتىن بۇرۇن", "چۈشتىن بۇرۇن", "چۈشتىن بۇرۇن" ],
                PM: [ "چۈشتىن كېيىن", "چۈشتىن كېيىن", "چۈشتىن كېيىن" ],
                eras: [ {
                    name: "مىلادى",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-M-d",
                    D: "yyyy-'يىلى' MMMM d-'كۈنى،'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy-'يىلى' MMMM d-'كۈنى،' H:mm",
                    F: "yyyy-'يىلى' MMMM d-'كۈنى،' H:mm:ss",
                    M: "MMMM d'-كۈنى'",
                    Y: "yyyy-'يىلى' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mi-NZ", "default", {
        name: "mi-NZ",
        englishName: "Maori (New Zealand)",
        nativeName: "Reo Māori (Aotearoa)",
        language: "mi",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Rātapu", "Rāhina", "Rātū", "Rāapa", "Rāpare", "Rāmere", "Rāhoroi" ],
                    namesAbbr: [ "Ta", "Hi", "Tū", "Apa", "Pa", "Me", "Ho" ],
                    namesShort: [ "Ta", "Hi", "Tū", "Aa", "Pa", "Me", "Ho" ]
                },
                months: {
                    names: [ "Kohi-tātea", "Hui-tanguru", "Poutū-te-rangi", "Paenga-whāwhā", "Haratua", "Pipiri", "Hōngongoi", "Here-turi-kōkā", "Mahuru", "Whiringa-ā-nuku", "Whiringa-ā-rangi", "Hakihea", "" ],
                    namesAbbr: [ "Kohi", "Hui", "Pou", "Pae", "Hara", "Pipi", "Hōngo", "Here", "Mahu", "Nuku", "Rangi", "Haki", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd MMMM, yyyy",
                    f: "dddd, dd MMMM, yyyy h:mm tt",
                    F: "dddd, dd MMMM, yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM, yy"
                }
            }
        }
    });
    Globalize.addCultureInfo("oc-FR", "default", {
        name: "oc-FR",
        englishName: "Occitan (France)",
        nativeName: "Occitan (França)",
        language: "oc",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numeric",
            negativeInfinity: "-Infinit",
            positiveInfinity: "+Infinit",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimenge", "diluns", "dimars", "dimècres", "dijòus", "divendres", "dissabte" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mèc.", "jòu.", "ven.", "sab." ],
                    namesShort: [ "di", "lu", "ma", "mè", "jò", "ve", "sa" ]
                },
                months: {
                    names: [ "genier", "febrier", "març", "abril", "mai", "junh", "julh", "agost", "setembre", "octobre", "novembre", "desembre", "" ],
                    namesAbbr: [ "gen.", "feb.", "mar.", "abr.", "mai.", "jun.", "jul.", "ag.", "set.", "oct.", "nov.", "des.", "" ]
                },
                monthsGenitive: {
                    names: [ "de genier", "de febrier", "de març", "d'abril", "de mai", "de junh", "de julh", "d'agost", "de setembre", "d'octobre", "de novembre", "de desembre", "" ],
                    namesAbbr: [ "gen.", "feb.", "mar.", "abr.", "mai.", "jun.", "jul.", "ag.", "set.", "oct.", "nov.", "des.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "après Jèsus-Crist",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd,' lo 'd MMMM' de 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd,' lo 'd MMMM' de 'yyyy HH:mm",
                    F: "dddd,' lo 'd MMMM' de 'yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("co-FR", "default", {
        name: "co-FR",
        englishName: "Corsican (France)",
        nativeName: "Corsu (France)",
        language: "co",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Mica numericu",
            negativeInfinity: "-Infinitu",
            positiveInfinity: "+Infinitu",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dumenica", "luni", "marti", "mercuri", "ghjovi", "venderi", "sabbatu" ],
                    namesAbbr: [ "dum.", "lun.", "mar.", "mer.", "ghj.", "ven.", "sab." ],
                    namesShort: [ "du", "lu", "ma", "me", "gh", "ve", "sa" ]
                },
                months: {
                    names: [ "ghjennaghju", "ferraghju", "marzu", "aprile", "maghju", "ghjunghju", "lugliu", "aostu", "settembre", "ottobre", "nuvembre", "dicembre", "" ],
                    namesAbbr: [ "ghje", "ferr", "marz", "apri", "magh", "ghju", "lugl", "aost", "sett", "otto", "nuve", "dice", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "dopu J-C",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gsw-FR", "default", {
        name: "gsw-FR",
        englishName: "Alsatian (France)",
        nativeName: "Elsässisch (Frànkrisch)",
        language: "gsw",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Ohne Nummer",
            negativeInfinity: "-Unendlich",
            positiveInfinity: "+Unendlich",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Sundàà", "Mondàà", "Dienschdàà", "Mittwuch", "Dunnerschdàà", "Fridàà", "Sàmschdàà" ],
                    namesAbbr: [ "Su.", "Mo.", "Di.", "Mi.", "Du.", "Fr.", "Sà." ],
                    namesShort: [ "Su", "Mo", "Di", "Mi", "Du", "Fr", "Sà" ]
                },
                months: {
                    names: [ "Jänner", "Feverje", "März", "Àpril", "Mai", "Jüni", "Jüli", "Augscht", "September", "Oktower", "Nowember", "Dezember", "" ],
                    namesAbbr: [ "Jän.", "Fev.", "März", "Apr.", "Mai", "Jüni", "Jüli", "Aug.", "Sept.", "Okt.", "Now.", "Dez.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "Vor J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sah-RU", "default", {
        name: "sah-RU",
        englishName: "Yakut (Russia)",
        nativeName: "саха (Россия)",
        language: "sah",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "NAN",
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "с."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "баскыһыанньа", "бэнидиэнньик", "оптуорунньук", "сэрэдэ", "чэппиэр", "бээтинсэ", "субуота" ],
                    namesAbbr: [ "Бс", "Бн", "Оп", "Ср", "Чп", "Бт", "Сб" ],
                    namesShort: [ "Бс", "Бн", "Оп", "Ср", "Чп", "Бт", "Сб" ]
                },
                months: {
                    names: [ "Тохсунньу", "Олунньу", "Кулун тутар", "Муус устар", "Ыам ыйа", "Бэс ыйа", "От ыйа", "Атырдьах ыйа", "Балаҕан ыйа", "Алтынньы", "Сэтинньи", "Ахсынньы", "" ],
                    namesAbbr: [ "тхс", "олн", "кул", "мст", "ыам", "бэс", "отй", "атр", "блҕ", "алт", "стн", "ахс", "" ]
                },
                monthsGenitive: {
                    names: [ "тохсунньу", "олунньу", "кулун тутар", "муус устар", "ыам ыйын", "бэс ыйын", "от ыйын", "атырдьах ыйын", "балаҕан ыйын", "алтынньы", "сэтинньи", "ахсынньы", "" ],
                    namesAbbr: [ "тхс", "олн", "кул", "мст", "ыам", "бэс", "отй", "атр", "блҕ", "алт", "стн", "ахс", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "MM.dd.yyyy",
                    D: "MMMM d yyyy 'с.'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d yyyy 'с.' H:mm",
                    F: "MMMM d yyyy 'с.' H:mm:ss",
                    Y: "MMMM yyyy 'с.'"
                }
            }
        }
    });
    Globalize.addCultureInfo("qut-GT", "default", {
        name: "qut-GT",
        englishName: "K'iche (Guatemala)",
        nativeName: "K'iche (Guatemala)",
        language: "qut",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                symbol: "Q"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "juq'ij", "kaq'ij", "oxq'ij", "kajq'ij", "joq'ij", "waqq'ij", "wuqq'ij" ],
                    namesAbbr: [ "juq", "kaq", "oxq", "kajq", "joq", "waqq", "wuqq" ],
                    namesShort: [ "ju", "ka", "ox", "ka", "jo", "wa", "wu" ]
                },
                months: {
                    names: [ "nab'e ik'", "ukab' ik'", "rox ik'", "ukaj ik'", "uro' ik'", "uwaq ik'", "uwuq ik'", "uwajxaq ik'", "ub'elej ik'", "ulaj ik'", "ujulaj ik'", "ukab'laj ik'", "" ],
                    namesAbbr: [ "nab'e", "ukab", "rox", "ukaj", "uro", "uwaq", "uwuq", "uwajxaq", "ub'elej", "ulaj", "ujulaj", "ukab'laj", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("rw-RW", "default", {
        name: "rw-RW",
        englishName: "Kinyarwanda (Rwanda)",
        nativeName: "Kinyarwanda (Rwanda)",
        language: "rw",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "RWF"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Ku wa mbere", "Ku wa kabiri", "Ku wa gatatu", "Ku wa kane", "Ku wa gatanu", "Ku wa gatandatu", "Ku cyumweru" ],
                    namesAbbr: [ "mbe.", "kab.", "gat.", "kan.", "gat.", "gat.", "cyu." ],
                    namesShort: [ "mb", "ka", "ga", "ka", "ga", "ga", "cy" ]
                },
                months: {
                    names: [ "Mutarama", "Gashyantare", "Werurwe", "Mata", "Gicurasi", "Kamena", "Nyakanga", "Kanama", "Nzeli", "Ukwakira", "Ugushyingo", "Ukuboza", "" ],
                    namesAbbr: [ "Mut", "Gas", "Wer", "Mat", "Gic", "Kam", "Nya", "Kan", "Nze", "Ukwa", "Ugu", "Uku", "" ]
                },
                AM: [ "saa moya z.m.", "saa moya z.m.", "SAA MOYA Z.M." ],
                PM: [ "saa moya z.n.", "saa moya z.n.", "SAA MOYA Z.N." ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ]
            }
        }
    });
    Globalize.addCultureInfo("wo-SN", "default", {
        name: "wo-SN",
        englishName: "Wolof (Senegal)",
        nativeName: "Wolof (Sénégal)",
        language: "wo",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "XOF"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("prs-AF", "default", {
        name: "prs-AF",
        englishName: "Dari (Afghanistan)",
        nativeName: "درى (افغانستان)",
        language: "prs",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            ",": ".",
            ".": ",",
            NaN: "غ ع",
            negativeInfinity: "-∞",
            positiveInfinity: "∞",
            percent: {
                pattern: [ "%n-", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$n-", "$n" ],
                symbol: "؋"
            }
        },
        calendars: {
            standard: {
                name: "Hijri",
                firstDay: 5,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    f: "dd/MM/yyyy h:mm tt",
                    F: "dd/MM/yyyy h:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_Localized: {
                firstDay: 5,
                days: {
                    names: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesAbbr: [ "یکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه" ],
                    namesShort: [ "ی", "د", "س", "چ", "پ", "ج", "ش" ]
                },
                months: {
                    names: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګاښ", "زمرى", "وږى", "تله", "لړم", "ليندۍ", "مرغومى", "" ],
                    namesAbbr: [ "سلواغه", "كب", "ورى", "غويى", "غبرګولى", "چنګاښ", "زمرى", "وږى", "تله", "لړم", "ليندۍ", "مرغومى", "" ]
                },
                AM: [ "غ.م", "غ.م", "غ.م" ],
                PM: [ "غ.و", "غ.و", "غ.و" ],
                eras: [ {
                    name: "ل.ه",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy, dd, MMMM, dddd",
                    f: "yyyy, dd, MMMM, dddd h:mm tt",
                    F: "yyyy, dd, MMMM, dddd h:mm:ss tt",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("gd-GB", "default", {
        name: "gd-GB",
        englishName: "Scottish Gaelic (United Kingdom)",
        nativeName: "Gàidhlig (An Rìoghachd Aonaichte)",
        language: "gd",
        numberFormat: {
            negativeInfinity: "-Neo-chrìochnachd",
            positiveInfinity: "Neo-chrìochnachd",
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "£"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ],
                    namesAbbr: [ "Dòm", "Lua", "Mài", "Cia", "Ard", "Hao", "Sat" ],
                    namesShort: [ "D", "L", "M", "C", "A", "H", "S" ]
                },
                months: {
                    names: [ "Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd", "" ],
                    namesAbbr: [ "Fao", "Gea", "Màr", "Gib", "Cèi", "Ògm", "Iuc", "Lùn", "Sul", "Dàm", "Sam", "Dùb", "" ]
                },
                AM: [ "m", "m", "M" ],
                PM: [ "f", "f", "F" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-IQ", "default", {
        name: "ar-IQ",
        englishName: "Arabic (Iraq)",
        nativeName: "العربية (العراق)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "د.ع.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-CN", "default", {
        name: "zh-CN",
        englishName: "Chinese (Simplified, PRC)",
        nativeName: "中文(中华人民共和国)",
        language: "zh-CHS",
        numberFormat: {
            NaN: "非数字",
            negativeInfinity: "负无穷大",
            positiveInfinity: "正无穷大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("de-CH", "default", {
        name: "de-CH",
        englishName: "German (Switzerland)",
        nativeName: "Deutsch (Schweiz)",
        language: "de",
        numberFormat: {
            ",": "'",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "Fr."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-GB", "default", {
        name: "en-GB",
        englishName: "English (United Kingdom)",
        nativeName: "English (United Kingdom)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "£"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-MX", "default", {
        name: "es-MX",
        englishName: "Spanish (Mexico)",
        nativeName: "Español (México)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-BE", "default", {
        name: "fr-BE",
        englishName: "French (Belgium)",
        nativeName: "français (Belgique)",
        language: "fr",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("it-CH", "default", {
        name: "it-CH",
        englishName: "Italian (Switzerland)",
        nativeName: "italiano (Svizzera)",
        language: "it",
        numberFormat: {
            ",": "'",
            NaN: "Non un numero reale",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "fr."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "domenica", "lunedì", "martedì", "mercoledì", "giovedì", "venerdì", "sabato" ],
                    namesAbbr: [ "dom", "lun", "mar", "mer", "gio", "ven", "sab" ],
                    namesShort: [ "do", "lu", "ma", "me", "gi", "ve", "sa" ]
                },
                months: {
                    names: [ "gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre", "" ],
                    namesAbbr: [ "gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("nl-BE", "default", {
        name: "nl-BE",
        englishName: "Dutch (Belgium)",
        nativeName: "Nederlands (België)",
        language: "nl",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NaN (Niet-een-getal)",
            negativeInfinity: "-oneindig",
            positiveInfinity: "oneindig",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag" ],
                    namesAbbr: [ "zo", "ma", "di", "wo", "do", "vr", "za" ],
                    namesShort: [ "zo", "ma", "di", "wo", "do", "vr", "za" ]
                },
                months: {
                    names: [ "januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd d MMMM yyyy H:mm",
                    F: "dddd d MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("nn-NO", "default", {
        name: "nn-NO",
        englishName: "Norwegian, Nynorsk (Norway)",
        nativeName: "norsk, nynorsk (Noreg)",
        language: "nn",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "søndag", "måndag", "tysdag", "onsdag", "torsdag", "fredag", "laurdag" ],
                    namesAbbr: [ "sø", "må", "ty", "on", "to", "fr", "la" ],
                    namesShort: [ "sø", "må", "ty", "on", "to", "fr", "la" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("pt-PT", "default", {
        name: "pt-PT",
        englishName: "Portuguese (Portugal)",
        nativeName: "português (Portugal)",
        language: "pt",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NaN (Não é um número)",
            negativeInfinity: "-Infinito",
            positiveInfinity: "+Infinito",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado" ],
                    namesAbbr: [ "dom", "seg", "ter", "qua", "qui", "sex", "sáb" ],
                    namesShort: [ "D", "S", "T", "Q", "Q", "S", "S" ]
                },
                months: {
                    names: [ "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro", "" ],
                    namesAbbr: [ "Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dddd, d' de 'MMMM' de 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d' de 'MMMM' de 'yyyy HH:mm",
                    F: "dddd, d' de 'MMMM' de 'yyyy HH:mm:ss",
                    M: "d/M",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Latn-CS", "default", {
        name: "sr-Latn-CS",
        englishName: "Serbian (Latin, Serbia and Montenegro (Former))",
        nativeName: "srpski (Srbija i Crna Gora (Prethodno))",
        language: "sr-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Din."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sv-FI", "default", {
        name: "sv-FI",
        englishName: "Swedish (Finland)",
        nativeName: "svenska (Finland)",
        language: "sv",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag" ],
                    namesAbbr: [ "sö", "må", "ti", "on", "to", "fr", "lö" ],
                    namesShort: [ "sö", "må", "ti", "on", "to", "fr", "lö" ]
                },
                months: {
                    names: [ "januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "'den 'd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "'den 'd MMMM yyyy HH:mm",
                    F: "'den 'd MMMM yyyy HH:mm:ss",
                    M: "'den 'd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("az-Cyrl-AZ", "default", {
        name: "az-Cyrl-AZ",
        englishName: "Azeri (Cyrillic, Azerbaijan)",
        nativeName: "Азәрбајҹан (Азәрбајҹан)",
        language: "az-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "ман."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Базар", "Базар ертәси", "Чәршәнбә ахшамы", "Чәршәнбә", "Ҹүмә ахшамы", "Ҹүмә", "Шәнбә" ],
                    namesAbbr: [ "Б", "Бе", "Ча", "Ч", "Ҹа", "Ҹ", "Ш" ],
                    namesShort: [ "Б", "Бе", "Ча", "Ч", "Ҹа", "Ҹ", "Ш" ]
                },
                months: {
                    names: [ "Јанвар", "Феврал", "Март", "Апрел", "Мај", "Ијун", "Ијул", "Август", "Сентјабр", "Октјабр", "Нојабр", "Декабр", "" ],
                    namesAbbr: [ "Јан", "Фев", "Мар", "Апр", "Мај", "Ијун", "Ијул", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "јанвар", "феврал", "март", "апрел", "мај", "ијун", "ијул", "август", "сентјабр", "октјабр", "нојабр", "декабр", "" ],
                    namesAbbr: [ "Јан", "Фев", "Мар", "Апр", "мая", "ијун", "ијул", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("dsb-DE", "default", {
        name: "dsb-DE",
        englishName: "Lower Sorbian (Germany)",
        nativeName: "dolnoserbšćina (Nimska)",
        language: "dsb",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "njedefinowane",
            negativeInfinity: "-njekońcne",
            positiveInfinity: "+njekońcne",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "njeźela", "ponjeźele", "wałtora", "srjoda", "stwortk", "pětk", "sobota" ],
                    namesAbbr: [ "nje", "pon", "wał", "srj", "stw", "pět", "sob" ],
                    namesShort: [ "n", "p", "w", "s", "s", "p", "s" ]
                },
                months: {
                    names: [ "januar", "februar", "měrc", "apryl", "maj", "junij", "julij", "awgust", "september", "oktober", "nowember", "december", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "maj", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "januara", "februara", "měrca", "apryla", "maja", "junija", "julija", "awgusta", "septembra", "oktobra", "nowembra", "decembra", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "maj", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "po Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "dddd, 'dnja' d. MMMM yyyy",
                    t: "H.mm 'goź.'",
                    T: "H:mm:ss",
                    f: "dddd, 'dnja' d. MMMM yyyy H.mm 'goź.'",
                    F: "dddd, 'dnja' d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("se-SE", "default", {
        name: "se-SE",
        englishName: "Sami, Northern (Sweden)",
        nativeName: "davvisámegiella (Ruoŧŧa)",
        language: "se",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "sotnabeaivi", "mánnodat", "disdat", "gaskavahkku", "duorastat", "bearjadat", "lávvardat" ],
                    namesAbbr: [ "sotn", "mán", "dis", "gask", "duor", "bear", "láv" ],
                    namesShort: [ "s", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ođđajagemánnu", "guovvamánnu", "njukčamánnu", "cuoŋománnu", "miessemánnu", "geassemánnu", "suoidnemánnu", "borgemánnu", "čakčamánnu", "golggotmánnu", "skábmamánnu", "juovlamánnu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđajagimánu", "guovvamánu", "njukčamánu", "cuoŋománu", "miessemánu", "geassemánu", "suoidnemánu", "borgemánu", "čakčamánu", "golggotmánu", "skábmamánu", "juovlamánu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ga-IE", "default", {
        name: "ga-IE",
        englishName: "Irish (Ireland)",
        nativeName: "Gaeilge (Éire)",
        language: "ga",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn" ],
                    namesAbbr: [ "Domh", "Luan", "Máir", "Céad", "Déar", "Aoi", "Sath" ],
                    namesShort: [ "Do", "Lu", "Má", "Cé", "De", "Ao", "Sa" ]
                },
                months: {
                    names: [ "Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig", "" ],
                    namesAbbr: [ "Ean", "Feabh", "Már", "Aib", "Bealt", "Meith", "Iúil", "Lún", "M.Fómh", "D.Fómh", "Samh", "Noll", "" ]
                },
                AM: [ "r.n.", "r.n.", "R.N." ],
                PM: [ "i.n.", "i.n.", "I.N." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ms-BN", "default", {
        name: "ms-BN",
        englishName: "Malay (Brunei Darussalam)",
        nativeName: "Bahasa Melayu (Brunei Darussalam)",
        language: "ms",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                decimals: 0,
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesAbbr: [ "Ahad", "Isnin", "Sel", "Rabu", "Khamis", "Jumaat", "Sabtu" ],
                    namesShort: [ "A", "I", "S", "R", "K", "J", "S" ]
                },
                months: {
                    names: [ "Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogos", "Sept", "Okt", "Nov", "Dis", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM yyyy H:mm",
                    F: "dd MMMM yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("uz-Cyrl-UZ", "default", {
        name: "uz-Cyrl-UZ",
        englishName: "Uzbek (Cyrillic, Uzbekistan)",
        nativeName: "Ўзбек (Ўзбекистон)",
        language: "uz-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "сўм"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "якшанба", "душанба", "сешанба", "чоршанба", "пайшанба", "жума", "шанба" ],
                    namesAbbr: [ "якш", "дш", "сш", "чш", "пш", "ж", "ш" ],
                    namesShort: [ "я", "д", "с", "ч", "п", "ж", "ш" ]
                },
                months: {
                    names: [ "Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "январ", "феврал", "март", "апрел", "май", "июн", "июл", "август", "сентябр", "октябр", "ноябр", "декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "мая", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "yyyy 'йил' d-MMMM",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'йил' d-MMMM HH:mm",
                    F: "yyyy 'йил' d-MMMM HH:mm:ss",
                    M: "d-MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bn-BD", "default", {
        name: "bn-BD",
        englishName: "Bengali (Bangladesh)",
        nativeName: "বাংলা (বাংলাদেশ)",
        language: "bn",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                pattern: [ "-%n", "%n" ],
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "৳"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                ":": ".",
                firstDay: 1,
                days: {
                    names: [ "রবিবার", "সোমবার", "মঙ্গলবার", "বুধবার", "বৃহস্পতিবার", "শুক্রবার", "শনিবার" ],
                    namesAbbr: [ "রবি.", "সোম.", "মঙ্গল.", "বুধ.", "বৃহস্পতি.", "শুক্র.", "শনি." ],
                    namesShort: [ "র", "স", "ম", "ব", "ব", "শ", "শ" ]
                },
                months: {
                    names: [ "জানুয়ারী", "ফেব্রুয়ারী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগস্ট", "সেপ্টেম্বর", "অক্টোবর", "নভেম্বর", "ডিসেম্বর", "" ],
                    namesAbbr: [ "জানু.", "ফেব্রু.", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগ.", "সেপ্টে.", "অক্টো.", "নভে.", "ডিসে.", "" ]
                },
                AM: [ "পুর্বাহ্ন", "পুর্বাহ্ন", "পুর্বাহ্ন" ],
                PM: [ "অপরাহ্ন", "অপরাহ্ন", "অপরাহ্ন" ],
                patterns: {
                    d: "dd-MM-yy",
                    D: "dd MMMM yyyy",
                    t: "HH.mm",
                    T: "HH.mm.ss",
                    f: "dd MMMM yyyy HH.mm",
                    F: "dd MMMM yyyy HH.mm.ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("mn-Mong-CN", "default", {
        name: "mn-Mong-CN",
        englishName: "Mongolian (Traditional Mongolian, PRC)",
        nativeName: "ᠮᠤᠨᠭᠭᠤᠯ ᠬᠡᠯᠡ (ᠪᠦᠭᠦᠳᠡ ᠨᠠᠢᠷᠠᠮᠳᠠᠬᠤ ᠳᠤᠮᠳᠠᠳᠤ ᠠᠷᠠᠳ ᠣᠯᠣᠰ)",
        language: "mn-Mong",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ᠲᠤᠭᠠᠠ ᠪᠤᠰᠤ",
            negativeInfinity: "ᠰᠦᠬᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠡᠬᠡ",
            positiveInfinity: "ᠡᠶ᠋ᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠠᠬᠡ",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "ᠭᠠᠷᠠᠭ ᠤᠨ ᠡᠳᠦᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠨᠢᠭᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠬᠣᠶᠠᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠭᠤᠷᠪᠠᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠳᠥᠷᠪᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠲᠠᠪᠤᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠵᠢᠷᠭᠤᠭᠠᠨ" ],
                    namesAbbr: [ "ᠭᠠᠷᠠᠭ ᠤᠨ ᠡᠳᠦᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠨᠢᠭᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠬᠣᠶᠠᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠭᠤᠷᠪᠠᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠳᠥᠷᠪᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠲᠠᠪᠤᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠵᠢᠷᠭᠤᠭᠠᠨ" ],
                    namesShort: [ "ᠡ‍", "ᠨᠢ‍", "ᠬᠣ‍", "ᠭᠤ‍", "ᠳᠥ‍", "ᠲᠠ‍", "ᠵᠢ‍" ]
                },
                months: {
                    names: [ "ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠭᠤᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠦᠷᠪᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠠᠪᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠵᠢᠷᠭᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠤᠯᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠨᠠᠢᠮᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠶᠢᠰᠦᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "" ],
                    namesAbbr: [ "ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠭᠤᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠦᠷᠪᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠠᠪᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠵᠢᠷᠭᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠤᠯᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠨᠠᠢᠮᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠶᠢᠰᠦᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ᠣᠨ ᠲᠣᠭᠠᠯᠠᠯ ᠤᠨ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ' H:mm",
                    F: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ' H:mm:ss",
                    M: "M'ᠰᠠᠷ᠎ᠠ' d'ᠡᠳᠦᠷ'",
                    Y: "yyyy'ᠣᠨ' M'ᠰᠠᠷ᠎ᠠ'"
                }
            }
        }
    });
    Globalize.addCultureInfo("iu-Latn-CA", "default", {
        name: "iu-Latn-CA",
        englishName: "Inuktitut (Latin, Canada)",
        nativeName: "Inuktitut (Kanatami)",
        language: "iu-Latn",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Naattiinguja", "Naggajjau", "Aippiq", "Pingatsiq", "Sitammiq", "Tallirmiq", "Sivataarvik" ],
                    namesAbbr: [ "Nat", "Nag", "Aip", "Pi", "Sit", "Tal", "Siv" ],
                    namesShort: [ "N", "N", "A", "P", "S", "T", "S" ]
                },
                months: {
                    names: [ "Jaannuari", "Viivvuari", "Maatsi", "Iipuri", "Mai", "Juuni", "Julai", "Aaggiisi", "Sitipiri", "Utupiri", "Nuvipiri", "Tisipiri", "" ],
                    namesAbbr: [ "Jan", "Viv", "Mas", "Ipu", "Mai", "Jun", "Jul", "Agi", "Sii", "Uut", "Nuv", "Tis", "" ]
                },
                patterns: {
                    d: "d/MM/yyyy",
                    D: "ddd, MMMM dd,yyyy",
                    f: "ddd, MMMM dd,yyyy h:mm tt",
                    F: "ddd, MMMM dd,yyyy h:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("tzm-Latn-DZ", "default", {
        name: "tzm-Latn-DZ",
        englishName: "Tamazight (Latin, Algeria)",
        nativeName: "Tamazight (Djazaïr)",
        language: "tzm-Latn",
        numberFormat: {
            pattern: [ "n-" ],
            ",": ".",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                symbol: "DZD"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 6,
                days: {
                    names: [ "Acer", "Arime", "Aram", "Ahad", "Amhadh", "Sem", "Sedh" ],
                    namesAbbr: [ "Ace", "Ari", "Ara", "Aha", "Amh", "Sem", "Sed" ],
                    namesShort: [ "Ac", "Ar", "Ar", "Ah", "Am", "Se", "Se" ]
                },
                months: {
                    names: [ "Yenayer", "Furar", "Maghres", "Yebrir", "Mayu", "Yunyu", "Yulyu", "Ghuct", "Cutenber", "Ktuber", "Wambir", "Dujanbir", "" ],
                    namesAbbr: [ "Yen", "Fur", "Mag", "Yeb", "May", "Yun", "Yul", "Ghu", "Cut", "Ktu", "Wam", "Duj", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("quz-EC", "default", {
        name: "quz-EC",
        englishName: "Quechua (Ecuador)",
        nativeName: "runasimi (Ecuador)",
        language: "quz",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "intichaw", "killachaw", "atipachaw", "quyllurchaw", "Ch' askachaw", "Illapachaw", "k'uychichaw" ],
                    namesAbbr: [ "int", "kil", "ati", "quy", "Ch'", "Ill", "k'u" ],
                    namesShort: [ "d", "k", "a", "m", "h", "b", "k" ]
                },
                months: {
                    names: [ "Qulla puquy", "Hatun puquy", "Pauqar waray", "ayriwa", "Aymuray", "Inti raymi", "Anta Sitwa", "Qhapaq Sitwa", "Uma raymi", "Kantaray", "Ayamarq'a", "Kapaq Raymi", "" ],
                    namesAbbr: [ "Qul", "Hat", "Pau", "ayr", "Aym", "Int", "Ant", "Qha", "Uma", "Kan", "Aya", "Kap", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-EG", "default", {
        name: "ar-EG",
        englishName: "Arabic (Egypt)",
        nativeName: "العربية (مصر)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ج.م.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-HK", "default", {
        name: "zh-HK",
        englishName: "Chinese (Traditional, Hong Kong S.A.R.)",
        nativeName: "中文(香港特別行政區)",
        language: "zh-CHT",
        numberFormat: {
            NaN: "非數字",
            negativeInfinity: "負無窮大",
            positiveInfinity: "正無窮大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                symbol: "HK$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("de-AT", "default", {
        name: "de-AT",
        englishName: "German (Austria)",
        nativeName: "Deutsch (Österreich)",
        language: "de",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Jänner", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jän", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, dd. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, dd. MMMM yyyy HH:mm",
                    F: "dddd, dd. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-AU", "default", {
        name: "en-AU",
        englishName: "English (Australia)",
        nativeName: "English (Australia)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                patterns: {
                    d: "d/MM/yyyy",
                    D: "dddd, d MMMM yyyy",
                    f: "dddd, d MMMM yyyy h:mm tt",
                    F: "dddd, d MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-ES", "default", {
        name: "es-ES",
        englishName: "Spanish (Spain, International Sort)",
        nativeName: "Español (España, alfabetización internacional)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-CA", "default", {
        name: "fr-CA",
        englishName: "French (Canada)",
        nativeName: "français (Canada)",
        language: "fr",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "(n $)", "n $" ],
                ",": " ",
                ".": ","
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d MMMM yyyy HH:mm",
                    F: "d MMMM yyyy HH:mm:ss",
                    M: "d MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Cyrl-CS", "default", {
        name: "sr-Cyrl-CS",
        englishName: "Serbian (Cyrillic, Serbia and Montenegro (Former))",
        nativeName: "српски (Србија и Црна Гора (Претходно))",
        language: "sr-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Дин."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недеља", "понедељак", "уторак", "среда", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "не", "по", "ут", "ср", "че", "пе", "су" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("se-FI", "default", {
        name: "se-FI",
        englishName: "Sami, Northern (Finland)",
        nativeName: "davvisámegiella (Suopma)",
        language: "se",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sotnabeaivi", "vuossárga", "maŋŋebárga", "gaskavahkku", "duorastat", "bearjadat", "lávvardat" ],
                    namesAbbr: [ "sotn", "vuos", "maŋ", "gask", "duor", "bear", "láv" ],
                    namesShort: [ "s", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ođđajagemánnu", "guovvamánnu", "njukčamánnu", "cuoŋománnu", "miessemánnu", "geassemánnu", "suoidnemánnu", "borgemánnu", "čakčamánnu", "golggotmánnu", "skábmamánnu", "juovlamánnu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđajagimánu", "guovvamánu", "njukčamánu", "cuoŋománu", "miessemánu", "geassemánu", "suoidnemánu", "borgemánu", "čakčamánu", "golggotmánu", "skábmamánu", "juovlamánu", "" ],
                    namesAbbr: [ "ođđj", "guov", "njuk", "cuo", "mies", "geas", "suoi", "borg", "čakč", "golg", "skáb", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "MMMM d'. b. 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d'. b. 'yyyy H:mm",
                    F: "MMMM d'. b. 'yyyy H:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("quz-PE", "default", {
        name: "quz-PE",
        englishName: "Quechua (Peru)",
        nativeName: "runasimi (Piruw)",
        language: "quz",
        numberFormat: {
            percent: {
                pattern: [ "-%n", "%n" ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                symbol: "S/."
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "intichaw", "killachaw", "atipachaw", "quyllurchaw", "Ch' askachaw", "Illapachaw", "k'uychichaw" ],
                    namesAbbr: [ "int", "kil", "ati", "quy", "Ch'", "Ill", "k'u" ],
                    namesShort: [ "d", "k", "a", "m", "h", "b", "k" ]
                },
                months: {
                    names: [ "Qulla puquy", "Hatun puquy", "Pauqar waray", "ayriwa", "Aymuray", "Inti raymi", "Anta Sitwa", "Qhapaq Sitwa", "Uma raymi", "Kantaray", "Ayamarq'a", "Kapaq Raymi", "" ],
                    namesAbbr: [ "Qul", "Hat", "Pau", "ayr", "Aym", "Int", "Ant", "Qha", "Uma", "Kan", "Aya", "Kap", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-LY", "default", {
        name: "ar-LY",
        englishName: "Arabic (Libya)",
        nativeName: "العربية (ليبيا)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$n" ],
                decimals: 3,
                symbol: "د.ل.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-SG", "default", {
        name: "zh-SG",
        englishName: "Chinese (Simplified, Singapore)",
        nativeName: "中文(新加坡)",
        language: "zh-CHS",
        numberFormat: {
            percent: {
                pattern: [ "-n%", "n%" ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "yyyy'年'M'月'd'日'",
                    t: "tt h:mm",
                    T: "tt h:mm:ss",
                    f: "yyyy'年'M'月'd'日' tt h:mm",
                    F: "yyyy'年'M'月'd'日' tt h:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("de-LU", "default", {
        name: "de-LU",
        englishName: "German (Luxembourg)",
        nativeName: "Deutsch (Luxemburg)",
        language: "de",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-CA", "default", {
        name: "en-CA",
        englishName: "English (Canada)",
        nativeName: "English (Canada)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "MMMM-dd-yy",
                    f: "MMMM-dd-yy h:mm tt",
                    F: "MMMM-dd-yy h:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-GT", "default", {
        name: "es-GT",
        englishName: "Spanish (Guatemala)",
        nativeName: "Español (Guatemala)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                symbol: "Q"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-CH", "default", {
        name: "fr-CH",
        englishName: "French (Switzerland)",
        nativeName: "français (Suisse)",
        language: "fr",
        numberFormat: {
            ",": "'",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "fr."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("hr-BA", "default", {
        name: "hr-BA",
        englishName: "Croatian (Latin, Bosnia and Herzegovina)",
        nativeName: "hrvatski (Bosna i Hercegovina)",
        language: "hr",
        numberFormat: {
            pattern: [ "- n" ],
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "KM"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "siječanj", "veljača", "ožujak", "travanj", "svibanj", "lipanj", "srpanj", "kolovoz", "rujan", "listopad", "studeni", "prosinac", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                monthsGenitive: {
                    names: [ "siječnja", "veljače", "ožujka", "travnja", "svibnja", "lipnja", "srpnja", "kolovoza", "rujna", "listopada", "studenog", "prosinca", "" ],
                    namesAbbr: [ "sij", "vlj", "ožu", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy.",
                    D: "d. MMMM yyyy.",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy. H:mm",
                    F: "d. MMMM yyyy. H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("smj-NO", "default", {
        name: "smj-NO",
        englishName: "Sami, Lule (Norway)",
        nativeName: "julevusámegiella (Vuodna)",
        language: "smj",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "sådnåbiejvve", "mánnodahka", "dijstahka", "gasskavahkko", "duorastahka", "bierjjedahka", "lávvodahka" ],
                    namesAbbr: [ "såd", "mán", "dis", "gas", "duor", "bier", "láv" ],
                    namesShort: [ "s", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ådåjakmánno", "guovvamánno", "sjnjuktjamánno", "vuoratjismánno", "moarmesmánno", "biehtsemánno", "sjnjilltjamánno", "bårggemánno", "ragátmánno", "gålgådismánno", "basádismánno", "javllamánno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                monthsGenitive: {
                    names: [ "ådåjakmáno", "guovvamáno", "sjnjuktjamáno", "vuoratjismáno", "moarmesmáno", "biehtsemáno", "sjnjilltjamáno", "bårggemáno", "ragátmáno", "gålgådismáno", "basádismáno", "javllamáno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-DZ", "default", {
        name: "ar-DZ",
        englishName: "Arabic (Algeria)",
        nativeName: "العربية (الجزائر)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "د.ج.‏"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MM/yyyy H:mm",
                    F: "dd/MM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MMMM/yyyy H:mm",
                    F: "dd/MMMM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-MO", "default", {
        name: "zh-MO",
        englishName: "Chinese (Traditional, Macao S.A.R.)",
        nativeName: "中文(澳門特別行政區)",
        language: "zh-CHT",
        numberFormat: {
            NaN: "非數字",
            negativeInfinity: "負無窮大",
            positiveInfinity: "正無窮大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                symbol: "MOP"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("de-LI", "default", {
        name: "de-LI",
        englishName: "German (Liechtenstein)",
        nativeName: "Deutsch (Liechtenstein)",
        language: "de",
        numberFormat: {
            ",": "'",
            NaN: "n. def.",
            negativeInfinity: "-unendlich",
            positiveInfinity: "+unendlich",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": "'"
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": "'",
                symbol: "CHF"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
                    namesAbbr: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
                    namesShort: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ]
                },
                months: {
                    names: [ "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n. Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "dddd, d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd, d. MMMM yyyy HH:mm",
                    F: "dddd, d. MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-NZ", "default", {
        name: "en-NZ",
        englishName: "English (New Zealand)",
        nativeName: "English (New Zealand)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                patterns: {
                    d: "d/MM/yyyy",
                    D: "dddd, d MMMM yyyy",
                    f: "dddd, d MMMM yyyy h:mm tt",
                    F: "dddd, d MMMM yyyy h:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-CR", "default", {
        name: "es-CR",
        englishName: "Spanish (Costa Rica)",
        nativeName: "Español (Costa Rica)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                ",": ".",
                ".": ",",
                symbol: "₡"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-LU", "default", {
        name: "fr-LU",
        englishName: "French (Luxembourg)",
        nativeName: "français (Luxembourg)",
        language: "fr",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bs-Latn-BA", "default", {
        name: "bs-Latn-BA",
        englishName: "Bosnian (Latin, Bosnia and Herzegovina)",
        nativeName: "bosanski (Bosna i Hercegovina)",
        language: "bs-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "KM"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "juni", "juli", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("smj-SE", "default", {
        name: "smj-SE",
        englishName: "Sami, Lule (Sweden)",
        nativeName: "julevusámegiella (Svierik)",
        language: "smj",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ájllek", "mánnodahka", "dijstahka", "gasskavahkko", "duorastahka", "bierjjedahka", "lávvodahka" ],
                    namesAbbr: [ "ájl", "mán", "dis", "gas", "duor", "bier", "láv" ],
                    namesShort: [ "á", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ådåjakmánno", "guovvamánno", "sjnjuktjamánno", "vuoratjismánno", "moarmesmánno", "biehtsemánno", "sjnjilltjamánno", "bårggemánno", "ragátmánno", "gålgådismánno", "basádismánno", "javllamánno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                monthsGenitive: {
                    names: [ "ådåjakmáno", "guovvamáno", "sjnjuktjamáno", "vuoratjismáno", "moarmesmáno", "biehtsemáno", "sjnjilltjamáno", "bårggemáno", "ragátmáno", "gålgådismáno", "basádismáno", "javllamáno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-MA", "default", {
        name: "ar-MA",
        englishName: "Arabic (Morocco)",
        nativeName: "العربية (المملكة المغربية)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "د.م.‏"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "ماي", "يونيو", "يوليوز", "غشت", "شتنبر", "أكتوبر", "نونبر", "دجنبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "ماي", "يونيو", "يوليوز", "غشت", "شتنبر", "أكتوبر", "نونبر", "دجنبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MM/yyyy H:mm",
                    F: "dd/MM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MMMM/yyyy H:mm",
                    F: "dd/MMMM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-IE", "default", {
        name: "en-IE",
        englishName: "English (Ireland)",
        nativeName: "English (Ireland)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-PA", "default", {
        name: "es-PA",
        englishName: "Spanish (Panama)",
        nativeName: "Español (Panamá)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "($ n)", "$ n" ],
                symbol: "B/."
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("fr-MC", "default", {
        name: "fr-MC",
        englishName: "French (Monaco)",
        nativeName: "français (Principauté de Monaco)",
        language: "fr",
        numberFormat: {
            ",": " ",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd d MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dddd d MMMM yyyy HH:mm",
                    F: "dddd d MMMM yyyy HH:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Latn-BA", "default", {
        name: "sr-Latn-BA",
        englishName: "Serbian (Latin, Bosnia and Herzegovina)",
        nativeName: "srpski (Bosna i Hercegovina)",
        language: "sr-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "KM"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sma-NO", "default", {
        name: "sma-NO",
        englishName: "Sami, Southern (Norway)",
        nativeName: "åarjelsaemiengiele (Nöörje)",
        language: "sma",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-%n", "%n" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "aejlege", "måanta", "dæjsta", "gaskevåhkoe", "duarsta", "bearjadahke", "laavvardahke" ],
                    namesAbbr: [ "aej", "måa", "dæj", "gask", "duar", "bearj", "laav" ],
                    namesShort: [ "a", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "tsïengele", "goevte", "njoktje", "voerhtje", "suehpede", "ruffie", "snjaltje", "mïetske", "skïerede", "golke", "rahka", "goeve", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                monthsGenitive: {
                    names: [ "tsïengelen", "goevten", "njoktjen", "voerhtjen", "suehpeden", "ruffien", "snjaltjen", "mïetsken", "skïereden", "golken", "rahkan", "goeven", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-TN", "default", {
        name: "ar-TN",
        englishName: "Arabic (Tunisia)",
        nativeName: "العربية (تونس)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$ n" ],
                decimals: 3,
                symbol: "د.ت.‏"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MM/yyyy H:mm",
                    F: "dd/MM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd/MMMM/yyyy H:mm",
                    F: "dd/MMMM/yyyy H:mm:ss",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, MMMM dd, yyyy H:mm",
                    F: "dddd, MMMM dd, yyyy H:mm:ss"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-ZA", "default", {
        name: "en-ZA",
        englishName: "English (South Africa)",
        nativeName: "English (South Africa)",
        numberFormat: {
            ",": " ",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " "
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "R"
            }
        },
        calendars: {
            standard: {
                patterns: {
                    d: "yyyy/MM/dd",
                    D: "dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM yyyy hh:mm tt",
                    F: "dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-DO", "default", {
        name: "es-DO",
        englishName: "Spanish (Dominican Republic)",
        nativeName: "Español (República Dominicana)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                symbol: "RD$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Cyrl-BA", "default", {
        name: "sr-Cyrl-BA",
        englishName: "Serbian (Cyrillic, Bosnia and Herzegovina)",
        nativeName: "српски (Босна и Херцеговина)",
        language: "sr-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "КМ"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недеља", "понедељак", "уторак", "среда", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "н", "п", "у", "с", "ч", "п", "с" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sma-SE", "default", {
        name: "sma-SE",
        englishName: "Sami, Southern (Sweden)",
        nativeName: "åarjelsaemiengiele (Sveerje)",
        language: "sma",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "aejlege", "måanta", "dæjsta", "gaskevåhkoe", "duarsta", "bearjadahke", "laavvardahke" ],
                    namesAbbr: [ "aej", "måa", "dæj", "gask", "duar", "bearj", "laav" ],
                    namesShort: [ "a", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "tsïengele", "goevte", "njoktje", "voerhtje", "suehpede", "ruffie", "snjaltje", "mïetske", "skïerede", "golke", "rahka", "goeve", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                monthsGenitive: {
                    names: [ "tsïengelen", "goevten", "njoktjen", "voerhtjen", "suehpeden", "ruffien", "snjaltjen", "mïetsken", "skïereden", "golken", "rahkan", "goeven", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-OM", "default", {
        name: "ar-OM",
        englishName: "Arabic (Oman)",
        nativeName: "العربية (عمان)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                decimals: 3,
                symbol: "ر.ع.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-JM", "default", {
        name: "en-JM",
        englishName: "English (Jamaica)",
        nativeName: "English (Jamaica)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ],
                symbol: "J$"
            }
        },
        calendars: {
            standard: {
                patterns: {
                    d: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-VE", "default", {
        name: "es-VE",
        englishName: "Spanish (Bolivarian Republic of Venezuela)",
        nativeName: "Español (Republica Bolivariana de Venezuela)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "Bs. F."
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bs-Cyrl-BA", "default", {
        name: "bs-Cyrl-BA",
        englishName: "Bosnian (Cyrillic, Bosnia and Herzegovina)",
        nativeName: "босански (Босна и Херцеговина)",
        language: "bs-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "КМ"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недјеља", "понедјељак", "уторак", "сриједа", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "н", "п", "у", "с", "ч", "п", "с" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("sms-FI", "default", {
        name: "sms-FI",
        englishName: "Sami, Skolt (Finland)",
        nativeName: "sääm´ǩiõll (Lää´ddjânnam)",
        language: "sms",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pâ´sspei´vv", "vuõssargg", "mââibargg", "seärad", "nelljdpei´vv", "piâtnâc", "sue´vet" ],
                    namesAbbr: [ "pâ", "vu", "mâ", "se", "ne", "pi", "su" ],
                    namesShort: [ "p", "v", "m", "s", "n", "p", "s" ]
                },
                months: {
                    names: [ "ođđee´jjmään", "tä´lvvmään", "pâ´zzlâšttammään", "njuhččmään", "vue´ssmään", "ǩie´ssmään", "suei´nnmään", "på´rǧǧmään", "čõhččmään", "kålggmään", "skamm´mään", "rosttovmään", "" ],
                    namesAbbr: [ "ođjm", "tä´lvv", "pâzl", "njuh", "vue", "ǩie", "suei", "på´r", "čõh", "kålg", "ska", "rost", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđee´jjmannu", "tä´lvvmannu", "pâ´zzlâšttammannu", "njuhččmannu", "vue´ssmannu", "ǩie´ssmannu", "suei´nnmannu", "på´rǧǧmannu", "čõhččmannu", "kålggmannu", "skamm´mannu", "rosttovmannu", "" ],
                    namesAbbr: [ "ođjm", "tä´lvv", "pâzl", "njuh", "vue", "ǩie", "suei", "på´r", "čõh", "kålg", "ska", "rost", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "MMMM d'. p. 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d'. p. 'yyyy H:mm",
                    F: "MMMM d'. p. 'yyyy H:mm:ss",
                    M: "MMMM d'. p. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-YE", "default", {
        name: "ar-YE",
        englishName: "Arabic (Yemen)",
        nativeName: "العربية (اليمن)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ر.ي.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-029", "default", {
        name: "en-029",
        englishName: "English (Caribbean)",
        nativeName: "English (Caribbean)",
        numberFormat: {
            currency: {
                pattern: [ "-$n", "$n" ]
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                patterns: {
                    d: "MM/dd/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-CO", "default", {
        name: "es-CO",
        englishName: "Spanish (Colombia)",
        nativeName: "Español (Colombia)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Latn-RS", "default", {
        name: "sr-Latn-RS",
        englishName: "Serbian (Latin, Serbia)",
        nativeName: "srpski (Srbija)",
        language: "sr-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Din."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("smn-FI", "default", {
        name: "smn-FI",
        englishName: "Sami, Inari (Finland)",
        nativeName: "sämikielâ (Suomâ)",
        language: "smn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pasepeivi", "vuossargâ", "majebargâ", "koskokko", "tuorâstâh", "vástuppeivi", "lávárdâh" ],
                    namesAbbr: [ "pa", "vu", "ma", "ko", "tu", "vá", "lá" ],
                    namesShort: [ "p", "v", "m", "k", "t", "v", "l" ]
                },
                months: {
                    names: [ "uđđâivemáánu", "kuovâmáánu", "njuhčâmáánu", "cuáŋuimáánu", "vyesimáánu", "kesimáánu", "syeinimáánu", "porgemáánu", "čohčâmáánu", "roovvâdmáánu", "skammâmáánu", "juovlâmáánu", "" ],
                    namesAbbr: [ "uđiv", "kuov", "njuh", "cuoŋ", "vyes", "kesi", "syei", "porg", "čoh", "roov", "ska", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "MMMM d'. p. 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d'. p. 'yyyy H:mm",
                    F: "MMMM d'. p. 'yyyy H:mm:ss",
                    M: "MMMM d'. p. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-SY", "default", {
        name: "ar-SY",
        englishName: "Arabic (Syria)",
        nativeName: "العربية (سوريا)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ل.س.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-BZ", "default", {
        name: "en-BZ",
        englishName: "English (Belize)",
        nativeName: "English (Belize)",
        numberFormat: {
            currency: {
                groupSizes: [ 3, 0 ],
                symbol: "BZ$"
            }
        },
        calendars: {
            standard: {
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd MMMM yyyy hh:mm tt",
                    F: "dddd, dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-PE", "default", {
        name: "es-PE",
        englishName: "Spanish (Peru)",
        nativeName: "Español (Perú)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "$ -n", "$ n" ],
                symbol: "S/."
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Cyrl-RS", "default", {
        name: "sr-Cyrl-RS",
        englishName: "Serbian (Cyrillic, Serbia)",
        nativeName: "српски (Србија)",
        language: "sr-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Дин."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недеља", "понедељак", "уторак", "среда", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "не", "по", "ут", "ср", "че", "пе", "су" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-JO", "default", {
        name: "ar-JO",
        englishName: "Arabic (Jordan)",
        nativeName: "العربية (الأردن)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$ n" ],
                decimals: 3,
                symbol: "د.ا.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-TT", "default", {
        name: "en-TT",
        englishName: "English (Trinidad and Tobago)",
        nativeName: "English (Trinidad y Tobago)",
        numberFormat: {
            currency: {
                groupSizes: [ 3, 0 ],
                symbol: "TT$"
            }
        },
        calendars: {
            standard: {
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd MMMM yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd MMMM yyyy hh:mm tt",
                    F: "dddd, dd MMMM yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-AR", "default", {
        name: "es-AR",
        englishName: "Spanish (Argentina)",
        nativeName: "Español (Argentina)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "$-n", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Latn-ME", "default", {
        name: "sr-Latn-ME",
        englishName: "Serbian (Latin, Montenegro)",
        nativeName: "srpski (Crna Gora)",
        language: "sr-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-LB", "default", {
        name: "ar-LB",
        englishName: "Arabic (Lebanon)",
        nativeName: "العربية (لبنان)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ل.ل.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 1,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_TransliteratedEnglish: {
                name: "Gregorian_TransliteratedEnglish",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "أ", "ا", "ث", "أ", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 1,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-ZW", "default", {
        name: "en-ZW",
        englishName: "English (Zimbabwe)",
        nativeName: "English (Zimbabwe)",
        numberFormat: {
            currency: {
                symbol: "Z$"
            }
        }
    });
    Globalize.addCultureInfo("es-EC", "default", {
        name: "es-EC",
        englishName: "Spanish (Ecuador)",
        nativeName: "Español (Ecuador)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Cyrl-ME", "default", {
        name: "sr-Cyrl-ME",
        englishName: "Serbian (Cyrillic, Montenegro)",
        nativeName: "српски (Црна Гора)",
        language: "sr-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недеља", "понедељак", "уторак", "среда", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "не", "по", "ут", "ср", "че", "пе", "су" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-KW", "default", {
        name: "ar-KW",
        englishName: "Arabic (Kuwait)",
        nativeName: "العربية (الكويت)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$ n" ],
                decimals: 3,
                symbol: "د.ك.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-PH", "default", {
        name: "en-PH",
        englishName: "English (Republic of the Philippines)",
        nativeName: "English (Philippines)",
        numberFormat: {
            currency: {
                symbol: "Php"
            }
        }
    });
    Globalize.addCultureInfo("es-CL", "default", {
        name: "es-CL",
        englishName: "Spanish (Chile)",
        nativeName: "Español (Chile)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-$ n", "$ n" ],
                ",": ".",
                ".": ","
            }
        },
        calendars: {
            standard: {
                "/": "-",
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dddd, dd' de 'MMMM' de 'yyyy H:mm",
                    F: "dddd, dd' de 'MMMM' de 'yyyy H:mm:ss",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-AE", "default", {
        name: "ar-AE",
        englishName: "Arabic (U.A.E.)",
        nativeName: "العربية (الإمارات العربية المتحدة)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "د.إ.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-UY", "default", {
        name: "es-UY",
        englishName: "Spanish (Uruguay)",
        nativeName: "Español (Uruguay)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "$U"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-BH", "default", {
        name: "ar-BH",
        englishName: "Arabic (Bahrain)",
        nativeName: "العربية (البحرين)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            decimals: 3,
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            percent: {
                decimals: 3
            },
            currency: {
                pattern: [ "$n-", "$ n" ],
                decimals: 3,
                symbol: "د.ب.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "اغسطس", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-PY", "default", {
        name: "es-PY",
        englishName: "Spanish (Paraguay)",
        nativeName: "Español (Paraguay)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "Gs"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("ar-QA", "default", {
        name: "ar-QA",
        englishName: "Arabic (Qatar)",
        nativeName: "العربية (قطر)",
        language: "ar",
        isRTL: true,
        numberFormat: {
            pattern: [ "n-" ],
            NaN: "ليس برقم",
            negativeInfinity: "-لا نهاية",
            positiveInfinity: "+لا نهاية",
            currency: {
                pattern: [ "$n-", "$ n" ],
                symbol: "ر.ق.‏"
            }
        },
        calendars: {
            standard: {
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dd MMMM, yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd MMMM, yyyy hh:mm tt",
                    F: "dd MMMM, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            UmAlQura: {
                name: "UmAlQura",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MMMM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MMMM/yyyy hh:mm tt",
                    F: "dd/MMMM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    _yearInfo: [ [ 746, -21987072e5 ], [ 1769, -21681216e5 ], [ 3794, -21374496e5 ], [ 3748, -21067776e5 ], [ 3402, -2076192e6 ], [ 2710, -20456064e5 ], [ 1334, -20150208e5 ], [ 2741, -19844352e5 ], [ 3498, -19537632e5 ], [ 2980, -19230912e5 ], [ 2889, -18925056e5 ], [ 2707, -186192e7 ], [ 1323, -18313344e5 ], [ 2647, -18007488e5 ], [ 1206, -17700768e5 ], [ 2741, -17394912e5 ], [ 1450, -17088192e5 ], [ 3413, -16782336e5 ], [ 3370, -16475616e5 ], [ 2646, -1616976e6 ], [ 1198, -15863904e5 ], [ 2397, -15558048e5 ], [ 748, -15251328e5 ], [ 1749, -14945472e5 ], [ 1706, -14638752e5 ], [ 1365, -14332896e5 ], [ 1195, -1402704e6 ], [ 2395, -13721184e5 ], [ 698, -13414464e5 ], [ 1397, -13108608e5 ], [ 2994, -12801888e5 ], [ 1892, -12495168e5 ], [ 1865, -12189312e5 ], [ 1621, -11883456e5 ], [ 683, -115776e7 ], [ 1371, -11271744e5 ], [ 2778, -10965024e5 ], [ 1748, -10658304e5 ], [ 3785, -10352448e5 ], [ 3474, -10045728e5 ], [ 3365, -9739872e5 ], [ 2637, -9434016e5 ], [ 685, -912816e6 ], [ 1389, -8822304e5 ], [ 2922, -8515584e5 ], [ 2898, -8208864e5 ], [ 2725, -7903008e5 ], [ 2635, -7597152e5 ], [ 1175, -7291296e5 ], [ 2359, -698544e6 ], [ 694, -667872e6 ], [ 1397, -6372864e5 ], [ 3434, -6066144e5 ], [ 3410, -5759424e5 ], [ 2710, -5453568e5 ], [ 2349, -5147712e5 ], [ 605, -4841856e5 ], [ 1245, -4536e8 ], [ 2778, -422928e6 ], [ 1492, -392256e6 ], [ 3497, -3616704e5 ], [ 3410, -3309984e5 ], [ 2730, -3004128e5 ], [ 1238, -2698272e5 ], [ 2486, -2392416e5 ], [ 884, -2085696e5 ], [ 1897, -177984e6 ], [ 1874, -147312e6 ], [ 1701, -1167264e5 ], [ 1355, -861408e5 ], [ 2731, -555552e5 ], [ 1370, -248832e5 ], [ 2773, 57024e5 ], [ 3538, 363744e5 ], [ 3492, 670464e5 ], [ 3401, 97632e6 ], [ 2709, 1282176e5 ], [ 1325, 1588032e5 ], [ 2653, 1893888e5 ], [ 1370, 2200608e5 ], [ 2773, 2506464e5 ], [ 1706, 2813184e5 ], [ 1685, 311904e6 ], [ 1323, 3424896e5 ], [ 2647, 3730752e5 ], [ 1198, 4037472e5 ], [ 2422, 4343328e5 ], [ 1388, 4650048e5 ], [ 2901, 4955904e5 ], [ 2730, 5262624e5 ], [ 2645, 556848e6 ], [ 1197, 5874336e5 ], [ 2397, 6180192e5 ], [ 730, 6486912e5 ], [ 1497, 6792768e5 ], [ 3506, 7099488e5 ], [ 2980, 7406208e5 ], [ 2890, 7712064e5 ], [ 2645, 801792e6 ], [ 693, 8323776e5 ], [ 1397, 8629632e5 ], [ 2922, 8936352e5 ], [ 3026, 9243072e5 ], [ 3012, 9549792e5 ], [ 2953, 9855648e5 ], [ 2709, 10161504e5 ], [ 1325, 1046736e6 ], [ 1453, 10773216e5 ], [ 2922, 11079936e5 ], [ 1748, 11386656e5 ], [ 3529, 11692512e5 ], [ 3474, 11999232e5 ], [ 2726, 12305088e5 ], [ 2390, 12610944e5 ], [ 686, 129168e7 ], [ 1389, 13222656e5 ], [ 874, 13529376e5 ], [ 2901, 13835232e5 ], [ 2730, 14141952e5 ], [ 2381, 14447808e5 ], [ 1181, 14753664e5 ], [ 2397, 1505952e6 ], [ 698, 1536624e6 ], [ 1461, 15672096e5 ], [ 1450, 15978816e5 ], [ 3413, 16284672e5 ], [ 2714, 16591392e5 ], [ 2350, 16897248e5 ], [ 622, 17203104e5 ], [ 1373, 1750896e6 ], [ 2778, 1781568e6 ], [ 1748, 181224e7 ], [ 1701, 18428256e5 ], [ 0, 18734112e5 ] ],
                    minDate: -21987072e5,
                    maxDate: 1873411199999,
                    toGregorian: function(hyear, hmonth, hday) {
                        var days = hday - 1, gyear = hyear - 1318;
                        if (gyear < 0 || gyear >= this._yearInfo.length) return null;
                        var info = this._yearInfo[gyear], gdate = new Date(info[1]), monthLength = info[0];
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        for (var i = 0; i < hmonth; i++) {
                            days += 29 + (monthLength & 1);
                            monthLength = monthLength >> 1;
                        }
                        gdate.setDate(gdate.getDate() + days);
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        var ticks = gdate - gdate.getTimezoneOffset() * 6e4;
                        if (ticks < this.minDate || ticks > this.maxDate) return null;
                        var hyear = 0, hmonth = 1;
                        while (ticks > this._yearInfo[++hyear][1]) {}
                        if (ticks !== this._yearInfo[hyear][1]) {
                            hyear--;
                        }
                        var info = this._yearInfo[hyear], days = Math.floor((ticks - info[1]) / 864e5), monthLength = info[0];
                        hyear += 1318;
                        var daysInMonth = 29 + (monthLength & 1);
                        while (days >= daysInMonth) {
                            days -= daysInMonth;
                            monthLength = monthLength >> 1;
                            daysInMonth = 29 + (monthLength & 1);
                            hmonth++;
                        }
                        return [ hyear, hmonth - 1, days + 1 ];
                    }
                }
            },
            Hijri: {
                name: "Hijri",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ],
                    namesAbbr: [ "محرم", "صفر", "ربيع الأول", "ربيع الثاني", "جمادى الأولى", "جمادى الثانية", "رجب", "شعبان", "رمضان", "شوال", "ذو القعدة", "ذو الحجة", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "بعد الهجرة",
                    start: null,
                    offset: 0
                } ],
                twoDigitYearMax: 1451,
                patterns: {
                    d: "dd/MM/yy",
                    D: "dd/MM/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dd/MM/yyyy hh:mm tt",
                    F: "dd/MM/yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                },
                convert: {
                    ticks1970: 621355968e5,
                    monthDays: [ 0, 30, 59, 89, 118, 148, 177, 207, 236, 266, 295, 325, 355 ],
                    minDate: -425216736e5,
                    maxDate: 0xe677d21fdbff,
                    hijriAdjustment: 0,
                    toGregorian: function(hyear, hmonth, hday) {
                        var daysSinceJan0101 = this.daysToYear(hyear) + this.monthDays[hmonth] + hday - 1 - this.hijriAdjustment;
                        var gdate = new Date(daysSinceJan0101 * 864e5 - this.ticks1970);
                        gdate.setMinutes(gdate.getMinutes() + gdate.getTimezoneOffset());
                        return gdate;
                    },
                    fromGregorian: function(gdate) {
                        if (gdate < this.minDate || gdate > this.maxDate) return null;
                        var ticks = this.ticks1970 + (gdate - 0) - gdate.getTimezoneOffset() * 6e4, daysSinceJan0101 = Math.floor(ticks / 864e5) + 1 + this.hijriAdjustment;
                        var hday, hmonth, hyear = Math.floor((daysSinceJan0101 - 227013) * 30 / 10631) + 1, absDays = this.daysToYear(hyear), daysInYear = this.isLeapYear(hyear) ? 355 : 354;
                        if (daysSinceJan0101 < absDays) {
                            hyear--;
                            absDays -= daysInYear;
                        } else if (daysSinceJan0101 === absDays) {
                            hyear--;
                            absDays = this.daysToYear(hyear);
                        } else {
                            if (daysSinceJan0101 > absDays + daysInYear) {
                                absDays += daysInYear;
                                hyear++;
                            }
                        }
                        hmonth = 0;
                        var daysIntoYear = daysSinceJan0101 - absDays;
                        while (hmonth <= 11 && daysIntoYear > this.monthDays[hmonth]) {
                            hmonth++;
                        }
                        hmonth--;
                        hday = daysIntoYear - this.monthDays[hmonth];
                        return [ hyear, hmonth, hday ];
                    },
                    daysToYear: function(year) {
                        var yearsToYear30 = Math.floor((year - 1) / 30) * 30, yearsInto30 = year - yearsToYear30 - 1, days = Math.floor(yearsToYear30 * 10631 / 30) + 227013;
                        while (yearsInto30 > 0) {
                            days += this.isLeapYear(yearsInto30) ? 355 : 354;
                            yearsInto30--;
                        }
                        return days;
                    },
                    isLeapYear: function(year) {
                        return (year * 11 + 14) % 30 < 11;
                    }
                }
            },
            Gregorian_MiddleEastFrench: {
                name: "Gregorian_MiddleEastFrench",
                firstDay: 6,
                days: {
                    names: [ "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi" ],
                    namesAbbr: [ "dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam." ],
                    namesShort: [ "di", "lu", "ma", "me", "je", "ve", "sa" ]
                },
                months: {
                    names: [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre", "" ],
                    namesAbbr: [ "janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc.", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "ap. J.-C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt",
                    M: "dd MMMM"
                }
            },
            Gregorian_Arabic: {
                name: "Gregorian_Arabic",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ],
                    namesAbbr: [ "كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            },
            Gregorian_TransliteratedFrench: {
                name: "Gregorian_TransliteratedFrench",
                firstDay: 6,
                days: {
                    names: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesAbbr: [ "الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت" ],
                    namesShort: [ "ح", "ن", "ث", "ر", "خ", "ج", "س" ]
                },
                months: {
                    names: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ],
                    namesAbbr: [ "جانفييه", "فيفرييه", "مارس", "أفريل", "مي", "جوان", "جوييه", "أوت", "سبتمبر", "اكتوبر", "نوفمبر", "ديسمبر", "" ]
                },
                AM: [ "ص", "ص", "ص" ],
                PM: [ "م", "م", "م" ],
                eras: [ {
                    name: "م",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "MM/dd/yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, MMMM dd, yyyy hh:mm tt",
                    F: "dddd, MMMM dd, yyyy hh:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-IN", "default", {
        name: "en-IN",
        englishName: "English (India)",
        nativeName: "English (India)",
        numberFormat: {
            groupSizes: [ 3, 2 ],
            percent: {
                groupSizes: [ 3, 2 ]
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 2 ],
                symbol: "Rs."
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "dd MMMM yyyy HH:mm",
                    F: "dd MMMM yyyy HH:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-BO", "default", {
        name: "es-BO",
        englishName: "Spanish (Bolivia)",
        nativeName: "Español (Bolivia)",
        language: "es",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "($ n)", "$ n" ],
                ",": ".",
                ".": ",",
                symbol: "$b"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-MY", "default", {
        name: "en-MY",
        englishName: "English (Malaysia)",
        nativeName: "English (Malaysia)",
        numberFormat: {
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                symbol: "RM"
            }
        },
        calendars: {
            standard: {
                days: {
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd, d MMMM, yyyy",
                    f: "dddd, d MMMM, yyyy h:mm tt",
                    F: "dddd, d MMMM, yyyy h:mm:ss tt",
                    M: "d MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-SV", "default", {
        name: "es-SV",
        englishName: "Spanish (El Salvador)",
        nativeName: "Español (El Salvador)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("en-SG", "default", {
        name: "en-SG",
        englishName: "English (Singapore)",
        nativeName: "English (Singapore)",
        numberFormat: {
            percent: {
                pattern: [ "-n%", "n%" ]
            }
        },
        calendars: {
            standard: {
                days: {
                    namesShort: [ "S", "M", "T", "W", "T", "F", "S" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd, d MMMM, yyyy",
                    f: "dddd, d MMMM, yyyy h:mm tt",
                    F: "dddd, d MMMM, yyyy h:mm:ss tt",
                    M: "d MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-HN", "default", {
        name: "es-HN",
        englishName: "Spanish (Honduras)",
        nativeName: "Español (Honduras)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "$ -n", "$ n" ],
                groupSizes: [ 3, 0 ],
                symbol: "L."
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-NI", "default", {
        name: "es-NI",
        englishName: "Spanish (Nicaragua)",
        nativeName: "Español (Nicaragua)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "($ n)", "$ n" ],
                groupSizes: [ 3, 0 ],
                symbol: "C$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-PR", "default", {
        name: "es-PR",
        englishName: "Spanish (Puerto Rico)",
        nativeName: "Español (Puerto Rico)",
        language: "es",
        numberFormat: {
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            currency: {
                pattern: [ "($ n)", "$ n" ],
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sá" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                AM: [ "a.m.", "a.m.", "A.M." ],
                PM: [ "p.m.", "p.m.", "P.M." ],
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "dd/MM/yyyy",
                    D: "dddd, dd' de 'MMMM' de 'yyyy",
                    t: "hh:mm tt",
                    T: "hh:mm:ss tt",
                    f: "dddd, dd' de 'MMMM' de 'yyyy hh:mm tt",
                    F: "dddd, dd' de 'MMMM' de 'yyyy hh:mm:ss tt",
                    M: "dd MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("es-US", "default", {
        name: "es-US",
        englishName: "Spanish (United States)",
        nativeName: "Español (Estados Unidos)",
        language: "es",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "NeuN",
            negativeInfinity: "-Infinito",
            positiveInfinity: "Infinito",
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado" ],
                    namesAbbr: [ "dom", "lun", "mar", "mié", "jue", "vie", "sáb" ],
                    namesShort: [ "do", "lu", "ma", "mi", "ju", "vi", "sa" ]
                },
                months: {
                    names: [ "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre", "" ],
                    namesAbbr: [ "ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic", "" ]
                },
                eras: [ {
                    name: "d.C.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    M: "dd' de 'MMMM",
                    Y: "MMMM' de 'yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bs-Cyrl", "default", {
        name: "bs-Cyrl",
        englishName: "Bosnian (Cyrillic)",
        nativeName: "босански",
        language: "bs-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "КМ"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недјеља", "понедјељак", "уторак", "сриједа", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "н", "п", "у", "с", "ч", "п", "с" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("bs-Latn", "default", {
        name: "bs-Latn",
        englishName: "Bosnian (Latin)",
        nativeName: "bosanski",
        language: "bs-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "KM"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "juni", "juli", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Cyrl", "default", {
        name: "sr-Cyrl",
        englishName: "Serbian (Cyrillic)",
        nativeName: "српски",
        language: "sr-Cyrl",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-бесконачност",
            positiveInfinity: "+бесконачност",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Дин."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "недеља", "понедељак", "уторак", "среда", "четвртак", "петак", "субота" ],
                    namesAbbr: [ "нед", "пон", "уто", "сре", "чет", "пет", "суб" ],
                    namesShort: [ "не", "по", "ут", "ср", "че", "пе", "су" ]
                },
                months: {
                    names: [ "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар", "" ],
                    namesAbbr: [ "јан", "феб", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "нов", "дец", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "н.е.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr-Latn", "default", {
        name: "sr-Latn",
        englishName: "Serbian (Latin)",
        nativeName: "srpski",
        language: "sr-Latn",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Din."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("smn", "default", {
        name: "smn",
        englishName: "Sami (Inari)",
        nativeName: "sämikielâ",
        language: "smn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pasepeivi", "vuossargâ", "majebargâ", "koskokko", "tuorâstâh", "vástuppeivi", "lávárdâh" ],
                    namesAbbr: [ "pa", "vu", "ma", "ko", "tu", "vá", "lá" ],
                    namesShort: [ "p", "v", "m", "k", "t", "v", "l" ]
                },
                months: {
                    names: [ "uđđâivemáánu", "kuovâmáánu", "njuhčâmáánu", "cuáŋuimáánu", "vyesimáánu", "kesimáánu", "syeinimáánu", "porgemáánu", "čohčâmáánu", "roovvâdmáánu", "skammâmáánu", "juovlâmáánu", "" ],
                    namesAbbr: [ "uđiv", "kuov", "njuh", "cuoŋ", "vyes", "kesi", "syei", "porg", "čoh", "roov", "ska", "juov", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "MMMM d'. p. 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d'. p. 'yyyy H:mm",
                    F: "MMMM d'. p. 'yyyy H:mm:ss",
                    M: "MMMM d'. p. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("az-Cyrl", "default", {
        name: "az-Cyrl",
        englishName: "Azeri (Cyrillic)",
        nativeName: "Азәрбајҹан дили",
        language: "az-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "ман."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Базар", "Базар ертәси", "Чәршәнбә ахшамы", "Чәршәнбә", "Ҹүмә ахшамы", "Ҹүмә", "Шәнбә" ],
                    namesAbbr: [ "Б", "Бе", "Ча", "Ч", "Ҹа", "Ҹ", "Ш" ],
                    namesShort: [ "Б", "Бе", "Ча", "Ч", "Ҹа", "Ҹ", "Ш" ]
                },
                months: {
                    names: [ "Јанвар", "Феврал", "Март", "Апрел", "Мај", "Ијун", "Ијул", "Август", "Сентјабр", "Октјабр", "Нојабр", "Декабр", "" ],
                    namesAbbr: [ "Јан", "Фев", "Мар", "Апр", "Мај", "Ијун", "Ијул", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "јанвар", "феврал", "март", "апрел", "мај", "ијун", "ијул", "август", "сентјабр", "октјабр", "нојабр", "декабр", "" ],
                    namesAbbr: [ "Јан", "Фев", "Мар", "Апр", "мая", "ијун", "ијул", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sms", "default", {
        name: "sms",
        englishName: "Sami (Skolt)",
        nativeName: "sääm´ǩiõll",
        language: "sms",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "pâ´sspei´vv", "vuõssargg", "mââibargg", "seärad", "nelljdpei´vv", "piâtnâc", "sue´vet" ],
                    namesAbbr: [ "pâ", "vu", "mâ", "se", "ne", "pi", "su" ],
                    namesShort: [ "p", "v", "m", "s", "n", "p", "s" ]
                },
                months: {
                    names: [ "ođđee´jjmään", "tä´lvvmään", "pâ´zzlâšttammään", "njuhččmään", "vue´ssmään", "ǩie´ssmään", "suei´nnmään", "på´rǧǧmään", "čõhččmään", "kålggmään", "skamm´mään", "rosttovmään", "" ],
                    namesAbbr: [ "ođjm", "tä´lvv", "pâzl", "njuh", "vue", "ǩie", "suei", "på´r", "čõh", "kålg", "ska", "rost", "" ]
                },
                monthsGenitive: {
                    names: [ "ođđee´jjmannu", "tä´lvvmannu", "pâ´zzlâšttammannu", "njuhččmannu", "vue´ssmannu", "ǩie´ssmannu", "suei´nnmannu", "på´rǧǧmannu", "čõhččmannu", "kålggmannu", "skamm´mannu", "rosttovmannu", "" ],
                    namesAbbr: [ "ođjm", "tä´lvv", "pâzl", "njuh", "vue", "ǩie", "suei", "på´r", "čõh", "kålg", "ska", "rost", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "MMMM d'. p. 'yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "MMMM d'. p. 'yyyy H:mm",
                    F: "MMMM d'. p. 'yyyy H:mm:ss",
                    M: "MMMM d'. p. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh", "default", {
        name: "zh",
        englishName: "Chinese",
        nativeName: "中文",
        language: "zh",
        numberFormat: {
            NaN: "非数字",
            negativeInfinity: "负无穷大",
            positiveInfinity: "正无穷大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("nn", "default", {
        name: "nn",
        englishName: "Norwegian (Nynorsk)",
        nativeName: "norsk (nynorsk)",
        language: "nn",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "søndag", "måndag", "tysdag", "onsdag", "torsdag", "fredag", "laurdag" ],
                    namesAbbr: [ "sø", "må", "ty", "on", "to", "fr", "la" ],
                    namesShort: [ "sø", "må", "ty", "on", "to", "fr", "la" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("bs", "default", {
        name: "bs",
        englishName: "Bosnian",
        nativeName: "bosanski",
        language: "bs",
        numberFormat: {
            ",": ".",
            ".": ",",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "KM"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sri", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "juni", "juli", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("az-Latn", "default", {
        name: "az-Latn",
        englishName: "Azeri (Latin)",
        nativeName: "Azərbaycan­ılı",
        language: "az-Latn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "man."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə" ],
                    namesAbbr: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ],
                    namesShort: [ "B", "Be", "Ça", "Ç", "Ca", "C", "Ş" ]
                },
                months: {
                    names: [ "Yanvar", "Fevral", "Mart", "Aprel", "May", "İyun", "İyul", "Avgust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                monthsGenitive: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avg", "Sen", "Okt", "Noy", "Dek", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    M: "d MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sma", "default", {
        name: "sma",
        englishName: "Sami (Southern)",
        nativeName: "åarjelsaemiengiele",
        language: "sma",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "aejlege", "måanta", "dæjsta", "gaskevåhkoe", "duarsta", "bearjadahke", "laavvardahke" ],
                    namesAbbr: [ "aej", "måa", "dæj", "gask", "duar", "bearj", "laav" ],
                    namesShort: [ "a", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "tsïengele", "goevte", "njoktje", "voerhtje", "suehpede", "ruffie", "snjaltje", "mïetske", "skïerede", "golke", "rahka", "goeve", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                monthsGenitive: {
                    names: [ "tsïengelen", "goevten", "njoktjen", "voerhtjen", "suehpeden", "ruffien", "snjaltjen", "mïetsken", "skïereden", "golken", "rahkan", "goeven", "" ],
                    namesAbbr: [ "tsïen", "goevt", "njok", "voer", "sueh", "ruff", "snja", "mïet", "skïer", "golk", "rahk", "goev", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("uz-Cyrl", "default", {
        name: "uz-Cyrl",
        englishName: "Uzbek (Cyrillic)",
        nativeName: "Ўзбек",
        language: "uz-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": " ",
                ".": ",",
                symbol: "сўм"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "якшанба", "душанба", "сешанба", "чоршанба", "пайшанба", "жума", "шанба" ],
                    namesAbbr: [ "якш", "дш", "сш", "чш", "пш", "ж", "ш" ],
                    namesShort: [ "я", "д", "с", "ч", "п", "ж", "ш" ]
                },
                months: {
                    names: [ "Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "январ", "феврал", "март", "апрел", "май", "июн", "июл", "август", "сентябр", "октябр", "ноябр", "декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "мая", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "yyyy 'йил' d-MMMM",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'йил' d-MMMM HH:mm",
                    F: "yyyy 'йил' d-MMMM HH:mm:ss",
                    M: "d-MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mn-Cyrl", "default", {
        name: "mn-Cyrl",
        englishName: "Mongolian (Cyrillic)",
        nativeName: "Монгол хэл",
        language: "mn-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n$", "n$" ],
                ",": " ",
                ".": ",",
                symbol: "₮"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "Ням", "Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба" ],
                    namesAbbr: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ],
                    namesShort: [ "Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя" ]
                },
                months: {
                    names: [ "1 дүгээр сар", "2 дугаар сар", "3 дугаар сар", "4 дүгээр сар", "5 дугаар сар", "6 дугаар сар", "7 дугаар сар", "8 дугаар сар", "9 дүгээр сар", "10 дугаар сар", "11 дүгээр сар", "12 дугаар сар", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                monthsGenitive: {
                    names: [ "1 дүгээр сарын", "2 дугаар сарын", "3 дугаар сарын", "4 дүгээр сарын", "5 дугаар сарын", "6 дугаар сарын", "7 дугаар сарын", "8 дугаар сарын", "9 дүгээр сарын", "10 дугаар сарын", "11 дүгээр сарын", "12 дугаар сарын", "" ],
                    namesAbbr: [ "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yy.MM.dd",
                    D: "yyyy 'оны' MMMM d",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy 'оны' MMMM d H:mm",
                    F: "yyyy 'оны' MMMM d H:mm:ss",
                    M: "d MMMM",
                    Y: "yyyy 'он' MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("iu-Cans", "default", {
        name: "iu-Cans",
        englishName: "Inuktitut (Syllabics)",
        nativeName: "ᐃᓄᒃᑎᑐᑦ",
        language: "iu-Cans",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "ᓈᑦᑏᖑᔭ", "ᓇᒡᒐᔾᔭᐅ", "ᐊᐃᑉᐱᖅ", "ᐱᖓᑦᓯᖅ", "ᓯᑕᒻᒥᖅ", "ᑕᓪᓕᕐᒥᖅ", "ᓯᕙᑖᕐᕕᒃ" ],
                    namesAbbr: [ "ᓈᑦᑏ", "ᓇᒡᒐ", "ᐊᐃᑉᐱ", "ᐱᖓᑦᓯ", "ᓯᑕ", "ᑕᓪᓕ", "ᓯᕙᑖᕐᕕᒃ" ],
                    namesShort: [ "ᓈ", "ᓇ", "ᐊ", "ᐱ", "ᓯ", "ᑕ", "ᓯ" ]
                },
                months: {
                    names: [ "ᔮᓐᓄᐊᕆ", "ᕖᕝᕗᐊᕆ", "ᒫᑦᓯ", "ᐄᐳᕆ", "ᒪᐃ", "ᔫᓂ", "ᔪᓚᐃ", "ᐋᒡᒌᓯ", "ᓯᑎᐱᕆ", "ᐅᑐᐱᕆ", "ᓄᕕᐱᕆ", "ᑎᓯᐱᕆ", "" ],
                    namesAbbr: [ "ᔮᓐᓄ", "ᕖᕝᕗ", "ᒫᑦᓯ", "ᐄᐳᕆ", "ᒪᐃ", "ᔫᓂ", "ᔪᓚᐃ", "ᐋᒡᒌ", "ᓯᑎᐱ", "ᐅᑐᐱ", "ᓄᕕᐱ", "ᑎᓯᐱ", "" ]
                },
                patterns: {
                    d: "d/M/yyyy",
                    D: "dddd,MMMM dd,yyyy",
                    f: "dddd,MMMM dd,yyyy h:mm tt",
                    F: "dddd,MMMM dd,yyyy h:mm:ss tt",
                    Y: "MMMM,yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-Hant", "default", {
        name: "zh-Hant",
        englishName: "Chinese (Traditional)",
        nativeName: "中文(繁體)",
        language: "zh-Hant",
        numberFormat: {
            NaN: "非數字",
            negativeInfinity: "負無窮大",
            positiveInfinity: "正無窮大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                symbol: "HK$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("nb", "default", {
        name: "nb",
        englishName: "Norwegian (Bokmål)",
        nativeName: "norsk (bokmål)",
        language: "nb",
        numberFormat: {
            ",": " ",
            ".": ",",
            negativeInfinity: "-INF",
            positiveInfinity: "INF",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "$ -n", "$ n" ],
                ",": " ",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag" ],
                    namesAbbr: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ],
                    namesShort: [ "sø", "ma", "ti", "on", "to", "fr", "lø" ]
                },
                months: {
                    names: [ "januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yyyy",
                    D: "d. MMMM yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "d. MMMM yyyy HH:mm",
                    F: "d. MMMM yyyy HH:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("sr", "default", {
        name: "sr",
        englishName: "Serbian",
        nativeName: "srpski",
        language: "sr",
        numberFormat: {
            ",": ".",
            ".": ",",
            negativeInfinity: "-beskonačnost",
            positiveInfinity: "+beskonačnost",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "Din."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                firstDay: 1,
                days: {
                    names: [ "nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota" ],
                    namesAbbr: [ "ned", "pon", "uto", "sre", "čet", "pet", "sub" ],
                    namesShort: [ "ne", "po", "ut", "sr", "če", "pe", "su" ]
                },
                months: {
                    names: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar", "" ],
                    namesAbbr: [ "jan", "feb", "mar", "apr", "maj", "jun", "jul", "avg", "sep", "okt", "nov", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "n.e.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d.M.yyyy",
                    D: "d. MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d. MMMM yyyy H:mm",
                    F: "d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("tg-Cyrl", "default", {
        name: "tg-Cyrl",
        englishName: "Tajik (Cyrillic)",
        nativeName: "Тоҷикӣ",
        language: "tg-Cyrl",
        numberFormat: {
            ",": " ",
            ".": ",",
            groupSizes: [ 3, 0 ],
            negativeInfinity: "-бесконечность",
            positiveInfinity: "бесконечность",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                groupSizes: [ 3, 0 ],
                ",": " ",
                ".": ";",
                symbol: "т.р."
            }
        },
        calendars: {
            standard: {
                "/": ".",
                days: {
                    names: [ "Яш", "Душанбе", "Сешанбе", "Чоршанбе", "Панҷшанбе", "Ҷумъа", "Шанбе" ],
                    namesAbbr: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ],
                    namesShort: [ "Яш", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн" ]
                },
                months: {
                    names: [ "Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                monthsGenitive: {
                    names: [ "январи", "феврали", "марти", "апрели", "маи", "июни", "июли", "августи", "сентябри", "октябри", "ноябри", "декабри", "" ],
                    namesAbbr: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd.MM.yy",
                    D: "d MMMM yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "d MMMM yyyy H:mm",
                    F: "d MMMM yyyy H:mm:ss",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("dsb", "default", {
        name: "dsb",
        englishName: "Lower Sorbian",
        nativeName: "dolnoserbšćina",
        language: "dsb",
        numberFormat: {
            ",": ".",
            ".": ",",
            NaN: "njedefinowane",
            negativeInfinity: "-njekońcne",
            positiveInfinity: "+njekońcne",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "€"
            }
        },
        calendars: {
            standard: {
                "/": ". ",
                firstDay: 1,
                days: {
                    names: [ "njeźela", "ponjeźele", "wałtora", "srjoda", "stwortk", "pětk", "sobota" ],
                    namesAbbr: [ "nje", "pon", "wał", "srj", "stw", "pět", "sob" ],
                    namesShort: [ "n", "p", "w", "s", "s", "p", "s" ]
                },
                months: {
                    names: [ "januar", "februar", "měrc", "apryl", "maj", "junij", "julij", "awgust", "september", "oktober", "nowember", "december", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "maj", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                monthsGenitive: {
                    names: [ "januara", "februara", "měrca", "apryla", "maja", "junija", "julija", "awgusta", "septembra", "oktobra", "nowembra", "decembra", "" ],
                    namesAbbr: [ "jan", "feb", "měr", "apr", "maj", "jun", "jul", "awg", "sep", "okt", "now", "dec", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "po Chr.",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d. M. yyyy",
                    D: "dddd, 'dnja' d. MMMM yyyy",
                    t: "H.mm 'goź.'",
                    T: "H:mm:ss",
                    f: "dddd, 'dnja' d. MMMM yyyy H.mm 'goź.'",
                    F: "dddd, 'dnja' d. MMMM yyyy H:mm:ss",
                    M: "d. MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("smj", "default", {
        name: "smj",
        englishName: "Sami (Lule)",
        nativeName: "julevusámegiella",
        language: "smj",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                ",": ".",
                ".": ",",
                symbol: "kr"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 1,
                days: {
                    names: [ "ájllek", "mánnodahka", "dijstahka", "gasskavahkko", "duorastahka", "bierjjedahka", "lávvodahka" ],
                    namesAbbr: [ "ájl", "mán", "dis", "gas", "duor", "bier", "láv" ],
                    namesShort: [ "á", "m", "d", "g", "d", "b", "l" ]
                },
                months: {
                    names: [ "ådåjakmánno", "guovvamánno", "sjnjuktjamánno", "vuoratjismánno", "moarmesmánno", "biehtsemánno", "sjnjilltjamánno", "bårggemánno", "ragátmánno", "gålgådismánno", "basádismánno", "javllamánno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                monthsGenitive: {
                    names: [ "ådåjakmáno", "guovvamáno", "sjnjuktjamáno", "vuoratjismáno", "moarmesmáno", "biehtsemáno", "sjnjilltjamáno", "bårggemáno", "ragátmáno", "gålgådismáno", "basádismáno", "javllamáno", "" ],
                    namesAbbr: [ "ådåj", "guov", "snju", "vuor", "moar", "bieh", "snji", "bårg", "ragá", "gålg", "basá", "javl", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "yyyy-MM-dd",
                    D: "MMMM d'. b. 'yyyy",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "MMMM d'. b. 'yyyy HH:mm",
                    F: "MMMM d'. b. 'yyyy HH:mm:ss",
                    M: "MMMM d'. b. '",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("uz-Latn", "default", {
        name: "uz-Latn",
        englishName: "Uzbek (Latin)",
        nativeName: "U'zbek",
        language: "uz-Latn",
        numberFormat: {
            ",": " ",
            ".": ",",
            percent: {
                pattern: [ "-n%", "n%" ],
                ",": " ",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                decimals: 0,
                ",": " ",
                ".": ",",
                symbol: "so'm"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "yakshanba", "dushanba", "seshanba", "chorshanba", "payshanba", "juma", "shanba" ],
                    namesAbbr: [ "yak.", "dsh.", "sesh.", "chr.", "psh.", "jm.", "sh." ],
                    namesShort: [ "ya", "d", "s", "ch", "p", "j", "sh" ]
                },
                months: {
                    names: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ],
                    namesAbbr: [ "yanvar", "fevral", "mart", "aprel", "may", "iyun", "iyul", "avgust", "sentyabr", "oktyabr", "noyabr", "dekabr", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd/MM yyyy",
                    D: "yyyy 'yil' d-MMMM",
                    t: "HH:mm",
                    T: "HH:mm:ss",
                    f: "yyyy 'yil' d-MMMM HH:mm",
                    F: "yyyy 'yil' d-MMMM HH:mm:ss",
                    M: "d-MMMM",
                    Y: "MMMM yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("mn-Mong", "default", {
        name: "mn-Mong",
        englishName: "Mongolian (Traditional Mongolian)",
        nativeName: "ᠮᠤᠨᠭᠭᠤᠯ ᠬᠡᠯᠡ",
        language: "mn-Mong",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            NaN: "ᠲᠤᠭᠠᠠ ᠪᠤᠰᠤ",
            negativeInfinity: "ᠰᠦᠬᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠡᠬᠡ",
            positiveInfinity: "ᠡᠶ᠋ᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠠᠬᠡ",
            percent: {
                pattern: [ "-n%", "n%" ],
                groupSizes: [ 3, 0 ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                groupSizes: [ 3, 0 ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                firstDay: 1,
                days: {
                    names: [ "ᠭᠠᠷᠠᠭ ᠤᠨ ᠡᠳᠦᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠨᠢᠭᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠬᠣᠶᠠᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠭᠤᠷᠪᠠᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠳᠥᠷᠪᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠲᠠᠪᠤᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠵᠢᠷᠭᠤᠭᠠᠨ" ],
                    namesAbbr: [ "ᠭᠠᠷᠠᠭ ᠤᠨ ᠡᠳᠦᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠨᠢᠭᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠬᠣᠶᠠᠷ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠭᠤᠷᠪᠠᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠳᠥᠷᠪᠡᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠲᠠᠪᠤᠨ", "ᠭᠠᠷᠠᠭ ᠤᠨ ᠵᠢᠷᠭᠤᠭᠠᠨ" ],
                    namesShort: [ "ᠡ‍", "ᠨᠢ‍", "ᠬᠣ‍", "ᠭᠤ‍", "ᠳᠥ‍", "ᠲᠠ‍", "ᠵᠢ‍" ]
                },
                months: {
                    names: [ "ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠭᠤᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠦᠷᠪᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠠᠪᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠵᠢᠷᠭᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠤᠯᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠨᠠᠢᠮᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠶᠢᠰᠦᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "" ],
                    namesAbbr: [ "ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠭᠤᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠦᠷᠪᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠠᠪᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠵᠢᠷᠭᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠲᠤᠯᠤᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠨᠠᠢᠮᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠶᠢᠰᠦᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠨᠢᠭᠡᠳᠦᠭᠡᠷ ᠰᠠᠷ᠎ᠠ", "ᠠᠷᠪᠠᠨ ᠬᠤᠶ᠋ᠠᠳᠤᠭᠠᠷ ᠰᠠᠷ᠎ᠠ", "" ]
                },
                AM: null,
                PM: null,
                eras: [ {
                    name: "ᠣᠨ ᠲᠣᠭᠠᠯᠠᠯ ᠤᠨ",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ' H:mm",
                    F: "yyyy'ᠣᠨ ᠤ᠋' M'ᠰᠠᠷ᠎ᠠ  ᠢᠢᠨ 'd' ᠤ᠋ ᠡᠳᠦᠷ' H:mm:ss",
                    M: "M'ᠰᠠᠷ᠎ᠠ' d'ᠡᠳᠦᠷ'",
                    Y: "yyyy'ᠣᠨ' M'ᠰᠠᠷ᠎ᠠ'"
                }
            }
        }
    });
    Globalize.addCultureInfo("iu-Latn", "default", {
        name: "iu-Latn",
        englishName: "Inuktitut (Latin)",
        nativeName: "Inuktitut",
        language: "iu-Latn",
        numberFormat: {
            groupSizes: [ 3, 0 ],
            percent: {
                groupSizes: [ 3, 0 ]
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Naattiinguja", "Naggajjau", "Aippiq", "Pingatsiq", "Sitammiq", "Tallirmiq", "Sivataarvik" ],
                    namesAbbr: [ "Nat", "Nag", "Aip", "Pi", "Sit", "Tal", "Siv" ],
                    namesShort: [ "N", "N", "A", "P", "S", "T", "S" ]
                },
                months: {
                    names: [ "Jaannuari", "Viivvuari", "Maatsi", "Iipuri", "Mai", "Juuni", "Julai", "Aaggiisi", "Sitipiri", "Utupiri", "Nuvipiri", "Tisipiri", "" ],
                    namesAbbr: [ "Jan", "Viv", "Mas", "Ipu", "Mai", "Jun", "Jul", "Agi", "Sii", "Uut", "Nuv", "Tis", "" ]
                },
                patterns: {
                    d: "d/MM/yyyy",
                    D: "ddd, MMMM dd,yyyy",
                    f: "ddd, MMMM dd,yyyy h:mm tt",
                    F: "ddd, MMMM dd,yyyy h:mm:ss tt"
                }
            }
        }
    });
    Globalize.addCultureInfo("tzm-Latn", "default", {
        name: "tzm-Latn",
        englishName: "Tamazight (Latin)",
        nativeName: "Tamazight",
        language: "tzm-Latn",
        numberFormat: {
            pattern: [ "n-" ],
            ",": ".",
            ".": ",",
            NaN: "Non Numérique",
            negativeInfinity: "-Infini",
            positiveInfinity: "+Infini",
            percent: {
                ",": ".",
                ".": ","
            },
            currency: {
                pattern: [ "-n $", "n $" ],
                symbol: "DZD"
            }
        },
        calendars: {
            standard: {
                "/": "-",
                firstDay: 6,
                days: {
                    names: [ "Acer", "Arime", "Aram", "Ahad", "Amhadh", "Sem", "Sedh" ],
                    namesAbbr: [ "Ace", "Ari", "Ara", "Aha", "Amh", "Sem", "Sed" ],
                    namesShort: [ "Ac", "Ar", "Ar", "Ah", "Am", "Se", "Se" ]
                },
                months: {
                    names: [ "Yenayer", "Furar", "Maghres", "Yebrir", "Mayu", "Yunyu", "Yulyu", "Ghuct", "Cutenber", "Ktuber", "Wambir", "Dujanbir", "" ],
                    namesAbbr: [ "Yen", "Fur", "Mag", "Yeb", "May", "Yun", "Yul", "Ghu", "Cut", "Ktu", "Wam", "Duj", "" ]
                },
                AM: null,
                PM: null,
                patterns: {
                    d: "dd-MM-yyyy",
                    D: "dd MMMM, yyyy",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "dd MMMM, yyyy H:mm",
                    F: "dd MMMM, yyyy H:mm:ss",
                    M: "dd MMMM"
                }
            }
        }
    });
    Globalize.addCultureInfo("ha-Latn", "default", {
        name: "ha-Latn",
        englishName: "Hausa (Latin)",
        nativeName: "Hausa",
        language: "ha-Latn",
        numberFormat: {
            currency: {
                pattern: [ "$-n", "$ n" ],
                symbol: "N"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "Lahadi", "Litinin", "Talata", "Laraba", "Alhamis", "Juma'a", "Asabar" ],
                    namesAbbr: [ "Lah", "Lit", "Tal", "Lar", "Alh", "Jum", "Asa" ],
                    namesShort: [ "L", "L", "T", "L", "A", "J", "A" ]
                },
                months: {
                    names: [ "Januwaru", "Febreru", "Maris", "Afrilu", "Mayu", "Yuni", "Yuli", "Agusta", "Satumba", "Oktocba", "Nuwamba", "Disamba", "" ],
                    namesAbbr: [ "Jan", "Feb", "Mar", "Afr", "May", "Yun", "Yul", "Agu", "Sat", "Okt", "Nuw", "Dis", "" ]
                },
                AM: [ "Safe", "safe", "SAFE" ],
                PM: [ "Yamma", "yamma", "YAMMA" ],
                eras: [ {
                    name: "AD",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-CHS", "default", {
        name: "zh-CHS",
        englishName: "Chinese (Simplified) Legacy",
        nativeName: "中文(简体) 旧版",
        language: "zh-CHS",
        numberFormat: {
            NaN: "非数字",
            negativeInfinity: "负无穷大",
            positiveInfinity: "正无穷大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                pattern: [ "$-n", "$n" ],
                symbol: "¥"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "周日", "周一", "周二", "周三", "周四", "周五", "周六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "yyyy/M/d",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
    Globalize.addCultureInfo("zh-CHT", "default", {
        name: "zh-CHT",
        englishName: "Chinese (Traditional) Legacy",
        nativeName: "中文(繁體) 舊版",
        language: "zh-CHT",
        numberFormat: {
            NaN: "非數字",
            negativeInfinity: "負無窮大",
            positiveInfinity: "正無窮大",
            percent: {
                pattern: [ "-n%", "n%" ]
            },
            currency: {
                symbol: "HK$"
            }
        },
        calendars: {
            standard: {
                days: {
                    names: [ "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" ],
                    namesAbbr: [ "週日", "週一", "週二", "週三", "週四", "週五", "週六" ],
                    namesShort: [ "日", "一", "二", "三", "四", "五", "六" ]
                },
                months: {
                    names: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ],
                    namesAbbr: [ "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月", "" ]
                },
                AM: [ "上午", "上午", "上午" ],
                PM: [ "下午", "下午", "下午" ],
                eras: [ {
                    name: "公元",
                    start: null,
                    offset: 0
                } ],
                patterns: {
                    d: "d/M/yyyy",
                    D: "yyyy'年'M'月'd'日'",
                    t: "H:mm",
                    T: "H:mm:ss",
                    f: "yyyy'年'M'月'd'日' H:mm",
                    F: "yyyy'年'M'月'd'日' H:mm:ss",
                    M: "M'月'd'日'",
                    Y: "yyyy'年'M'月'"
                }
            }
        }
    });
})(this);

if (typeof DEBUG === "undefined") DEBUG = true;

var powerbi;

(function(powerbi) {
    var UnknownClientError = function() {
        function UnknownClientError() {}
        Object.defineProperty(UnknownClientError.prototype, "code", {
            get: function() {
                return "UnknownClientError";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnknownClientError.prototype, "ignorable", {
            get: function() {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        UnknownClientError.prototype.getDetails = function(resourceProvider) {
            var details = {
                message: resourceProvider.get("ClientError_UnknownClientErrorValue"),
                additionalErrorInfo: [ {
                    errorInfoKey: resourceProvider.get("ClientError_UnknownClientErrorKey"),
                    errorInfoValue: resourceProvider.get("ClientError_UnknownClientErrorValue")
                } ]
            };
            return details;
        };
        return UnknownClientError;
    }();
    powerbi.UnknownClientError = UnknownClientError;
    var IgnorableClientError = function() {
        function IgnorableClientError() {}
        Object.defineProperty(IgnorableClientError.prototype, "code", {
            get: function() {
                return "IgnorableClientError";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgnorableClientError.prototype, "ignorable", {
            get: function() {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        IgnorableClientError.prototype.getDetails = function(resourceProvider) {
            var details = {
                message: "",
                additionalErrorInfo: []
            };
            return details;
        };
        return IgnorableClientError;
    }();
    powerbi.IgnorableClientError = IgnorableClientError;
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var ArrayExtensions;
    (function(ArrayExtensions) {
        function intersect(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                if (other.indexOf(target[i]) !== -1) {
                    result.push(target[i]);
                }
            }
            return result;
        }
        ArrayExtensions.intersect = intersect;
        function diff(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                var value = target[i];
                if (other.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.diff = diff;
        function distinct(source) {
            var result = [];
            for (var i = 0, len = source.length; i < len; i++) {
                var value = source[i];
                if (result.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.distinct = distinct;
        function union(target, source) {
            for (var i = 0, len = source.length; i < len; ++i) {
                unionSingle(target, source[i]);
            }
        }
        ArrayExtensions.union = union;
        function unionSingle(target, value) {
            if (target.indexOf(value) < 0) {
                target.push(value);
            }
        }
        ArrayExtensions.unionSingle = unionSingle;
        function range(source, startIndex, endIndex) {
            debug.assert(startIndex >= 0 && startIndex < source.length, "startIndex is out of range.");
            debug.assert(endIndex >= 0 && endIndex < source.length, "endIndex is out of range.");
            var result = [];
            for (var i = startIndex; i <= endIndex; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.range = range;
        function take(source, count) {
            debug.assert(count >= 0, "Count is negative.");
            debug.assert(count <= source.length, "Count is too large.");
            var result = [];
            for (var i = 0; i < count; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.take = take;
        function sequenceEqual(left, right, comparison) {
            debug.assertValue(comparison, "comparison");
            if (left === right) {
                return true;
            }
            if (!!left !== !!right) {
                return false;
            }
            var len = left.length;
            if (len !== right.length) {
                return false;
            }
            var i = 0;
            while (i < len && comparison(left[i], right[i])) {
                ++i;
            }
            return i === len;
        }
        ArrayExtensions.sequenceEqual = sequenceEqual;
        function emptyToNull(array) {
            if (array && array.length === 0) {
                return null;
            }
            return array;
        }
        ArrayExtensions.emptyToNull = emptyToNull;
        function indexOf(array, predicate) {
            debug.assertValue(array, "array");
            debug.assertValue(predicate, "predicate");
            for (var i = 0, len = array.length; i < len; ++i) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        }
        ArrayExtensions.indexOf = indexOf;
        function createWithId() {
            return extendWithId([]);
        }
        ArrayExtensions.createWithId = createWithId;
        function extendWithId(array) {
            debug.assertValue(array, "array");
            var extended = array;
            extended.withId = withId;
            return extended;
        }
        ArrayExtensions.extendWithId = extendWithId;
        function findWithId(array, id) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.id === id) return item;
            }
        }
        ArrayExtensions.findWithId = findWithId;
        function withId(id) {
            return ArrayExtensions.findWithId(this, id);
        }
        function createWithName() {
            return extendWithName([]);
        }
        ArrayExtensions.createWithName = createWithName;
        function extendWithName(array) {
            debug.assertValue(array, "array");
            var extended = array;
            extended.withName = withName;
            return extended;
        }
        ArrayExtensions.extendWithName = extendWithName;
        function findItemWithName(array, name) {
            var index = indexWithName(array, name);
            if (index >= 0) return array[index];
        }
        ArrayExtensions.findItemWithName = findItemWithName;
        function indexWithName(array, name) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.name === name) return i;
            }
            return -1;
        }
        ArrayExtensions.indexWithName = indexWithName;
        function withName(name) {
            var array = this;
            return findItemWithName(array, name);
        }
        function clear(array) {
            array.length = 0;
        }
        ArrayExtensions.clear = clear;
        function isUndefinedOrEmpty(array) {
            if (!array || array.length === 0) {
                return true;
            }
            return false;
        }
        ArrayExtensions.isUndefinedOrEmpty = isUndefinedOrEmpty;
    })(ArrayExtensions = jsCommon.ArrayExtensions || (jsCommon.ArrayExtensions = {}));
})(jsCommon || (jsCommon = {}));

var InJs;

(function(InJs) {
    var DomFactory;
    (function(DomFactory) {
        function div() {
            return $("<div/>");
        }
        DomFactory.div = div;
        function span() {
            return $("<span/>");
        }
        DomFactory.span = span;
        function checkbox() {
            return $('<input type="checkbox"/>');
        }
        DomFactory.checkbox = checkbox;
        function ul() {
            return $("<ul/>");
        }
        DomFactory.ul = ul;
        function li() {
            return $("<li/>");
        }
        DomFactory.li = li;
        function button() {
            return $('<input type="button"/>');
        }
        DomFactory.button = button;
        function select() {
            return $("<select/>");
        }
        DomFactory.select = select;
        function textBox() {
            return $('<input type="text"/>');
        }
        DomFactory.textBox = textBox;
        function img() {
            return $("<img/>");
        }
        DomFactory.img = img;
        function iframe() {
            return $("<iframe/>");
        }
        DomFactory.iframe = iframe;
    })(DomFactory = InJs.DomFactory || (InJs.DomFactory = {}));
})(InJs || (InJs = {}));

var jsCommon;

(function(jsCommon) {
    var ModalDialog = function() {
        function ModalDialog(dialogHost) {
            var _this = this;
            this._modalContainer = null;
            this._modalDialogElement = null;
            this._dialogTitle = null;
            this._dialogCloseButton = null;
            this._dialogContent = null;
            this._dialogActions = null;
            this._messageQueue = new Array();
            this._isReady = false;
            this._messageCurrentlyShown = false;
            $(document).ready(function() {
                _this._modalContainer = $(ModalDialog.ModalDialogHtml);
                _this._modalDialogElement = _this._modalContainer.find(ModalDialog.modalDialogClassSelector);
                _this._dialogTitle = _this._modalContainer.find(ModalDialog.dialogTitleClassSelector);
                _this._dialogCloseButton = _this._modalContainer.find(ModalDialog.dialogCloseIconClassSelector);
                _this._dialogContent = _this._modalContainer.find(ModalDialog.dialogContentClassSelector);
                _this._dialogActions = _this._modalContainer.find(ModalDialog.dialogActionsClassSelector);
                var that = _this;
                _this._dialogCloseButton.on(jsCommon.DOMConstants.mouseClickEventName, function() {
                    return that.hideDialog();
                });
                if (!dialogHost) {
                    var containerHost = $(ModalDialog.modalDialogContainerHostClassSelector);
                    if (containerHost && containerHost.length > 0) containerHost.remove();
                    containerHost = InJs.DomFactory.div().addClass(ModalDialog.modalDialogContainerHostClassName);
                    dialogHost = $(jsCommon.DOMConstants.DocumentBody).append(containerHost);
                    dialogHost = containerHost;
                }
                dialogHost.append(_this._modalContainer);
                _this._isReady = true;
                if (_this._messageQueue.length > 0) {
                    _this.showDialogInternal(_this._messageQueue.shift());
                }
            });
        }
        ModalDialog.prototype.showMessage = function(messageTitle, messageText) {
            var _this = this;
            jsCommon.Utility.throwIfNullOrEmptyString(messageTitle, null, "ShowMessage", "messageTitle");
            jsCommon.Utility.throwIfNullOrEmptyString(messageText, null, "ShowMessage", "messageText");
            var actions = [];
            actions[0] = this.createButton(InJs.Strings.dialogCloseActionLabel, function(sender, dialogHost) {
                _this.hideDialog();
            });
            this.pushMessage(messageTitle, messageText, null, actions, true, null);
        };
        ModalDialog.prototype.showPrompt = function(promptTitle, promptText, promptActions, isDismissable) {
            jsCommon.Utility.throwIfNullOrEmptyString(promptTitle, null, "ShowPrompt", "promptTitle");
            jsCommon.Utility.throwIfNullOrEmptyString(promptText, null, "ShowPrompt", "promptText");
            jsCommon.Utility.throwIfNullOrUndefined(promptActions, null, "ShowPrompt", "promptActions");
            var actionButtons = new Array();
            for (var i = 0; i < promptActions.length; i++) {
                var thisAction = promptActions[i];
                var cssClass = thisAction.cssClass;
                if (i === 0) {
                    cssClass = cssClass + " primary";
                }
                actionButtons[i] = this.createButton(thisAction.labelText, thisAction.actionCallback, thisAction.data, cssClass, thisAction.disabled);
            }
            this.pushMessage(promptTitle, promptText, null, actionButtons, isDismissable, null);
        };
        ModalDialog.prototype.showError = function(errorText, errorType, additionalErrorInfo, afterDismissCallback, dialogOptions) {
            this.showCustomError(InJs.Strings.errorDialogTitle, errorText, errorType, errorType !== 6, additionalErrorInfo, afterDismissCallback, dialogOptions);
        };
        ModalDialog.prototype.showCustomError = function(errorTitle, errorText, errorType, isDismissable, additionalErrorInfo, afterDismissCallback, dialogOptions) {
            var _this = this;
            jsCommon.Utility.throwIfNullOrEmptyString(errorTitle, null, "ShowError", "errorTitle");
            jsCommon.Utility.throwIfNullOrEmptyString(errorText, null, "ShowError", "errorText");
            var actions = new Array();
            if (dialogOptions) {
                dialogOptions.forEach(function(element, index, array) {
                    actions.push(_this.createButton(element.label, function(sender, dialogHost) {
                        _this.hideDialog();
                        if ($.isFunction(afterDismissCallback)) {
                            afterDismissCallback(element.resultValue);
                        }
                    }, null, element.cssClass, element.disabled));
                });
            } else if (errorType !== 6) {
                actions[0] = this.createButton(InJs.Strings.dialogCloseActionLabel, function(sender, dialogHost) {
                    _this.hideDialog();
                    if ($.isFunction(afterDismissCallback)) {
                        afterDismissCallback(0);
                    }
                });
            } else {
                actions[0] = this.createButton(InJs.Strings.dialogRefreshPageActionLabel, function(sender, dialogHost) {
                    window.location.reload();
                }, null, "primary");
            }
            var dialogContent = $("<div/>").text(errorText);
            this.addAdditionalErrorInfo(dialogContent, additionalErrorInfo);
            this.pushMessage(errorTitle || InJs.Strings.errorDialogTitle, null, dialogContent, actions, isDismissable, null);
        };
        ModalDialog.prototype.showCustomDialog = function(titleText, dialogContent, dialogActions, onDialogDisplayed, isDismissable, focusOnFirstButton, dialogCssClass, containerCssClass) {
            var actionsButtons = [];
            for (var i = 0; i < dialogActions.length; i++) {
                var thisAction = dialogActions[i];
                var cssClass = thisAction.cssClass;
                if (i === 0) {
                    cssClass = cssClass + " primary";
                }
                actionsButtons[i] = this.createButton(thisAction.labelText, thisAction.actionCallback, thisAction.data, cssClass, thisAction.disabled);
            }
            this.pushMessage(titleText, null, dialogContent, actionsButtons, isDismissable, onDialogDisplayed, focusOnFirstButton, dialogCssClass, containerCssClass);
            return this._dialogContent;
        };
        ModalDialog.prototype.hideDialog = function() {
            var _this = this;
            this._modalContainer.fadeTo(ModalDialog.AnimationSpeedMs, 0, function() {
                _this._modalContainer.css(jsCommon.CssConstants.displayProperty, jsCommon.CssConstants.noneValue);
                _this._modalDialogElement.removeClass(_this._modalDialogCustomClass);
                _this._modalContainer.removeClass(_this._modalContainerCustomClass);
                _this._messageCurrentlyShown = false;
                if (_this._messageQueue.length) {
                    var nextMessage = _this._messageQueue.shift();
                    _this.showDialogInternal(nextMessage);
                }
            });
        };
        ModalDialog.prototype.updatePosition = function(animate) {
            var modalDialogHeight = this._modalDialogElement.height();
            if (animate) {
                this._modalDialogElement.animate({
                    "margin-top": (-1 * (modalDialogHeight / 2)).toString() + jsCommon.CssConstants.pixelUnits
                }, ModalDialog.AnimationSpeedMs);
            } else {
                this._modalDialogElement.css(jsCommon.CssConstants.marginTopProperty, (-1 * (modalDialogHeight / 2)).toString() + jsCommon.CssConstants.pixelUnits);
            }
        };
        ModalDialog.prototype.addAdditionalErrorInfo = function(dialogContent, additionalErrorInfoKeyValuePairs) {
            var _this = this;
            if (additionalErrorInfoKeyValuePairs) {
                var additionalErrorInfo = $("<p />");
                for (var i = 0; i < additionalErrorInfoKeyValuePairs.length; i++) {
                    additionalErrorInfo.append(InJs.InfoNavUtility.constructErrorField(additionalErrorInfoKeyValuePairs[i].errorInfoKey, additionalErrorInfoKeyValuePairs[i].errorInfoValue));
                }
                var additionalErrorInfoContainer = InJs.InfoNavUtility.constructShowDetailsContainer(additionalErrorInfo);
                dialogContent.append($("<br />"));
                dialogContent.append(additionalErrorInfoContainer);
                dialogContent.find(".showAdditionalDetailsLink").on(jsCommon.DOMConstants.mouseClickEventName, function(e) {
                    _this.updatePosition(true);
                });
            }
        };
        ModalDialog.prototype.pushMessage = function(titleText, messageText, dialogContent, dialogButtons, isDismissable, onDialogDisplayed, focusOnFirstButton, dialogCssClass, containerCssClass) {
            if (typeof isDismissable === "undefined") {
                isDismissable = true;
            }
            if (typeof dialogCssClass === "undefined") {
                dialogCssClass = "";
            }
            if (typeof containerCssClass === "undefined") {
                containerCssClass = "";
            }
            var nextMessage = new QueueableMessage();
            nextMessage.titleText = titleText;
            nextMessage.messageText = messageText;
            nextMessage.dialogContent = dialogContent;
            nextMessage.dialogButtons = dialogButtons;
            nextMessage.onDialogDisplayed = onDialogDisplayed;
            nextMessage.isDismissable = isDismissable;
            nextMessage.dialogCssClass = dialogCssClass;
            nextMessage.containerCssClass = containerCssClass;
            this._messageQueue.push(nextMessage);
            if (!this._messageCurrentlyShown && this._isReady) {
                this.showDialogInternal(this._messageQueue.shift(), focusOnFirstButton);
            }
        };
        ModalDialog.prototype.showDialogInternal = function(message, focusOnFirstButton) {
            var _this = this;
            this._messageCurrentlyShown = true;
            this._dialogTitle.empty();
            this._dialogContent.empty();
            this._dialogActions.empty();
            this._dialogTitle.text(message.titleText);
            if (jsCommon.StringExtensions.isNullOrEmpty(message.messageText)) {
                this._dialogContent.append(message.dialogContent);
            } else {
                this._dialogContent.text(message.messageText);
            }
            if (message.isDismissable) {
                this._dialogCloseButton.css(jsCommon.CssConstants.displayProperty, jsCommon.CssConstants.blockValue);
            } else {
                this._dialogCloseButton.css(jsCommon.CssConstants.displayProperty, jsCommon.CssConstants.noneValue);
            }
            if (message.dialogButtons.length > 0) {
                this._dialogActions.show();
                for (var i = 0; i < message.dialogButtons.length; i++) {
                    this._dialogActions.append(message.dialogButtons[i]);
                }
            } else {
                this._dialogActions.hide();
            }
            if (message.dialogCssClass) {
                this._modalDialogElement.addClass(message.dialogCssClass);
                this._modalDialogCustomClass = message.dialogCssClass;
            }
            if (message.containerCssClass) {
                this._modalContainer.addClass(message.containerCssClass);
                this._modalContainerCustomClass = message.containerCssClass;
            }
            var fadingElem = this._modalContainer.css(jsCommon.CssConstants.displayProperty) === jsCommon.CssConstants.noneValue ? this._modalContainer : this._modalDialogElement;
            fadingElem.fadeTo(0, 0);
            this.updatePosition(false);
            fadingElem.fadeTo(ModalDialog.AnimationSpeedMs, 1, function() {
                _this._modalDialogElement.focus();
                var buttons = _this._dialogActions.find("input");
                if (buttons.length > 0) {
                    buttons[0].focus();
                }
                if (message.onDialogDisplayed) {
                    message.onDialogDisplayed(_this._dialogContent);
                }
                if (focusOnFirstButton) {
                    _this._dialogContent.parent().find(".infonav-dialogActions input[type=button]:first").focus();
                }
            });
        };
        ModalDialog.prototype.createButton = function(labelText, action, data, cssClass, disabled) {
            var _this = this;
            var button = $(ModalDialog.NewButtonSelector);
            button.attr("value", labelText);
            button.on(jsCommon.DOMConstants.mouseClickEventName, function(e) {
                action(button, _this._dialogContent, data);
            });
            if (cssClass) {
                button.addClass(cssClass);
            }
            if (disabled) {
                button.prop("disabled", true);
            }
            return button;
        };
        ModalDialog.AnimationSpeedMs = 250;
        ModalDialog.modalDialogCssClass = "infonav-modalDialog";
        ModalDialog.dialogTitleCssClass = "infonav-dialogTitle";
        ModalDialog.dialogCloseIconCssClass = "infonav-dialogCloseIcon";
        ModalDialog.dialogContentCssClass = "infonav-dialogContent";
        ModalDialog.dialogActionsCssClass = "infonav-dialogActions";
        ModalDialog.modalDialogClassSelector = "." + ModalDialog.modalDialogCssClass;
        ModalDialog.dialogTitleClassSelector = "." + ModalDialog.dialogTitleCssClass;
        ModalDialog.dialogCloseIconClassSelector = "." + ModalDialog.dialogCloseIconCssClass;
        ModalDialog.dialogContentClassSelector = "." + ModalDialog.dialogContentCssClass;
        ModalDialog.dialogActionsClassSelector = "." + ModalDialog.dialogActionsCssClass;
        ModalDialog.modalDialogContainerHostClassName = "infonav-modalContainerHost";
        ModalDialog.modalDialogContainerHostClassSelector = "." + ModalDialog.modalDialogContainerHostClassName;
        ModalDialog.ModalDialogHtml = '<div class="infonav-modalContainer' + (location.search.indexOf("renderAsModalDialog") !== -1 ? " small" : "") + '">' + '<div class="' + ModalDialog.modalDialogCssClass + '" tabindex="-1">' + '<div class="infonav-dialogLayout">' + '<div class="' + ModalDialog.dialogTitleCssClass + '"></div>' + '<div class="' + ModalDialog.dialogCloseIconCssClass + '"></div>' + '<div class="' + ModalDialog.dialogContentCssClass + '"></div>' + '<div class="' + ModalDialog.dialogActionsCssClass + '"></div>' + "</div>" + "</div>" + "</div>";
        ModalDialog.NewButtonSelector = '<input type="button"></input>';
        return ModalDialog;
    }();
    jsCommon.ModalDialog = ModalDialog;
    var QueueableMessage = function() {
        function QueueableMessage() {
            this.titleText = null;
            this.messageText = null;
            this.dialogContent = null;
            this.dialogButtons = null;
            this.onDialogDisplayed = null;
            this.isDismissable = true;
            this.dialogCssClass = null;
            this.containerCssClass = null;
        }
        return QueueableMessage;
    }();
})(jsCommon || (jsCommon = {}));

var InJs;

(function(InJs) {
    var ModalDialogAction = function() {
        function ModalDialogAction(labelText, actionCallback, data, cssClass, disabled) {
            this.labelText = labelText;
            this.actionCallback = actionCallback;
            this.data = data;
            this.cssClass = cssClass;
            this.disabled = !!disabled;
        }
        return ModalDialogAction;
    }();
    InJs.ModalDialogAction = ModalDialogAction;
})(InJs || (InJs = {}));

var jsCommon;

(function(jsCommon) {
    var color;
    (function(_color) {
        function rotate(rgbString, rotateFactor) {
            if (rotateFactor === 0) return rgbString;
            var originalRgb = parseRgb(rgbString);
            var originalHsv = rgbToHsv(originalRgb);
            var rotatedHsv = rotateHsv(originalHsv, rotateFactor);
            var rotatedRgb = hsvToRgb(rotatedHsv);
            return rgbToHexString(rotatedRgb);
        }
        _color.rotate = rotate;
        function parseRgb(rgbString) {
            jsCommon.Utility.throwIfNullOrEmpty(rgbString, "RgbColor", "parse", "rgbString");
            jsCommon.Utility.throwIfNotTrue(rgbString.length === 7, "RgbColor", "parse", "rgbString");
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(rgbString);
            jsCommon.Utility.throwIfNullOrUndefined(result, "RgbColor", "parse", "rgbString");
            return {
                R: parseInt(result[1], 16),
                G: parseInt(result[2], 16),
                B: parseInt(result[3], 16)
            };
        }
        _color.parseRgb = parseRgb;
        function rgbToHsv(rgbColor) {
            var s, h;
            var r = rgbColor.R / 255, g = rgbColor.G / 255, b = rgbColor.B / 255;
            var min = Math.min(r, Math.min(g, b));
            var max = Math.max(r, Math.max(g, b));
            var v = max;
            var delta = max - min;
            if (max === 0 || delta === 0) {
                s = 0;
                h = 0;
            } else {
                s = delta / max;
                if (r === max) {
                    h = (g - b) / delta;
                } else if (g === max) {
                    h = 2 + (b - r) / delta;
                } else {
                    h = 4 + (r - g) / delta;
                }
            }
            h /= 6;
            if (h < 0) {
                h += 1;
            }
            return {
                H: h,
                S: s,
                V: v
            };
        }
        function rgbToHexString(rgbColor) {
            return "#" + componentToHex(rgbColor.R) + componentToHex(rgbColor.G) + componentToHex(rgbColor.B);
        }
        _color.rgbToHexString = rgbToHexString;
        function componentToHex(hexComponent) {
            var hex = hexComponent.toString(16).toUpperCase();
            return hex.length === 1 ? "0" + hex : hex;
        }
        function hsvToRgb(hsvColor) {
            var r, g, b;
            var h = hsvColor.H, s = hsvColor.S, v = hsvColor.V;
            if (s === 0) {
                r = v;
                g = v;
                b = v;
            } else {
                var p, q, t, fractionalSector, sectorNumber, sectorPos;
                sectorPos = h * 6;
                sectorNumber = Math.floor(sectorPos);
                fractionalSector = sectorPos - sectorNumber;
                p = v * (1 - s);
                q = v * (1 - s * fractionalSector);
                t = v * (1 - s * (1 - fractionalSector));
                switch (sectorNumber) {
                  case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;

                  case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;

                  case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;

                  case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;

                  case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;

                  case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
                }
            }
            return {
                R: Math.floor(r * 255),
                G: Math.floor(g * 255),
                B: Math.floor(b * 255)
            };
        }
        function rotateHsv(hsvColor, rotateFactor) {
            var newH = hsvColor.H + rotateFactor;
            return {
                H: newH > 1 ? newH - 1 : newH,
                S: hsvColor.S,
                V: hsvColor.V
            };
        }
        function darken(color, diff) {
            var flooredNumber = Math.floor(diff);
            return {
                R: Math.max(0, color.R - flooredNumber),
                G: Math.max(0, color.G - flooredNumber),
                B: Math.max(0, color.B - flooredNumber)
            };
        }
        _color.darken = darken;
        function rgbWithAlphaString(color, a) {
            return rgbaString(color.R, color.G, color.B, a);
        }
        _color.rgbWithAlphaString = rgbWithAlphaString;
        function rgbString(color) {
            return "rgb(" + color.R + "," + color.G + "," + color.B + ")";
        }
        _color.rgbString = rgbString;
        function rgbaString(r, g, b, a) {
            return "rgba(" + r + "," + g + "," + b + "," + a + ")";
        }
        _color.rgbaString = rgbaString;
        function rgbStringToHexString(rgb) {
            debug.assert(rgb.indexOf("rgb(") !== -1, "input string does not starts with('rgb(')");
            var rgbColors = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
            var rgbArr = rgbColors.exec(rgb);
            if (rgbArr) {
                return rgbNumbersToHexString(rgbArr[1], rgbArr[2], rgbArr[3]);
            }
            return "";
        }
        _color.rgbStringToHexString = rgbStringToHexString;
        function rgbaStringToHexString(rgba) {
            debug.assert(rgba.indexOf("rgba(") !== -1, "input string does not starts with('rgba(')");
            var rgbColors = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/;
            var rgbArr = rgbColors.exec(rgba);
            if (rgbArr) {
                return rgbNumbersToHexString(rgbArr[1], rgbArr[2], rgbArr[3]);
            }
            return "";
        }
        _color.rgbaStringToHexString = rgbaStringToHexString;
        function rgbNumbersToHexString(Red, Green, Blue) {
            var rHex = parseInt(Red, 10).toString(16);
            var gHex = parseInt(Green, 10).toString(16);
            var bHex = parseInt(Blue, 10).toString(16);
            return "#" + (rHex.length === 1 ? "0" + rHex : rHex) + (gHex.length === 1 ? "0" + gHex : gHex) + (bHex.length === 1 ? "0" + bHex : bHex);
        }
    })(color = jsCommon.color || (jsCommon.color = {}));
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var CssConstants;
    (function(CssConstants) {
        CssConstants.styleAttribute = "style";
        CssConstants.pixelUnits = "px";
        CssConstants.heightProperty = "height";
        CssConstants.widthProperty = "width";
        CssConstants.topProperty = "top";
        CssConstants.bottomProperty = "bottom";
        CssConstants.leftProperty = "left";
        CssConstants.rightProperty = "right";
        CssConstants.marginTopProperty = "margin-top";
        CssConstants.marginLeftProperty = "margin-left";
        CssConstants.displayProperty = "display";
        CssConstants.backgroundProperty = "background";
        CssConstants.backgroundColorProperty = "background-color";
        CssConstants.backgroundRepeatProperty = "background-repeat";
        CssConstants.backgroundSizeProperty = "background-size";
        CssConstants.backgroundImageProperty = "background-image";
        CssConstants.textShadowProperty = "text-shadow";
        CssConstants.borderTopWidthProperty = "border-top-width";
        CssConstants.borderBottomWidthProperty = "border-bottom-width";
        CssConstants.borderLeftWidthProperty = "border-left-width";
        CssConstants.borderRightWidthProperty = "border-right-width";
        CssConstants.fontWeightProperty = "font-weight";
        CssConstants.colorProperty = "color";
        CssConstants.opacityProperty = "opacity";
        CssConstants.paddingLeftProperty = "padding-left";
        CssConstants.paddingRightProperty = "padding-right";
        CssConstants.positionProperty = "position";
        CssConstants.maxWidthProperty = "max-width";
        CssConstants.minWidthProperty = "min-width";
        CssConstants.overflowProperty = "overflow";
        CssConstants.cursorProperty = "cursor";
        CssConstants.visibilityProperty = "visibility";
        CssConstants.absoluteValue = "absolute";
        CssConstants.zeroPixelValue = "0px";
        CssConstants.autoValue = "auto";
        CssConstants.hiddenValue = "hidden";
        CssConstants.noneValue = "none";
        CssConstants.blockValue = "block";
        CssConstants.inlineBlockValue = "inline-block";
        CssConstants.transparentValue = "transparent";
        CssConstants.boldValue = "bold";
        CssConstants.visibleValue = "visible";
        CssConstants.tableRowValue = "table-row";
        CssConstants.coverValue = "cover";
        CssConstants.pointerValue = "pointer";
    })(CssConstants = jsCommon.CssConstants || (jsCommon.CssConstants = {}));
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var DOMConstants;
    (function(DOMConstants) {
        DOMConstants.escKeyCode = 27;
        DOMConstants.enterKeyCode = 13;
        DOMConstants.tabKeyCode = 9;
        DOMConstants.upArrowKeyCode = 38;
        DOMConstants.downArrowKeyCode = 40;
        DOMConstants.leftArrowKeyCode = 37;
        DOMConstants.rightArrowKeyCode = 39;
        DOMConstants.homeKeyCode = 36;
        DOMConstants.endKeyCode = 35;
        DOMConstants.backSpaceKeyCode = 8;
        DOMConstants.deleteKeyCode = 46;
        DOMConstants.spaceKeyCode = 32;
        DOMConstants.shiftKeyCode = 16;
        DOMConstants.ctrlKeyCode = 17;
        DOMConstants.altKeyCode = 18;
        DOMConstants.aKeyCode = 65;
        DOMConstants.cKeyCode = 67;
        DOMConstants.vKeyCode = 86;
        DOMConstants.xKeyCode = 88;
        DOMConstants.yKeyCode = 89;
        DOMConstants.zKeyCode = 90;
        DOMConstants.DocumentBody = "body";
        DOMConstants.Anchor = "a";
        DOMConstants.EditableTextElements = "input, textarea, select";
        DOMConstants.disabledAttributeOrValue = "disabled";
        DOMConstants.readonlyAttributeOrValue = "readonly";
        DOMConstants.styleAttribute = "style";
        DOMConstants.hrefAttribute = "href";
        DOMConstants.targetAttribute = "target";
        DOMConstants.blankValue = "_blank";
        DOMConstants.classAttribute = "class";
        DOMConstants.titleAttribute = "title";
        DOMConstants.srcAttribute = "src";
        DOMConstants.contextmenuEventName = "contextmenu";
        DOMConstants.blurEventName = "blur";
        DOMConstants.keyUpEventName = "keyup";
        DOMConstants.inputEventName = "input";
        DOMConstants.changeEventName = "change";
        DOMConstants.cutEventName = "cut";
        DOMConstants.keyDownEventName = "keydown";
        DOMConstants.mouseMoveEventName = "mousemove";
        DOMConstants.mouseDownEventName = "mousedown";
        DOMConstants.mouseEnterEventName = "mouseenter";
        DOMConstants.mouseLeaveEventName = "mouseleave";
        DOMConstants.mouseOverEventName = "mouseover";
        DOMConstants.mouseOutEventName = "mouseout";
        DOMConstants.mouseClickEventName = "click";
        DOMConstants.pasteEventName = "paste";
        DOMConstants.scrollEventName = "scroll";
        DOMConstants.dropEventName = "drop";
        DOMConstants.focusInEventName = "focusin";
        DOMConstants.focusOutEventName = "focusout";
        DOMConstants.selectEventName = "select";
        DOMConstants.messageEventName = "message";
        DOMConstants.loadEventName = "load";
        DOMConstants.beforeUnload = "beforeunload";
        DOMConstants.inputAndSelectEventNames = "input, select";
    })(DOMConstants = jsCommon.DOMConstants || (jsCommon.DOMConstants = {}));
})(jsCommon || (jsCommon = {}));

var debug;

(function(debug) {
    debug.assertFailFunction;
    function assert(condition, message) {
        if (condition !== true) {
            assertFail(message || "condition: " + condition);
        }
    }
    debug.assert = assert;
    function assertValue(value, message) {
        if (value === null || value === undefined) {
            assertFail(message || "condition: " + value);
        }
    }
    debug.assertValue = assertValue;
    function assertAnyValue(value, message) {}
    debug.assertAnyValue = assertAnyValue;
    function assertFail(message) {
        (debug.assertFailFunction || alert)("Debug Assert failed: " + message);
    }
    debug.assertFail = assertFail;
})(debug || (debug = {}));

var powerbi;

(function(powerbi) {
    function RejectablePromise2(deferred) {
        return new RejectablePromiseImpl(deferred);
    }
    powerbi.RejectablePromise2 = RejectablePromise2;
    function RejectablePromise(deferred) {
        return new RejectablePromiseImpl(deferred);
    }
    powerbi.RejectablePromise = RejectablePromise;
    var promiseState;
    (function(promiseState) {
        promiseState[promiseState["pending"] = 0] = "pending";
        promiseState[promiseState["resolved"] = 1] = "resolved";
        promiseState[promiseState["rejected"] = 2] = "rejected";
    })(promiseState || (promiseState = {}));
    var RejectablePromiseImpl = function() {
        function RejectablePromiseImpl(deferred) {
            var _this = this;
            debug.assertValue(deferred, "deferred");
            this.deferred = deferred;
            this.state = 0;
            deferred.promise.then(function() {
                return _this.state = 1;
            }, function() {
                return _this.state = 2;
            });
        }
        RejectablePromiseImpl.prototype.then = function(successCallback, errorCallback) {
            return this.deferred.promise.then(successCallback, errorCallback);
        };
        RejectablePromiseImpl.prototype.catch = function(callback) {
            return this.deferred.promise.catch(callback);
        };
        RejectablePromiseImpl.prototype.finally = function(callback) {
            return this.deferred.promise.finally(callback);
        };
        RejectablePromiseImpl.prototype.resolved = function() {
            return this.state === 1;
        };
        RejectablePromiseImpl.prototype.rejected = function() {
            return this.state === 2;
        };
        RejectablePromiseImpl.prototype.pending = function() {
            return this.state === 0;
        };
        RejectablePromiseImpl.prototype.reject = function(reason) {
            if (this.pending()) {
                this.deferred.reject(reason);
                this.state = 2;
            }
        };
        return RejectablePromiseImpl;
    }();
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var DateExtensions;
    (function(DateExtensions) {
        var datePrefix = "/Date(";
        var dateSuffix = ")/";
        function formatAbsolute(date) {
            debug.assertValue(date, "date");
            if (DateExtensions.isMidnight(date)) {
                return date.toLocaleDateString();
            }
            return date.toLocaleString();
        }
        DateExtensions.formatAbsolute = formatAbsolute;
        function formatPretty(date) {
            debug.assertValue(date, "date");
            if (DateExtensions.isMomentPresent()) {
                return moment(date).fromNow();
            }
            return formatAbsolute(date);
        }
        DateExtensions.formatPretty = formatPretty;
        var milisecondsPerHour = 3600 * 1e3;
        var millisecondsPerDay = 24 * milisecondsPerHour;
        function isMidnight(date) {
            debug.assertValue(date, "date");
            return date.getTime() % millisecondsPerDay === 0;
        }
        DateExtensions.isMidnight = isMidnight;
        function elapsedToNow(date, units) {
            debug.assertValue(date, "date");
            var from = moment(date);
            return moment().diff(from, units);
        }
        DateExtensions.elapsedToNow = elapsedToNow;
        function isMomentPresent() {
            return typeof moment !== "undefined";
        }
        DateExtensions.isMomentPresent = isMomentPresent;
        function parseIsoDate(isoDate) {
            debug.assert(isMomentPresent(), "Moment.js should be loaded for parseIsoDate.");
            var momentDate = moment(isoDate);
            return momentDate.isValid() ? momentDate.toDate() : null;
        }
        DateExtensions.parseIsoDate = parseIsoDate;
        function parseUtcDate(isoDate) {
            debug.assert(isMomentPresent(), "Moment.js should be loaded for parseUtcDate.");
            return moment.utc(isoDate).toDate();
        }
        DateExtensions.parseUtcDate = parseUtcDate;
        function fromNow(date) {
            return moment(date).fromNow();
        }
        DateExtensions.fromNow = fromNow;
        function serializeDate(date) {
            debug.assertValue(date, "date");
            return datePrefix + date.getTime().toString() + dateSuffix;
        }
        DateExtensions.serializeDate = serializeDate;
        function deserializeDate(data) {
            jsCommon.Utility.throwIfNullOrEmptyString(data, null, "deserializeDate", "Cannot deserialize empty string");
            jsCommon.Utility.throwIfNotTrue(data.indexOf(datePrefix) === 0 && jsCommon.StringExtensions.endsWith(data, dateSuffix), null, "deserializeDate", "Cannot deserialize empty string");
            if (DateExtensions.isMomentPresent()) {
                var parsedValue = moment(data);
                jsCommon.Utility.throwIfNotTrue(parsedValue.isValid(), null, "deserializeDate", "parsedValue.isValid must be true");
                return parsedValue.toDate();
            }
            var ticksString = data.substring(datePrefix.length, data.length - dateSuffix.length);
            jsCommon.Utility.throwIfNotTrue(/^\-?\d+$/.test(ticksString), null, "deserializeDate", "Cannot deserialize invalid date");
            var ticksValue = parseInt(ticksString, 10);
            jsCommon.Utility.throwIfNotTrue(!isNaN(ticksValue), null, "deserializeDate", "Cannot deserialize invalid date");
            return new Date(ticksValue);
        }
        DateExtensions.deserializeDate = deserializeDate;
        function tryDeserializeDate(data) {
            try {
                return deserializeDate(data);
            } catch (e) {}
        }
        DateExtensions.tryDeserializeDate = tryDeserializeDate;
    })(DateExtensions = jsCommon.DateExtensions || (jsCommon.DateExtensions = {}));
})(jsCommon || (jsCommon = {}));

var powerbi;

(function(powerbi) {
    var Double;
    (function(Double) {
        Double.MIN_VALUE = -Number.MAX_VALUE;
        Double.MAX_VALUE = Number.MAX_VALUE;
        Double.MIN_EXP = -308;
        Double.MAX_EXP = 308;
        Double.EPSILON = 1e-323;
        Double.DEFAULT_PRECISION = 1e-4;
        Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS = 12;
        Double.LOG_E_10 = Math.log(10);
        Double.POSITIVE_POWERS = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29, 1e30, 1e31, 1e32, 1e33, 1e34, 1e35, 1e36, 1e37, 1e38, 1e39, 1e40, 1e41, 1e42, 1e43, 1e44, 1e45, 1e46, 1e47, 1e48, 1e49, 1e50, 1e51, 1e52, 1e53, 1e54, 1e55, 1e56, 1e57, 1e58, 1e59, 1e60, 1e61, 1e62, 1e63, 1e64, 1e65, 1e66, 1e67, 1e68, 1e69, 1e70, 1e71, 1e72, 1e73, 1e74, 1e75, 1e76, 1e77, 1e78, 1e79, 1e80, 1e81, 1e82, 1e83, 1e84, 1e85, 1e86, 1e87, 1e88, 1e89, 1e90, 1e91, 1e92, 1e93, 1e94, 1e95, 1e96, 1e97, 1e98, 1e99, 1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109, 1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119, 1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129, 1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139, 1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149, 1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159, 1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169, 1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179, 1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189, 1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199, 1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209, 1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219, 1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229, 1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239, 1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249, 1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259, 1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269, 1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279, 1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289, 1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299, 1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308 ];
        Double.NEGATIVE_POWERS = [ 1, .1, .01, .001, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-9, 1e-10, 1e-11, 1e-12, 1e-13, 1e-14, 1e-15, 1e-16, 1e-17, 1e-18, 1e-19, 1e-20, 1e-21, 1e-22, 1e-23, 1e-24, 1e-25, 1e-26, 1e-27, 1e-28, 1e-29, 1e-30, 1e-31, 1e-32, 1e-33, 1e-34, 1e-35, 1e-36, 1e-37, 1e-38, 1e-39, 1e-40, 1e-41, 1e-42, 1e-43, 1e-44, 1e-45, 1e-46, 1e-47, 1e-48, 1e-49, 1e-50, 1e-51, 1e-52, 1e-53, 1e-54, 1e-55, 1e-56, 1e-57, 1e-58, 1e-59, 1e-60, 1e-61, 1e-62, 1e-63, 1e-64, 1e-65, 1e-66, 1e-67, 1e-68, 1e-69, 1e-70, 1e-71, 1e-72, 1e-73, 1e-74, 1e-75, 1e-76, 1e-77, 1e-78, 1e-79, 1e-80, 1e-81, 1e-82, 1e-83, 1e-84, 1e-85, 1e-86, 1e-87, 1e-88, 1e-89, 1e-90, 1e-91, 1e-92, 1e-93, 1e-94, 1e-95, 1e-96, 1e-97, 1e-98, 1e-99, 1e-100, 1e-101, 1e-102, 1e-103, 1e-104, 1e-105, 1e-106, 1e-107, 1e-108, 1e-109, 1e-110, 1e-111, 1e-112, 1e-113, 1e-114, 1e-115, 1e-116, 1e-117, 1e-118, 1e-119, 1e-120, 1e-121, 1e-122, 1e-123, 1e-124, 1e-125, 1e-126, 1e-127, 1e-128, 1e-129, 1e-130, 1e-131, 1e-132, 1e-133, 1e-134, 1e-135, 1e-136, 1e-137, 1e-138, 1e-139, 1e-140, 1e-141, 1e-142, 1e-143, 1e-144, 1e-145, 1e-146, 1e-147, 1e-148, 1e-149, 1e-150, 1e-151, 1e-152, 1e-153, 1e-154, 1e-155, 1e-156, 1e-157, 1e-158, 1e-159, 1e-160, 1e-161, 1e-162, 1e-163, 1e-164, 1e-165, 1e-166, 1e-167, 1e-168, 1e-169, 1e-170, 1e-171, 1e-172, 1e-173, 1e-174, 1e-175, 1e-176, 1e-177, 1e-178, 1e-179, 1e-180, 1e-181, 1e-182, 1e-183, 1e-184, 1e-185, 1e-186, 1e-187, 1e-188, 1e-189, 1e-190, 1e-191, 1e-192, 1e-193, 1e-194, 1e-195, 1e-196, 1e-197, 1e-198, 1e-199, 1e-200, 1e-201, 1e-202, 1e-203, 1e-204, 1e-205, 1e-206, 1e-207, 1e-208, 1e-209, 1e-210, 1e-211, 1e-212, 1e-213, 1e-214, 1e-215, 1e-216, 1e-217, 1e-218, 1e-219, 1e-220, 1e-221, 1e-222, 1e-223, 1e-224, 1e-225, 1e-226, 1e-227, 1e-228, 1e-229, 1e-230, 1e-231, 1e-232, 1e-233, 1e-234, 1e-235, 1e-236, 1e-237, 1e-238, 1e-239, 1e-240, 1e-241, 1e-242, 1e-243, 1e-244, 1e-245, 1e-246, 1e-247, 1e-248, 1e-249, 1e-250, 1e-251, 1e-252, 1e-253, 1e-254, 1e-255, 1e-256, 1e-257, 1e-258, 1e-259, 1e-260, 1e-261, 1e-262, 1e-263, 1e-264, 1e-265, 1e-266, 1e-267, 1e-268, 1e-269, 1e-270, 1e-271, 1e-272, 1e-273, 1e-274, 1e-275, 1e-276, 1e-277, 1e-278, 1e-279, 1e-280, 1e-281, 1e-282, 1e-283, 1e-284, 1e-285, 1e-286, 1e-287, 1e-288, 1e-289, 1e-290, 1e-291, 1e-292, 1e-293, 1e-294, 1e-295, 1e-296, 1e-297, 1e-298, 1e-299, 1e-300, 1e-301, 1e-302, 1e-303, 1e-304, 1e-305, 1e-306, 1e-307, 1e-308, 1e-309, 1e-310, 1e-311, 1e-312, 1e-313, 1e-314, 1e-315, 1e-316, 1e-317, 1e-318, 1e-319, 1e-320, 1e-321, 1e-322, 1e-323, 0 ];
        function pow10(exp) {
            debug.assertValue(exp, "exp");
            if (exp >= 0) {
                if (exp < Double.POSITIVE_POWERS.length) {
                    return Double.POSITIVE_POWERS[exp];
                } else {
                    return Infinity;
                }
            }
            exp = -exp;
            if (exp > 0 && exp < Double.NEGATIVE_POWERS.length) {
                return Double.NEGATIVE_POWERS[exp];
            } else {
                return 0;
            }
        }
        Double.pow10 = pow10;
        function log10(val) {
            debug.assert(val >= 0, "val");
            if (val > 1 && val < 1e16) {
                if (val < 1e8) {
                    if (val < 1e4) {
                        if (val < 100) {
                            if (val < 10) {
                                return 0;
                            } else {
                                return 1;
                            }
                        } else {
                            if (val < 1e3) {
                                return 2;
                            } else {
                                return 3;
                            }
                        }
                    } else {
                        if (val < 1e6) {
                            if (val < 1e5) {
                                return 4;
                            } else {
                                return 5;
                            }
                        } else {
                            if (val < 1e7) {
                                return 6;
                            } else {
                                return 7;
                            }
                        }
                    }
                } else {
                    if (val < 1e12) {
                        if (val < 1e10) {
                            if (val < 1e9) {
                                return 8;
                            } else {
                                return 9;
                            }
                        } else {
                            if (val < 1e11) {
                                return 10;
                            } else {
                                return 11;
                            }
                        }
                    } else {
                        if (val < 1e14) {
                            if (val < 1e13) {
                                return 12;
                            } else {
                                return 13;
                            }
                        } else {
                            if (val < 1e15) {
                                return 14;
                            } else {
                                return 15;
                            }
                        }
                    }
                }
            }
            if (val > 1e-16 && val < 1) {
                if (val < 1e-8) {
                    if (val < 1e-12) {
                        if (val < 1e-14) {
                            if (val < 1e-15) {
                                return -16;
                            } else {
                                return -15;
                            }
                        } else {
                            if (val < 1e-13) {
                                return -14;
                            } else {
                                return -13;
                            }
                        }
                    } else {
                        if (val < 1e-10) {
                            if (val < 1e-11) {
                                return -12;
                            } else {
                                return -11;
                            }
                        } else {
                            if (val < 1e-9) {
                                return -10;
                            } else {
                                return -9;
                            }
                        }
                    }
                } else {
                    if (val < 1e-4) {
                        if (val < 1e-6) {
                            if (val < 1e-7) {
                                return -8;
                            } else {
                                return -7;
                            }
                        } else {
                            if (val < 1e-5) {
                                return -6;
                            } else {
                                return -5;
                            }
                        }
                    } else {
                        if (val < .01) {
                            if (val < .001) {
                                return -4;
                            } else {
                                return -3;
                            }
                        } else {
                            if (val < .1) {
                                return -2;
                            } else {
                                return -1;
                            }
                        }
                    }
                }
            }
            var log10 = Math.log(val) / Double.LOG_E_10;
            return Double.floorWithPrecision(log10);
        }
        Double.log10 = log10;
        function getPrecision(x, decimalDigits) {
            if (decimalDigits === undefined) {
                decimalDigits = Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS;
            } else {
                debug.assert(decimalDigits >= 0, "decimalDigits");
            }
            if (!x) {
                return undefined;
            }
            var exp = Double.log10(Math.abs(x));
            if (exp < Double.MIN_EXP) {
                return 0;
            }
            var precisionExp = Math.max(exp - decimalDigits, -Double.NEGATIVE_POWERS.length + 1);
            return Double.pow10(precisionExp);
        }
        Double.getPrecision = getPrecision;
        function equalWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x === y || Math.abs(x - y) < precision;
        }
        Double.equalWithPrecision = equalWithPrecision;
        function lessWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x < y && Math.abs(x - y) > precision;
        }
        Double.lessWithPrecision = lessWithPrecision;
        function lessOrEqualWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x < y || Math.abs(x - y) < precision;
        }
        Double.lessOrEqualWithPrecision = lessOrEqualWithPrecision;
        function greaterWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x > y && Math.abs(x - y) > precision;
        }
        Double.greaterWithPrecision = greaterWithPrecision;
        function greaterOrEqualWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x > y || Math.abs(x - y) < precision;
        }
        Double.greaterOrEqualWithPrecision = greaterOrEqualWithPrecision;
        function floorWithPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            } else {
                return Math.floor(x);
            }
        }
        Double.floorWithPrecision = floorWithPrecision;
        function ceilWithPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            } else {
                return Math.ceil(x);
            }
        }
        Double.ceilWithPrecision = ceilWithPrecision;
        function floorToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            return Math.floor(x / precision) * precision;
        }
        Double.floorToPrecision = floorToPrecision;
        function ceilToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            return Math.ceil(x / precision) * precision;
        }
        Double.ceilToPrecision = ceilToPrecision;
        function roundToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            var result = Math.round(x / precision) * precision;
            var decimalDigits = Math.round(Double.log10(Math.abs(x)) - Double.log10(precision)) + 1;
            if (decimalDigits > 0 && decimalDigits < 16) {
                result = parseFloat(result.toPrecision(decimalDigits));
            }
            return result;
        }
        Double.roundToPrecision = roundToPrecision;
        function ensureInRange(x, min, max) {
            debug.assert(min <= max, "min must be less or equal to max");
            if (x === undefined || x === null) {
                return x;
            }
            if (x < min) {
                return min;
            }
            if (x > max) {
                return max;
            }
            return x;
        }
        Double.ensureInRange = ensureInRange;
        function round(x) {
            debug.assert(x >= 0, "x must be greater or equal to 0");
            return .5 + x << 0;
        }
        Double.round = round;
        function project(value, fromMin, fromSize, toMin, toSize) {
            if (fromSize === 0 || toSize === 0) {
                if (fromMin <= value && value <= fromMin + fromSize) {
                    return toMin;
                } else {
                    return NaN;
                }
            }
            var relativeX = (value - fromMin) / fromSize;
            var projectedX = toMin + relativeX * toSize;
            return projectedX;
        }
        Double.project = project;
        function removeDecimalNoise(value) {
            return roundToPrecision(value, getPrecision(value));
        }
        Double.removeDecimalNoise = removeDecimalNoise;
        function isInteger(value) {
            return value !== null && value % 1 === 0;
        }
        Double.isInteger = isInteger;
    })(Double = powerbi.Double || (powerbi.Double = {}));
    function applyDefault(value, defaultValue) {
        return value !== undefined ? value : defaultValue;
    }
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var Errors;
    (function(Errors) {
        function infoNavAppAlreadyPresent() {
            return {
                name: "infoNavAppAlreadyPresent",
                message: "Cannot initialize embedded scenario when the InfoNav App is already present in this context",
                stack: getExceptionStackTrace()
            };
        }
        Errors.infoNavAppAlreadyPresent = infoNavAppAlreadyPresent;
        function invalidOperation(message) {
            return {
                name: "invalidOperation",
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.invalidOperation = invalidOperation;
        function argument(argumentName, message) {
            return {
                name: "invalidArgumentError",
                argument: argumentName,
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.argument = argument;
        function argumentNull(argumentName) {
            return {
                name: "argumentNull",
                argument: argumentName,
                message: "Argument was null",
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentNull = argumentNull;
        function argumentUndefined(argumentName) {
            return {
                name: "argumentUndefined",
                argument: argumentName,
                message: "Argument was undefined",
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentUndefined = argumentUndefined;
        function argumentOutOfRange(argumentName) {
            return {
                name: "argumentOutOfRange",
                argument: argumentName,
                message: "Argument was out of range",
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentOutOfRange = argumentOutOfRange;
        function pureVirtualMethodException(className, methodName) {
            return {
                name: "pureVirtualMethodException",
                message: "This method must be overriden by the derived class:" + className + "." + methodName,
                stack: getExceptionStackTrace()
            };
        }
        Errors.pureVirtualMethodException = pureVirtualMethodException;
        function notImplementedException(message) {
            return {
                name: "notImplementedException",
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.notImplementedException = notImplementedException;
        function getExceptionStackTrace() {
            return getStackTrace(2);
        }
    })(Errors = jsCommon.Errors || (jsCommon.Errors = {}));
    function getStackTrace(leadingFramesToRemove) {
        if (leadingFramesToRemove === void 0) {
            leadingFramesToRemove = 1;
        }
        var stackTrace, stackSegments;
        try {
            throw new Error();
        } catch (error) {
            stackTrace = error.stack;
            if (stackTrace != null) {
                stackSegments = stackTrace.split("\n");
                stackSegments.splice(1, leadingFramesToRemove);
                stackTrace = stackSegments.join("\n");
            }
        }
        return stackTrace;
    }
    jsCommon.getStackTrace = getStackTrace;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var Formatting;
    (function(Formatting) {
        var _regexCache;
        function findDateFormat(value, format, cultureName) {
            switch (format) {
              case "m":
                format = "M";
                break;

              case "O":
              case "o":
                format = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff'0000'";
                break;

              case "R":
              case "r":
                value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                format = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
                break;

              case "s":
                format = "S";
                break;

              case "u":
                value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                format = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";
                break;

              case "U":
                value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                format = "F";
                break;

              case "y":
              case "Y":
                switch (cultureName) {
                  case "default":
                  case "en":
                  case "en-US":
                    format = "MMMM, yyyy";
                    break;

                  default:
                    format = "Y";
                }
                break;
            }
            return {
                value: value,
                format: format
            };
        }
        Formatting.findDateFormat = findDateFormat;
        function fixDateTimeFormat(format) {
            format = format.replace(/%K/g, "zzz");
            format = format.replace(/K/g, "zzz");
            format = format.replace(/fffffff/g, "fff0000");
            format = format.replace(/ffffff/g, "fff000");
            format = format.replace(/fffff/g, "fff00");
            format = format.replace(/ffff/g, "fff0");
            format = format.replace(/yyyyy/g, "0yyyy");
            format = format.replace(/(^y|^)yyy(^y|$)/g, "yyyy");
            if (!_regexCache) {
                _regexCache = [ "d", "f", "F", "g", "h", "H", "K", "m", "M", "s", "t", "y", "z", ":", "/" ].map(function(s) {
                    return {
                        r: new RegExp("%" + s + "(?!" + s + ")", "g"),
                        s: s
                    };
                });
            }
            if (format.indexOf("%") !== -1 && format.length > 2) {
                for (var i = 0; i < _regexCache.length; i++) {
                    format = format.replace(_regexCache[i].r, _regexCache[i].s);
                }
            }
            return format;
        }
        Formatting.fixDateTimeFormat = fixDateTimeFormat;
    })(Formatting = jsCommon.Formatting || (jsCommon.Formatting = {}));
})(jsCommon || (jsCommon = {}));

$.fn.multiline = function(text) {
    this.text(text);
    this.html(this.html().replace(/\n/g, "<br/>"));
    return this;
};

$.fn.togglePanelControl = function() {
    return this.each(function() {
        $(this).addClass("ui-accordion ui-accordion-icons ui-widget ui-helper-reset").find(".accordionHeader").addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-top ui-corner-bottom").hover(function() {
            $(this).toggleClass("ui-state-hover");
        }).prepend('<span class="ui-icon ui-icon-triangle-1-e"></span>').click(function() {
            $(this).toggleClass("ui-accordion-header-active ui-state-active ui-state-default ui-corner-bottom").find("> .ui-icon").toggleClass("ui-icon-triangle-1-e ui-icon-triangle-1-s").end().next().slideToggle();
            return false;
        }).next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide();
    });
};

var jsCommon;

(function(jsCommon) {
    var JQueryConstants;
    (function(JQueryConstants) {
        JQueryConstants.VisibleSelector = ":visible";
    })(JQueryConstants = jsCommon.JQueryConstants || (jsCommon.JQueryConstants = {}));
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var Lazy = function() {
        function Lazy(factoryMethod) {
            jsCommon.Utility.throwIfNullOrUndefined(factoryMethod, this, "constructor", "factoryMethod");
            this._factoryMethod = factoryMethod;
        }
        Lazy.prototype.getValue = function() {
            if (this._factoryMethod !== null) {
                this._value = this._factoryMethod();
                this._factoryMethod = null;
            }
            return this._value;
        };
        return Lazy;
    }();
    jsCommon.Lazy = Lazy;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var Path = function() {
        function Path(segments) {
            debug.assertValue(segments, "segments");
            debug.assert(segments.length > 0, "segments.length");
            this._segments = segments;
        }
        Path.prototype.getLeafSegment = function() {
            return this._segments[this._segments.length - 1];
        };
        Path.prototype.isExtensionOf = function(other) {
            if (this._segments.length <= other._segments.length) {
                return false;
            }
            for (var i = 0, len = other._segments.length; i < len; ++i) {
                if (this._segments[i] !== other._segments[i]) {
                    return false;
                }
            }
            return true;
        };
        Path.prototype.extend = function(segment) {
            return new Path(this._segments.concat([ segment ]));
        };
        return Path;
    }();
    jsCommon.Path = Path;
})(jsCommon || (jsCommon = {}));

var powerbi;

(function(powerbi) {
    var Prototype;
    (function(Prototype) {
        function inherit(obj, extension) {
            debug.assertValue(obj, "obj");
            function wrapCtor() {}
            wrapCtor.prototype = obj;
            var inherited = new wrapCtor();
            if (extension) extension(inherited);
            return inherited;
        }
        Prototype.inherit = inherit;
        function overrideArray(prototype, override) {
            if (!prototype) return;
            var overwritten;
            for (var i = 0, len = prototype.length; i < len; i++) {
                var value = override(prototype[i]);
                if (value) {
                    if (!overwritten) overwritten = inherit(prototype);
                    overwritten[i] = value;
                }
            }
            return overwritten;
        }
        Prototype.overrideArray = overrideArray;
    })(Prototype = powerbi.Prototype || (powerbi.Prototype = {}));
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var QueryStringUtil = function() {
        function QueryStringUtil() {}
        QueryStringUtil.clearQueryString = function(queryField) {
            var queries = QueryStringUtil.parseQueryString();
            delete queries[queryField];
            return QueryStringUtil.rebuildQueryString(queries);
        };
        QueryStringUtil.addOrUpdateQueryString = function(queryField, queryValue) {
            var queries = QueryStringUtil.parseQueryString();
            queries[queryField] = queryValue;
            return QueryStringUtil.rebuildQueryString(queries);
        };
        QueryStringUtil.getQueryStringValue = function(key) {
            var queries = QueryStringUtil.parseQueryString();
            return queries[key];
        };
        QueryStringUtil.parseQueryString = function(queryString) {
            if (queryString === void 0) {
                queryString = window.location.search;
            }
            var queryStringDictionary = {};
            var search = queryString;
            if (!jsCommon.StringExtensions.isNullOrEmpty(search) && search.substr(0, 1) === "?") {
                var pairs = search.substr(1).split("&");
                for (var i = 0; i < pairs.length; i++) {
                    var keyValuePair = pairs[i].split("=");
                    queryStringDictionary[decodeURIComponent(keyValuePair[0])] = decodeURIComponent(keyValuePair[1]);
                }
            }
            return queryStringDictionary;
        };
        QueryStringUtil.rebuildQueryString = function(queries) {
            var queryString = "";
            var isEmpty = true;
            for (var queryField in queries) {
                if (!isEmpty) {
                    queryString += "&";
                }
                queryString += encodeURIComponent(queryField);
                if (queries[queryField]) {
                    queryString += "=" + encodeURIComponent(queries[queryField]);
                }
                isEmpty = false;
            }
            if (!isEmpty) {
                queryString = "?" + queryString;
            }
            return queryString;
        };
        QueryStringUtil.OriginClientActivityIdParameterName = "caid";
        QueryStringUtil.OriginRootActivityIdParameterName = "raid";
        QueryStringUtil.OriginActivityIdParameterName = "aid";
        return QueryStringUtil;
    }();
    jsCommon.QueryStringUtil = QueryStringUtil;
})(jsCommon || (jsCommon = {}));

var InJs;

(function(InJs) {
    var Strings;
    (function(Strings) {
        Strings.dateTimeFormat = "M/d/yyyy h:mm tt";
        Strings.serverErrorTitleText = "Sorry, something went wrong";
        Strings.serverErrorDetailsText = "Please try your query again. If the error continues please contact your system administrator.";
        Strings.serverTimeoutDetailsText = "There was a timeout processing your request. Please try again. If the error continues please contact your system administrator.";
        Strings.serverReloadDetailsText = "There was a mismatch in the metadata. This usually occurs when the data on the server has been updated. Please refresh the browser and try your query again.";
        Strings.infoNavErrorCodeTemplate = "{0} ({1})";
        Strings.infoNavErrorWithActivityIdTemplate = "{0} (Activity Id: {1})";
        Strings.errorCodeText = "Error Code";
        Strings.errorActivityIdText = "Activity Id";
        Strings.errorRequestIdText = "Request Id";
        Strings.errorLineNumberText = "Line number";
        Strings.errorColumnNumberText = "Column number";
        Strings.errorStackTraceText = "Stack trace";
        Strings.errorSourceFileText = "Source file";
        Strings.errorTimestampText = "Time";
        Strings.errorCallStackText = "Call stack";
        Strings.emptyResultTitleText = "Sorry, I wasn't able to find a good answer.";
        Strings.emptyResultDescriptionText = "";
        Strings.showDetailsText = "Show technical details";
        Strings.showMoreVisualizationsLabel = "show more";
        Strings.showFewerVisualizationsLabel = "show fewer";
        Strings.stackedBarChartVisualizationsLabel = "bar chart";
        Strings.clusteredBarChartVisualizationsLabel = "clustered bar chart";
        Strings.hundredPercentBarChartVisualizationsLabel = "100% stacked bar chart";
        Strings.stackedColumnChartVisualizationsLabel = "column chart";
        Strings.clusteredColumnChartVisualizationsLabel = "clustered column chart";
        Strings.hundredPercentColumnChartVisualizationsLabel = "100% stacked column chart";
        Strings.scatterChartVisualizationsLabel = "scatter chart";
        Strings.lineChartVisualizationsLabel = "line chart";
        Strings.pieChartVisualizationsLabel = "pie chart";
        Strings.mapVisualizationsLabel = "map";
        Strings.matrixVisualizationsLabel = "matrix";
        Strings.tableVisualizationsLabel = "table";
        Strings.cardVisualizationsLabel = "card";
        Strings.sharePointAppSettingsLinkLabel = "Settings";
        Strings.sharePointAppAddSamplesLinkLabel = "Add sample data...";
        Strings.sharePointAppSettingsPaneTitle = "Settings";
        Strings.sharePointAppCloseSettingsPaneButtonLabel = "Close";
        Strings.sharePointSettingsInvalidModelUrlLabel = "Please enter a valid URL";
        Strings.sharePointSettingsRetrievingModelLabel = "Looking for a workbook at the given URL...";
        Strings.sharePointSettingsModelNeedsPublishingLabel = "Your workbook needs to be enabled for web viewing before it can be searched with Power BI Q&A.";
        Strings.sharePointSettingsModelRetrievalFailedLabel = "There was a problem retrieving the specified workbook";
        Strings.sharePointSettingsModelRemovalFailedLabel = "There was a problem removing the specified workbook";
        Strings.sharePointSettingsDuplicateModelSpecifiedLabel = "The specified workbook has already been added";
        Strings.sharePointSettingsModelsSectionTitleLabel = "Models";
        Strings.sharePointSettingsModelsLoadingLabel = "Please wait...";
        Strings.sharePointSettingsAddModelDialogTitle = "Add workbook";
        Strings.sharePointSettingsAddModelBtnLabel = "Add workbook...";
        Strings.sharePointSettingsAddModelDialogText = "To add a new workbook, enter the workbook's URL in the box below and click 'Add'.";
        Strings.sharePointSettingsAddModelDialogAddActionLabel = "Add";
        Strings.sharePointSettingsRemoveModelBtnLabel = "Remove";
        Strings.sharePointSettingsRemoveModelDialogTitle = "Are you sure you want to remove this workbook?";
        Strings.sharePointSettingsRemoveModelDialogText = "This will remove {0} from the list of workbooks.";
        Strings.sharePointSettingsModelNameColumnLabel = "Workbook Name";
        Strings.sharePointSettingsModelUrlColumnLabel = "URL";
        Strings.sharePointSettingsModelStatusColumnLabel = "Status";
        Strings.sharePointSettingsModelsLoadFailedLabel = "We were unable to load the list of workbooks at this time, please try again later";
        Strings.sharePointSettingsBICenterAppNotInstalled = "Please install the BI Center app to configure Power BI Q&A";
        Strings.sharePointSettingsBICenterAppErrorInstallation = "Please fix the status of BI Center app to configure Power BI Q&A";
        Strings.sharePointSettingsModelsSectionFirstParagraghText = "These are the workbooks that Power BI Q&A will use when querying for results.";
        Strings.sharePointSettingsModelsSectionSecondParagraghText = "To add a workbook, click on the 'Add workbook...' button below. Similarly, you may remove previously added workbooks by clicking the Remove button for the corresponding workbook.";
        Strings.sharePointSettingsAddModelErrorText = "The add operation failed. Error: {0}";
        Strings.sharePointSettingsModelStatusNoneLabel = "None";
        Strings.sharePointSettingsModelStatusValidatingLabel = "Validating";
        Strings.sharePointSettingsModelStatusPublishingLabel = "Publishing";
        Strings.sharePointSettingsModelStatusDeletePendingLabel = "Deleting";
        Strings.sharePointSettingsModelStatusPublishSuccessfulLabel = "Published";
        Strings.sharePointSettingsModelPublishErrorNone = "None";
        Strings.sharePointSettingsModelPublishMissingError = "Workbook does not contain a model";
        Strings.sharePointSettingsModelPublishAboveLimitError = "Workbook size without model is above size limit";
        Strings.sharePointSettingsModelPublishXmlaError = "Xmla operation exception was thrown";
        Strings.sharePointSettingsModelNotPublishedError = "The workbook is not published";
        Strings.sharePointSettingsModelPublishCheckoutError = "Workbook in this checkout type is already being processed";
        Strings.sharePointSettingsModelPublishUnknownError = "Unknown error";
        Strings.addModelNonSharePointUrlError = "This is not a SharePoint URL. You must provide the URL of an Excel workbook in the current SharePoint site.";
        Strings.addModelSharePointDocumentNotFoundError = "No document exists for this URL. You must provide the URL of an Excel workbook in the current SharePoint site.";
        Strings.addModelSharePointInvalidUrlError = "This URL is not an Excel workbook. You must provide the URL of an Excel workbook in the current SharePoint site.";
        Strings.addModelSharePointUrlNotInCurrentSiteError = "This Excel workbook is not stored in the same site as the Power BI Q&A application is installed in.  You must provide the URL of an Excel workbook in the current SharePoint site.";
        Strings.addModelOperationFailedError = "The workbook could not be added at this time.  Please try again.  If the problem persists, please contact support.";
        Strings.addModelDisallowedError = "The workbook could not be added since it is disallowed by the server.";
        Strings.addModelErrorHelpLinkText = "Find out more about adding workbooks";
        Strings.sharePointAppLoadModelsErrorText = "There was a problem accessing the current set of workbooks. Refresh the page to try again.  If the problem persists, please contact support.";
        Strings.sharePointAppNoModelsConfiguredTitle = "You need to set up Power BI Q&A";
        Strings.sharePointAppNoModelsConfiguredMessage = "You need to choose the workbooks to search before you can start asking questions using Power BI Q&A.";
        Strings.sharePointAppNoModelsConfiguredUserTitle = "Oops, not ready yet";
        Strings.sharePointAppNoModelsConfiguredUserMessage = "No workbooks have been set up for Power BI Q&A. Contact a site owner to set up the site.";
        Strings.sharePointAppNoModelsActionLabel = "Go to settings...";
        Strings.sharePointSettingsAccessDeniedMessage = "You do not have permission to manage the Power BI Q&A application for this site.  Only Site Owners or users with the manage site permission level can manage the Power BI Q&A application.";
        Strings.dialogCancelActionLabel = "Cancel";
        Strings.dialogCloseActionLabel = "Close";
        Strings.dialogSendActionLabel = "Send";
        Strings.dialogRefreshPageActionLabel = "Refresh Page";
        Strings.dialogGoBackActionLabel = "Go Back";
        Strings.errorDialogTitle = "oops, something went wrong";
        Strings.fatalErrorDialogText = "The page could not be loaded at this time.  Refresh the page to try again.  If the problem persists, please contact support.";
        Strings.unsupportedUrlMessageText = "The URL of this page has changed. Please return to SharePoint to get the latest URL.";
        Strings.linguisticSchemaWarningTitle = "Get better search results";
        Strings.linguisticSchemaSingleWorkbookWarningTemplate = "{WorkbookLink} will return better results if you add language information to the workbook.";
        Strings.linguisticSchemaMultipleWorkbookWarningTemplate = "{WorkbookLink} and other workbooks will return better results if you add language information to the workbooks.";
        Strings.linguisticSchemaWarningMoreInfoLink = "Learn about language modeling";
        Strings.refinementPaneOpenWorkbookLabel = "Open workbook";
        Strings.refinementPaneLastModifiedDateFormat = "MMM' 'd', 'yyyy' at 'h':'mmtt";
        Strings.unsupportedBrowserMessageTitle = "Unsupported browser detected";
        Strings.unsupportedBrowserMessageText = "Power BI Q&A requires Internet Explorer 10 or higher, please upgrade your browser and try again";
        Strings.modelingClarifyTermCommand = "Help us understand what {term} means";
        Strings.modelingAddSynonymTermCommand = "Change how {term} is being understood";
        Strings.modelingTermHasNoTemplates = "Sorry, we don't have any suggestions for the term you selected";
        Strings.modelingSynonymTemplateDisplayText = "the same as";
        Strings.pendingAddModelOperationsText = "There are pending publish operations.";
        Strings.showCollageText = "See some other questions we do have answers for...";
        Strings.silverlightInstallRequiredText = "Power BI Q&A requires Silverlight 5. Click here to Install Silverlight";
        Strings.workbooksLoadingTimeoutTitle = "Please wait";
        Strings.workbooksLoadingTimeoutText = "Contacting Power BI Q&A service...";
        Strings.interpretRetryMaxCountExceededMessageText = "There was a timeout executing your query. Please try again later. If the problem persists, contact your administrator.";
        Strings.sharePointAppNoSamplesTitle = "We've been making some great changes to our sample workbooks";
        Strings.sharePointAppNoSamplesMessage = "Go back to the Power BI page, click the settings gear in the top right corner and click add sample data to update your samples.";
        Strings.powerBIChromeBrandingText = "Power BI for Office 365";
        Strings.notAuthenticatedErrorMessage = "You need to sign in before we can show you this page.  Click the Refresh Page button to continue.";
        Strings.tokenInvalidOrExpiredErrorText = "We couldn’t connect to Power BI right now.";
        Strings.connectionExpiredTitleText = "Connection expired";
        Strings.helpViewerControlTitleText = "ABOUT THIS DATA";
        Strings.helpViewerFeedbackBannerTitle = "Learn More. Give Feedback.";
        Strings.helpViewerFeedbackBannerText = "We're working to improve Power BI Q&A. Share feedback and learn more about what's coming next.";
        Strings.helpViewerHelpUnavailableCaptionText = "We're sorry, there is no help content available at this time.";
        Strings.helpViewerHelpLoadingCaptionText = "Looking for content...";
        Strings.backToBISiteLinkText = "Back to Power BI Site";
        Strings.showFeaturedQuestionsLinkText = "Show Featured Questions";
        Strings.copyResultLinkText = "Copy URL";
        Strings.shareResultLinkText = "Share";
        Strings.shareResultEmailSubjectText = "Check out this data insight";
        Strings.shareResultEmailBodyTemplateText = "{0}\r\rDiscovered with Power BI Q&A";
        Strings.resultLinkCopiedNotificationText = "A link to this result was copied to the clipboard.";
        Strings.CollageItemEditorAddItemTitle = "Feature a question";
        Strings.CollageItemEditorEditItemTitle = "Edit featured question";
        Strings.CollageItemEditorUtteranceFormRegionTitle = "Type a question";
        Strings.CollageItemEditorUtteranceInputPlaceholder = "Enter your question...";
        Strings.CollageItemEditorUtteranceInputCaption = "You can ask anything about the workbooks currently available on the site";
        Strings.CollageItemEditorUtteranceInputSearchingCaption = "We're trying to find an answer to your question...";
        Strings.CollageItemEditorUtteranceInputNoResultsCaption = "We're sorry, we couldn't find an answer to your question";
        Strings.CollageItemEditorUtteranceInputResultFoundCaption = "We've found an answer to your question!";
        Strings.CollageItemEditorFeatureOnPowerBICheckboxCaption = "Show on the Power BI site home page";
        Strings.CollageItemEditorTileSizeFormRegionTitle = "Tile size";
        Strings.CollageItemEditorTileSizeSmallCaption = "Small";
        Strings.CollageItemEditorTileSizeLargeCaption = "Large";
        Strings.CollageItemEditorTileColorRegionTitle = "Background color";
        Strings.CollageItemEditorTileIconRegionTitle = "Background icon";
        Strings.CollageItemCustomImageRegionTitle = "Background image";
        Strings.CollageItemCustomImageUrlInputPlaceholder = "Enter image URL here (optional)";
        Strings.CollageItemCustomImageUrlCaption = "For best results use an image that is 250 pixels wide or larger";
        Strings.CollageItemCustomImageUrlLoadingCaption = "Loading image...";
        Strings.CollageItemCustomImageUrlLoadErrorCaption = "We're sorry, we couldn't find an image at the specified location";
        Strings.CollageItemCustomImageUrlBadAddressCaption = "Please enter a valid URL";
        Strings.CollageItemCustomImageUrlSuccessCaption = "Image loaded successfully";
        Strings.CollageItemEditorPreviewRegionTitle = "Preview";
        Strings.CollageItemEditorSaveBtnTxt = "Save";
        Strings.CollageItemEditorCancelBtnTxt = "Cancel";
        Strings.CollageControlMaxNumberOfItemsMessageTitle = "Maximum number of featured questions reached";
        Strings.CollageControlMaxNumberOfItemsMessageText = "You have reached the maximum number of featured questions that can be displayed. Please remove some questions to continue";
        Strings.CollageDeleteItemDialogTitle = "Remove Featured Question";
        Strings.CollageDeleteItemDialogText = "Are you sure you want to permanently remove this featured question?";
        Strings.ModelSelectionControlPulldownDescriptionText = "results from";
        Strings.YesDialogOption = "Yes";
        Strings.NoDialogOption = "No";
        Strings.mainHelpPageTitle = "Q&A";
        Strings.mainHelpPageDescription = "Power BI Q&A makes it easy for anyone to discover and explore their data.";
        Strings.mainHelpPageWorkbookListTitle = "Workbooks";
        Strings.modelHelpPageDescription = "Here are some examples of questions you could ask about this workbook.";
        Strings.modelHelpPageQuestionListTitle = "Featured questions";
        Strings.helpPageAddFeaturedQuestion = "add featured question";
        Strings.helpPageFeaturedQuestions = "featured questions";
        Strings.helpPageNoItemsListed = "no items listed";
        Strings.flagUtteranceTooltip = "Flag the result of this question as not helpful.";
        Strings.utteranceFeedbackTooltip = "Help improve Q&A";
        Strings.utteranceFeedbackDialogTitle = "Q&A Feedback";
        Strings.utteranceFeedbackDialogPrompt = "Please rate how well Q&A helped find data to answer your question.";
        Strings.utteranceFeedbackResultBad = "Way Off";
        Strings.utteranceFeedbackResultMedium = "Got Close";
        Strings.utteranceFeedbackResultGood = "Great";
        Strings.modelSelectionHasErrors = "Some workbooks did not load successfully";
    })(Strings = InJs.Strings || (InJs.Strings = {}));
})(InJs || (InJs = {}));

var powerbi;

(function(powerbi) {
    var RejectablePromiseCache = function() {
        function RejectablePromiseCache(promiseFactory) {
            this.cache = {};
            this.promiseFactory = promiseFactory;
        }
        RejectablePromiseCache.prototype.getEntryCount = function() {
            return Object.keys(this.cache).length;
        };
        RejectablePromiseCache.prototype.hasCacheEntry = function(cacheKey) {
            debug.assertValue(cacheKey, "cacheKey");
            return !!this.getCacheEntry(cacheKey);
        };
        RejectablePromiseCache.prototype.createCacheEntry = function(cacheKey) {
            debug.assertValue(cacheKey, "cacheKey");
            var cacheEntry = this.getCacheEntry(cacheKey);
            if (!cacheKey || cacheEntry) return;
            if (this.getEntryCount() > RejectablePromiseCache.maxCacheEntries) this.cache = {};
            var promiseFactory = this.promiseFactory;
            var queryCache = this.cache;
            var deferred = promiseFactory.defer();
            var promise = powerbi.RejectablePromise(deferred);
            var entryDeferred = promiseFactory.defer();
            var entryPromise = powerbi.RejectablePromise(entryDeferred);
            cacheEntry = queryCache[cacheKey] = {
                promise: entryPromise,
                refCount: 0
            };
            promise.then(function(result) {
                if (cacheEntry.updateResult) result = cacheEntry.updateResult(result);
                cacheEntry.result = result;
                entryDeferred.resolve(result);
            }, function(reason) {
                return entryDeferred.reject(reason);
            }).finally(function() {
                delete cacheEntry.updateResult;
            });
            entryPromise.catch(function(reason) {
                return promise.reject();
            });
            entryPromise.finally(function() {
                if (queryCache[cacheKey]) {
                    delete queryCache[cacheKey].promise;
                    if (entryPromise.rejected()) delete queryCache[cacheKey];
                }
            });
            return {
                deferred: deferred,
                promise: promise
            };
        };
        RejectablePromiseCache.prototype.clearEntry = function(cacheKey, rejectPromise) {
            var cacheEntry = this.getCacheEntry(cacheKey);
            if (cacheEntry) {
                var cachePromise = cacheEntry.promise;
                if (rejectPromise && cachePromise) {
                    cachePromise.reject();
                } else {
                    delete this.cache[cacheKey];
                }
                return true;
            }
            return false;
        };
        RejectablePromiseCache.prototype.clearAllEntries = function(rejectPromise) {
            for (var cacheKey in this.cache) {
                this.clearEntry(cacheKey, rejectPromise);
            }
        };
        RejectablePromiseCache.prototype.bindCacheEntry = function(cacheKey) {
            debug.assertValue(cacheKey, "cacheKey");
            var cacheEntry = this.getCacheEntry(cacheKey);
            if (cacheEntry === undefined) return;
            var deferred = this.promiseFactory.defer();
            var promise = powerbi.RejectablePromise(deferred);
            if (cacheEntry.result) {
                deferred.resolve(cacheEntry.result);
                return promise;
            }
            var cachePromise = cacheEntry.promise;
            if (!cachePromise) {
                deferred.reject(null);
                return promise;
            }
            cacheEntry.refCount++;
            promise.finally(function() {
                cacheEntry.refCount--;
                if (cacheEntry.refCount === 0 && cachePromise.pending()) cachePromise.reject();
            });
            cachePromise.then(function(result) {
                return deferred.resolve(result);
            }, function(errorReason) {
                return deferred.reject(errorReason);
            });
            return promise;
        };
        RejectablePromiseCache.prototype.rewriteAllEntries = function(rewriter) {
            var keyUpdates = [];
            var hasRewriteKey = !!rewriter.rewriteKey;
            var hasRewriteResult = !!rewriter.rewriteResult;
            var queryCache = this.cache;
            for (var cacheKey in queryCache) {
                if (hasRewriteKey) {
                    var newKey = rewriter.rewriteKey(cacheKey);
                    if (newKey !== cacheKey) keyUpdates.push({
                        oldKey: cacheKey,
                        newKey: newKey
                    });
                }
                if (hasRewriteResult) {
                    var entry = queryCache[cacheKey];
                    if (entry && entry.result) {
                        entry.result = rewriter.rewriteResult(entry.result, cacheKey);
                    } else {
                        entry.updateResult = function(result) {
                            return rewriter.rewriteResult(result, cacheKey);
                        };
                    }
                }
            }
            for (var i = 0, length = keyUpdates.length; i < length; i++) this.changeCacheKey(keyUpdates[i].oldKey, keyUpdates[i].newKey);
        };
        RejectablePromiseCache.prototype.changeCacheKey = function(oldKey, newKey) {
            if (!newKey) {
                return this.clearEntry(oldKey, true);
            }
            if (this.hasCacheEntry(newKey) || !this.hasCacheEntry(oldKey)) return false;
            var cacheEntry = this.getCacheEntry(oldKey);
            delete this.cache[oldKey];
            this.cache[newKey] = cacheEntry;
            return true;
        };
        RejectablePromiseCache.prototype.getCacheEntry = function(cacheKey) {
            debug.assertValue(cacheKey, "cacheKey");
            var entry;
            if (!!cacheKey && (entry = this.cache[cacheKey]) && (entry.promise || entry.result)) {
                return entry;
            }
            return;
        };
        RejectablePromiseCache.maxCacheEntries = 100;
        return RejectablePromiseCache;
    }();
    powerbi.RejectablePromiseCache = RejectablePromiseCache;
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var doc = document, headElement = doc.head, firstScriptInHeadElement = headElement.getElementsByTagName("script")[0], linkElement = doc.createElement("link"), scriptElement = doc.createElement("script"), styleSheetLoaded = [], javaScriptFilesLoaded = [], javaScriptFilesLoading = [];
    linkElement.setAttribute("rel", "stylesheet");
    function requires(dependency, to) {
        if (to === void 0) {
            to = function() {};
        }
        loadStyleSheets(dependency.cssFiles || []);
        var scriptsToRun = dependency.javaScriptFilesWithCallback || [];
        if (dependency.javaScriptFiles) {
            for (var i = 0, len = dependency.javaScriptFiles.length; i < len; ++i) {
                scriptsToRun.push({
                    javascriptFile: dependency.javaScriptFiles[i]
                });
            }
        }
        loadJavaScriptFiles(scriptsToRun, to);
    }
    jsCommon.requires = requires;
    function loadStyleSheets(hrefList) {
        hrefList.forEach(function(href) {
            if (styleSheetLoaded.indexOf(href) === -1) {
                styleSheetLoaded.push(href);
                loadStyleSheet(href);
            }
        });
    }
    function loadJavaScriptFiles(scripts, callback) {
        var loadingCount = scripts.length, parsingCount = loadingCount, sourceCodeList = [];
        function parseIfLoadingComplete() {
            if (!--loadingCount) {
                parseJavaScriptSourceCodes(scripts, sourceCodeList);
            }
        }
        function makeCallbackIfParsingComplete() {
            if (!--parsingCount) {
                callback();
            }
        }
        scripts.forEach(function(script, index) {
            var file = script.javascriptFile;
            if (javaScriptFilesLoaded.indexOf(file) === -1) {
                if (file in javaScriptFilesLoading) {
                    javaScriptFilesLoading[file].push(function() {
                        parseIfLoadingComplete();
                        makeCallbackIfParsingComplete();
                    });
                } else {
                    javaScriptFilesLoading[file] = [ function() {
                        makeCallbackIfParsingComplete();
                    } ];
                    if (isExternalUrl(file)) {
                        sourceCodeList[index] = script;
                        parseIfLoadingComplete();
                    } else {
                        loadJavaScriptSourceCode(file, function(sourceCode) {
                            sourceCodeList[index] = {
                                javascriptFile: sourceCode
                            };
                            parseIfLoadingComplete();
                        });
                    }
                }
            } else {
                parseIfLoadingComplete();
                makeCallbackIfParsingComplete();
            }
        });
    }
    function loadStyleSheet(href) {
        var link = linkElement.cloneNode();
        link.href = href;
        if (firstScriptInHeadElement) {
            headElement.insertBefore(link, firstScriptInHeadElement);
        } else {
            headElement.appendChild(link);
        }
    }
    function loadJavaScriptSourceCode(src, onload) {
        webGet(src, function() {
            onload(this.responseText);
        });
    }
    function parseJavaScript(script, onComplete) {
        if (onComplete === void 0) {
            onComplete = function() {};
        }
        if (!script) {
            onComplete();
            return;
        }
        var sourceCodeOrFileName = script.javascriptFile;
        var targetCallback = onComplete;
        if (script.onLoadCallback) {
            var promiseAsCallback = function() {
                script.onLoadCallback().then(onComplete);
            };
            targetCallback = promiseAsCallback;
        }
        isExternalUrl(sourceCodeOrFileName) ? loadExternalJavaScriptFile(sourceCodeOrFileName, targetCallback) : parseInternalJavaScriptCode(sourceCodeOrFileName, targetCallback);
    }
    function parseInternalJavaScriptCode(sourceCode, onComplete) {
        if (onComplete === void 0) {
            onComplete = function() {};
        }
        var script;
        if (sourceCode) {
            script = scriptElement.cloneNode();
            script.setAttribute("type", "text/javascript");
            script.innerHTML = sourceCode;
            headElement.appendChild(script);
        }
        setTimeout(onComplete, 0);
    }
    function loadExternalJavaScriptFile(src, onload) {
        var script;
        if (src) {
            script = scriptElement.cloneNode();
            script.setAttribute("src", src);
            script.setAttribute("charset", "utf-8");
            script.onload = onload;
            headElement.appendChild(script);
        }
    }
    function parseJavaScriptSourceCodes(scripts, sourceCodeList) {
        asyncLoop(sourceCodeList, parseJavaScript, function() {
            scripts.forEach(function(script) {
                var file = script.javascriptFile;
                var listeners = javaScriptFilesLoading[file];
                if (listeners) {
                    listeners.forEach(function(listener) {
                        listener();
                    });
                }
                delete javaScriptFilesLoading[file];
                if (javaScriptFilesLoaded.indexOf(file) === -1) {
                    javaScriptFilesLoaded.push(file);
                }
            });
        });
    }
    function webGet(src, onload, onerror) {
        var xhr = new XMLHttpRequest();
        try {
            xhr.open("GET", src, true);
            xhr.onload = onload;
            xhr.onerror = onerror;
            xhr.send(null);
        } catch (e) {}
    }
    function isExternalUrl(url) {
        var origin = location.protocol + "//" + location.host + "/";
        return /^http[s]?:\/\/.+/i.test(url) && url.indexOf(origin) !== 0;
    }
    function _() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
    }
    function asyncSteps() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (args.length === 0) {
            return;
        }
        var steps = [], i = args.length;
        while (i--) {
            (function(j) {
                steps[j] = function() {
                    args[j](steps[j + 1] || _);
                };
            })(i);
        }
        steps[0]();
    }
    function asyncLoop(enumerable, func, callback) {
        var steps = [], i = 0, len = enumerable.length;
        for (;i < len - 1; i++) {
            (function(i) {
                steps[i] = function(next) {
                    func(enumerable[i], next);
                };
            })(i);
        }
        steps[len - 1] = function(next) {
            func(enumerable[len - 1], callback);
        };
        asyncSteps.apply(null, steps);
    }
})(jsCommon || (jsCommon = {}));

var powerbi;

(function(powerbi) {
    powerbi.CategoryTypes = {
        Address: "Address",
        City: "City",
        Continent: "Continent",
        CountryRegion: "Country",
        County: "County",
        Longitude: "Longitude",
        Latitude: "Latitude",
        Place: "Place",
        PostalCode: "PostalCode",
        StateOrProvince: "StateOrProvince"
    };
    function createGeoTaggingAnalyzerService(getLocalized) {
        return new GeoTaggingAnalyzerService(getLocalized);
    }
    powerbi.createGeoTaggingAnalyzerService = createGeoTaggingAnalyzerService;
    var GeoTaggingAnalyzerService = function() {
        function GeoTaggingAnalyzerService(getLocalized) {
            this.GeotaggingString_VRMBackCompat_CountryRegion = "CountryRegion";
            this.GeotaggingString_VRMBackCompat_StateOrProvince = "StateOrProvince";
            this.GeotaggingString_Continent = getLocalized("GeotaggingString_Continent").toLowerCase();
            this.GeotaggingString_Continents = getLocalized("GeotaggingString_Continents").toLowerCase();
            this.GeotaggingString_Country = getLocalized("GeotaggingString_Country").toLowerCase();
            this.GeotaggingString_Countries = getLocalized("GeotaggingString_Countries").toLowerCase();
            this.GeotaggingString_State = getLocalized("GeotaggingString_State").toLowerCase();
            this.GeotaggingString_States = getLocalized("GeotaggingString_States").toLowerCase();
            this.GeotaggingString_City = getLocalized("GeotaggingString_City").toLowerCase();
            this.GeotaggingString_Cities = getLocalized("GeotaggingString_Cities").toLowerCase();
            this.GeotaggingString_Town = getLocalized("GeotaggingString_Town").toLowerCase();
            this.GeotaggingString_Towns = getLocalized("GeotaggingString_Towns").toLowerCase();
            this.GeotaggingString_Province = getLocalized("GeotaggingString_Province").toLowerCase();
            this.GeotaggingString_Provinces = getLocalized("GeotaggingString_Provinces").toLowerCase();
            this.GeotaggingString_County = getLocalized("GeotaggingString_County").toLowerCase();
            this.GeotaggingString_Counties = getLocalized("GeotaggingString_Counties").toLowerCase();
            this.GeotaggingString_Village = getLocalized("GeotaggingString_Village").toLowerCase();
            this.GeotaggingString_Villages = getLocalized("GeotaggingString_Villages").toLowerCase();
            this.GeotaggingString_Post = getLocalized("GeotaggingString_Post").toLowerCase();
            this.GeotaggingString_Zip = getLocalized("GeotaggingString_Zip").toLowerCase();
            this.GeotaggingString_Code = getLocalized("GeotaggingString_Code").toLowerCase();
            this.GeotaggingString_Place = getLocalized("GeotaggingString_Place").toLowerCase();
            this.GeotaggingString_Places = getLocalized("GeotaggingString_Places").toLowerCase();
            this.GeotaggingString_Address = getLocalized("GeotaggingString_Address").toLowerCase();
            this.GeotaggingString_Addresses = getLocalized("GeotaggingString_Addresses").toLowerCase();
            this.GeotaggingString_Street = getLocalized("GeotaggingString_Street").toLowerCase();
            this.GeotaggingString_Streets = getLocalized("GeotaggingString_Streets").toLowerCase();
            this.GeotaggingString_Longitude = getLocalized("GeotaggingString_Longitude").toLowerCase();
            this.GeotaggingString_Longitude_Short = getLocalized("GeotaggingString_Longitude_Short").toLowerCase();
            this.GeotaggingString_Latitude = getLocalized("GeotaggingString_Latitude").toLowerCase();
            this.GeotaggingString_Latitude_Short = getLocalized("GeotaggingString_Latitude_Short").toLowerCase();
            this.GeotaggingString_PostalCode = getLocalized("GeotaggingString_PostalCode").toLowerCase();
            this.GeotaggingString_PostalCodes = getLocalized("GeotaggingString_PostalCodes").toLowerCase();
            this.GeotaggingString_ZipCode = getLocalized("GeotaggingString_ZipCode").toLowerCase();
            this.GeotaggingString_ZipCodes = getLocalized("GeotaggingString_ZipCodes").toLowerCase();
            this.GeotaggingString_Territory = getLocalized("GeotaggingString_Territory").toLowerCase();
            this.GeotaggingString_Territories = getLocalized("GeotaggingString_Territories").toLowerCase();
        }
        GeoTaggingAnalyzerService.prototype.isLongitudeOrLatitude = function(fieldRefName) {
            return this.isLongitude(fieldRefName) || this.isLatitude(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeographic = function(fieldRefName) {
            return this.isLongitudeOrLatitude(fieldRefName) || this.isGeocodable(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeocodable = function(fieldRefName) {
            return this.isAddress(fieldRefName) || this.isCity(fieldRefName) || this.isContinent(fieldRefName) || this.isCountry(fieldRefName) || this.isCounty(fieldRefName) || this.isStateOrProvince(fieldRefName) || this.isPlace(fieldRefName) || this.isPostalCode(fieldRefName) || this.isTerritory(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isAddress = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Address, this.GeotaggingString_Addresses, this.GeotaggingString_Street, this.GeotaggingString_Streets ]);
        };
        GeoTaggingAnalyzerService.prototype.isPlace = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Place, this.GeotaggingString_Places ]);
        };
        GeoTaggingAnalyzerService.prototype.isCity = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_City, this.GeotaggingString_Cities, this.GeotaggingString_Town, this.GeotaggingString_Towns, this.GeotaggingString_Village, this.GeotaggingString_Villages ]);
        };
        GeoTaggingAnalyzerService.prototype.isStateOrProvince = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_State, this.GeotaggingString_States, this.GeotaggingString_Province, this.GeotaggingString_Provinces, this.GeotaggingString_VRMBackCompat_StateOrProvince ]);
        };
        GeoTaggingAnalyzerService.prototype.isCountry = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Country, this.GeotaggingString_Countries, this.GeotaggingString_VRMBackCompat_CountryRegion ]);
        };
        GeoTaggingAnalyzerService.prototype.isCounty = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_County, this.GeotaggingString_Counties ]);
        };
        GeoTaggingAnalyzerService.prototype.isContinent = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Continent, this.GeotaggingString_Continents ]);
        };
        GeoTaggingAnalyzerService.prototype.isPostalCode = function(fieldRefName) {
            var result = GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Post, this.GeotaggingString_Zip ]) && GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Code ]) || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_PostalCode, this.GeotaggingString_PostalCodes, this.GeotaggingString_ZipCode, this.GeotaggingString_ZipCodes ]);
            if (!result) {
                var whiteSpaceRegexPattern = new RegExp("s");
                result = GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_PostalCode.replace(whiteSpaceRegexPattern, ""), this.GeotaggingString_PostalCodes.replace(whiteSpaceRegexPattern, ""), this.GeotaggingString_ZipCode.replace(whiteSpaceRegexPattern, ""), this.GeotaggingString_ZipCodes.replace(whiteSpaceRegexPattern, "") ]);
            }
            return result;
        };
        GeoTaggingAnalyzerService.prototype.isLongitude = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Longitude, this.GeotaggingString_Longitude_Short ]);
        };
        GeoTaggingAnalyzerService.prototype.isLatitude = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Latitude, this.GeotaggingString_Latitude_Short ]);
        };
        GeoTaggingAnalyzerService.prototype.isTerritory = function(fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [ this.GeotaggingString_Territory, this.GeotaggingString_Territories ]);
        };
        GeoTaggingAnalyzerService.hasMatches = function(fieldName, possibleMatches) {
            var value = fieldName.toLowerCase();
            for (var i = 0, len = possibleMatches.length; i < len; i++) {
                var possibleMatch = possibleMatches[i];
                if (value.indexOf(possibleMatch) > -1) return true;
            }
            return false;
        };
        GeoTaggingAnalyzerService.prototype.getFieldType = function(fieldName) {
            if (fieldName == null) return undefined;
            if (this.isLatitude(fieldName)) return powerbi.CategoryTypes.Latitude;
            if (this.isLongitude(fieldName)) return powerbi.CategoryTypes.Longitude;
            if (this.isPostalCode(fieldName)) return powerbi.CategoryTypes.PostalCode;
            if (this.isAddress(fieldName)) return powerbi.CategoryTypes.Address;
            if (this.isPlace(fieldName)) return powerbi.CategoryTypes.Place;
            if (this.isCity(fieldName)) return powerbi.CategoryTypes.City;
            if (this.isCountry(fieldName)) return powerbi.CategoryTypes.CountryRegion;
            if (this.isCounty(fieldName)) return powerbi.CategoryTypes.County;
            if (this.isStateOrProvince(fieldName)) return powerbi.CategoryTypes.StateOrProvince;
            if (this.isContinent(fieldName)) return powerbi.CategoryTypes.Continent;
            return undefined;
        };
        return GeoTaggingAnalyzerService;
    }();
    powerbi.GeoTaggingAnalyzerService = GeoTaggingAnalyzerService;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    function createJQueryPromiseFactory() {
        return new JQueryPromiseFactory();
    }
    powerbi.createJQueryPromiseFactory = createJQueryPromiseFactory;
    var JQueryPromiseFactory = function() {
        function JQueryPromiseFactory() {}
        JQueryPromiseFactory.prototype.defer = function() {
            return new JQueryDeferredWrapper($.Deferred());
        };
        JQueryPromiseFactory.prototype.reject = function(reason) {
            var deferred = this.defer();
            deferred.reject(reason);
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.resolve = function(value) {
            var deferred = this.defer();
            deferred.resolve(value);
            return deferred.promise;
        };
        return JQueryPromiseFactory;
    }();
    var JQueryDeferredWrapper = function() {
        function JQueryDeferredWrapper(deferred) {
            debug.assertValue(deferred, "deferred");
            this.deferred = deferred;
            this.promise = new JQueryPromiseWrapper(deferred.promise());
        }
        JQueryDeferredWrapper.prototype.resolve = function(value) {
            this.deferred.resolve(value);
        };
        JQueryDeferredWrapper.prototype.reject = function(reason) {
            this.deferred.reject(reason);
        };
        return JQueryDeferredWrapper;
    }();
    var JQueryPromiseWrapper = function() {
        function JQueryPromiseWrapper(promise) {
            debug.assertValue(promise, "promise");
            this.promise = promise;
        }
        JQueryPromiseWrapper.prototype.then = function(a, b) {
            return new JQueryPromiseWrapper(this.promise.then(JQueryPromiseWrapper.wrapCallback(a), JQueryPromiseWrapper.wrapCallback(b)));
        };
        JQueryPromiseWrapper.prototype.catch = function(callback) {
            return this.then(null, callback);
        };
        JQueryPromiseWrapper.prototype.finally = function(callback) {
            this.promise.always(JQueryPromiseWrapper.wrapCallback(callback));
            return this;
        };
        JQueryPromiseWrapper.wrapCallback = function(callback) {
            if (callback) return function(arg) {
                var value = callback(arg);
                if (value instanceof JQueryPromiseWrapper) return value.promise;
                return value;
            };
            return callback;
        };
        return JQueryPromiseWrapper;
    }();
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var LocalStorageService = function() {
        function LocalStorageService() {}
        LocalStorageService.prototype.getData = function(key) {
            try {
                if (localStorage) {
                    return JSON.parse(localStorage[key]);
                }
            } catch (exception) {}
            return null;
        };
        LocalStorageService.prototype.setData = function(key, data) {
            try {
                if (localStorage) {
                    localStorage[key] = JSON.stringify(data);
                }
            } catch (e) {}
        };
        return LocalStorageService;
    }();
    powerbi.localStorageService = new LocalStorageService();
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var TextMeasurementService;
    (function(TextMeasurementService) {
        var spanElement;
        var svgTextElement;
        var canvasCtx;
        function ensureDOM() {
            if (spanElement) return;
            spanElement = $("<span/>");
            $("body").append(spanElement);
            svgTextElement = d3.select($("body").get(0)).append("svg").style({
                height: "0px",
                width: "0px",
                position: "absolute"
            }).append("text");
            canvasCtx = $("<canvas/>").get(0).getContext("2d");
        }
        function measureTextWidth(textProperties) {
            ensureDOM();
            spanElement.removeAttr("style").empty().css("visibility", "hidden");
            spanElement.text(textProperties.text).css({
                fontFamily: textProperties.fontFamily,
                fontSize: textProperties.fontSize,
                fontWeight: textProperties.fontWeight,
                fontStyle: textProperties.fontStyle,
                whiteSpace: textProperties.whiteSpace || "nowrap"
            });
            var measuredWidth = parseInt(getComputedStyle(spanElement[0]).width, 10);
            return measuredWidth;
        }
        TextMeasurementService.measureTextWidth = measureTextWidth;
        function measureSvgTextWidth(textProperties) {
            ensureDOM();
            canvasCtx.font = textProperties.fontSize + " " + textProperties.fontFamily;
            return canvasCtx.measureText(textProperties.text).width;
        }
        TextMeasurementService.measureSvgTextWidth = measureSvgTextWidth;
        function measureSvgTextHeight(textProperties) {
            ensureDOM();
            svgTextElement.style(null);
            svgTextElement.text(textProperties.text).attr({
                visibility: "hidden",
                "font-family": textProperties.fontFamily,
                "font-size": textProperties.fontSize,
                "font-weight": textProperties.fontWeight,
                "font-style": textProperties.fontStyle,
                "white-space": textProperties.whiteSpace || "nowrap"
            });
            return svgTextElement.node().getBoundingClientRect().height;
        }
        TextMeasurementService.measureSvgTextHeight = measureSvgTextHeight;
        function measureSvgTextElementWidth(svgElement) {
            return measureSvgTextWidth(getSvgMeasurementProperties(svgElement));
        }
        TextMeasurementService.measureSvgTextElementWidth = measureSvgTextElementWidth;
        function getMeasurementProperties(element) {
            return {
                text: element.val() || element.text(),
                fontFamily: element.css("font-family"),
                fontSize: element.css("font-size"),
                fontWeight: element.css("font-weight"),
                fontStyle: element.css("font-style"),
                whiteSpace: element.css("white-space")
            };
        }
        TextMeasurementService.getMeasurementProperties = getMeasurementProperties;
        function getSvgMeasurementProperties(svgElement) {
            var style = window.getComputedStyle(svgElement, null);
            return {
                text: svgElement.textContent,
                fontFamily: style.fontFamily,
                fontSize: style.fontSize,
                fontWeight: style.fontWeight,
                fontStyle: style.fontStyle,
                whiteSpace: style.whiteSpace
            };
        }
        TextMeasurementService.getSvgMeasurementProperties = getSvgMeasurementProperties;
        function getDivElementWidth(element) {
            debug.assert(element.is("div"), "Given element is not a div type. Cannot get width");
            return getComputedStyle(element[0]).width;
        }
        TextMeasurementService.getDivElementWidth = getDivElementWidth;
        function getTailoredTextOrDefault(properties, maxWidth) {
            ensureDOM();
            var dotsString = "...";
            debug.assertValue(properties, "properties");
            debug.assertValue(properties.text, "properties.text");
            var strLength = properties.text.length;
            if (strLength === 0) return properties.text;
            var width = measureSvgTextWidth(properties);
            if (width < maxWidth) return properties.text;
            var text = properties.text = dotsString + properties.text;
            var min = 1;
            var max = text.length;
            var i = 3;
            while (min <= max) {
                i = (min + max) / 2 | 0;
                properties.text = text.substr(0, i);
                width = measureSvgTextWidth(properties);
                if (maxWidth > width) min = i + 1; else if (maxWidth < width) max = i - 1; else break;
            }
            properties.text = text.substr(0, i);
            width = measureSvgTextWidth(properties);
            if (width > maxWidth) i--;
            return text.substr(3, i - 3) + dotsString;
        }
        TextMeasurementService.getTailoredTextOrDefault = getTailoredTextOrDefault;
        function svgEllipsis(textElement, maxWidth) {
            var properties = getSvgMeasurementProperties(textElement);
            var originalText = properties.text;
            var tailoredText = getTailoredTextOrDefault(properties, maxWidth);
            if (originalText !== tailoredText) {
                textElement.textContent = tailoredText;
            }
        }
        TextMeasurementService.svgEllipsis = svgEllipsis;
    })(TextMeasurementService = powerbi.TextMeasurementService || (powerbi.TextMeasurementService = {}));
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var UnionExtensions;
    (function(UnionExtensions) {
        function mergeUnionType(arg1, arg2, arg3) {
            if (!arg1 && !arg2 && !arg3) return;
            if (arg1 && !arg2 && !arg3) return arg1;
            if (!arg1 && arg2 && !arg3) return arg2;
            if (!arg1 && !arg2 && arg3) return arg3;
            return $.extend(arg1, arg2, arg3);
        }
        UnionExtensions.mergeUnionType = mergeUnionType;
    })(UnionExtensions = jsCommon.UnionExtensions || (jsCommon.UnionExtensions = {}));
})(jsCommon || (jsCommon = {}));

var InJs;

(function(InJs) {
    var InfoNavUtility = function() {
        function InfoNavUtility() {}
        InfoNavUtility.constructAdditionalErrorInfoBlock = function(statusCode, errorType, activityId, requestId, timeStamp, scriptError) {
            var additionalErrorInfo = $("<p />");
            if (!jsCommon.StringExtensions.isNullOrEmpty(statusCode)) {
                var errorCode = statusCode;
                if (!jsCommon.StringExtensions.isNullOrEmpty(errorType)) {
                    errorCode = jsCommon.StringExtensions.format(InJs.Strings.infoNavErrorCodeTemplate, statusCode, errorType);
                }
                additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorCodeText, errorCode));
            }
            if (!jsCommon.StringExtensions.isNullOrEmpty(activityId)) {
                additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorActivityIdText, activityId));
            }
            if (!jsCommon.StringExtensions.isNullOrEmpty(requestId)) {
                additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorRequestIdText, requestId));
            }
            if (scriptError) {
                if (scriptError.sourceUrl) {
                    additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorSourceFileText, scriptError.sourceUrl));
                }
                if (scriptError.lineNumber) {
                    additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorLineNumberText, scriptError.lineNumber.toString()));
                }
                if (scriptError.columnNumber) {
                    additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorColumnNumberText, scriptError.columnNumber.toString()));
                }
                if (scriptError.stack) {
                    additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorStackTraceText, scriptError.stack));
                }
            }
            if (!timeStamp) {
                timeStamp = new Date();
            }
            additionalErrorInfo.append(InfoNavUtility.constructErrorField(InJs.Strings.errorTimestampText, timeStamp.toString()));
            return additionalErrorInfo;
        };
        InfoNavUtility.constructShowDetailsContainer = function(additionalErrorInfo) {
            var additionalErrorInfoContainer = $("<div />");
            var showDetailsLink = $("<a class=\"showAdditionalDetailsLink\" href='javascript:' />");
            showDetailsLink.addClass(InfoNavUtility.infonavShowAdditionalErrorClass);
            showDetailsLink.text(InJs.Strings.showDetailsText);
            showDetailsLink.on(jsCommon.DOMConstants.mouseClickEventName, function(e) {
                additionalErrorInfoContainer.find(jsCommon.Utility.createClassSelector(InfoNavUtility.infonavShowAdditionalErrorClass)).remove();
                additionalErrorInfoContainer.find(jsCommon.Utility.createClassSelector(InfoNavUtility.infonavAdditionalErrorClass)).css(jsCommon.CssConstants.displayProperty, jsCommon.CssConstants.blockValue);
            });
            additionalErrorInfo.css(jsCommon.CssConstants.displayProperty, jsCommon.CssConstants.noneValue);
            additionalErrorInfo.addClass(InfoNavUtility.infonavAdditionalErrorClass);
            additionalErrorInfoContainer.append(showDetailsLink);
            additionalErrorInfoContainer.append(additionalErrorInfo);
            return additionalErrorInfoContainer;
        };
        InfoNavUtility.constructErrorField = function(fieldTitle, fieldValue) {
            var retValue = $(InfoNavUtility.infoNavErrorInfoFieldTemplate.replace("{FieldTitle}", fieldTitle));
            retValue.find(".infonav-errorInfoText").multiline(fieldValue);
            return retValue;
        };
        InfoNavUtility.infonavAdditionalErrorClass = "infonav-additionalError";
        InfoNavUtility.infonavShowAdditionalErrorClass = "infonav-showAdditionalError";
        InfoNavUtility.infoNavErrorInfoFieldTemplate = '<div class="infonav-errorInfoItem">' + '<span class="infonav-errorInfoHeader">{FieldTitle}</span>' + '<span class="infonav-errorInfoText">{FieldValue}</span>' + "</div>";
        return InfoNavUtility;
    }();
    InJs.InfoNavUtility = InfoNavUtility;
})(InJs || (InJs = {}));

var jsCommon;

(function(jsCommon) {
    var DeferredBatch = function() {
        function DeferredBatch(operation, timerFactory, maxBatchSize) {
            debug.assertValue(operation, "operation");
            this._operation = operation;
            this._timerFactory = timerFactory || jsCommon.TimerPromiseFactory.instance;
            this._batches = [];
            if (maxBatchSize) {
                this._maxBatchSize = maxBatchSize;
                this._batchSize = 0;
            }
        }
        DeferredBatch.prototype.enqueue = function() {
            var _this = this;
            var current = this._batches, currentBatch;
            ++this._batchSize;
            if (current.length === 0) {
                currentBatch = $.Deferred();
                current.push(currentBatch);
                this._timerFactory.create(0).done(function() {
                    return _this.completeBatches();
                });
            } else if (this._maxBatchSize && this._batchSize >= this._maxBatchSize) {
                this._batchSize = 0;
                currentBatch = $.Deferred();
                current.push(currentBatch);
            } else {
                currentBatch = current[current.length - 1];
            }
            return currentBatch.promise();
        };
        DeferredBatch.prototype.completeBatches = function() {
            var batch;
            while (batch = this._batches.pop()) this.completeBatch(batch);
        };
        DeferredBatch.prototype.completeBatch = function(batch) {
            this._operation().done(function(r) {
                return batch.resolve(r);
            }).fail(function(r) {
                return batch.reject(r);
            });
        };
        return DeferredBatch;
    }();
    jsCommon.DeferredBatch = DeferredBatch;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var ThrottleUtility = function() {
        function ThrottleUtility(delay) {
            this.timerFactory = jsCommon.TimerPromiseFactory.instance;
            this.delay = 0;
            if (delay) {
                this.delay = delay;
            }
        }
        ThrottleUtility.prototype.run = function(fn) {
            var _this = this;
            if (!this.fn) {
                this.fn = fn;
                this.timerFactory.create(this.delay).done(function() {
                    return _this.timerComplete(_this.fn);
                });
            } else {
                this.fn = fn;
            }
        };
        ThrottleUtility.prototype.timerComplete = function(fn) {
            fn();
            this.fn = null;
        };
        return ThrottleUtility;
    }();
    jsCommon.ThrottleUtility = ThrottleUtility;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var TimerPromiseFactory = function() {
        function TimerPromiseFactory() {}
        TimerPromiseFactory.prototype.create = function(delayInMs) {
            debug.assertValue(delayInMs, "delayInMs");
            debug.assert(delayInMs >= 0, "delayInMs must be a positive value.");
            var deferred = $.Deferred();
            window.setTimeout(function() {
                return deferred.resolve();
            }, delayInMs);
            return deferred;
        };
        TimerPromiseFactory.instance = new TimerPromiseFactory();
        return TimerPromiseFactory;
    }();
    jsCommon.TimerPromiseFactory = TimerPromiseFactory;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    (function(HttpStatusCode) {
        HttpStatusCode[HttpStatusCode["OK"] = 200] = "OK";
        HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
        HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
        HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
        HttpStatusCode[HttpStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    })(jsCommon.HttpStatusCode || (jsCommon.HttpStatusCode = {}));
    var HttpStatusCode = jsCommon.HttpStatusCode;
    var HttpConstants;
    (function(HttpConstants) {
        HttpConstants.ApplicationOctetStream = "application/octet-stream";
        HttpConstants.MultiPartFormData = "multipart/form-data";
    })(HttpConstants = jsCommon.HttpConstants || (jsCommon.HttpConstants = {}));
    var StringExtensions;
    (function(StringExtensions) {
        function format() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var s = args[0];
            if (isNullOrUndefinedOrWhiteSpaceString(s)) return s;
            for (var i = 0; i < args.length - 1; i++) {
                var reg = new RegExp("\\{" + i + "\\}", "gm");
                s = s.replace(reg, args[i + 1]);
            }
            return s;
        }
        StringExtensions.format = format;
        function equalIgnoreCase(a, b) {
            return StringExtensions.normalizeCase(a) === StringExtensions.normalizeCase(b);
        }
        StringExtensions.equalIgnoreCase = equalIgnoreCase;
        function startsWithIgnoreCase(a, b) {
            var normalizedSearchString = StringExtensions.normalizeCase(b);
            return StringExtensions.normalizeCase(a).indexOf(normalizedSearchString) === 0;
        }
        StringExtensions.startsWithIgnoreCase = startsWithIgnoreCase;
        function normalizeCase(value) {
            Utility.throwIfNullOrUndefined(value, StringExtensions, "normalizeCase", "value");
            return value.toUpperCase();
        }
        StringExtensions.normalizeCase = normalizeCase;
        function isNullOrEmpty(value) {
            return value == null || value.length === 0;
        }
        StringExtensions.isNullOrEmpty = isNullOrEmpty;
        function isNullOrUndefinedOrWhiteSpaceString(str) {
            return StringExtensions.isNullOrEmpty(str) || StringExtensions.isNullOrEmpty(str.trim());
        }
        StringExtensions.isNullOrUndefinedOrWhiteSpaceString = isNullOrUndefinedOrWhiteSpaceString;
        function containsWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, "containsWhitespace", "str");
            var expr = /\s/;
            return expr.test(str);
        }
        StringExtensions.containsWhitespace = containsWhitespace;
        function isWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, "isWhitespace", "str");
            return str.trim() === "";
        }
        StringExtensions.isWhitespace = isWhitespace;
        function trimTrailingWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, "trimTrailingWhitespace", "str");
            return str.replace(/\s+$/, "");
        }
        StringExtensions.trimTrailingWhitespace = trimTrailingWhitespace;
        function trimWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, "trimWhitespace", "str");
            return str.replace(/^\s+/, "").replace(/\s+$/, "");
        }
        StringExtensions.trimWhitespace = trimWhitespace;
        function getLengthDifference(left, right) {
            Utility.throwIfNullOrUndefined(left, this, "getLengthDifference", "left");
            Utility.throwIfNullOrUndefined(right, this, "getLengthDifference", "right");
            return Math.abs(left.length - right.length);
        }
        StringExtensions.getLengthDifference = getLengthDifference;
        function repeat(char, count) {
            var result = "";
            for (var i = 0; i < count; i++) {
                result += char;
            }
            return result;
        }
        StringExtensions.repeat = repeat;
        function replaceAll(text, textToFind, textToReplace) {
            if (!textToFind) return text;
            var pattern = textToFind.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1");
            return text.replace(new RegExp(pattern, "g"), textToReplace);
        }
        StringExtensions.replaceAll = replaceAll;
        function findUniqueName(usedNames, baseName) {
            debug.assertValue(usedNames, "usedNames");
            debug.assertValue(baseName, "baseName");
            var i = 0, uniqueName = baseName;
            while (usedNames[uniqueName]) {
                uniqueName = baseName + ++i;
            }
            return uniqueName;
        }
        StringExtensions.findUniqueName = findUniqueName;
    })(StringExtensions = jsCommon.StringExtensions || (jsCommon.StringExtensions = {}));
    var Utility = function() {
        function Utility() {}
        Utility.throwIfNullOrUndefined = function(value, context, methodName, parameterName) {
            if (value === null) {
                Utility.throwException(jsCommon.Errors.argumentNull(Utility.getComponentName(context) + methodName + "." + parameterName));
            } else if (typeof value === Utility.Undefined) {
                Utility.throwException(jsCommon.Errors.argumentUndefined(Utility.getComponentName(context) + methodName + "." + parameterName));
            }
        };
        Utility.throwIfNullOrEmpty = function(value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (!value.length) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + "." + parameterName));
            }
        };
        Utility.throwIfNullOrEmptyString = function(value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (value.length < 1) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + "." + parameterName));
            }
        };
        Utility.throwIfNullEmptyOrWhitespaceString = function(value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(value)) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + "." + parameterName));
            }
        };
        Utility.throwIfNotTrue = function(condition, context, methodName, parameterName) {
            if (!condition) {
                Utility.throwException(jsCommon.Errors.argument(parameterName, Utility.getComponentName(context) + methodName + "." + parameterName));
            }
        };
        Utility.isString = function(value) {
            return typeof value === "string";
        };
        Utility.isBoolean = function(value) {
            return typeof value === "boolean";
        };
        Utility.isNumber = function(value) {
            return typeof value === "number";
        };
        Utility.isDate = function(value) {
            return Utility.isObject(value) && value instanceof Date;
        };
        Utility.isObject = function(value) {
            return value != null && typeof value === "object";
        };
        Utility.isNullOrUndefined = function(value) {
            return value === null || typeof value === Utility.Undefined;
        };
        Utility.urlCombine = function(baseUrl, path) {
            Utility.throwIfNullOrUndefined(baseUrl, null, "urlCombine", "baseUrl");
            Utility.throwIfNullOrUndefined(path, null, "urlCombine", "path");
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(path)) {
                return baseUrl;
            }
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(baseUrl)) {
                return path;
            }
            var finalUrl = baseUrl;
            if (finalUrl.charAt(finalUrl.length - 1) === "/") {
                if (path.charAt(0) === "/") path = path.slice(1);
            } else {
                if (path.charAt(0) !== "/") path = "/" + path;
            }
            return finalUrl + path;
        };
        Utility.getAbsoluteUri = function(path) {
            Utility.throwIfNullOrUndefined(path, null, "getAbsoluteUri", "path");
            var url = path;
            if (url && url.indexOf("http") === -1) {
                url = Utility.urlCombine(clusterUri, url);
            }
            return url;
        };
        Utility.getStaticResourceUri = function(path) {
            Utility.throwIfNullOrUndefined(path, null, "getStaticResourceUri", "path");
            var url = path;
            if (url && url.indexOf("http") === -1) {
                url = jsCommon.Utility.urlCombine(Utility.staticContentLocation, url);
            }
            return url;
        };
        Utility.getComponentName = function(context) {
            return !context ? "" : (typeof context).toString() + ".";
        };
        Utility.throwException = function(e) {
            jsCommon.Trace.error(StringExtensions.format("Throwing exception: {0}", JSON.stringify(e)), e.stack != null ? false : true);
            throw e;
        };
        Utility.createClassSelector = function(className) {
            Utility.throwIfNullOrEmptyString(className, null, "CreateClassSelector", "className");
            return "." + className;
        };
        Utility.createIdSelector = function(id) {
            Utility.throwIfNullOrEmptyString(id, null, "CreateIdSelector", "id");
            return "#" + id;
        };
        Utility.generateGuid = function() {
            var guid = "", idx = 0;
            for (idx = 0; idx < 32; idx += 1) {
                var guidDigitsItem = Math.random() * 16 | 0;
                switch (idx) {
                  case 8:
                  case 12:
                  case 16:
                  case 20:
                    guid += "-";
                    break;
                }
                guid += guidDigitsItem.toString(16);
            }
            return guid;
        };
        Utility.generateConnectionGroupName = function() {
            var name = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < 7; i++) name += possible.charAt(Math.floor(Math.random() * possible.length));
            return name;
        };
        Utility.getCookieValue = function(key) {
            var keyValuePairs = document.cookie.split(";");
            for (var i = 0; i < keyValuePairs.length; i++) {
                var keyValue = keyValuePairs[i];
                var split = keyValue.split("=");
                if (split.length > 0 && split[0].trim() === key) {
                    return keyValue.substr(keyValue.indexOf("=") + 1);
                }
            }
            return null;
        };
        Utility.getDomainForUrl = function(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop("protocol") + "//" + hrefObject.prop("hostname");
        };
        Utility.getHostNameForUrl = function(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return Utility.urlCombine(hrefObject.prop("hostname"), hrefObject.prop("pathname"));
        };
        Utility.getUrlWithoutQueryString = function(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop("protocol") + "//" + Utility.urlCombine(hrefObject.prop("host"), hrefObject.prop("pathname"));
        };
        Utility.getProtocolFromUrl = function(url) {
            return Utility.getHrefObjectFromUrl(url).prop("protocol").replace(":", "");
        };
        Utility.getHrefObjectFromUrl = function(url) {
            var aObject = $("<a>");
            aObject = aObject.prop("href", url);
            return aObject;
        };
        Utility.convertWcfToJsDictionary = function(wcfDictionary) {
            var result = {};
            for (var i = 0; i < wcfDictionary.length; i++) {
                var keyValuePair = wcfDictionary[i];
                result[keyValuePair["Key"]] = keyValuePair["Value"];
            }
            return result;
        };
        Utility.getDateFromWcfJsonString = function(jsonDate, fromUtcMilliseconds) {
            if (StringExtensions.isNullOrEmpty(jsonDate)) {
                return null;
            }
            var begIndex = jsonDate.indexOf("(");
            var endIndex = jsonDate.indexOf(")");
            if (begIndex !== -1 && endIndex !== -1) {
                var milliseconds = parseInt(jsonDate.substring(begIndex + 1, endIndex), 10);
                if (fromUtcMilliseconds) {
                    return new Date(milliseconds);
                } else {
                    var retValue = new Date(0);
                    retValue.setUTCMilliseconds(milliseconds);
                    return retValue;
                }
            }
            return null;
        };
        Utility.getOuterHtml = function(content) {
            return $("<div>").append(content).html();
        };
        Utility.compareInt = function(a, b) {
            return a - b;
        };
        Utility.getIndexOfMinValue = function(a) {
            var retValue = 0;
            var currentMinValue = a[0];
            for (var i = 0; i < a.length; i++) {
                if (a[i] < currentMinValue) {
                    currentMinValue = a[i];
                    retValue = i;
                }
            }
            return retValue;
        };
        Utility.isValidUrl = function(url) {
            return !StringExtensions.isNullOrEmpty(url) && (StringExtensions.startsWithIgnoreCase(url, "http://") || StringExtensions.startsWithIgnoreCase(url, "https://"));
        };
        Utility.extractUrlFromCssBackgroundImage = function(input) {
            return input.replace(/"/g, "").replace(/url\(|\)$/gi, "");
        };
        Utility.saveAsFile = function(content, fileName) {
            var contentBlob = new Blob([ content ], {
                type: HttpConstants.ApplicationOctetStream
            });
            var url = window["webkitURL"] || URL;
            var urlLink = url.createObjectURL(contentBlob);
            var fileNameLink = fileName || urlLink;
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(contentBlob, fileNameLink);
                return;
            }
            var hyperlink = document.createElement("a");
            hyperlink.href = urlLink;
            hyperlink.target = "_blank";
            hyperlink["download"] = fileNameLink;
            document.body.appendChild(hyperlink);
            hyperlink.click();
            document.body.removeChild(hyperlink);
        };
        Utility.getType = function(obj) {
            Utility.throwIfNullEmptyOrWhitespaceString(obj.__type, this, "getType", "obj");
            var parts = obj.__type.split(":");
            if (parts.length !== 2) {
                jsCommon.Errors.argument("obj.__type", "Type String not in expected format [Type]#[Namespace]: " + obj.__type);
            }
            if (parts[1] !== Utility.TypeNamespace) {
                jsCommon.Errors.argument("obj.__type", "Type Namespace not expected: " + parts[1]);
            }
            return parts[0];
        };
        Utility.isEventSupported = function(eventName, element) {
            eventName = "on" + eventName;
            var isSupported = eventName in element;
            if (!isSupported) {
                if (!element.setAttribute) {
                    element = document.createElement("div");
                }
                if (element.setAttribute && element.removeAttribute) {
                    element.setAttribute(eventName, "");
                    isSupported = typeof element[eventName] === "function";
                    if (typeof element[eventName] !== "undefined") {
                        element[eventName] = null;
                    }
                    element.removeAttribute(eventName);
                }
            }
            element = null;
            return isSupported;
        };
        Utility.toPixel = function(pixelAmount) {
            Utility.throwIfNullOrUndefined(pixelAmount, this, "toPixel", "pixelAmount");
            return pixelAmount.toString() + jsCommon.CssConstants.pixelUnits;
        };
        Utility.getPropertyCount = function(object) {
            Utility.throwIfNullOrUndefined(object, this, "getPropertyCount", "object");
            return Object.getOwnPropertyNames(object).length;
        };
        Utility.getFileExtension = function(filePath) {
            if (filePath) {
                var index = filePath.lastIndexOf(".");
                if (index >= 0) return filePath.substr(index + 1);
            }
            return "";
        };
        Utility.canUseClipboard = function() {
            return typeof MSApp === "undefined";
        };
        Utility.is64BitOperatingSystem = function() {
            return navigator.userAgent.indexOf("WOW64") !== -1 || navigator.userAgent.indexOf("Win64") !== -1;
        };
        Utility.parseNumber = function(value, defaultValue) {
            if (value === null) return null;
            if (value === undefined) return defaultValue;
            var result = Number(value);
            if (isFinite(result)) return result;
            if (isNaN(result) && !(typeof value === "number" || value === "NaN")) return defaultValue;
            return result;
        };
        Utility.TypeNamespace = "http://schemas.microsoft.com/sqlbi/2013/01/NLRuntimeService";
        Utility.JsonContentType = "application/json";
        Utility.JpegContentType = "image/jpeg";
        Utility.XJavascriptContentType = "application/x-javascript";
        Utility.JsonDataType = "json";
        Utility.BlobDataType = "blob";
        Utility.HttpGetMethod = "GET";
        Utility.HttpPostMethod = "POST";
        Utility.HttpPutMethod = "PUT";
        Utility.HttpDeleteMethod = "DELETE";
        Utility.HttpContentTypeHeader = "Content-Type";
        Utility.HttpAcceptHeader = "Accept";
        Utility.Undefined = "undefined";
        Utility.staticContentLocation = window.location.protocol + "//" + window.location.host;
        return Utility;
    }();
    jsCommon.Utility = Utility;
    var VersionUtility = function() {
        function VersionUtility() {}
        VersionUtility.compareVersions = function(versionA, versionB) {
            var a = versionA.split(".").map(parseFloat);
            var b = versionB.split(".").map(parseFloat);
            var versionParts = Math.max(a.length, b.length);
            for (var i = 0; i < versionParts; i++) {
                var partA = a[i] || 0;
                var partB = b[i] || 0;
                if (partA > partB) return 1;
                if (partA < partB) return -1;
            }
            return 0;
        };
        return VersionUtility;
    }();
    jsCommon.VersionUtility = VersionUtility;
    var PerformanceUtil;
    (function(PerformanceUtil) {
        var PerfMarker = function() {
            function PerfMarker(name) {
                this._name = name;
                this._start = PerfMarker.begin(name);
            }
            PerfMarker.begin = function(name) {
                if (window.performance === undefined || performance.mark === undefined) return;
                if (console.time) {
                    console.time(name);
                }
                name = "Begin " + name;
                performance.mark(name);
                return name;
            };
            PerfMarker.prototype.end = function() {
                if (window.performance === undefined || performance.mark === undefined || performance.measure === undefined) return;
                var name = this._name;
                var end = "End " + name;
                performance.mark(end);
                performance.measure(name, this._start, end);
                if (console.timeEnd) {
                    console.timeEnd(name);
                }
            };
            return PerfMarker;
        }();
        PerformanceUtil.PerfMarker = PerfMarker;
        function create(name) {
            return new PerfMarker(name);
        }
        PerformanceUtil.create = create;
    })(PerformanceUtil = jsCommon.PerformanceUtil || (jsCommon.PerformanceUtil = {}));
    var GzipUtility;
    (function(GzipUtility) {
        function uncompress(encoded) {
            if (encoded) {
                try {
                    var decoded = atob(encoded);
                    var uncompressed = pako.inflate(decoded, {
                        to: "string"
                    });
                    return uncompressed;
                } catch (e) {
                    var msg = "Error while uncompressing TileData: {0}";
                    jsCommon.Trace.error(StringExtensions.format(msg, JSON.stringify(e)), e.stack != null ? false : true);
                }
            }
            return null;
        }
        GzipUtility.uncompress = uncompress;
        function compress(data) {
            if (data) {
                try {
                    var compressed = pako.gzip(data, {
                        to: "string"
                    });
                    var encoded = btoa(compressed);
                    return encoded;
                } catch (e) {
                    jsCommon.Trace.error(StringExtensions.format("Error while compressing TileData: {0}", JSON.stringify(e)), e.stack != null ? false : true);
                    return null;
                }
            }
            return null;
        }
        GzipUtility.compress = compress;
    })(GzipUtility = jsCommon.GzipUtility || (jsCommon.GzipUtility = {}));
    var DeferUtility;
    (function(DeferUtility) {
        function deferUntilNextFrame(callback) {
            var _this = this;
            var isWaiting, args, context;
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = function(func) {
                    return setTimeout(func, 1e3 / 50);
                };
            }
            return function() {
                if (!isWaiting) {
                    isWaiting = true;
                    args = arguments;
                    context = _this;
                    window.requestAnimationFrame(function() {
                        isWaiting = false;
                        callback.apply(context, args);
                    });
                }
            };
        }
        DeferUtility.deferUntilNextFrame = deferUntilNextFrame;
    })(DeferUtility = jsCommon.DeferUtility || (jsCommon.DeferUtility = {}));
    var EncryptionContext = function() {
        function EncryptionContext(message, publicKey, entropy, callbackFunction) {
            this.rsaMaxLength = 85;
            this.rsaEncryptedLength = 128;
            this.callback = callbackFunction;
            this.plainTextBytes = this.toUTF8Array(message);
            this.publicKey = publicKey;
            this.entropy = entropy;
            this.segments = Math.ceil(this.plainTextBytes.length / this.rsaMaxLength);
            this.currentSegment = 0;
            this.encryptedBytes = new Uint8Array(this.segments * this.rsaEncryptedLength);
        }
        EncryptionContext.prototype.RSAEncrypt = function() {
            var _this = this;
            var supportedPublicKey = this.toSupportedRSAPublicKey(this.publicKey);
            var publicKeyBytes = this.toSupportedArray(supportedPublicKey);
            msrCrypto.subtle.forceSync = true;
            if (msrCrypto.initPrng) {
                msrCrypto.initPrng(this.entropy);
            }
            var keyOperation = msrCrypto.subtle.importKey("jwk", publicKeyBytes, {
                name: "RSA-OAEP",
                hash: {
                    name: "sha-1"
                }
            });
            keyOperation.oncomplete = function(e) {
                return _this.rsaPublicKeyImportComplete(e);
            };
        };
        EncryptionContext.generateEntropy = function() {
            var entropy = [];
            for (var i = 0; i < 48; i++) {
                entropy.push(Math.floor(Math.random() * 256));
            }
            return entropy;
        };
        EncryptionContext.prototype.rsaPublicKeyImportComplete = function(e) {
            this.publicKeyHandle = e.target.result;
            this.rsaEncryption();
        };
        EncryptionContext.prototype.rsaEncryption = function() {
            var _this = this;
            var cryptoOperation = msrCrypto.subtle.encrypt({
                name: "RSA-OAEP",
                hash: {
                    name: "sha-1"
                }
            }, this.publicKeyHandle, this.plainTextBytes.subarray(this.currentSegment * this.rsaMaxLength, (this.currentSegment + 1) * this.rsaMaxLength));
            cryptoOperation.oncomplete = function(e) {
                return _this.rsaEncryptionSegmentComplete(e);
            };
        };
        EncryptionContext.prototype.rsaEncryptionSegmentComplete = function(e) {
            this.encryptedBytes.set(new Uint8Array(e.target.result), this.currentSegment * this.rsaEncryptedLength);
            this.currentSegment++;
            if (this.currentSegment < this.segments) {
                this.rsaEncryption();
            } else {
                this.callback(this.arrayToBase64String(this.encryptedBytes));
            }
        };
        EncryptionContext.prototype.toSupportedRSAPublicKey = function(publicKey) {
            return '{                 "kty" : "RSA",                 "extractable" : true,                 "n" : "' + publicKey + '",                 "e" : "AQAB"             }';
        };
        EncryptionContext.prototype.arrayToBase64String = function(bytes) {
            var binaryString = "";
            var len = bytes.length;
            for (var i = 0; i < len; i++) {
                binaryString += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binaryString);
        };
        EncryptionContext.prototype.toSupportedArray = function(data) {
            var typedArraySupport = typeof Uint8Array !== "undefined";
            var dataType = Object.prototype.toString.call(data);
            dataType = dataType.substring(8, dataType.length - 1);
            switch (dataType) {
              case "Array":
                return typedArraySupport ? new Uint8Array(data) : data;

              case "ArrayBuffer":
                return new Uint8Array(data);

              case "Uint8Array":
                return data;

              case "Uint16Array":
              case "Uint32Array":
                return new Uint8Array(data);

              case "String":
                var dataLength = data.length;
                var newArray = typedArraySupport ? new Uint8Array(dataLength) : new Array(dataLength);
                for (var i = 0; i < dataLength; i++) {
                    newArray[i] = data.charCodeAt(i);
                }
                return newArray;

              default:
                throw new Error("toSupportedArray : unsupported data type " + dataType);
            }
        };
        EncryptionContext.prototype.toUTF8Array = function(str) {
            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 128) utf8.push(charcode); else if (charcode < 2048) {
                    utf8.push(192 | charcode >> 6, 128 | charcode & 63);
                } else if (charcode < 55296 || charcode >= 57344) {
                    utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
                } else {
                    i++;
                    charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
                    utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
                }
            }
            var utf8Uint8Array = new Uint8Array(utf8.length);
            utf8Uint8Array.set(utf8, 0);
            return utf8Uint8Array;
        };
        return EncryptionContext;
    }();
    jsCommon.EncryptionContext = EncryptionContext;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var XmlUtility = function() {
        function XmlUtility() {}
        XmlUtility.removeInvalidCharacters = function(input) {
            debug.assertValue(input, "input");
            var startIndex = 0;
            var resultString;
            for (var i = 0, len = input.length; i < len; i++) {
                if (!XmlUtility.isValidXmlCharacter(input, i)) {
                    if (typeof resultString === "undefined") resultString = "";
                    if (startIndex !== i) resultString += input.substring(startIndex, i);
                    startIndex = i + 1;
                }
            }
            if (typeof resultString === "undefined") return input;
            if (startIndex <= input.length - 1) resultString += input.substring(startIndex, input.length);
            return resultString;
        };
        XmlUtility.isValidXmlCharacter = function(input, index) {
            debug.assertValue(input, "input");
            debug.assertValue(index, "index");
            debug.assert(index < input.length, "index < input.length");
            var charCode = input.charCodeAt(index);
            return charCode === XmlUtility.TabCharCode || charCode === XmlUtility.NewLineCharCode || charCode === XmlUtility.CarriageReturnCharCode || charCode >= 32 && charCode <= 55295 || charCode >= 57344 && charCode <= 65533 || charCode >= 65536 && charCode <= 1114111;
        };
        XmlUtility.TabCharCode = 9;
        XmlUtility.NewLineCharCode = 10;
        XmlUtility.CarriageReturnCharCode = 13;
        return XmlUtility;
    }();
    jsCommon.XmlUtility = XmlUtility;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var TraceItem = function() {
        function TraceItem(text, type, sessionId, requestId) {
            this.text = text;
            this.type = type;
            this.sessionId = sessionId;
            this.requestId = requestId;
            this.timeStamp = new Date();
        }
        TraceItem.prototype.toString = function() {
            var resultString = "";
            resultString += jsCommon.StringExtensions.format("{0} ({1}): {2}", TraceItem.traceTypeStrings[this.type], this.timeStamp.toUTCString(), this.text);
            if (this.requestId) resultString += "\n(Request id: " + this.requestId + ")";
            return resultString;
        };
        TraceItem.traceTypeStrings = [ "INFORMATION", "VERBOSE", "WARNING", "ERROR", "EXPECTEDERROR", "UNEXPECTEDERROR", "FATAL" ];
        return TraceItem;
    }();
    jsCommon.TraceItem = TraceItem;
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var EnumExtensions;
    (function(EnumExtensions) {
        function hasFlag(value, flag) {
            debug.assert(!!flag, "flag must be specified and nonzero.");
            return (value & flag) === flag;
        }
        EnumExtensions.hasFlag = hasFlag;
        function toString(enumType, value) {
            return enumType[value];
        }
        EnumExtensions.toString = toString;
    })(EnumExtensions = jsCommon.EnumExtensions || (jsCommon.EnumExtensions = {}));
    var StringExtensions;
    (function(StringExtensions) {
        function endsWith(str, suffix) {
            debug.assertValue(str, "str");
            debug.assertValue(suffix, "suffix");
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }
        StringExtensions.endsWith = endsWith;
    })(StringExtensions = jsCommon.StringExtensions || (jsCommon.StringExtensions = {}));
    var LogicExtensions;
    (function(LogicExtensions) {
        function XOR(a, b) {
            return (a || b) && !(a && b);
        }
        LogicExtensions.XOR = XOR;
    })(LogicExtensions = jsCommon.LogicExtensions || (jsCommon.LogicExtensions = {}));
    var JsonComparer;
    (function(JsonComparer) {
        function equals(x, y) {
            if (x === y) return true;
            return JSON.stringify(x) === JSON.stringify(y);
        }
        JsonComparer.equals = equals;
    })(JsonComparer = jsCommon.JsonComparer || (jsCommon.JsonComparer = {}));
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    var ConsoleTracer = function() {
        function ConsoleTracer() {}
        ConsoleTracer.prototype.logTrace = function(trace) {
            if (DEBUG) {
                switch (trace.type) {
                  case 0:
                    console.info(trace.toString());
                    break;

                  case 5:
                  case 3:
                  case 6:
                    console.error(trace.toString());
                    break;

                  case 4:
                  case 2:
                    console.warn(trace.toString());
                    break;

                  case 1:
                    console.log(trace.toString());
                    break;

                  default:
                    console.log(trace.toString());
                    break;
                }
            }
        };
        return ConsoleTracer;
    }();
    jsCommon.ConsoleTracer = ConsoleTracer;
    var Trace;
    (function(Trace) {
        var traceMaxCount = 1e3;
        var traces = new Array(traceMaxCount);
        var lastTraceIndex = -1;
        var defaultListener = new ConsoleTracer();
        var listeners = new Array(defaultListener);
        function warning(text, requestId) {
            debug.assertValue(text, "text");
            logTraceInternal(new jsCommon.TraceItem(text, 2, requestId));
        }
        Trace.warning = warning;
        function error(text, includeStackTrace, requestId) {
            debug.assertValue(text, "text");
            if (includeStackTrace) text = jsCommon.StringExtensions.format("{0}.\nStack:\n{1}", text, jsCommon.getStackTrace());
            logTraceInternal(new jsCommon.TraceItem(text, 3, requestId));
        }
        Trace.error = error;
        function verbose(text, requestId) {
            debug.assertValue(text, "text");
            logTraceInternal(new jsCommon.TraceItem(text, 1, requestId));
        }
        Trace.verbose = verbose;
        function addListener(listener) {
            debug.assertValue(listener, "listener");
            listeners.push(listener);
        }
        Trace.addListener = addListener;
        function removeListener(listener) {
            debug.assertValue(listener, "listener");
            var index = listeners.indexOf(listener);
            if (index >= 0) listeners.splice(index, 1);
        }
        Trace.removeListener = removeListener;
        function resetListeners() {
            listeners = new Array(defaultListener);
        }
        Trace.resetListeners = resetListeners;
        function reset() {
            lastTraceIndex = -1;
        }
        Trace.reset = reset;
        function getTraces() {
            if (lastTraceIndex < 0) return;
            var result = new Array(lastTraceIndex + 1);
            for (var i = 0; i <= lastTraceIndex; i++) result[i] = traces[i];
            return result;
        }
        Trace.getTraces = getTraces;
        function disableDefaultListener() {
            removeListener(defaultListener);
        }
        Trace.disableDefaultListener = disableDefaultListener;
        function enableDefaultListener() {
            addListener(defaultListener);
        }
        Trace.enableDefaultListener = enableDefaultListener;
        function logTraceInternal(trace) {
            if (lastTraceIndex + 1 >= traceMaxCount) reset();
            traces[++lastTraceIndex] = trace;
            for (var i = 0, len = listeners.length; i < len; i++) listeners[i].logTrace(trace);
        }
    })(Trace = jsCommon.Trace || (jsCommon.Trace = {}));
})(jsCommon || (jsCommon = {}));

var jsCommon;

(function(jsCommon) {
    (function(TraceType) {
        TraceType[TraceType["Information"] = 0] = "Information";
        TraceType[TraceType["Verbose"] = 1] = "Verbose";
        TraceType[TraceType["Warning"] = 2] = "Warning";
        TraceType[TraceType["Error"] = 3] = "Error";
        TraceType[TraceType["ExpectedError"] = 4] = "ExpectedError";
        TraceType[TraceType["UnexpectedError"] = 5] = "UnexpectedError";
        TraceType[TraceType["Fatal"] = 6] = "Fatal";
    })(jsCommon.TraceType || (jsCommon.TraceType = {}));
    var TraceType = jsCommon.TraceType;
})(jsCommon || (jsCommon = {}));

var powerbi;

(function(powerbi) {
    (function(HttpStatusCode) {
        HttpStatusCode[HttpStatusCode["AngularCancelOrTimeout"] = 0] = "AngularCancelOrTimeout";
        HttpStatusCode[HttpStatusCode["OK"] = 200] = "OK";
        HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
        HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
        HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
        HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
        HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
        HttpStatusCode[HttpStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    })(powerbi.HttpStatusCode || (powerbi.HttpStatusCode = {}));
    var HttpStatusCode = powerbi.HttpStatusCode;
})(powerbi || (powerbi = {}));

var jsCommon;

(function(jsCommon) {
    var JQueryUI = "https://ajax.aspnetcdn.com/ajax/jquery.ui/1.10.3/jquery-ui.min.js";
    var JQueryUII18n = "https://ajax.aspnetcdn.com/ajax/jquery.ui/1.10.3/i18n/jquery-ui-i18n.min.js";
    var Globalize = "https://ajax.aspnetcdn.com/ajax/globalize/0.1.1/globalize.js";
    var MSMapcontrol = "https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1&onscriptload=globalMapControlLoaded";
    var JQueryUICss = "https://ajax.aspnetcdn.com/ajax/jquery.ui/1.10.3/themes/base/jquery-ui.css";
    var MSMapcontrolLoaded = false;
    var WaitForMSMapLoad = null;
    var PowerViewPackage = {
        javaScriptFiles: [ JQueryUI, JQueryUII18n, Globalize, powerbi.build + "/externals/globalize.cultures.js", powerbi.build + "/externals/pv/webclient.js" ],
        cssFiles: [ JQueryUICss, powerbi.build + "/externals/pv/Styles/_all.css" ],
        javaScriptFilesWithCallback: [ {
            javascriptFile: MSMapcontrol,
            onLoadCallback: waitForMapControlLoaded
        } ]
    };
    function ensurePowerView(action) {
        if (action === void 0) {
            action = function() {};
        }
        jsCommon.requires(PowerViewPackage, action);
    }
    jsCommon.ensurePowerView = ensurePowerView;
    var MapPackage = {
        javaScriptFilesWithCallback: [ {
            javascriptFile: MSMapcontrol,
            onLoadCallback: waitForMapControlLoaded
        } ]
    };
    function ensureMap(action) {
        jsCommon.requires(MapPackage, action);
    }
    jsCommon.ensureMap = ensureMap;
    function mapControlLoaded() {
        MSMapcontrolLoaded = true;
        if (WaitForMSMapLoad) {
            WaitForMSMapLoad.resolve();
            WaitForMSMapLoad = undefined;
        }
    }
    jsCommon.mapControlLoaded = mapControlLoaded;
    function waitForMapControlLoaded() {
        var task;
        if (!MSMapcontrolLoaded) {
            task = WaitForMSMapLoad = $.Deferred();
        } else {
            task = $.Deferred();
            task.resolve();
        }
        return task.promise();
    }
    jsCommon.waitForMapControlLoaded = waitForMapControlLoaded;
})(jsCommon || (jsCommon = {}));

var globalMapControlLoaded = function() {
    jsCommon.mapControlLoaded();
};

var __extends = this.__extends || function(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DefaultSQExprVisitorWithArg = function() {
            function DefaultSQExprVisitorWithArg() {}
            DefaultSQExprVisitorWithArg.prototype.visitEntity = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAggr = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitBetween = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitIn = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAnd = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitOr = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitCompare = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitContains = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitExists = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNot = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitConstant = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNow = function(expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDefault = function(expr, arg) {
                return;
            };
            return DefaultSQExprVisitorWithArg;
        }();
        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;
        var DefaultSQExprVisitor = function(_super) {
            __extends(DefaultSQExprVisitor, _super);
            function DefaultSQExprVisitor() {
                _super.apply(this, arguments);
            }
            return DefaultSQExprVisitor;
        }(DefaultSQExprVisitorWithArg);
        data.DefaultSQExprVisitor = DefaultSQExprVisitor;
        var DefaultSQExprVisitorWithTraversal = function() {
            function DefaultSQExprVisitorWithTraversal() {}
            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function(expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function(expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function(expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function(expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function(expr) {
                expr.arg.accept(this);
                expr.lower.accept(this);
                expr.upper.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function(expr) {
                var args = expr.args;
                for (var i = 0, len = args.length; i < len; i++) args[i].accept(this);
                var values = expr.values;
                for (var i = 0, len = values.length; i < len; i++) {
                    var valueTuple = values[i];
                    for (var j = 0, jlen = values.length; j < jlen; j++) valueTuple[j].accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function(expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function(expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function(expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function(expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function(expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function(expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function(expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function(expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function(expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function(expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function(expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function(expr) {
                return;
            };
            return DefaultSQExprVisitorWithTraversal;
        }();
        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var InvalidDataFormatClientError = function() {
            function InvalidDataFormatClientError() {}
            Object.defineProperty(InvalidDataFormatClientError.prototype, "code", {
                get: function() {
                    return "InvalidDataFormat";
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(InvalidDataFormatClientError.prototype, "ignorable", {
                get: function() {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            InvalidDataFormatClientError.prototype.getDetails = function(resourceProvider) {
                var message = resourceProvider.get("ServiceError_CannotLoadVisual");
                var key = resourceProvider.get("ServiceError_ExecuteSemanticQueryErrorKey");
                var val = resourceProvider.get("InvalidDataFormat_DataFormatIsInvalid");
                var details = {
                    message: message,
                    additionalErrorInfo: [ {
                        errorInfoKey: key,
                        errorInfoValue: val
                    } ]
                };
                return details;
            };
            return InvalidDataFormatClientError;
        }();
        data.InvalidDataFormatClientError = InvalidDataFormatClientError;
        var InvalidDataResponseClientError = function() {
            function InvalidDataResponseClientError() {}
            Object.defineProperty(InvalidDataResponseClientError.prototype, "code", {
                get: function() {
                    return "InvalidDataResponse";
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(InvalidDataResponseClientError.prototype, "ignorable", {
                get: function() {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            InvalidDataResponseClientError.prototype.getDetails = function(resourceProvider) {
                var message = resourceProvider.get("ServiceError_CannotLoadVisual");
                var key = resourceProvider.get("ServiceError_ExecuteSemanticQueryErrorKey");
                var val = resourceProvider.get("InvalidDataResponse_ServerError");
                var details = {
                    message: message,
                    additionalErrorInfo: [ {
                        errorInfoKey: key,
                        errorInfoValue: val
                    } ]
                };
                return details;
            };
            return InvalidDataResponseClientError;
        }();
        data.InvalidDataResponseClientError = InvalidDataResponseClientError;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var services;
        (function(services) {
            var DataViewTransformActionsSerializer;
            (function(DataViewTransformActionsSerializer) {
                function deserializeTransformActions(visualType, objectDescs, transformsString) {
                    if (!visualType || !transformsString) return;
                    var serializedTransform = JSON.parse(transformsString);
                    var dataViewObjectDefns;
                    var dataViewObjectDescs = objectDescs;
                    if (objectDescs) {
                        var objects = serializedTransform.objects;
                        if (objects) dataViewObjectDefns = services.DataViewObjectSerializer.deserializeObjects(objects, dataViewObjectDescs);
                    }
                    return data.DataViewTransform.createTransformActions(serializedTransform.queryMetadata, serializedTransform.visualElements, dataViewObjectDescs, dataViewObjectDefns);
                }
                DataViewTransformActionsSerializer.deserializeTransformActions = deserializeTransformActions;
                function serializeTransformActions(actions) {
                    return JSON.stringify(actions);
                }
                DataViewTransformActionsSerializer.serializeTransformActions = serializeTransformActions;
            })(DataViewTransformActionsSerializer = services.DataViewTransformActionsSerializer || (services.DataViewTransformActionsSerializer = {}));
        })(services = data.services || (data.services = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var alignment;
    (function(alignment) {
        alignment.right = "right";
        alignment.left = "left";
        alignment.center = "center";
    })(alignment = powerbi.alignment || (powerbi.alignment = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var axisStyle;
    (function(axisStyle) {
        axisStyle.showBoth = "showBoth";
        axisStyle.showTitleOnly = "showTitleOnly";
        axisStyle.showUnitOnly = "showUnitOnly";
        var allMembers = [ {
            value: axisStyle.showTitleOnly,
            displayName: function(resources) {
                return resources.get("Visual_Axis_ShowTitleOnly");
            }
        }, {
            value: axisStyle.showUnitOnly,
            displayName: function(resources) {
                return resources.get("Visual_Axis_ShowUnitOnly");
            }
        }, {
            value: axisStyle.showBoth,
            displayName: function(resources) {
                return resources.get("Visual_Axis_ShowBoth");
            }
        } ];
        function members(validMembers) {
            var validMembersToReturn = [];
            if (validMembers) {
                for (var i = 0, len = allMembers.length; i < len; i++) {
                    if (validMembers.indexOf(allMembers[i].value) !== -1) {
                        validMembersToReturn.push(allMembers[i]);
                    }
                }
            }
            return validMembersToReturn;
        }
        axisStyle.members = members;
    })(axisStyle = powerbi.axisStyle || (powerbi.axisStyle = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var axisType;
    (function(axisType) {
        axisType.scalar = "Scalar";
        axisType.categorical = "Categorical";
        axisType.both = "Both";
        function members() {
            return [ {
                value: axisType.scalar,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Scalar");
                }
            }, {
                value: axisType.categorical,
                displayName: function(resources) {
                    return resources.get("Visual_Axis_Categorical");
                }
            } ];
        }
        axisType.members = members;
    })(axisType = powerbi.axisType || (powerbi.axisType = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var labelPosition;
    (function(labelPosition) {
        labelPosition.insideEnd = "InsideEnd";
        labelPosition.insideCenter = "InsideCenter";
        labelPosition.outsideEnd = "OutsideEnd";
        labelPosition.insideBase = "InsideBase";
        var allMembers = [ {
            value: labelPosition.insideEnd,
            displayName: function(resources) {
                return resources.get("Visual_LabelPosition_InsideEnd");
            }
        }, {
            value: labelPosition.outsideEnd,
            displayName: function(resources) {
                return resources.get("Visual_LabelPosition_OutsideEnd");
            }
        }, {
            value: labelPosition.insideCenter,
            displayName: function(resources) {
                return resources.get("Visual_LabelPosition_InsideCenter");
            }
        }, {
            value: labelPosition.insideBase,
            displayName: function(resources) {
                return resources.get("Visual_LabelPosition_InsideBase");
            }
        } ];
        function members(validMembers) {
            var validMembersToReturn = [];
            if (validMembers) {
                for (var i = 0, len = allMembers.length; i < len; i++) {
                    if (validMembers.indexOf(allMembers[i].value) !== -1) {
                        validMembersToReturn.push(allMembers[i]);
                    }
                }
            }
            return validMembersToReturn;
        }
        labelPosition.members = members;
    })(labelPosition = powerbi.labelPosition || (powerbi.labelPosition = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var legendPosition;
    (function(legendPosition) {
        legendPosition.top = "Top";
        legendPosition.bottom = "Bottom";
        legendPosition.left = "Left";
        legendPosition.right = "Right";
        function members() {
            return [ {
                value: legendPosition.top,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Top");
                }
            }, {
                value: legendPosition.bottom,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Bottom");
                }
            }, {
                value: legendPosition.left,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Left");
                }
            }, {
                value: legendPosition.right,
                displayName: function(resources) {
                    return resources.get("Visual_LegendPosition_Right");
                }
            } ];
        }
        legendPosition.members = members;
    })(legendPosition = powerbi.legendPosition || (powerbi.legendPosition = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var StructuralTypeDescriptor;
    (function(StructuralTypeDescriptor) {
        function isValid(type) {
            debug.assertValue(type, "type");
            if (type.fill || type.fillRule || type.filter) {
                return true;
            }
            return false;
        }
        StructuralTypeDescriptor.isValid = isValid;
    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var EnumExtensions = jsCommon.EnumExtensions;
    var ValueType = function() {
        function ValueType(type, category) {
            debug.assert(!!type && ExtendedType[type] != null || type === 0, "type");
            debug.assert(!!category || category === null, "category");
            this.underlyingType = type;
            this.category = category;
            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {
                this.temporalType = new TemporalType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {
                this.geographyType = new GeographyType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {
                this.miscType = new MiscellaneousType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {
                this.formattingType = new FormattingType(type);
            }
        }
        ValueType.fromDescriptor = function(descriptor) {
            descriptor = descriptor || {};
            if (descriptor.text) return ValueType.fromExtendedType(1);
            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);
            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);
            if (descriptor.bool) return ValueType.fromExtendedType(5);
            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);
            if (descriptor.duration) return ValueType.fromExtendedType(10);
            if (descriptor.binary) return ValueType.fromExtendedType(11);
            if (descriptor.none) return ValueType.fromExtendedType(12);
            if (descriptor.temporal) {
                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);
                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);
            }
            if (descriptor.geography) {
                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);
                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);
                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);
                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);
                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);
                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);
                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);
                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);
                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);
                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);
                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);
            }
            if (descriptor.misc) {
                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);
                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);
                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);
            }
            if (descriptor.formatting) {
                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);
                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);
                if (descriptor.formatting.legendPosition) return ValueType.fromExtendedType(ExtendedType.LegendPosition);
                if (descriptor.formatting.axisType) return ValueType.fromExtendedType(ExtendedType.AxisType);
                if (descriptor.formatting.yAxisPosition) return ValueType.fromExtendedType(ExtendedType.YAxisPosition);
                if (descriptor.formatting.axisStyle) return ValueType.fromExtendedType(ExtendedType.AxisStyle);
                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);
                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);
                if (descriptor.formatting.labelPosition) return ValueType.fromExtendedType(ExtendedType.LabelPosition);
            }
            if (descriptor.extendedType) {
                return ValueType.fromExtendedType(descriptor.extendedType);
            }
            return ValueType.fromExtendedType(0);
        };
        ValueType.fromExtendedType = function(extendedType) {
            extendedType = extendedType || 0;
            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);
            debug.assert(primitiveType !== 0 || extendedType === 0, "Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.");
            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);
        };
        ValueType.fromPrimitiveTypeAndCategory = function(primitiveType, category) {
            primitiveType = primitiveType || 0;
            category = category || null;
            var id = primitiveType.toString();
            if (category) id += "|" + category;
            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));
        };
        Object.defineProperty(ValueType.prototype, "primitiveType", {
            get: function() {
                return getPrimitiveType(this.underlyingType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "extendedType", {
            get: function() {
                return this.underlyingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "categoryString", {
            get: function() {
                return this.category;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "text", {
            get: function() {
                return this.primitiveType === 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "numeric", {
            get: function() {
                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "integer", {
            get: function() {
                return this.primitiveType === 4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "bool", {
            get: function() {
                return this.primitiveType === 5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "dateTime", {
            get: function() {
                return this.primitiveType === 7 || this.primitiveType === 6 || this.primitiveType === 9;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "duration", {
            get: function() {
                return this.primitiveType === 10;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "binary", {
            get: function() {
                return this.primitiveType === 11;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "none", {
            get: function() {
                return this.primitiveType === 12;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "temporal", {
            get: function() {
                return this.temporalType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "geography", {
            get: function() {
                return this.geographyType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "misc", {
            get: function() {
                return this.miscType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "formatting", {
            get: function() {
                return this.formattingType;
            },
            enumerable: true,
            configurable: true
        });
        ValueType.typeCache = {};
        return ValueType;
    }();
    powerbi.ValueType = ValueType;
    var TemporalType = function() {
        function TemporalType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), "type");
            this.underlyingType = type;
        }
        Object.defineProperty(TemporalType.prototype, "year", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "month", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);
            },
            enumerable: true,
            configurable: true
        });
        return TemporalType;
    }();
    powerbi.TemporalType = TemporalType;
    var GeographyType = function() {
        function GeographyType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), "type");
            this.underlyingType = type;
        }
        Object.defineProperty(GeographyType.prototype, "address", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "city", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "continent", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "country", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "county", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "region", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "postalCode", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "stateOrProvince", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "place", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "latitude", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "longitude", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);
            },
            enumerable: true,
            configurable: true
        });
        return GeographyType;
    }();
    powerbi.GeographyType = GeographyType;
    var MiscellaneousType = function() {
        function MiscellaneousType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), "type");
            this.underlyingType = type;
        }
        Object.defineProperty(MiscellaneousType.prototype, "image", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "imageUrl", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "webUrl", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);
            },
            enumerable: true,
            configurable: true
        });
        return MiscellaneousType;
    }();
    powerbi.MiscellaneousType = MiscellaneousType;
    var FormattingType = function() {
        function FormattingType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), "type");
            this.underlyingType = type;
        }
        Object.defineProperty(FormattingType.prototype, "color", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "formatString", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "legendPosition", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LegendPosition);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "axisType", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.AxisType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "yAxisPosition", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.YAxisPosition);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "axisStyle", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.AxisStyle);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "alignment", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelDisplayUnits", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelPosition", {
            get: function() {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelPosition);
            },
            enumerable: true,
            configurable: true
        });
        return FormattingType;
    }();
    powerbi.FormattingType = FormattingType;
    (function(PrimitiveType) {
        PrimitiveType[PrimitiveType["Null"] = 0] = "Null";
        PrimitiveType[PrimitiveType["Text"] = 1] = "Text";
        PrimitiveType[PrimitiveType["Decimal"] = 2] = "Decimal";
        PrimitiveType[PrimitiveType["Double"] = 3] = "Double";
        PrimitiveType[PrimitiveType["Integer"] = 4] = "Integer";
        PrimitiveType[PrimitiveType["Boolean"] = 5] = "Boolean";
        PrimitiveType[PrimitiveType["Date"] = 6] = "Date";
        PrimitiveType[PrimitiveType["DateTime"] = 7] = "DateTime";
        PrimitiveType[PrimitiveType["DateTimeZone"] = 8] = "DateTimeZone";
        PrimitiveType[PrimitiveType["Time"] = 9] = "Time";
        PrimitiveType[PrimitiveType["Duration"] = 10] = "Duration";
        PrimitiveType[PrimitiveType["Binary"] = 11] = "Binary";
        PrimitiveType[PrimitiveType["None"] = 12] = "None";
    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));
    var PrimitiveType = powerbi.PrimitiveType;
    (function(ExtendedType) {
        ExtendedType[ExtendedType["Numeric"] = 1 << 8] = "Numeric";
        ExtendedType[ExtendedType["Temporal"] = 1 << 9] = "Temporal";
        ExtendedType[ExtendedType["Geography"] = 1 << 10] = "Geography";
        ExtendedType[ExtendedType["Miscellaneous"] = 1 << 11] = "Miscellaneous";
        ExtendedType[ExtendedType["Formatting"] = 1 << 12] = "Formatting";
        ExtendedType[ExtendedType["Null"] = 0] = "Null";
        ExtendedType[ExtendedType["Text"] = 1] = "Text";
        ExtendedType[ExtendedType["Decimal"] = ExtendedType.Numeric | 2] = "Decimal";
        ExtendedType[ExtendedType["Double"] = ExtendedType.Numeric | 3] = "Double";
        ExtendedType[ExtendedType["Integer"] = ExtendedType.Numeric | 4] = "Integer";
        ExtendedType[ExtendedType["Boolean"] = 5] = "Boolean";
        ExtendedType[ExtendedType["Date"] = ExtendedType.Temporal | 6] = "Date";
        ExtendedType[ExtendedType["DateTime"] = ExtendedType.Temporal | 7] = "DateTime";
        ExtendedType[ExtendedType["DateTimeZone"] = ExtendedType.Temporal | 8] = "DateTimeZone";
        ExtendedType[ExtendedType["Time"] = ExtendedType.Temporal | 9] = "Time";
        ExtendedType[ExtendedType["Duration"] = 10] = "Duration";
        ExtendedType[ExtendedType["Binary"] = 11] = "Binary";
        ExtendedType[ExtendedType["None"] = 12] = "None";
        ExtendedType[ExtendedType["Year"] = ExtendedType.Temporal | 1 << 16] = "Year";
        ExtendedType[ExtendedType["Year_Text"] = ExtendedType.Year | ExtendedType.Text] = "Year_Text";
        ExtendedType[ExtendedType["Year_Integer"] = ExtendedType.Year | ExtendedType.Integer] = "Year_Integer";
        ExtendedType[ExtendedType["Year_Date"] = ExtendedType.Year | ExtendedType.Date] = "Year_Date";
        ExtendedType[ExtendedType["Year_DateTime"] = ExtendedType.Year | ExtendedType.DateTime] = "Year_DateTime";
        ExtendedType[ExtendedType["Month"] = ExtendedType.Temporal | 2 << 16] = "Month";
        ExtendedType[ExtendedType["Month_Text"] = ExtendedType.Month | ExtendedType.Text] = "Month_Text";
        ExtendedType[ExtendedType["Month_Integer"] = ExtendedType.Month | ExtendedType.Integer] = "Month_Integer";
        ExtendedType[ExtendedType["Month_Date"] = ExtendedType.Month | ExtendedType.Date] = "Month_Date";
        ExtendedType[ExtendedType["Month_DateTime"] = ExtendedType.Month | ExtendedType.DateTime] = "Month_DateTime";
        ExtendedType[ExtendedType["Address"] = ExtendedType.Text | ExtendedType.Geography | 100 << 16] = "Address";
        ExtendedType[ExtendedType["City"] = ExtendedType.Text | ExtendedType.Geography | 101 << 16] = "City";
        ExtendedType[ExtendedType["Continent"] = ExtendedType.Text | ExtendedType.Geography | 102 << 16] = "Continent";
        ExtendedType[ExtendedType["Country"] = ExtendedType.Text | ExtendedType.Geography | 103 << 16] = "Country";
        ExtendedType[ExtendedType["County"] = ExtendedType.Text | ExtendedType.Geography | 104 << 16] = "County";
        ExtendedType[ExtendedType["Region"] = ExtendedType.Text | ExtendedType.Geography | 105 << 16] = "Region";
        ExtendedType[ExtendedType["PostalCode"] = ExtendedType.Geography | 106 << 16] = "PostalCode";
        ExtendedType[ExtendedType["PostalCode_Text"] = ExtendedType.PostalCode | ExtendedType.Text] = "PostalCode_Text";
        ExtendedType[ExtendedType["PostalCode_Integer"] = ExtendedType.PostalCode | ExtendedType.Integer] = "PostalCode_Integer";
        ExtendedType[ExtendedType["StateOrProvince"] = ExtendedType.Text | ExtendedType.Geography | 107 << 16] = "StateOrProvince";
        ExtendedType[ExtendedType["Place"] = ExtendedType.Text | ExtendedType.Geography | 108 << 16] = "Place";
        ExtendedType[ExtendedType["Latitude"] = ExtendedType.Geography | 109 << 16] = "Latitude";
        ExtendedType[ExtendedType["Latitude_Decimal"] = ExtendedType.Latitude | ExtendedType.Decimal] = "Latitude_Decimal";
        ExtendedType[ExtendedType["Latitude_Double"] = ExtendedType.Latitude | ExtendedType.Double] = "Latitude_Double";
        ExtendedType[ExtendedType["Longitude"] = ExtendedType.Geography | 110 << 16] = "Longitude";
        ExtendedType[ExtendedType["Longitude_Decimal"] = ExtendedType.Longitude | ExtendedType.Decimal] = "Longitude_Decimal";
        ExtendedType[ExtendedType["Longitude_Double"] = ExtendedType.Longitude | ExtendedType.Double] = "Longitude_Double";
        ExtendedType[ExtendedType["Image"] = ExtendedType.Binary | ExtendedType.Miscellaneous | 200 << 16] = "Image";
        ExtendedType[ExtendedType["ImageUrl"] = ExtendedType.Text | ExtendedType.Miscellaneous | 201 << 16] = "ImageUrl";
        ExtendedType[ExtendedType["WebUrl"] = ExtendedType.Text | ExtendedType.Miscellaneous | 202 << 16] = "WebUrl";
        ExtendedType[ExtendedType["Color"] = ExtendedType.Text | ExtendedType.Formatting | 300 << 16] = "Color";
        ExtendedType[ExtendedType["FormatString"] = ExtendedType.Text | ExtendedType.Formatting | 301 << 16] = "FormatString";
        ExtendedType[ExtendedType["LegendPosition"] = ExtendedType.Text | ExtendedType.Formatting | 302 << 16] = "LegendPosition";
        ExtendedType[ExtendedType["AxisType"] = ExtendedType.Text | ExtendedType.Formatting | 303 << 16] = "AxisType";
        ExtendedType[ExtendedType["YAxisPosition"] = ExtendedType.Text | ExtendedType.Formatting | 304 << 16] = "YAxisPosition";
        ExtendedType[ExtendedType["AxisStyle"] = ExtendedType.Text | ExtendedType.Formatting | 305 << 16] = "AxisStyle";
        ExtendedType[ExtendedType["Alignment"] = ExtendedType.Text | ExtendedType.Formatting | 306 << 16] = "Alignment";
        ExtendedType[ExtendedType["LabelDisplayUnits"] = ExtendedType.Text | ExtendedType.Formatting | 307 << 16] = "LabelDisplayUnits";
        ExtendedType[ExtendedType["LabelPosition"] = ExtendedType.Text | ExtendedType.Formatting | 308 << 16] = "LabelPosition";
    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));
    var ExtendedType = powerbi.ExtendedType;
    var PrimitiveTypeMask = 255;
    var PrimitiveTypeWithFlagsMask = 65535;
    var PrimitiveTypeFlagsExcludedMask = 4294901760;
    function getPrimitiveType(extendedType) {
        return extendedType & PrimitiveTypeMask;
    }
    function isPrimitiveType(extendedType) {
        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;
    }
    function getCategoryFromExtendedType(extendedType) {
        if (isPrimitiveType(extendedType)) return null;
        var category = ExtendedType[extendedType];
        if (category) {
            var delimIdx = category.lastIndexOf("_");
            if (delimIdx > 0) {
                var baseCategory = category.slice(0, delimIdx);
                if (ExtendedType[baseCategory]) {
                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), "Unexpected value for ExtendedType base member of " + extendedType);
                    category = baseCategory;
                }
            }
        }
        return category || null;
    }
    function toExtendedType(primitiveType, category) {
        var primitiveString = PrimitiveType[primitiveType];
        var t = ExtendedType[primitiveString];
        if (t == null) {
            debug.assertFail("Unexpected primitiveType " + primitiveType);
            t = 0;
        }
        if (primitiveType && category) {
            var categoryType = ExtendedType[category];
            if (categoryType) {
                var categoryPrimitiveType = getPrimitiveType(categoryType);
                if (categoryPrimitiveType === 0) {
                    categoryType = t | categoryType;
                    if (ExtendedType[categoryType]) {
                        debug.assert(ExtendedType[categoryType] === category + "_" + primitiveString, "Unexpected name for ExtendedType member " + categoryType);
                        t = categoryType;
                    }
                } else if (categoryPrimitiveType === primitiveType) {
                    t = categoryType;
                }
            }
        }
        return t;
    }
    function matchesExtendedTypeWithAnyPrimitive(a, b) {
        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);
    }
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var ConceptualSchema = function() {
            function ConceptualSchema() {}
            ConceptualSchema.prototype.findProperty = function(entityName, propertyName) {
                var entity = this.entities.withName(entityName);
                if (entity) return entity.properties.withName(propertyName);
            };
            return ConceptualSchema;
        }();
        data.ConceptualSchema = ConceptualSchema;
        (function(ConceptualQueryableState) {
            ConceptualQueryableState[ConceptualQueryableState["Queryable"] = 0] = "Queryable";
            ConceptualQueryableState[ConceptualQueryableState["Error"] = 1] = "Error";
        })(data.ConceptualQueryableState || (data.ConceptualQueryableState = {}));
        var ConceptualQueryableState = data.ConceptualQueryableState;
        (function(ConceptualPropertyKind) {
            ConceptualPropertyKind[ConceptualPropertyKind["Column"] = 0] = "Column";
            ConceptualPropertyKind[ConceptualPropertyKind["Measure"] = 1] = "Measure";
            ConceptualPropertyKind[ConceptualPropertyKind["Kpi"] = 2] = "Kpi";
        })(data.ConceptualPropertyKind || (data.ConceptualPropertyKind = {}));
        var ConceptualPropertyKind = data.ConceptualPropertyKind;
        (function(ConceptualDefaultAggregate) {
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Default"] = 0] = "Default";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["None"] = 1] = "None";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Sum"] = 2] = "Sum";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Count"] = 3] = "Count";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Min"] = 4] = "Min";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Max"] = 5] = "Max";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["Average"] = 6] = "Average";
            ConceptualDefaultAggregate[ConceptualDefaultAggregate["DistinctCount"] = 7] = "DistinctCount";
        })(data.ConceptualDefaultAggregate || (data.ConceptualDefaultAggregate = {}));
        var ConceptualDefaultAggregate = data.ConceptualDefaultAggregate;
        (function(ConceptualDataCategory) {
            ConceptualDataCategory[ConceptualDataCategory["None"] = 0] = "None";
            ConceptualDataCategory[ConceptualDataCategory["Address"] = 1] = "Address";
            ConceptualDataCategory[ConceptualDataCategory["City"] = 2] = "City";
            ConceptualDataCategory[ConceptualDataCategory["Company"] = 3] = "Company";
            ConceptualDataCategory[ConceptualDataCategory["Continent"] = 4] = "Continent";
            ConceptualDataCategory[ConceptualDataCategory["Country"] = 5] = "Country";
            ConceptualDataCategory[ConceptualDataCategory["County"] = 6] = "County";
            ConceptualDataCategory[ConceptualDataCategory["Date"] = 7] = "Date";
            ConceptualDataCategory[ConceptualDataCategory["Image"] = 8] = "Image";
            ConceptualDataCategory[ConceptualDataCategory["ImageUrl"] = 9] = "ImageUrl";
            ConceptualDataCategory[ConceptualDataCategory["Latitude"] = 10] = "Latitude";
            ConceptualDataCategory[ConceptualDataCategory["Longitude"] = 11] = "Longitude";
            ConceptualDataCategory[ConceptualDataCategory["Organization"] = 12] = "Organization";
            ConceptualDataCategory[ConceptualDataCategory["Place"] = 13] = "Place";
            ConceptualDataCategory[ConceptualDataCategory["PostalCode"] = 14] = "PostalCode";
            ConceptualDataCategory[ConceptualDataCategory["Product"] = 15] = "Product";
            ConceptualDataCategory[ConceptualDataCategory["StateOrProvince"] = 16] = "StateOrProvince";
            ConceptualDataCategory[ConceptualDataCategory["WebUrl"] = 17] = "WebUrl";
        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));
        var ConceptualDataCategory = data.ConceptualDataCategory;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        (function(DataShapeBindingVersions) {
            DataShapeBindingVersions[DataShapeBindingVersions["Version0"] = 0] = "Version0";
            DataShapeBindingVersions[DataShapeBindingVersions["Version1"] = 1] = "Version1";
        })(data.DataShapeBindingVersions || (data.DataShapeBindingVersions = {}));
        var DataShapeBindingVersions = data.DataShapeBindingVersions;
        (function(DataShapeBindingLimitType) {
            DataShapeBindingLimitType[DataShapeBindingLimitType["Top"] = 0] = "Top";
            DataShapeBindingLimitType[DataShapeBindingLimitType["First"] = 1] = "First";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Last"] = 2] = "Last";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Sample"] = 3] = "Sample";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Bottom"] = 4] = "Bottom";
        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));
        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;
        (function(SubtotalType) {
            SubtotalType[SubtotalType["None"] = 0] = "None";
            SubtotalType[SubtotalType["Before"] = 1] = "Before";
            SubtotalType[SubtotalType["After"] = 2] = "After";
        })(data.SubtotalType || (data.SubtotalType = {}));
        var SubtotalType = data.SubtotalType;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var FederatedConceptualSchema = function() {
            function FederatedConceptualSchema(options) {
                debug.assertValue(options, "options");
                this.schemas = options.schemas;
                if (options.links) this.links = options.links;
            }
            FederatedConceptualSchema.prototype.schema = function(name) {
                return this.schemas[name];
            };
            return FederatedConceptualSchema;
        }();
        data.FederatedConceptualSchema = FederatedConceptualSchema;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(_data) {
        var Selector;
        (function(Selector) {
            var ArrayExtensions = jsCommon.ArrayExtensions;
            function filterFromSelector(selectors, isNot) {
                if (ArrayExtensions.isUndefinedOrEmpty(selectors)) return;
                var expr;
                for (var i = 0, ilen = selectors.length; i < ilen; i++) {
                    var identity = selectors[i];
                    var data = identity.data;
                    var exprToAdd = undefined;
                    if (data && data.length) {
                        for (var j = 0, jlen = data.length; j < jlen; j++) {
                            var newExpr = identity.data[j].expr;
                            if (newExpr) {
                                if (exprToAdd) exprToAdd = _data.SQExprBuilder.and(exprToAdd, newExpr); else exprToAdd = newExpr;
                            }
                        }
                    }
                    if (exprToAdd) expr = expr ? _data.SQExprBuilder.or(expr, exprToAdd) : exprToAdd;
                }
                if (expr && isNot) expr = _data.SQExprBuilder.not(expr);
                return _data.SemanticFilter.fromSQExpr(expr);
            }
            Selector.filterFromSelector = filterFromSelector;
            function matchesData(selector, identities) {
                debug.assertValue(selector, "selector");
                debug.assertValue(selector.data, "selector.data");
                debug.assertValue(identities, "identities");
                var selectorData = selector.data;
                if (selectorData.length !== identities.length) return false;
                for (var i = 0, len = selectorData.length; i < len; i++) {
                    var dataItem = selector.data[i];
                    var selectorDataItem = dataItem;
                    if (selectorDataItem.expr) {
                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i])) return false;
                    } else {
                        if (!_data.DataViewScopeWildcard.matches(dataItem, identities[i])) return false;
                    }
                }
                return true;
            }
            Selector.matchesData = matchesData;
            function matchesKeys(selector, keysList) {
                debug.assertValue(selector, "selector");
                debug.assertValue(selector.data, "selector.data");
                debug.assertValue(keysList, "keysList");
                var selectorData = selector.data, selectorDataLength = selectorData.length;
                if (selectorDataLength !== keysList.length) return false;
                for (var i = 0; i < selectorDataLength; i++) {
                    var selectorDataItem = selector.data[i], selectorDataExprs;
                    if (selectorDataItem.expr) {
                        selectorDataExprs = _data.ScopeIdentityKeyExtractor.run(selectorDataItem.expr);
                    } else {
                        selectorDataExprs = selectorDataItem.exprs;
                    }
                    if (!selectorDataExprs) continue;
                    if (!_data.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs)) return false;
                }
                return true;
            }
            Selector.matchesKeys = matchesKeys;
            function equals(x, y) {
                x = x || null;
                y = y || null;
                if (x === y) return true;
                if (!x !== !y) return false;
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                if (x.id !== y.id) return false;
                if (x.metadata !== y.metadata) return false;
                if (!equalsDataArray(x.data, y.data)) return false;
                return true;
            }
            Selector.equals = equals;
            function equalsDataArray(x, y) {
                x = x || null;
                y = y || null;
                if (x === y) return true;
                if (!x !== !y) return false;
                if (x.length !== y.length) return false;
                for (var i = 0, len = x.length; i < len; i++) {
                    if (!equalsData(x[i], y[i])) return false;
                }
                return true;
            }
            function equalsData(x, y) {
                if (!x.expr && y.expr) {
                    return false;
                }
                return powerbi.DataViewScopeIdentity.equals(x, y);
            }
            function getKey(selector) {
                var toStringify = {};
                if (selector.data) {
                    var data = [];
                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {
                        data.push(selector.data[i].key);
                    }
                    toStringify.data = data;
                }
                if (selector.metadata) toStringify.metadata = selector.metadata;
                if (selector.id) toStringify.id = selector.id;
                return JSON.stringify(toStringify);
            }
            Selector.getKey = getKey;
            function containsWildcard(selector) {
                debug.assertValue(selector, "selector");
                var dataItems = selector.data;
                if (!dataItems) return false;
                for (var i = 0, len = dataItems.length; i < len; i++) {
                    var wildcard = dataItems[i];
                    if (wildcard.exprs) return true;
                }
                return false;
            }
            Selector.containsWildcard = containsWildcard;
        })(Selector = _data.Selector || (_data.Selector = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        (function(PowerBIErrorResourceType) {
            PowerBIErrorResourceType[PowerBIErrorResourceType["ResourceCodeReference"] = 0] = "ResourceCodeReference";
            PowerBIErrorResourceType[PowerBIErrorResourceType["EmbeddedString"] = 1] = "EmbeddedString";
        })(data.PowerBIErrorResourceType || (data.PowerBIErrorResourceType = {}));
        var PowerBIErrorResourceType = data.PowerBIErrorResourceType;
        (function(ServiceErrorStatusCode) {
            ServiceErrorStatusCode[ServiceErrorStatusCode["GeneralError"] = 0] = "GeneralError";
            ServiceErrorStatusCode[ServiceErrorStatusCode["CsdlFetching"] = 1] = "CsdlFetching";
            ServiceErrorStatusCode[ServiceErrorStatusCode["CsdlConvertXmlToConceptualSchema"] = 2] = "CsdlConvertXmlToConceptualSchema";
            ServiceErrorStatusCode[ServiceErrorStatusCode["CsdlCreateClientSchema"] = 3] = "CsdlCreateClientSchema";
            ServiceErrorStatusCode[ServiceErrorStatusCode["ExecuteSemanticQueryError"] = 4] = "ExecuteSemanticQueryError";
            ServiceErrorStatusCode[ServiceErrorStatusCode["ExecuteSemanticQueryInvalidStreamFormat"] = 5] = "ExecuteSemanticQueryInvalidStreamFormat";
        })(data.ServiceErrorStatusCode || (data.ServiceErrorStatusCode = {}));
        var ServiceErrorStatusCode = data.ServiceErrorStatusCode;
        var ServiceErrorToClientError = function() {
            function ServiceErrorToClientError(serviceError) {
                this.m_serviceError = serviceError;
            }
            Object.defineProperty(ServiceErrorToClientError.prototype, "code", {
                get: function() {
                    return ServiceErrorToClientError.codeName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ServiceErrorToClientError.prototype, "ignorable", {
                get: function() {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            ServiceErrorToClientError.prototype.getDetails = function(resourceProvider) {
                var errorDetails = PowerBIErrorDetailHelper.GetDetailsFromServerErrorStatusCode(resourceProvider, this.m_serviceError.statusCode);
                PowerBIErrorDetailHelper.addAdditionalInfo(errorDetails, this.m_serviceError.errorDetails, resourceProvider);
                return errorDetails;
            };
            ServiceErrorToClientError.codeName = "ServiceErrorToClientError";
            return ServiceErrorToClientError;
        }();
        data.ServiceErrorToClientError = ServiceErrorToClientError;
        var PowerBIErrorDetailHelper = function() {
            function PowerBIErrorDetailHelper() {}
            PowerBIErrorDetailHelper.addAdditionalInfo = function(errorDetails, pbiErrorDetails, localize) {
                if (pbiErrorDetails) {
                    for (var i = 0; i < pbiErrorDetails.length; i++) {
                        var element = pbiErrorDetails[i];
                        var additionErrorInfoKeyValuePair = {
                            errorInfoKey: localize.get(PowerBIErrorDetailHelper.serverErrorPrefix + element.code),
                            errorInfoValue: element.detail.type === 0 ? localize.get(PowerBIErrorDetailHelper.serverErrorPrefix + element.detail.value) : element.detail.value
                        };
                        errorDetails.additionalErrorInfo.push(additionErrorInfoKeyValuePair);
                    }
                }
                return errorDetails;
            };
            PowerBIErrorDetailHelper.GetDetailsFromServerErrorStatusCode = function(localize, statusCode) {
                var message = "";
                var key = "";
                var val = "";
                switch (statusCode) {
                  case 2:
                    message = localize.get("ServiceError_ModelCannotLoad");
                    key = localize.get("ServiceError_ModelConvertFailureKey");
                    val = localize.get("ServiceError_ModelConvertFailureValue");
                    break;

                  case 3:
                    message = localize.get("ServiceError_ModelCannotLoad");
                    key = localize.get("ServiceError_ModelCreationFailureKey");
                    val = localize.get("ServiceError_ModelCreationFailureValue");
                    break;

                  case 1:
                    message = localize.get("ServiceError_ModelCannotLoad");
                    key = localize.get("ServiceError_ModelFetchingFailureKey");
                    val = localize.get("ServiceError_ModelFetchingFailureValue");
                    break;

                  case 4:
                    message = localize.get("ServiceError_CannotLoadVisual");
                    key = localize.get("ServiceError_ExecuteSemanticQueryErrorKey");
                    val = localize.get("ServiceError_ExecuteSemanticQueryErrorValue");
                    break;

                  case 5:
                    message = localize.get("ServiceError_CannotLoadVisual");
                    key = localize.get("ServiceError_ExecuteSemanticQueryInvalidStreamFormatKey");
                    val = localize.get("ServiceError_ExecuteSemanticQueryInvalidStreamFormatValue");
                    break;

                  case 0:
                  default:
                    message = localize.get("ServiceError_GeneralError");
                    key = localize.get("ServiceError_GeneralErrorKey");
                    val = localize.get("ServiceError_GeneralErrorValue");
                    break;
                }
                var additionalInfo = [];
                additionalInfo.push({
                    errorInfoKey: key,
                    errorInfoValue: val
                });
                var errorDetails = {
                    message: message,
                    additionalErrorInfo: additionalInfo
                };
                return errorDetails;
            };
            PowerBIErrorDetailHelper.serverErrorPrefix = "ServerError_";
            return PowerBIErrorDetailHelper;
        }();
        data.PowerBIErrorDetailHelper = PowerBIErrorDetailHelper;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        (function(TimeUnit) {
            TimeUnit[TimeUnit["Day"] = 0] = "Day";
            TimeUnit[TimeUnit["Week"] = 1] = "Week";
            TimeUnit[TimeUnit["Month"] = 2] = "Month";
            TimeUnit[TimeUnit["Year"] = 3] = "Year";
            TimeUnit[TimeUnit["Decade"] = 4] = "Decade";
            TimeUnit[TimeUnit["Second"] = 5] = "Second";
            TimeUnit[TimeUnit["Minute"] = 6] = "Minute";
            TimeUnit[TimeUnit["Hour"] = 7] = "Hour";
        })(data.TimeUnit || (data.TimeUnit = {}));
        var TimeUnit = data.TimeUnit;
        (function(QueryAggregateFunction) {
            QueryAggregateFunction[QueryAggregateFunction["Sum"] = 0] = "Sum";
            QueryAggregateFunction[QueryAggregateFunction["Avg"] = 1] = "Avg";
            QueryAggregateFunction[QueryAggregateFunction["Count"] = 2] = "Count";
            QueryAggregateFunction[QueryAggregateFunction["Min"] = 3] = "Min";
            QueryAggregateFunction[QueryAggregateFunction["Max"] = 4] = "Max";
            QueryAggregateFunction[QueryAggregateFunction["CountNonNull"] = 5] = "CountNonNull";
        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));
        var QueryAggregateFunction = data.QueryAggregateFunction;
        (function(QuerySortDirection) {
            QuerySortDirection[QuerySortDirection["Ascending"] = 1] = "Ascending";
            QuerySortDirection[QuerySortDirection["Descending"] = 2] = "Descending";
        })(data.QuerySortDirection || (data.QuerySortDirection = {}));
        var QuerySortDirection = data.QuerySortDirection;
        (function(QueryComparisonKind) {
            QueryComparisonKind[QueryComparisonKind["Equal"] = 0] = "Equal";
            QueryComparisonKind[QueryComparisonKind["GreaterThan"] = 1] = "GreaterThan";
            QueryComparisonKind[QueryComparisonKind["GreaterThanOrEqual"] = 2] = "GreaterThanOrEqual";
            QueryComparisonKind[QueryComparisonKind["LessThan"] = 3] = "LessThan";
            QueryComparisonKind[QueryComparisonKind["LessThanOrEqual"] = 4] = "LessThanOrEqual";
        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));
        var QueryComparisonKind = data.QueryComparisonKind;
        (function(SemanticType) {
            SemanticType[SemanticType["None"] = 0] = "None";
            SemanticType[SemanticType["Number"] = 1] = "Number";
            SemanticType[SemanticType["Integer"] = SemanticType.Number + 2] = "Integer";
            SemanticType[SemanticType["DateTime"] = 4] = "DateTime";
            SemanticType[SemanticType["Time"] = 8] = "Time";
            SemanticType[SemanticType["Date"] = SemanticType.DateTime + 16] = "Date";
            SemanticType[SemanticType["Month"] = SemanticType.Integer + 32] = "Month";
            SemanticType[SemanticType["Year"] = SemanticType.Integer + 64] = "Year";
            SemanticType[SemanticType["YearAndMonth"] = 128] = "YearAndMonth";
            SemanticType[SemanticType["MonthAndDay"] = 256] = "MonthAndDay";
            SemanticType[SemanticType["Decade"] = SemanticType.Integer + 512] = "Decade";
            SemanticType[SemanticType["YearAndWeek"] = 1024] = "YearAndWeek";
            SemanticType[SemanticType["String"] = 2048] = "String";
            SemanticType[SemanticType["Boolean"] = 4096] = "Boolean";
            SemanticType[SemanticType["Table"] = 8192] = "Table";
            SemanticType[SemanticType["Range"] = 16384] = "Range";
        })(data.SemanticType || (data.SemanticType = {}));
        var SemanticType = data.SemanticType;
        (function(SelectKind) {
            SelectKind[SelectKind["None"] = 0] = "None";
            SelectKind[SelectKind["Group"] = 1] = "Group";
            SelectKind[SelectKind["Measure"] = 2] = "Measure";
        })(data.SelectKind || (data.SelectKind = {}));
        var SelectKind = data.SelectKind;
        (function(FilterKind) {
            FilterKind[FilterKind["Default"] = 0] = "Default";
            FilterKind[FilterKind["Period"] = 1] = "Period";
        })(data.FilterKind || (data.FilterKind = {}));
        var FilterKind = data.FilterKind;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    (function(DisplayUnitSystemType) {
        DisplayUnitSystemType[DisplayUnitSystemType["Default"] = 0] = "Default";
        DisplayUnitSystemType[DisplayUnitSystemType["Verbose"] = 1] = "Verbose";
        DisplayUnitSystemType[DisplayUnitSystemType["WholeUnits"] = 2] = "WholeUnits";
    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));
    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        (function(CompiledSubtotalType) {
            CompiledSubtotalType[CompiledSubtotalType["None"] = 0] = "None";
            CompiledSubtotalType[CompiledSubtotalType["Before"] = 1] = "Before";
            CompiledSubtotalType[CompiledSubtotalType["After"] = 2] = "After";
        })(data.CompiledSubtotalType || (data.CompiledSubtotalType = {}));
        var CompiledSubtotalType = data.CompiledSubtotalType;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var UnionExtensions = jsCommon.UnionExtensions;
        function compileDataView(options) {
            debug.assertValue(options, "options");
            var compiler = new DataViewMappingCompiler(options.queryDefn, options.queryProjections, options.schema);
            var result = [], mappings = options.mappings;
            for (var i = 0, len = mappings.length; i < len; i++) result.push(compiler.compileMapping(mappings[i], options.objectDescriptors, options.objectDefinitions));
            return result;
        }
        data.compileDataView = compileDataView;
        var DataViewMappingCompiler = function() {
            function DataViewMappingCompiler(queryDefn, queryProjections, schema) {
                debug.assertValue(queryDefn, "queryDefn");
                debug.assertValue(queryProjections, "queryProjections");
                debug.assertValue(schema, "schema");
                this.queryDefn = queryDefn;
                this.queryProjections = queryProjections;
                this.schema = schema;
            }
            DataViewMappingCompiler.prototype.compileMapping = function(mapping, objectDescriptors, objectDefinitions) {
                debug.assertValue(mapping, "mapping");
                debug.assertAnyValue(objectDescriptors, "objectDescriptors");
                debug.assertAnyValue(objectDefinitions, "objectDefinitions");
                var metadata = this.compileMetadata(objectDescriptors, objectDefinitions);
                var compiledMapping = {
                    metadata: metadata
                };
                if (mapping.categorical) compiledMapping.categorical = this.compileCategorical(mapping.categorical);
                if (mapping.table) compiledMapping.table = this.compileTable(mapping.table);
                if (mapping.single) compiledMapping.single = this.compileSingle(mapping.single);
                if (mapping.tree) compiledMapping.tree = this.compileTree(mapping.tree);
                if (mapping.matrix) compiledMapping.matrix = this.compileMatrix(mapping.matrix);
                return compiledMapping;
            };
            DataViewMappingCompiler.prototype.compileMetadata = function(objectDescriptors, objectDefinitions) {
                debug.assertAnyValue(objectDescriptors, "objectDescriptors");
                debug.assertAnyValue(objectDefinitions, "objectDefinitions");
                var metadata = {};
                var objects = this.evaluateConstantMetadataObjects(objectDescriptors, objectDefinitions);
                if (objects) metadata.objects = objects;
                return metadata;
            };
            DataViewMappingCompiler.prototype.evaluateConstantMetadataObjects = function(objectDescriptors, objectDefinitions) {
                debug.assertAnyValue(objectDescriptors, "objectDescriptors");
                debug.assertAnyValue(objectDefinitions, "objectDefinitions");
                if (!objectDefinitions || !objectDescriptors) return;
                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);
                if (objectsForAllSelectors.metadataOnce) return data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(objectDescriptors, objectsForAllSelectors.metadataOnce.objects);
            };
            DataViewMappingCompiler.prototype.compileCategorical = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = {};
                if (mapping.categories) compiled.categories = this.compileRoleMappingWithReduction(mapping.categories);
                var values = mapping.values;
                if (values) {
                    var grouped = this.compileGrouped(values);
                    var list = this.compileList(values);
                    var roleMapping = this.compileRoleMapping(values);
                    compiled.values = UnionExtensions.mergeUnionType(grouped, list, roleMapping);
                }
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileTable = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var roleMapping = this.compileRoleMappingWithReduction(mapping.rows);
                var listMapping = this.compileListWithReduction(mapping.rows);
                var rows = UnionExtensions.mergeUnionType(roleMapping, listMapping);
                return {
                    rows: rows
                };
            };
            DataViewMappingCompiler.prototype.compileSingle = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var role = this.compileRole(mapping.role);
                return {
                    role: role
                };
            };
            DataViewMappingCompiler.prototype.compileTree = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = {};
                if (mapping.nodes) compiled.nodes = this.compileGroupingRoleMapping(mapping.nodes);
                if (mapping.values) compiled.values = this.compileValuesRoleMapping(mapping.values);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileMatrix = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = {};
                if (mapping.rows) compiled.rows = this.compileForWithReduction(mapping.rows);
                if (mapping.columns) compiled.columns = this.compileForWithReduction(mapping.columns);
                if (mapping.values) compiled.values = this.compileFor(mapping.values);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileGroupingRoleMapping = function(mapping) {
                debug.assertValue(mapping, "mapping");
                if (!mapping.role) return;
                var role = this.compileRole(mapping.role);
                return {
                    role: role
                };
            };
            DataViewMappingCompiler.prototype.compileValuesRoleMapping = function(mapping) {
                var _this = this;
                debug.assertValue(mapping, "mapping");
                if (!mapping.roles) return;
                var roles = mapping.roles.map(function(item) {
                    return _this.compileRole(item);
                });
                return {
                    roles: roles
                };
            };
            DataViewMappingCompiler.prototype.compileListWithReduction = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = this.compileList(mapping);
                if (!compiled) return;
                if (mapping.dataReductionAlgorithm) compiled.dataReductionAlgorithm = this.compileReduction(mapping.dataReductionAlgorithm);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileList = function(mapping) {
                var _this = this;
                debug.assertValue(mapping, "mapping");
                if (!mapping.select) return;
                var select = mapping.select.map(function(item) {
                    return _this.compileRoleMapping(item);
                });
                return {
                    select: select
                };
            };
            DataViewMappingCompiler.prototype.compileGrouped = function(mapping) {
                var _this = this;
                debug.assertValue(mapping, "mapping");
                if (!mapping.group) return;
                var byItems = this.compileRole(mapping.group.by);
                var select = mapping.group.select.map(function(item) {
                    return _this.compileRoleMapping(item);
                });
                var compiled = {
                    group: {
                        by: byItems,
                        select: select
                    }
                };
                if (mapping.group.dataReductionAlgorithm) compiled.group.dataReductionAlgorithm = this.compileReduction(mapping.group.dataReductionAlgorithm);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileRoleMapping = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiledBind = this.compileBind(mapping);
                var compiledFor = this.compileFor(mapping);
                return UnionExtensions.mergeUnionType(compiledBind, compiledFor);
            };
            DataViewMappingCompiler.prototype.compileRoleMappingWithReduction = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = this.compileRoleMapping(mapping);
                if (!compiled) return;
                if (mapping.dataReductionAlgorithm) compiled.dataReductionAlgorithm = this.compileReduction(mapping.dataReductionAlgorithm);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileBind = function(mapping) {
                debug.assertValue(mapping, "mapping");
                if (!mapping.bind) return;
                var items = this.compileRole(mapping.bind.to);
                return {
                    bind: {
                        to: items
                    }
                };
            };
            DataViewMappingCompiler.prototype.compileForWithReduction = function(mapping) {
                debug.assertValue(mapping, "mapping");
                var compiled = this.compileFor(mapping);
                if (!compiled) return;
                if (mapping.dataReductionAlgorithm) compiled.dataReductionAlgorithm = this.compileReduction(mapping.dataReductionAlgorithm);
                return compiled;
            };
            DataViewMappingCompiler.prototype.compileFor = function(mapping) {
                debug.assertValue(mapping, "mapping");
                if (!mapping.for) return;
                var items = this.compileRole(mapping.for.in);
                return {
                    "for": {
                        "in": items
                    }
                };
            };
            DataViewMappingCompiler.prototype.compileRole = function(role) {
                var _this = this;
                debug.assertValue(role, "role");
                var items;
                var selects = this.queryDefn.select();
                var projections = this.queryProjections[role];
                if (!jsCommon.ArrayExtensions.isUndefinedOrEmpty(projections)) {
                    items = projections.map(function(projection) {
                        return _this.createDataViewRoleItem(selects.withName(projection.queryRef));
                    });
                }
                return {
                    role: role,
                    items: items
                };
            };
            DataViewMappingCompiler.prototype.createDataViewRoleItem = function(select) {
                debug.assertValue(select, "select");
                var item = {};
                var metadata = select.expr.getMetadata(this.schema);
                if (metadata) item.type = metadata.type;
                return item;
            };
            DataViewMappingCompiler.prototype.compileReduction = function(algorithm) {
                debug.assertAnyValue(algorithm, "algorithm");
                if (!algorithm) return;
                var compiled = {};
                if (algorithm.top) {
                    compiled.top = {};
                    if (algorithm.top.count) compiled.top.count = algorithm.top.count;
                }
                if (algorithm.bottom) {
                    compiled.bottom = {};
                    if (algorithm.bottom.count) compiled.bottom.count = algorithm.bottom.count;
                }
                if (algorithm.sample) {
                    compiled.sample = {};
                    if (algorithm.sample.count) compiled.sample.count = algorithm.sample.count;
                }
                if (algorithm.window) {
                    compiled.window = {};
                    if (algorithm.window.count) compiled.window.count = algorithm.window.count;
                }
                return compiled;
            };
            return DataViewMappingCompiler;
        }();
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewObjectDefinitions;
        (function(DataViewObjectDefinitions) {
            function ensure(defns, objectName, selector) {
                debug.assertValue(defns, "defns");
                var defnsForObject = defns[objectName];
                if (!defnsForObject) defns[objectName] = defnsForObject = [];
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector)) return defn;
                }
                var newDefn = {
                    selector: selector,
                    properties: {}
                };
                defnsForObject.push(newDefn);
                return newDefn;
            }
            DataViewObjectDefinitions.ensure = ensure;
            function deleteProperty(defns, objectName, selector, propertyName) {
                debug.assertValue(defns, "defns");
                var defnsForObject = defns[objectName];
                if (!defnsForObject) return;
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector)) {
                        delete defn.properties[propertyName];
                        return;
                    }
                }
            }
            DataViewObjectDefinitions.deleteProperty = deleteProperty;
            function getValue(defns, propertyId, selector) {
                var defnsForObject = defns[propertyId.objectName];
                if (!defnsForObject) return;
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector)) return defn.properties[propertyId.propertyName];
                }
            }
            DataViewObjectDefinitions.getValue = getValue;
        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewObjectDescriptors;
        (function(DataViewObjectDescriptors) {
            function findFormatString(descriptors) {
                return findProperty(descriptors, function(propDesc) {
                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;
                    return formattingTypeDesc && formattingTypeDesc.formatString;
                });
            }
            DataViewObjectDescriptors.findFormatString = findFormatString;
            function findFilterOutput(descriptors) {
                return findProperty(descriptors, function(propDesc) {
                    var propType = propDesc.type;
                    return propType && !!propType.filter;
                });
            }
            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;
            function findProperty(descriptors, propPredicate) {
                debug.assertAnyValue(descriptors, "descriptors");
                debug.assertAnyValue(propPredicate, "propPredicate");
                if (!descriptors) return;
                for (var objectName in descriptors) {
                    var objPropDescs = descriptors[objectName].properties;
                    for (var propertyName in objPropDescs) {
                        if (propPredicate(objPropDescs[propertyName])) {
                            return {
                                objectName: objectName,
                                propertyName: propertyName
                            };
                        }
                    }
                }
            }
        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewObjectEvaluationUtils;
        (function(DataViewObjectEvaluationUtils) {
            function evaluateDataViewObjects(objectDescriptors, objectDefns) {
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(objectDefns, "objectDefns");
                var objects;
                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {
                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;
                    var evaluatedObject = data.DataViewObjectEvaluator.run(objectDescriptors[objectName], objectDefinition.properties);
                    if (!evaluatedObject) continue;
                    if (!objects) objects = {};
                    objects[objectName] = evaluatedObject;
                }
                return objects;
            }
            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;
            function groupObjectsBySelector(objectDefinitions) {
                debug.assertAnyValue(objectDefinitions, "objectDefinitions");
                var grouped = {
                    data: []
                };
                if (objectDefinitions) {
                    for (var objectName in objectDefinitions) {
                        var objectDefnList = objectDefinitions[objectName];
                        for (var i = 0, len = objectDefnList.length; i < len; i++) {
                            var objectDefn = objectDefnList[i];
                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({
                                name: objectName,
                                properties: objectDefn.properties
                            });
                        }
                    }
                }
                return grouped;
            }
            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;
            function ensureDefinitionListForSelector(grouped, selector) {
                debug.assertValue(grouped, "grouped");
                debug.assertAnyValue(selector, "selector");
                if (!selector) {
                    if (!grouped.metadataOnce) grouped.metadataOnce = {
                        objects: []
                    };
                    return grouped.metadataOnce;
                }
                var groupedObjects;
                if (selector.data) {
                    groupedObjects = grouped.data;
                } else if (selector.metadata) {
                    if (!grouped.metadata) grouped.metadata = [];
                    groupedObjects = grouped.metadata;
                } else if (selector.id) {
                    if (!grouped.userDefined) grouped.userDefined = [];
                    groupedObjects = grouped.userDefined;
                }
                for (var i = 0, len = groupedObjects.length; i < len; i++) {
                    var item = groupedObjects[i];
                    if (data.Selector.equals(selector, item.selector)) return item;
                }
                var item = {
                    selector: selector,
                    objects: []
                };
                groupedObjects.push(item);
                return item;
            }
            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, "objectsForAllSelectors");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(columns, "columns");
                debug.assertValue(selectTransforms, "selectTransforms");
                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                if (!formatStringProp) return;
                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {
                    var selectTransform = selectTransforms[selectIdx];
                    if (!selectTransform) continue;
                    debug.assertValue(selectTransform.queryName, "selectTransform.queryName");
                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));
                }
            }
            DataViewObjectEvaluationUtils.addDefaultFormatString = addDefaultFormatString;
            function getColumnFormatForIndex(columns, selectIdx) {
                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {
                    var column = columns[columnIdx];
                    if (!column || column.index !== selectIdx) continue;
                    return column.format;
                }
            }
            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {
                if (!formatStringValue) return;
                var metadataObjects = objectsForAllSelectors.metadata;
                if (!metadataObjects) metadataObjects = objectsForAllSelectors.metadata = [];
                var selector = {
                    metadata: queryName
                };
                var targetMetadataObject = findWithMatchingSelector(metadataObjects, selector), targetObjectDefns;
                if (targetMetadataObject) {
                    targetObjectDefns = targetMetadataObject.objects;
                    if (hasExistingObjectProperty(targetObjectDefns, formatStringProp)) return;
                } else {
                    targetObjectDefns = [];
                    targetMetadataObject = {
                        selector: selector,
                        objects: targetObjectDefns
                    };
                    metadataObjects.push(targetMetadataObject);
                }
                var newObjectDefn = {
                    name: formatStringProp.objectName,
                    properties: {}
                };
                newObjectDefn.properties[formatStringProp.propertyName] = data.SQExprBuilder.text(formatStringValue);
                targetObjectDefns.push(newObjectDefn);
            }
            function findWithMatchingSelector(objects, selector) {
                debug.assertValue(objects, "objects");
                debug.assertValue(selector, "selector");
                for (var i = 0, len = objects.length; i < len; i++) {
                    var object = objects[i];
                    if (data.Selector.equals(object.selector, selector)) return object;
                }
            }
            function hasExistingObjectProperty(objectDefns, propertyId) {
                debug.assertValue(objectDefns, "objectDefns");
                debug.assertValue(propertyId, "propertyId");
                for (var i = 0, len = objectDefns.length; i < len; i++) {
                    var objectDefn = objectDefns[i];
                    if (objectDefn.name === propertyId.objectName && objectDefn.properties[propertyId.propertyName]) return true;
                }
                return false;
            }
        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewObjectEvaluator;
        (function(DataViewObjectEvaluator) {
            var colorValueType = powerbi.ValueType.fromDescriptor({
                formatting: {
                    color: true
                }
            });
            var numericType = powerbi.ValueType.fromDescriptor({
                numeric: true
            });
            function run(objectDescriptor, propertyDefinitions) {
                debug.assertAnyValue(objectDescriptor, "objectDescriptor");
                debug.assertValue(propertyDefinitions, "propertyDefinitions");
                if (!objectDescriptor) return;
                var object, propertyDescriptors = objectDescriptor.properties;
                for (var propertyName in propertyDefinitions) {
                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];
                    if (!propertyDescriptor) continue;
                    var propertyValue = evaluateProperty(propertyDescriptor, propertyDefinition);
                    if (propertyValue === undefined) continue;
                    if (!object) object = {};
                    object[propertyName] = propertyValue;
                }
                return object;
            }
            DataViewObjectEvaluator.run = run;
            function evaluateProperty(propertyDescriptor, propertyDefinition) {
                debug.assertValue(propertyDescriptor, "propertyDescriptor");
                debug.assertValue(propertyDefinition, "propertyDefinition");
                var value = evaluateValue(propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));
                if (value !== undefined || propertyDefinition instanceof data.RuleEvaluation) return value;
                var structuralType = propertyDescriptor.type;
                var valueFill = evaluateFill(propertyDefinition, structuralType);
                if (valueFill) return valueFill;
                var valueFillRule = evaluateFillRule(propertyDefinition, structuralType);
                if (valueFillRule) return valueFillRule;
                return propertyDefinition;
            }
            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;
            function evaluateFill(fillDefn, type) {
                var fillType = type.fill;
                if (!fillType) return;
                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {
                    return {
                        solid: {
                            color: evaluateValue(fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color))
                        }
                    };
                }
            }
            function evaluateFillRule(fillRuleDefn, type) {
                if (!type.fillRule) return;
                if (fillRuleDefn.linearGradient2) {
                    var linearGradient2 = fillRuleDefn.linearGradient2;
                    return {
                        linearGradient2: {
                            min: evaluateColorStop(linearGradient2.min),
                            max: evaluateColorStop(linearGradient2.max)
                        }
                    };
                }
                if (fillRuleDefn.linearGradient3) {
                    var linearGradient3 = fillRuleDefn.linearGradient3;
                    return {
                        linearGradient3: {
                            min: evaluateColorStop(linearGradient3.min),
                            mid: evaluateColorStop(linearGradient3.mid),
                            max: evaluateColorStop(linearGradient3.max)
                        }
                    };
                }
            }
            function evaluateColorStop(colorStop) {
                debug.assertValue(colorStop, "colorStop");
                var step = {
                    color: evaluateValue(colorStop.color, colorValueType)
                };
                var value = evaluateValue(colorStop.value, numericType);
                if (value) step.value = value;
                return step;
            }
            function evaluateValue(definition, valueType) {
                if (definition instanceof data.SQExpr) return ExpressionEvaluator.evaluate(definition, valueType);
                if (definition instanceof data.RuleEvaluation) return definition.evaluate();
            }
            var ExpressionEvaluator = function(_super) {
                __extends(ExpressionEvaluator, _super);
                function ExpressionEvaluator() {
                    _super.apply(this, arguments);
                }
                ExpressionEvaluator.evaluate = function(expr, type) {
                    if (expr == null) return;
                    return expr.accept(ExpressionEvaluator.instance, type);
                };
                ExpressionEvaluator.prototype.visitConstant = function(expr, type) {
                    return expr.value;
                };
                ExpressionEvaluator.instance = new ExpressionEvaluator();
                return ExpressionEvaluator;
            }(data.DefaultSQExprVisitorWithArg);
        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var DataViewObjects;
    (function(DataViewObjects) {
        function getValue(objects, propertyId, defaultValue) {
            debug.assertAnyValue(objects, "objects");
            debug.assertValue(propertyId, "propertyId");
            if (!objects) return defaultValue;
            return DataViewObject.getValue(objects[propertyId.objectName], propertyId.propertyName, defaultValue);
        }
        DataViewObjects.getValue = getValue;
        function getObject(objects, objectName, defaultValue) {
            if (objects && objects[objectName]) {
                return objects[objectName];
            } else {
                return defaultValue;
            }
        }
        DataViewObjects.getObject = getObject;
        function getFillColor(objects, propertyId, defaultColor) {
            var value = getValue(objects, propertyId);
            if (!value || !value.solid) return defaultColor;
            return value.solid.color;
        }
        DataViewObjects.getFillColor = getFillColor;
    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));
    var DataViewObject;
    (function(DataViewObject) {
        function getValue(object, propertyName, defaultValue) {
            debug.assertAnyValue(object, "object");
            debug.assertValue(propertyName, "propertyName");
            if (!object) return defaultValue;
            var propertyValue = object[propertyName];
            if (propertyValue === undefined) return defaultValue;
            return propertyValue;
        }
        DataViewObject.getValue = getValue;
    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var inherit = powerbi.Prototype.inherit;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataViewPivotCategorical;
        (function(DataViewPivotCategorical) {
            function apply(dataView) {
                debug.assertValue(dataView, "dataView");
                var categorical = dataView.categorical;
                if (!categorical) return null;
                var categories = categorical.categories;
                if (!categories || categories.length !== 1) return null;
                var values = categorical.values;
                if (ArrayExtensions.isUndefinedOrEmpty(values) || values.source) return null;
                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];
                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {
                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];
                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {
                        var value = values[colIdx], pivotedColumn = inherit(value.source);
                        if (value.identity) return null;
                        pivotedColumn.groupName = categoryValue;
                        var pivotedValue = {
                            source: pivotedColumn,
                            values: [ value.values[rowIdx] ],
                            identity: categoryIdentity,
                            min: value.min,
                            max: value.max,
                            subtotal: value.subtotal
                        };
                        var highlights = value.highlights;
                        if (highlights) {
                            pivotedValue.highlights = [ highlights[rowIdx] ];
                        }
                        pivotedColumns.push(pivotedColumn);
                        pivotedValues.push(pivotedValue);
                    }
                }
                var pivotedMetadata = inherit(dataView.metadata);
                pivotedMetadata.columns = pivotedColumns;
                var values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields);
                values.source = category.source;
                return {
                    metadata: pivotedMetadata,
                    categorical: {
                        values: values
                    },
                    matrix: dataView.matrix
                };
            }
            DataViewPivotCategorical.apply = apply;
        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewPivotMatrix;
        (function(DataViewPivotMatrix) {
            function apply(dataViewMatrix, context) {
                debug.assertValue(dataViewMatrix, "dataViewMatrix");
                if (!context.columnHierarchyRewritten) dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);
                var columns = dataViewMatrix.columns;
                if (!context.rowHierarchyRewritten) dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);
                var rows = dataViewMatrix.rows;
                if (columns.levels.length > 1) return;
                var pivotedRowNode = {
                    level: 0
                };
                var columnLeafNodes = columns.root.children;
                var columnCount = columnLeafNodes.length;
                if (columnCount > 0) {
                    var index = 0;
                    var callback = function(node) {
                        if (node.values) {
                            if (!pivotedRowNode.values) pivotedRowNode.values = {};
                            for (var i = 0; i < columnCount; i++) pivotedRowNode.values[index++] = node.values[i];
                            delete node.values;
                        }
                        if (columnCount > 1) {
                            var level = node.level + 1;
                            if (!node.children) node.children = [];
                            for (var j = 0; j < columnCount; j++) {
                                var measureHeaderLeaf = {
                                    level: level
                                };
                                var columnLeafNode = columnLeafNodes[j];
                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;
                                if (node.isSubtotal) measureHeaderLeaf.isSubtotal = true;
                                node.children.push(measureHeaderLeaf);
                            }
                        }
                    };
                    if (context.hierarchyTreesRewritten) {
                        forEachLeaf(rows.root, callback);
                    } else {
                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);
                    }
                } else {
                    if (!context.hierarchyTreesRewritten) {
                        dataViewMatrix.columns.root = cloneTree(rows.root);
                    }
                }
                if (columnCount > 1) {
                    var level = {
                        sources: columns.levels[0].sources
                    };
                    rows.levels.push(level);
                    columns.levels.length = 0;
                }
                if (context.hierarchyTreesRewritten) {
                    dataViewMatrix.columns.root = rows.root;
                    dataViewMatrix.rows.root = {
                        children: [ pivotedRowNode ]
                    };
                } else {
                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);
                    updatedRowRoot.children = [ pivotedRowNode ];
                    dataViewMatrix.rows.root = updatedRowRoot;
                }
                dataViewMatrix.columns.levels = rows.levels;
                dataViewMatrix.rows.levels = [];
            }
            DataViewPivotMatrix.apply = apply;
            function forEachLeaf(root, callback) {
                var children = root.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++) forEachLeaf(children[i], callback);
                    return;
                }
                callback(root);
            }
            function cloneTree(node) {
                return cloneTreeExecuteOnLeaf(node);
            }
            DataViewPivotMatrix.cloneTree = cloneTree;
            function cloneTreeExecuteOnLeaf(node, callback) {
                var updatedNode = powerbi.Prototype.inherit(node);
                var children = node.children;
                if (children && children.length > 0) {
                    var newChildren = [];
                    for (var i = 0, ilen = children.length; i < ilen; i++) {
                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);
                        newChildren.push(updatedChild);
                    }
                    updatedNode.children = newChildren;
                } else {
                    if (callback) callback(updatedNode);
                }
                return updatedNode;
            }
            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;
        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DataViewSelfCrossJoin;
        (function(DataViewSelfCrossJoin) {
            function apply(dataView) {
                debug.assertValue(dataView, "dataView");
                if (!dataView.categorical) return;
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1) return;
                if (dataViewCategorical.values && dataViewCategorical.values.source) return;
                return applyCategorical(dataView.metadata, dataViewCategorical);
            }
            DataViewSelfCrossJoin.apply = apply;
            function applyCategorical(dataViewMetadata, dataViewCategorical) {
                debug.assertValue(dataViewMetadata, "dataViewMetadata");
                debug.assertValue(dataViewCategorical, "dataViewCategorical");
                debug.assertValue(dataViewCategorical.categories, "dataViewCategorical.categories");
                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadata.columns = [];
                var valuesArray = dataViewCategorical.values ? dataViewCategorical.values.grouped()[0].values : [];
                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;
                if (categoryLength === 0) return;
                var categoryIdentities = category.identity, crossJoinedValuesArray = [], nullValuesArray = createNullValues(categoryLength);
                debug.assertValue(categoryIdentities, "categoryIdentities");
                dataViewMetadata.columns.push(category.source);
                for (var i = 0; i < categoryLength; i++) {
                    var identity = categoryIdentities[i], categoryValue = categoryValues[i];
                    for (var j = 0, jlen = valuesArray.length; j < jlen; j++) {
                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;
                        var crossJoinedValueColumnSource = powerbi.Prototype.inherit(originalValueColumn.source);
                        crossJoinedValueColumnSource.groupName = categoryValue;
                        dataViewMetadata.columns.push(crossJoinedValueColumnSource);
                        var crossJoinedValueColumn = {
                            source: crossJoinedValueColumnSource,
                            identity: identity,
                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i)
                        };
                        if (originalHighlightValues) crossJoinedValueColumn.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);
                        crossJoinedValuesArray.push(crossJoinedValueColumn);
                    }
                }
                var crossJoinedValues = data.DataViewTransform.createValueColumns(crossJoinedValuesArray, category.identityFields);
                crossJoinedValues.source = category.source;
                return {
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: dataViewCategorical.categories,
                        values: crossJoinedValues
                    }
                };
            }
            function createNullValues(length) {
                debug.assertValue(length, "length");
                var array = new Array(length);
                for (var i = 0; i < length; i++) array[i] = null;
                return array;
            }
            function inheritArrayWithValue(nullValues, original, index) {
                var inherited = powerbi.Prototype.inherit(nullValues);
                inherited[index] = original[index];
                return inherited;
            }
        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        function createDisplayNameGetter(displayNameKey) {
            return function(resourceProvider) {
                return resourceProvider.get(displayNameKey);
            };
        }
        data.createDisplayNameGetter = createDisplayNameGetter;
        function getDisplayName(displayNameGetter, resourceProvider) {
            if (typeof displayNameGetter === "function") return displayNameGetter(resourceProvider);
            if (typeof displayNameGetter === "string") return displayNameGetter;
        }
        data.getDisplayName = getDisplayName;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    (function(DateTimeUnit) {
        DateTimeUnit[DateTimeUnit["Year"] = 0] = "Year";
        DateTimeUnit[DateTimeUnit["Month"] = 1] = "Month";
        DateTimeUnit[DateTimeUnit["Week"] = 2] = "Week";
        DateTimeUnit[DateTimeUnit["Day"] = 3] = "Day";
        DateTimeUnit[DateTimeUnit["Hour"] = 4] = "Hour";
        DateTimeUnit[DateTimeUnit["Minute"] = 5] = "Minute";
        DateTimeUnit[DateTimeUnit["Second"] = 6] = "Second";
        DateTimeUnit[DateTimeUnit["Millisecond"] = 7] = "Millisecond";
    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));
    var DateTimeUnit = powerbi.DateTimeUnit;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        function createDataProviderFactory(plugins) {
            return new DataProviderFactory(plugins);
        }
        data.createDataProviderFactory = createDataProviderFactory;
        var DataProviderFactory = function() {
            function DataProviderFactory(plugins) {
                debug.assertValue(plugins, "plugins");
                this.plugins = plugins;
            }
            DataProviderFactory.prototype.getPlugin = function(type) {
                var plugin = this.plugins[normalizeProviderName(type || "dsr")];
                if (!plugin) {
                    debug.assertFail("Failed to load DataPlugin of type: " + type);
                    return;
                }
                return plugin;
            };
            return DataProviderFactory;
        }();
        var DataProviderUtils;
        (function(DataProviderUtils) {
            function findType(references) {
                var type;
                for (var i = 0, len = references.length; i < len; i++) {
                    var currentType = normalizeProviderName(references[i].type);
                    if (type && type !== currentType) return;
                    type = currentType;
                }
                return type;
            }
            DataProviderUtils.findType = findType;
        })(DataProviderUtils = data.DataProviderUtils || (data.DataProviderUtils = {}));
        function normalizeProviderName(type) {
            return type || "dsr";
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var DataViewAnalysis;
    (function(DataViewAnalysis) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        function validateAndReshape(dataView, dataViewMappings) {
            if (!dataViewMappings || dataViewMappings.length === 0) return {
                dataView: dataView,
                isValid: true
            };
            if (dataView) {
                var dataViewMapping = dataViewMappings[0];
                if (supports(dataView, dataViewMapping)) return {
                    dataView: dataView,
                    isValid: true
                };
                if (dataViewMapping.categorical) return reshapeCategorical(dataView, dataViewMapping);
                if (dataViewMapping.tree) return reshapeTree(dataView, dataViewMapping.tree);
                if (dataViewMapping.single) return reshapeSingle(dataView, dataViewMapping.single);
                if (dataViewMapping.table) return reshapeTable(dataView, dataViewMapping.table);
            }
            return {
                isValid: false
            };
        }
        DataViewAnalysis.validateAndReshape = validateAndReshape;
        function reshapeCategorical(dataView, dataViewMapping) {
            debug.assertValue(dataViewMapping, "dataViewMapping");
            var categoryRoleMapping = dataViewMapping.categorical;
            var categorical = dataView.categorical;
            if (!categorical) return {
                isValid: false
            };
            var rowCount;
            if (categoryRoleMapping.rowCount) {
                rowCount = categoryRoleMapping.rowCount.supported;
                if (rowCount && rowCount.max) {
                    var updated;
                    var categories = categorical.categories;
                    var maxRowCount = rowCount.max;
                    if (categories) {
                        for (var i = 0, len = categories.length; i < len; i++) {
                            var category = categories[i];
                            var originalLength = category.values.length;
                            if (maxRowCount !== undefined && originalLength > maxRowCount) {
                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);
                                updated = updated || {
                                    categories: []
                                };
                                updated.categories.push({
                                    source: category.source,
                                    values: updatedCategories
                                });
                            }
                        }
                    }
                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {
                        if (!originalLength) originalLength = categorical.values[0].values.length;
                        if (maxRowCount !== undefined && originalLength > maxRowCount) {
                            updated = updated || {};
                            updated.values = powerbi.data.DataViewTransform.createValueColumns();
                            for (var i = 0, len = categorical.values.length; i < len; i++) {
                                var column = categorical.values[i], updatedColumn = {
                                    source: column.source,
                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)
                                };
                                if (column.min !== undefined) updatedColumn.min = column.min;
                                if (column.max !== undefined) updatedColumn.max = column.max;
                                if (column.subtotal !== undefined) updatedColumn.subtotal = column.subtotal;
                                updated.values.push(updatedColumn);
                            }
                        }
                    }
                    if (updated) {
                        dataView = {
                            metadata: dataView.metadata,
                            categorical: updated
                        };
                    }
                }
            }
            if (supportsCategorical(dataView, dataViewMapping)) return {
                dataView: dataView,
                isValid: true
            };
            return null;
        }
        function reshapeSingle(dataView, singleRoleMapping) {
            debug.assertValue(dataView, "dataView");
            debug.assertValue(singleRoleMapping, "singleRoleMapping");
            if (dataView.single) return {
                dataView: dataView,
                isValid: true
            };
            return {
                isValid: false
            };
        }
        function reshapeTree(dataView, treeRoleMapping) {
            debug.assertValue(dataView, "dataView");
            debug.assertValue(treeRoleMapping, "treeRoleMapping");
            var metadata = dataView.metadata;
            if (conforms(countGroups(metadata.columns), treeRoleMapping.depth)) return {
                dataView: dataView,
                isValid: true
            };
            return {
                isValid: false
            };
        }
        function reshapeTable(dataView, tableRoleMapping) {
            debug.assertValue(dataView, "dataView");
            debug.assertValue(tableRoleMapping, "tableRoleMapping");
            if (dataView.table) return {
                dataView: dataView,
                isValid: true
            };
            return {
                isValid: false
            };
        }
        function countGroups(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (!columns[i].isMeasure) ++count;
            }
            return count;
        }
        DataViewAnalysis.countGroups = countGroups;
        function countMeasures(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (columns[i].isMeasure) ++count;
            }
            return count;
        }
        DataViewAnalysis.countMeasures = countMeasures;
        function supports(dataView, roleMapping, usePreferredDataViewSchema) {
            if (!roleMapping || !dataView) return false;
            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema)) return false;
            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree)) return false;
            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single)) return false;
            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema)) return false;
            return true;
        }
        DataViewAnalysis.supports = supports;
        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(categoryRoleMapping, "categoryRoleMapping");
            var dataViewCategorical = dataView.categorical;
            if (!dataViewCategorical) return false;
            if (categoryRoleMapping.rowCount) {
                var rowCount = categoryRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred) rowCount = categoryRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewCategorical.values && dataViewCategorical.values.length) len = dataViewCategorical.values[0].values.length; else if (dataViewCategorical.categories && dataViewCategorical.categories.length) len = dataViewCategorical.categories[0].values.length;
                    if (!conforms(len, rowCount)) return false;
                }
            }
            return true;
        }
        function supportsSingle(dataViewSingle, singleRoleMapping) {
            debug.assertValue(singleRoleMapping, "singleRoleMapping");
            if (!dataViewSingle) return false;
            return true;
        }
        function supportsTree(dataView, treeRoleMapping) {
            debug.assertValue(treeRoleMapping, "treeRoleMapping");
            var metadata = dataView.metadata;
            return conforms(countGroups(metadata.columns), treeRoleMapping.depth);
        }
        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(tableRoleMapping, "tableRoleMapping");
            if (!dataViewTable) return false;
            if (tableRoleMapping.rowCount) {
                var rowCount = tableRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred) rowCount = tableRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewTable.rows && dataViewTable.rows.length) len = dataViewTable.rows.length;
                    if (!conforms(len, rowCount)) return false;
                }
            }
            return true;
        }
        function conforms(value, range) {
            debug.assertValue(value, "value");
            if (!range) return value === 0;
            if (range.min !== undefined && range.min > value) return false;
            if (range.max !== undefined && range.max < value) return false;
            return true;
        }
        DataViewAnalysis.conforms = conforms;
        function chooseDataViewMappings(projections, mappings) {
            debug.assertValue(projections, "projections");
            debug.assertValue(mappings, "mappings");
            var supportedMappings = [];
            for (var i = 0, len = mappings.length; i < len; i++) {
                var mapping = mappings[i], mappingConditions = mapping.conditions;
                if (mappingConditions && mappingConditions.length) {
                    for (var j = 0, jlen = mappingConditions.length; j < jlen; j++) {
                        var condition = mappingConditions[j];
                        if (matchesCondition(projections, condition)) {
                            supportedMappings.push(mapping);
                            break;
                        }
                    }
                } else {
                    supportedMappings.push(mapping);
                }
            }
            return ArrayExtensions.emptyToNull(supportedMappings);
        }
        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;
        function matchesCondition(projections, condition) {
            debug.assertValue(projections, "projections");
            debug.assertValue(condition, "condition");
            var conditionRoles = Object.keys(condition);
            for (var i = 0, len = conditionRoles.length; i < len; i++) {
                var roleName = conditionRoles[i], range = condition[roleName];
                var roleCount = getPropertyCount(roleName, projections);
                if (!conforms(roleCount, range)) return false;
            }
            return true;
        }
        function getPropertyCount(roleName, projections) {
            debug.assertValue(roleName, "roleName");
            debug.assertValue(projections, "projections");
            var projectionsForRole = projections[roleName];
            if (projectionsForRole) return projectionsForRole.length;
            return 0;
        }
        DataViewAnalysis.getPropertyCount = getPropertyCount;
        function hasSameCategoryIdentity(dataView1, dataView2) {
            if (dataView1 && dataView2 && dataView1.categorical && dataView2.categorical) {
                var dv1Categories = dataView1.categorical.categories;
                var dv2Categories = dataView2.categorical.categories;
                if (dv1Categories && dv2Categories && dv1Categories.length === dv2Categories.length) {
                    for (var i = 0, len = dv1Categories.length; i < len; i++) {
                        var dv1Identity = dv1Categories[i].identity;
                        var dv2Identity = dv2Categories[i].identity;
                        if (dv1Identity != null !== (dv2Identity != null)) return false;
                        if (dv1Identity.length !== dv2Identity.length) {
                            return false;
                        }
                        for (var j = 0, jlen = dv1Identity.length; j < jlen; j++) {
                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j])) return false;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;
    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var DataViewScopeIdentity;
    (function(DataViewScopeIdentity) {
        function equals(x, y, ignoreCase) {
            x = x || null;
            y = y || null;
            if (x === y) return true;
            if (!x !== !y) return false;
            debug.assertValue(x, "x");
            debug.assertValue(y, "y");
            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);
        }
        DataViewScopeIdentity.equals = equals;
        function filterFromIdentity(identities, isNot) {
            if (ArrayExtensions.isUndefinedOrEmpty(identities)) return;
            var expr;
            for (var i = 0, len = identities.length; i < len; i++) {
                var identity = identities[i];
                expr = expr ? powerbi.data.SQExprBuilder.or(expr, identity.expr) : identity.expr;
            }
            if (expr && isNot) expr = powerbi.data.SQExprBuilder.not(expr);
            return powerbi.data.SemanticFilter.fromSQExpr(expr);
        }
        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;
    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));
    var data;
    (function(data) {
        var Lazy = jsCommon.Lazy;
        function createDataViewScopeIdentity(expr) {
            return new DataViewScopeIdentityImpl(expr);
        }
        data.createDataViewScopeIdentity = createDataViewScopeIdentity;
        var DataViewScopeIdentityImpl = function() {
            function DataViewScopeIdentityImpl(expr) {
                debug.assertValue(expr, "expr");
                this._expr = expr;
                this._key = new Lazy(function() {
                    return data.SQExprShortSerializer.serialize(expr);
                });
            }
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "expr", {
                get: function() {
                    return this._expr;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "key", {
                get: function() {
                    return this._key.getValue();
                },
                enumerable: true,
                configurable: true
            });
            return DataViewScopeIdentityImpl;
        }();
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var Lazy = jsCommon.Lazy;
        var DataViewScopeWildcard;
        (function(DataViewScopeWildcard) {
            function matches(wildcard, instance) {
                var instanceExprs = data.ScopeIdentityKeyExtractor.run(instance.expr);
                if (!instanceExprs) return false;
                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);
            }
            DataViewScopeWildcard.matches = matches;
            function fromExprs(exprs) {
                return new DataViewScopeWildcardImpl(exprs);
            }
            DataViewScopeWildcard.fromExprs = fromExprs;
            var DataViewScopeWildcardImpl = function() {
                function DataViewScopeWildcardImpl(exprs) {
                    debug.assertValue(exprs, "exprs");
                    this._exprs = exprs;
                    this._key = new Lazy(function() {
                        return data.SQExprShortSerializer.serializeArray(exprs);
                    });
                }
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "exprs", {
                    get: function() {
                        return this._exprs;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "key", {
                    get: function() {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewScopeWildcardImpl;
            }();
        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var inherit = powerbi.Prototype.inherit;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var CategoricalDataViewTransformation;
        (function(CategoricalDataViewTransformation) {
            CategoricalDataViewTransformation[CategoricalDataViewTransformation["None"] = 0] = "None";
            CategoricalDataViewTransformation[CategoricalDataViewTransformation["Pivot"] = 1] = "Pivot";
            CategoricalDataViewTransformation[CategoricalDataViewTransformation["SelfCrossJoin"] = 2] = "SelfCrossJoin";
        })(CategoricalDataViewTransformation || (CategoricalDataViewTransformation = {}));
        var DataViewTransform;
        (function(DataViewTransform) {
            function apply(options) {
                debug.assertValue(options, "options");
                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, colorAllocatorFactory = options.colorAllocatorFactory;
                if (!prototype) return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);
                if (!transforms) return [ prototype ];
                var splits = transforms.splits;
                if (ArrayExtensions.isUndefinedOrEmpty(splits)) {
                    return [ transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory) ];
                }
                var transformedDataviews = [];
                for (var i = 0, len = splits.length; i < len; i++) {
                    var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, splits[i].selects);
                    transformedDataviews.push(transformed);
                }
                return transformedDataviews;
            }
            DataViewTransform.apply = apply;
            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {
                if (transforms && transforms.objects) {
                    var emptyDataView = {
                        metadata: {
                            columns: []
                        }
                    };
                    transformObjects(emptyDataView, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);
                    return [ emptyDataView ];
                }
                return [];
            }
            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, selectsToInclude) {
                debug.assertValue(prototype, "prototype");
                var transformed = inherit(prototype);
                transformed.metadata = inherit(prototype.metadata);
                transformed = transformSelects(transformed, roleMappings, transforms.selects, transforms.projectionOrdering, selectsToInclude);
                transformObjects(transformed, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);
                return transformed;
            }
            function transformSelects(dataView, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {
                var columnRewrites = [];
                if (selectTransforms) {
                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);
                }
                if (dataView.categorical) {
                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);
                    dataView = pivotIfNecessary(dataView, roleMappings);
                }
                if (dataView.matrix) {
                    var matrixTransformationContext = {
                        rowHierarchyRewritten: false,
                        columnHierarchyRewritten: false,
                        hierarchyTreesRewritten: false
                    };
                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);
                    if (shouldPivotMatrix(dataView.matrix, roleMappings)) data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);
                }
                if (dataView.table) dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);
                return dataView;
            }
            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {
                debug.assertValue(prototypeColumns, "columns");
                if (!selects) return prototypeColumns;
                var columns = inherit(prototypeColumns);
                for (var i = 0, len = prototypeColumns.length; i < len; i++) {
                    var prototypeColumn = prototypeColumns[i];
                    var select = selects[prototypeColumn.index];
                    if (!select) continue;
                    var column = columns[i] = inherit(prototypeColumn);
                    if (select.roles) column.roles = select.roles;
                    if (select.type) column.type = select.type;
                    column.format = getFormatForColumn(select, column);
                    if (select.displayName) column.displayName = select.displayName;
                    if (select.queryName) column.queryName = select.queryName;
                    rewrites.push({
                        from: prototypeColumn,
                        to: column
                    });
                }
                return columns;
            }
            function getFormatForColumn(select, column) {
                if (select.format) return select.format;
                if (column.format) return column.format;
                var type = column.type;
                if (type) {
                    if (type.dateTime) return "d";
                    if (type.integer) return "g";
                    if (type.numeric) return "#,0.00";
                }
                return undefined;
            }
            function upgradeSettingsToObjects(settings, objectDefns) {
                if (!settings) return;
                if (!objectDefns) objectDefns = {};
                for (var propertyKey in settings) {
                    var propertyValue = settings[propertyKey], upgradedPropertyKey = propertyKey, upgradedPropertyValue = propertyValue, objectName = "general";
                    switch (propertyKey) {
                      case "hasScalarCategoryAxis":
                        objectName = "categoryAxis";
                        upgradedPropertyKey = "axisType";
                        upgradedPropertyValue = data.SQExprBuilder.text(propertyValue ? powerbi.axisType.scalar : powerbi.axisType.categorical);
                        break;

                      case "Totals":
                        upgradedPropertyKey = "totals";
                        upgradedPropertyValue = data.SQExprBuilder.boolean(!!propertyValue);
                        break;

                      case "textboxSettings":
                        upgradedPropertyKey = "paragraphs";
                        if (propertyValue && propertyValue.paragraphs) upgradedPropertyValue = propertyValue.paragraphs;
                        break;

                      case "VisualType1":
                        upgradedPropertyKey = "visualType1";
                        upgradedPropertyValue = data.SQExprBuilder.text(propertyValue);
                        break;

                      case "VisualType2":
                        upgradedPropertyKey = "visualType2";
                        upgradedPropertyValue = data.SQExprBuilder.text(propertyValue);
                        break;

                      case "imageVisualSettings":
                        upgradedPropertyKey = "imageUrl";
                        if (propertyValue && propertyValue.imageUrl) upgradedPropertyValue = data.SQExprBuilder.text(propertyValue.imageUrl);
                        break;

                      default:
                        continue;
                    }
                    setObjectDefinition(objectDefns, objectName, upgradedPropertyKey, upgradedPropertyValue);
                }
                return objectDefns;
            }
            DataViewTransform.upgradeSettingsToObjects = upgradeSettingsToObjects;
            function setObjectDefinition(objects, objectName, propertyName, value) {
                debug.assertValue(objects, "objects");
                debug.assertValue(objectName, "objectName");
                debug.assertValue(propertyName, "propertyName");
                var objectContainer = objects[objectName];
                if (objectContainer === undefined) objectContainer = objects[objectName] = [];
                var object = objectContainer[0];
                if (object === undefined) object = objectContainer[0] = {
                    properties: {}
                };
                object.properties[propertyName] = value;
            }
            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {
                debug.assertValue(prototype, "prototype");
                debug.assertValue(columnRewrites, "columnRewrites");
                var categorical = inherit(prototype);
                function override(value) {
                    var rewrittenSource = findOverride(value.source, columnRewrites);
                    if (rewrittenSource) {
                        var rewritten = inherit(value);
                        rewritten.source = rewrittenSource;
                        return rewritten;
                    }
                }
                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);
                if (categories) categorical.categories = categories;
                var values = powerbi.Prototype.overrideArray(prototype.values, override);
                if (values) {
                    if (selectsToInclude) {
                        for (var i = values.length - 1; i >= 0; i--) {
                            if (!selectsToInclude[values[i].source.index]) values.splice(i, 1);
                        }
                    }
                    if (values.source) {
                        if (selectsToInclude && !selectsToInclude[values.source.index]) {
                            values.source = undefined;
                        } else {
                            var rewrittenValuesSource = findOverride(values.source, columnRewrites);
                            if (rewrittenValuesSource) values.source = rewrittenValuesSource;
                        }
                    }
                    categorical.values = values;
                    setGrouped(values);
                }
                return categorical;
            }
            function applyRewritesToTable(prototype, columnRewrites, roleMappings, projectionOrdering) {
                debug.assertValue(prototype, "prototype");
                debug.assertValue(columnRewrites, "columnRewrites");
                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table) return prototype;
                var table = inherit(prototype);
                var override = function(metadata) {
                    return findOverride(metadata, columnRewrites);
                };
                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);
                if (columns) table.columns = columns;
                if (!projectionOrdering) return table;
                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);
                if (!newToOldPositions) return table;
                var columnsClone = columns.slice(0);
                var keys = Object.keys(newToOldPositions);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];
                    if (i === columns.length) columns.push(sourceColumn); else {
                        debug.assert(i < columns.length, "The column index is out of range for reordering.");
                        columns[i] = sourceColumn;
                    }
                }
                var rows = powerbi.Prototype.overrideArray(table.rows, function(row) {
                    var newRow = [];
                    for (var i = 0, len = keys.length; i < len; ++i) newRow[i] = row[newToOldPositions[keys[i]]];
                    return newRow;
                });
                if (rows) table.rows = rows;
                return table;
            }
            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {
                var roles = Object.keys(projectionOrdering);
                debug.assert(roles.length === 1, "Tables should have exactly one role.");
                var role = roles[0], originalOrder = columnRewrites.map(function(rewrite) {
                    return rewrite.from.index;
                }), newOrder = projectionOrdering[role];
                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function(x, y) {
                    return x === y;
                })) return;
                return createOrderMapping(originalOrder, newOrder);
            }
            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {
                debug.assertValue(prototype, "prototype");
                debug.assertValue(columnRewrites, "columnRewrites");
                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].matrix) return prototype;
                var matrix = inherit(prototype);
                function override(metadata) {
                    return findOverride(metadata, columnRewrites);
                }
                function overrideHierarchy(hierarchy) {
                    var rewrittenHierarchy = null;
                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function(level) {
                        var newLevel = null;
                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);
                        if (levelSources) newLevel = ensureRewritten(newLevel, level, function(h) {
                            return h.sources = levelSources;
                        });
                        return newLevel;
                    });
                    if (newLevels) rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function(r) {
                        return r.levels = newLevels;
                    });
                    return rewrittenHierarchy;
                }
                var rows = overrideHierarchy(matrix.rows);
                if (rows) {
                    matrix.rows = rows;
                    context.rowHierarchyRewritten = true;
                }
                var columns = overrideHierarchy(matrix.columns);
                if (columns) {
                    matrix.columns = columns;
                    context.columnHierarchyRewritten = true;
                }
                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);
                if (valueSources) {
                    matrix.valueSources = valueSources;
                    if (projectionOrdering && valueSources.length > 1) {
                        var columnLevels = columns.levels.length;
                        if (columnLevels > 0) {
                            var newToOldPositions = createMatrixValuesPositionMapping(roleMappings[0].matrix, projectionOrdering, valueSources, columnRewrites);
                            if (newToOldPositions) {
                                var keys = Object.keys(newToOldPositions);
                                var numKeys = keys.length;
                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);
                                if (columnLevels === 1) reorderChildNodes(columns.root, newToOldPositions); else forEachNodeAtLevel(columns.root, columnLevels - 2, function(node) {
                                    return reorderChildNodes(node, newToOldPositions);
                                });
                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function(node) {
                                    var newValues = {};
                                    var iterations = Object.keys(node.values).length / numKeys;
                                    for (var i = 0, len = iterations; i < len; i++) {
                                        var offset = i * numKeys;
                                        for (var keysIndex = 0; keysIndex < numKeys; keysIndex++) newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];
                                    }
                                    node.values = newValues;
                                });
                                context.hierarchyTreesRewritten = true;
                            }
                        }
                    }
                }
                return matrix;
            }
            function reorderChildNodes(node, newToOldPositions) {
                var keys = Object.keys(newToOldPositions);
                var numKeys = keys.length;
                var children = node.children;
                var childrenClone = children.slice(0);
                for (var i = 0, len = numKeys; i < len; i++) {
                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];
                    if (i === children.length) children.push(sourceColumn); else {
                        debug.assert(i < children.length, "The column index is out of range for reordering.");
                        children[i] = sourceColumn;
                    }
                }
            }
            function createMatrixValuesPositionMapping(matrixMapping, projectionOrdering, valueSources, columnRewrites) {
                var role = matrixMapping.values.for.in;
                function matchValueSource(columnRewrite) {
                    for (var i = 0, len = valueSources.length; i < len; i++) {
                        var valueSource = valueSources[i];
                        if (valueSource === columnRewrite.to) return columnRewrite;
                    }
                }
                var valueRewrites = [];
                for (var i = 0, len = columnRewrites.length; i < len; i++) {
                    var columnRewrite = columnRewrites[i];
                    if (matchValueSource(columnRewrite)) valueRewrites.push(columnRewrite);
                }
                var newOrder = projectionOrdering[role];
                var originalOrder = valueRewrites.map(function(rewrite) {
                    return rewrite.from.index;
                });
                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function(x, y) {
                    return x === y;
                })) return;
                return createOrderMapping(originalOrder, newOrder);
            }
            function createOrderMapping(originalOrder, newOrder) {
                var mapping = {};
                for (var i = 0, len = newOrder.length; i < len; ++i) {
                    var newPosition = newOrder[i];
                    mapping[i] = originalOrder.indexOf(newPosition);
                }
                return mapping;
            }
            function forEachNodeAtLevel(node, targetLevel, callback) {
                if (node.level === targetLevel) {
                    callback(node);
                    return;
                }
                var children = node.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++) forEachNodeAtLevel(children[i], targetLevel, callback);
                }
            }
            function findOverride(source, columnRewrites) {
                for (var i = 0, len = columnRewrites.length; i < len; i++) {
                    var columnRewrite = columnRewrites[i];
                    if (columnRewrite.from === source) return columnRewrite.to;
                }
            }
            function ensureRewritten(rewritten, prototype, callback) {
                if (!rewritten) rewritten = inherit(prototype);
                if (callback) callback(rewritten);
                return rewritten;
            }
            function transformObjects(dataView, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {
                debug.assertValue(dataView, "dataView");
                debug.assertAnyValue(objectDescriptors, "objectDescriptors");
                debug.assertAnyValue(objectDefinitions, "objectDefinitions");
                debug.assertAnyValue(selectTransforms, "selectTransforms");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                if (!objectDescriptors) return;
                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);
                if (selectTransforms) data.DataViewObjectEvaluationUtils.addDefaultFormatString(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);
                var metadataOnce = objectsForAllSelectors.metadataOnce;
                var dataObjects = objectsForAllSelectors.data;
                if (metadataOnce) evaluateMetadataObjects(dataView, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);
                var metadataObjects = objectsForAllSelectors.metadata;
                if (metadataObjects) {
                    for (var i = 0, len = metadataObjects.length; i < len; i++) {
                        var metadataObject = metadataObjects[i];
                        evaluateMetadataRepetition(dataView, objectDescriptors, metadataObject.selector, metadataObject.objects);
                    }
                }
                for (var i = 0, len = dataObjects.length; i < len; i++) {
                    var dataObject = dataObjects[i];
                    evaluateDataRepetition(dataView, objectDescriptors, dataObject.selector, dataObject.rules, dataObject.objects);
                }
                if (objectsForAllSelectors.userDefined) {}
            }
            function evaluateMetadataObjects(dataView, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(objectDefns, "objectDefns");
                debug.assertValue(dataObjects, "dataObjects");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(objectDescriptors, objectDefns);
                if (objects) {
                    dataView.metadata.objects = objects;
                    for (var objectName in objects) {
                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];
                        for (var propertyName in object) {
                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;
                            if (!ruleDesc) continue;
                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);
                            if (!definition) continue;
                            dataObjects.push(definition);
                        }
                    }
                }
            }
            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                debug.assertValue(ruleDesc, "ruleDesc");
                debug.assertValue(propertyValue, "propertyValue");
                debug.assertValue(ruleType, "ruleType");
                var ruleOutput = ruleDesc.output;
                if (!ruleOutput) return;
                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);
                if (ruleType.fillRule) return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);
                if (ruleType.filter) return createRuleEvaluationInstanceFilter(dataView, ruleDesc, selectorToCreate, objectName, propertyValue);
            }
            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                debug.assertValue(ruleDesc, "ruleDesc");
                debug.assertValue(selectorToCreate, "selectorToCreate");
                debug.assertValue(propertyValue, "propertyValue");
                var colorAllocator;
                if (propertyValue.linearGradient2) colorAllocator = createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient2); else if (propertyValue.linearGradient3) colorAllocator = createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, ruleDesc, propertyValue, propertyValue.linearGradient3);
                if (!colorAllocator) return;
                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);
                var fillRuleProperties = {};
                fillRuleProperties[ruleDesc.output.property] = {
                    solid: {
                        color: rule
                    }
                };
                return {
                    selector: selectorToCreate,
                    rules: [ rule ],
                    objects: [ {
                        name: objectName,
                        properties: fillRuleProperties
                    } ]
                };
            }
            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, ruleDesc, propertyValueFillRule, linearGradient2) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                debug.assertValue(ruleDesc, "ruleDesc");
                debug.assertValue(linearGradient2, "linearGradient2");
                var linearGradient2 = propertyValueFillRule.linearGradient2;
                if (linearGradient2.min.value === undefined || linearGradient2.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);
                    if (!inputRange) return;
                    if (linearGradient2.min.value === undefined) linearGradient2.min.value = inputRange.min;
                    if (linearGradient2.max.value === undefined) linearGradient2.max.value = inputRange.max;
                }
                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);
            }
            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, ruleDesc, propertyValueFillRule, linearGradient3) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(colorAllocatorFactory, "colorAllocatorFactory");
                debug.assertValue(ruleDesc, "ruleDesc");
                debug.assertValue(linearGradient3, "linearGradient3");
                var linearGradient3 = propertyValueFillRule.linearGradient3;
                if (linearGradient3.min.value === undefined || linearGradient3.mid.value === undefined || linearGradient3.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, ruleDesc.inputRole);
                    if (!inputRange) return;
                    if (linearGradient3.min.value === undefined) {
                        linearGradient3.min.value = inputRange.min;
                    }
                    if (linearGradient3.max.value === undefined) {
                        linearGradient3.max.value = inputRange.max;
                    }
                    if (linearGradient3.mid.value === undefined) {
                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;
                        linearGradient3.mid.value = midValue;
                    }
                }
                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3);
            }
            function createRuleEvaluationInstanceFilter(dataView, ruleDesc, selectorToCreate, objectName, propertyValue) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(ruleDesc, "ruleDesc");
                debug.assertValue(selectorToCreate, "selectorToCreate");
                debug.assertValue(propertyValue, "propertyValue");
                if (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length !== 1) return;
                var identityFields = dataView.categorical.categories[0].identityFields;
                if (!identityFields) return;
                var scopeIds = data.SQExprConverter.asScopeIdsContainer(propertyValue, identityFields);
                if (!scopeIds) return;
                var rule = new data.FilterRuleEvaluation(scopeIds);
                var properties = {};
                properties[ruleDesc.output.property] = rule;
                return {
                    selector: selectorToCreate,
                    rules: [ rule ],
                    objects: [ {
                        name: objectName,
                        properties: properties
                    } ]
                };
            }
            function evaluateDataRepetition(dataView, objectDescriptors, selector, rules, objectDefns) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(selector, "selector");
                debug.assertAnyValue(rules, "rules");
                debug.assertValue(objectDefns, "objectDefns");
                var containsWildcard = data.Selector.containsWildcard(selector);
                var dataViewCategorical = dataView.categorical;
                if (dataViewCategorical) {
                    var selectorMatched = false;
                    selectorMatched = evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) || selectorMatched;
                    selectorMatched = evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) || selectorMatched;
                    if (selectorMatched) return;
                }
            }
            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) {
                debug.assertValue(dataViewCategorical, "dataViewCategorical");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(selector, "selector");
                debug.assertAnyValue(rules, "rules");
                debug.assertValue(containsWildcard, "containsWildcard");
                debug.assertValue(objectDefns, "objectDefns");
                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0) return;
                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);
                if (!targetColumn) return;
                var identities = targetColumn.identities, foundMatch, matchedRules;
                if (!identities) return;
                debug.assert(targetColumn.column.values.length === identities.length, "Column length mismatch");
                for (var i = 0, len = identities.length; i < len; i++) {
                    var identity = identities[i];
                    if (containsWildcard || data.Selector.matchesData(selector, [ identity ])) {
                        if (rules) {
                            if (!matchedRules) matchedRules = matchRulesToDataViewCategorical(rules, dataViewCategorical);
                            for (var ruleIdx = 0, ruleLen = matchedRules.length; ruleIdx < ruleLen; ruleIdx++) {
                                var matchedRule = matchedRules[ruleIdx];
                                matchedRule.rule.setContext(identity, matchedRule.inputValues ? matchedRule.inputValues[i] : undefined);
                            }
                        }
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(objectDescriptors, objectDefns);
                        if (objects) {
                            if (!targetColumn.column.objects) {
                                targetColumn.column.objects = [];
                                targetColumn.column.objects.length = len;
                            }
                            targetColumn.column.objects[i] = objects;
                        }
                        if (!containsWildcard) return true;
                        foundMatch = true;
                    }
                }
                return foundMatch;
            }
            function matchRulesToDataViewCategorical(rules, dataViewCategorical) {
                var result = [];
                for (var i = 0, len = rules.length; i < len; i++) {
                    var rule = rules[i], inputColumn = findRuleInputCategoricalColumn(dataViewCategorical, rule.inputRole);
                    var inputValues;
                    if (inputColumn) inputValues = inputColumn.values;
                    result.push({
                        rule: rule,
                        inputValues: inputValues
                    });
                }
                return result;
            }
            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns) {
                debug.assertValue(dataViewCategorical, "dataViewCategorical");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(selector, "selector");
                debug.assertAnyValue(rules, "rules");
                debug.assertValue(containsWildcard, "containsWildcard");
                debug.assertValue(objectDefns, "objectDefns");
                var dataViewCategoricalValues = dataViewCategorical.values;
                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields) return;
                if (!data.Selector.matchesKeys(selector, [ dataViewCategoricalValues.identityFields ])) return;
                var valuesGrouped = dataViewCategoricalValues.grouped();
                if (!valuesGrouped) return;
                var foundMatch;
                for (var i = 0, len = valuesGrouped.length; i < len; i++) {
                    var valueGroup = valuesGrouped[i];
                    if (containsWildcard || data.Selector.matchesData(selector, [ valueGroup.identity ])) {
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(objectDescriptors, objectDefns);
                        if (objects) {
                            valueGroup.objects = objects;
                            setGrouped(dataViewCategoricalValues, valuesGrouped);
                        }
                        if (!containsWildcard) return true;
                        foundMatch = true;
                    }
                }
                return foundMatch;
            }
            function evaluateMetadataRepetition(dataView, objectDescriptors, selector, objectDefns) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(objectDescriptors, "objectDescriptors");
                debug.assertValue(selector, "selector");
                debug.assertValue(objectDefns, "objectDefns");
                var columns = dataView.metadata.columns, metadataId = selector.metadata;
                for (var i = 0, len = columns.length; i < len; i++) {
                    var column = columns[i];
                    if (column.queryName === metadataId) {
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(objectDescriptors, objectDefns);
                        if (objects) column.objects = objects;
                    }
                }
            }
            function findSelectedCategoricalColumn(dataViewCategorical, selector) {
                debug.assertValue(dataViewCategorical.categories[0], "dataViewCategorical.categories[0]");
                var categoricalColumn = dataViewCategorical.categories[0];
                if (!categoricalColumn.identityFields) return;
                if (!data.Selector.matchesKeys(selector, [ categoricalColumn.identityFields ])) return;
                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;
                var selectedMetadataId = selector.metadata;
                if (selectedMetadataId) {
                    var valueColumns = dataViewCategorical.values;
                    if (valueColumns) {
                        for (var i = 0, len = valueColumns.length; i < len; i++) {
                            var valueColumn = valueColumns[i];
                            if (valueColumn.source.queryName === selectedMetadataId) {
                                targetColumn = valueColumn;
                                break;
                            }
                        }
                    }
                }
                return {
                    column: targetColumn,
                    identities: identities
                };
            }
            function findSelectorForRuleInput(dataView, selectorRoles) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(selectorRoles, "selectorRoles");
                if (selectorRoles.length !== 1) return;
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical) return;
                var categories = dataViewCategorical.categories;
                if (!categories || categories.length !== 1) return;
                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;
                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]]) return;
                return {
                    data: [ data.DataViewScopeWildcard.fromExprs(categoryIdentityFields) ]
                };
            }
            function findRuleInputCategoricalColumn(dataViewCategorical, inputRole) {
                debug.assertValue(dataViewCategorical, "dataViewCategorical");
                return findRuleInputInCategoricalColumns(dataViewCategorical.values, inputRole) || findRuleInputInCategoricalColumns(dataViewCategorical.categories, inputRole);
            }
            function findRuleInputInCategoricalColumns(columns, inputRole) {
                debug.assertAnyValue(columns, "columns");
                if (!columns) return;
                for (var i = 0, len = columns.length; i < len; i++) {
                    var column = columns[i], roles = column.source.roles;
                    if (!roles || !roles[inputRole]) continue;
                    return column;
                }
            }
            function findRuleInputColumnNumberRange(dataView, inputRole) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(inputRole, "inputRole");
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical) return;
                var values = dataViewCategorical.values;
                if (!values) return;
                for (var i = 0, len = values.length; i < len; i++) {
                    var valueCol = values[i], valueColRoles = valueCol.source.roles;
                    if (!valueColRoles || !valueColRoles[inputRole]) continue;
                    var min = valueCol.min;
                    if (min === undefined) min = valueCol.minLocal;
                    if (min === undefined) continue;
                    var max = valueCol.max;
                    if (max === undefined) max = valueCol.maxLocal;
                    if (max === undefined) continue;
                    return {
                        min: min,
                        max: max
                    };
                }
            }
            function createTransformActions(queryMetadata, visualElements, objectDescs, objectDefns) {
                debug.assertAnyValue(queryMetadata, "queryMetadata");
                debug.assertAnyValue(visualElements, "visualElements");
                debug.assertAnyValue(objectDescs, "objectDescs");
                debug.assertAnyValue(objectDefns, "objectDefns");
                if ((!queryMetadata || ArrayExtensions.isUndefinedOrEmpty(queryMetadata.Select)) && ArrayExtensions.isUndefinedOrEmpty(visualElements) && !objectDefns) return;
                var transforms = {};
                if (queryMetadata) {
                    var querySelects = queryMetadata.Select;
                    if (querySelects) {
                        var transformSelects = transforms.selects = [];
                        for (var i = 0, len = querySelects.length; i < len; i++) {
                            var selectMetadata = querySelects[i], selectTransform = toTransformSelect(selectMetadata, i);
                            transformSelects.push(selectTransform);
                            if (selectTransform.format && objectDescs) {
                                debug.assert(!!selectTransform.queryName, "selectTransform.queryName should be defined (or defaulted).");
                                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescs);
                                if (formatStringProp) {
                                    if (!objectDefns) objectDefns = {};
                                    data.DataViewObjectDefinitions.ensure(objectDefns, formatStringProp.objectName, {
                                        metadata: selectTransform.queryName
                                    }).properties[formatStringProp.propertyName] = data.SQExprBuilder.text(selectTransform.format);
                                }
                            }
                        }
                    }
                }
                if (visualElements) {
                    var visualElementsLength = visualElements.length;
                    if (visualElementsLength > 1) transforms.splits = [];
                    for (var i = 0; i < visualElementsLength; i++) {
                        var visualElement = visualElements[i];
                        if (visualElement.Settings && i === 0) objectDefns = upgradeSettingsToObjects(visualElement.Settings, objectDefns);
                        if (visualElement.DataRoles) {
                            if (!transforms.selects) transforms.selects = [];
                            populateDataRoles(visualElement.DataRoles, transforms.selects);
                        }
                        if (transforms.splits) transforms.splits.push(populateSplit(visualElement.DataRoles));
                    }
                }
                if (objectDefns) transforms.objects = objectDefns;
                return transforms;
            }
            DataViewTransform.createTransformActions = createTransformActions;
            function toTransformSelect(select, index) {
                debug.assertValue(select, "select");
                var result = {};
                if (select.Restatement) result.displayName = select.Restatement;
                if (select.Name) result.queryName = select.Name; else if (!result.queryName) result.queryName = "$select" + index;
                if (select.Format) result.format = select.Format;
                if (select.Type) result.type = data.dsr.DataShapeUtility.describeDataType(select.Type, data.ConceptualDataCategory[select.DataCategory]);
                return result;
            }
            function populateDataRoles(roles, selects) {
                debug.assertValue(roles, "roles");
                debug.assertValue(selects, "selects");
                for (var i = 0, len = roles.length; i < len; i++) {
                    var role = roles[i], roleProjection = role.Projection;
                    var select = selects[roleProjection];
                    if (select === undefined) {
                        fillArray(selects, roleProjection);
                        select = selects[roleProjection] = {};
                    }
                    var selectRoles = select.roles;
                    if (select.roles === undefined) selectRoles = select.roles = {};
                    selectRoles[role.Name] = true;
                }
            }
            function fillArray(selects, length) {
                debug.assertValue(selects, "selects");
                debug.assertValue(length, "length");
                for (var i = selects.length; i < length; i++) selects[i] = {};
            }
            function populateSplit(roles) {
                debug.assertAnyValue(roles, "roles");
                var selects = {};
                var split = {
                    selects: selects
                };
                if (roles) {
                    for (var i = 0, len = roles.length; i < len; i++) {
                        var role = roles[i];
                        selects[role.Projection] = true;
                    }
                }
                return split;
            }
            function createValueColumns(values, valueIdentityFields) {
                if (values === void 0) {
                    values = [];
                }
                var result = values;
                setGrouped(values);
                if (valueIdentityFields) result.identityFields = valueIdentityFields;
                return result;
            }
            DataViewTransform.createValueColumns = createValueColumns;
            function setGrouped(values, groupedResult) {
                values.grouped = groupedResult ? function() {
                    return groupedResult;
                } : function() {
                    return groupValues(values);
                };
            }
            function groupValues(values) {
                debug.assertValue(values, "values");
                var groups = [], currentGroup;
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    if (!currentGroup || currentGroup.identity !== value.identity) {
                        currentGroup = {
                            values: []
                        };
                        if (value.identity) {
                            currentGroup.identity = value.identity;
                            var source = value.source;
                            if (source.groupName !== undefined) currentGroup.name = source.groupName; else if (source.displayName) currentGroup.name = source.displayName;
                        }
                        groups.push(currentGroup);
                    }
                    currentGroup.values.push(value);
                }
                return groups;
            }
            function pivotIfNecessary(dataView, dataViewMappings) {
                debug.assertValue(dataView, "dataView");
                var transformedDataView;
                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {
                  case 1:
                    transformedDataView = data.DataViewPivotCategorical.apply(dataView);
                    break;

                  case 2:
                    transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);
                    break;
                }
                return transformedDataView || dataView;
            }
            function determineCategoricalTransformation(categorical, dataViewMappings) {
                if (!categorical || ArrayExtensions.isUndefinedOrEmpty(dataViewMappings)) return;
                var categories = categorical.categories;
                if (!categories || categories.length !== 1) return;
                var values = categorical.values;
                if (ArrayExtensions.isUndefinedOrEmpty(values)) return;
                if (values.grouped().some(function(vg) {
                    return !!vg.identity;
                })) return;
                var categoryRoles = categories[0].source.roles;
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var roleMappingCategorical = dataViewMappings[i].categorical;
                    if (!roleMappingCategorical) continue;
                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values)) continue;
                    var categoriesMapping = roleMappingCategorical.categories;
                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) || hasRolesFor(categoryRoles, categoriesMapping);
                    if (hasCategoryRole) return 2;
                    return 1;
                }
            }
            function shouldPivotMatrix(matrix, dataViewMappings) {
                if (!matrix || ArrayExtensions.isUndefinedOrEmpty(dataViewMappings)) return;
                var rowLevels = matrix.rows.levels;
                if (rowLevels.length < 1) return;
                var rows = matrix.rows.root.children;
                if (!rows || rows.length === 0) return;
                var rowRoles = rowLevels[0].sources[0].roles;
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var roleMappingMatrix = dataViewMappings[i].matrix;
                    if (!roleMappingMatrix) continue;
                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) && hasRolesFor(rowRoles, roleMappingMatrix.columns)) {
                        return true;
                    }
                }
            }
            function hasRolesBind(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.bind) return roles[roleMapping.bind.to];
            }
            function hasRolesFor(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.for) return roles[roleMapping.for.in];
            }
            function hasRolesGrouped(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.group) return roles[roleMapping.group.by];
            }
        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var RuleEvaluation = function() {
            function RuleEvaluation(inputRole) {
                debug.assertAnyValue(inputRole, "inputRole");
                if (inputRole) this.inputRole = inputRole;
            }
            RuleEvaluation.prototype.setContext = function(scopeId, value) {
                this.scopeId = scopeId;
                this.value = value;
            };
            RuleEvaluation.prototype.evaluate = function() {
                debug.assertFail("Abstract method RuleEvaluation.evaluate not implemented.");
            };
            return RuleEvaluation;
        }();
        data.RuleEvaluation = RuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var ColorRuleEvaluation = function(_super) {
            __extends(ColorRuleEvaluation, _super);
            function ColorRuleEvaluation(inputRole, allocator) {
                debug.assertAnyValue(inputRole, "inputRole");
                debug.assertValue(allocator, "allocator");
                _super.call(this, inputRole);
                this.allocator = allocator;
            }
            ColorRuleEvaluation.prototype.evaluate = function() {
                return this.allocator.color(this.value);
            };
            return ColorRuleEvaluation;
        }(data.RuleEvaluation);
        data.ColorRuleEvaluation = ColorRuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var FilterRuleEvaluation = function(_super) {
            __extends(FilterRuleEvaluation, _super);
            function FilterRuleEvaluation(scopeIds) {
                debug.assertValue(scopeIds, "scopeIds");
                _super.call(this);
                this.selection = scopeIds;
            }
            FilterRuleEvaluation.prototype.evaluate = function() {
                var currentScopeId = this.scopeId, selectedScopeIds = this.selection.scopeIds;
                for (var i = 0, len = selectedScopeIds.length; i < len; i++) {
                    if (powerbi.DataViewScopeIdentity.equals(currentScopeId, selectedScopeIds[i])) return !this.selection.isNot;
                }
            };
            return FilterRuleEvaluation;
        }(data.RuleEvaluation);
        data.FilterRuleEvaluation = FilterRuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            function mergeMappings(mappings, projections, indicesByName) {
                debug.assertValue(mappings, "mappings");
                var mappingsLength = mappings.length;
                if (mappingsLength === 1) return {
                    mapping: mappings[0]
                };
                var mapping, splits = [];
                for (var i = 0; i < mappingsLength; i++) {
                    var currentMapping = mappings[i];
                    if (!currentMapping.categorical) return;
                    if (i === 0) {
                        mapping = {
                            metadata: currentMapping.metadata,
                            categorical: {}
                        };
                    }
                    Impl.mergeCategorical(mapping.categorical, currentMapping.categorical);
                    splits.push(Impl.createSplit(projections, indicesByName, currentMapping.categorical));
                }
                return {
                    mapping: mapping,
                    splits: splits
                };
            }
            dsr.mergeMappings = mergeMappings;
            var Impl;
            (function(Impl) {
                function mergeCategorical(target, source) {
                    if (source.categories) {
                        if (target.categories) {
                            debug.assert(jsCommon.JsonComparer.equals(target.categories, source.categories), "target.categories & source.categories must match when multiple mappings are used.");
                        } else {
                            target.categories = source.categories;
                        }
                    }
                    if (source.values) {
                        var targetValues = target.values;
                        if (!targetValues) targetValues = target.values = {};
                        var sourceValues = source.values, sourceValuesGrouping = sourceValues.group;
                        pushRolesToTargetList(targetValues, sourceValues);
                        pushArrayRolesToTargetList(targetValues, sourceValues.select);
                        if (sourceValuesGrouping) {
                            var targetValuesGrouping = target.values.group;
                            if (targetValuesGrouping) {
                                pushArrayRolesToTargetList(targetValuesGrouping, sourceValuesGrouping.select);
                            } else {
                                target.values.group = {
                                    select: sourceValuesGrouping.select.concat([]),
                                    by: sourceValuesGrouping.by,
                                    dataReductionAlgorithm: sourceValuesGrouping.dataReductionAlgorithm
                                };
                            }
                        }
                    }
                }
                Impl.mergeCategorical = mergeCategorical;
                function pushRolesToTargetList(targetValues, sourceValues) {
                    if (sourceValues.bind || sourceValues.for) {
                        if (!targetValues.select) targetValues.select = [];
                        targetValues.select.push(sourceValues);
                    }
                }
                function pushArrayRolesToTargetList(targetValues, select) {
                    if (!select) return;
                    if (!targetValues.select) targetValues.select = [];
                    Array.prototype.push.apply(targetValues.select, select);
                }
                function createSplit(projections, indicesByName, mapping) {
                    var result = {
                        selects: {}
                    };
                    if (mapping.categories) {
                        var categories = mapping.categories;
                        splitIfAnyBind(result, projections, indicesByName, categories);
                        splitIfAnyFor(result, projections, indicesByName, categories);
                    }
                    if (mapping.values) {
                        var valuesGrouped = mapping.values;
                        if (valuesGrouped.group) {
                            var valueGroupingProjections = projections[valuesGrouped.group.by.role];
                            splitIfAny(result, valueGroupingProjections, indicesByName);
                            for (var i = 0, len = valuesGrouped.group.select.length; i < len; i++) splitIfAnyRole(result, projections, indicesByName, valuesGrouped.group.select[i]);
                        } else {
                            splitIfAnyRole(result, projections, indicesByName, mapping.values);
                            splitIfAnySelect(result, projections, indicesByName, mapping.values);
                        }
                    }
                    return result;
                }
                Impl.createSplit = createSplit;
                function splitIfAnyBind(split, projections, indicesByName, bindMapping) {
                    debug.assertValue(split, "split");
                    debug.assertValue(projections, "projections");
                    if (bindMapping && bindMapping.bind) return splitIfAny(split, projections[bindMapping.bind.to.role], indicesByName);
                }
                function splitIfAnyFor(split, projections, indicesByName, forMapping) {
                    debug.assertValue(split, "split");
                    debug.assertValue(projections, "projections");
                    if (forMapping && forMapping.for) return splitIfAny(split, projections[forMapping.for.in.role], indicesByName);
                }
                function splitIfAnySelect(split, projections, indicesByName, selectMapping) {
                    debug.assertValue(split, "split");
                    debug.assertValue(projections, "projections");
                    if (selectMapping && selectMapping.select) {
                        for (var i = 0, len = selectMapping.select.length; i < len; i++) splitIfAnyRole(split, projections, indicesByName, selectMapping.select[i]);
                    }
                }
                function splitIfAnyRole(split, projections, indicesByName, mapping) {
                    debug.assertValue(split, "split");
                    debug.assertValue(projections, "projections");
                    splitIfAnyBind(split, projections, indicesByName, mapping);
                    splitIfAnyFor(split, projections, indicesByName, mapping);
                }
                function splitIfAny(split, projections, indicesByName) {
                    debug.assertValue(split, "split");
                    debug.assertValue(indicesByName, "indicesByName");
                    if (!projections) return;
                    var isAlreadyIncluded = [];
                    for (var i = 0, len = projections.length; i < len; i++) {
                        var queryReference = projections[i].queryRef, queryIndex = indicesByName[queryReference];
                        if (isAlreadyIncluded[queryIndex]) continue;
                        split.selects[queryIndex] = true;
                        isAlreadyIncluded[queryIndex] = true;
                    }
                }
            })(Impl || (Impl = {}));
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            (function(RestartFlagKind) {
                RestartFlagKind[RestartFlagKind["Append"] = 0] = "Append";
                RestartFlagKind[RestartFlagKind["Merge"] = 1] = "Merge";
            })(dsr.RestartFlagKind || (dsr.RestartFlagKind = {}));
            var RestartFlagKind = dsr.RestartFlagKind;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(_dsr) {
            var DataShapeUtility;
            (function(DataShapeUtility) {
                function findAndParseCalculation(calcs, id) {
                    var calc = findCalculation(calcs, id);
                    if (calc) return data.PrimitiveValueEncoding.parseValue(calc.Value);
                }
                DataShapeUtility.findAndParseCalculation = findAndParseCalculation;
                function findAndParseCalculationToSQExpr(calcs, id) {
                    var calc = findCalculation(calcs, id);
                    if (calc) return data.PrimitiveValueEncoding.parseValueToSQExpr(calc.Value);
                }
                DataShapeUtility.findAndParseCalculationToSQExpr = findAndParseCalculationToSQExpr;
                function findCalculation(calcs, id) {
                    debug.assertValue(calcs, "calcs");
                    for (var i = 0, len = calcs.length; i < len; i++) {
                        var calc = calcs[i];
                        if (calc.Id === id) return calc;
                    }
                }
                DataShapeUtility.findCalculation = findCalculation;
                function getCalculationInstanceCount(dsr, descriptor, selectOrdinal) {
                    debug.assertValue(descriptor, "descriptor");
                    debug.assertValue(selectOrdinal, "selectOrdinal");
                    if (!dsr || !dsr.DataShapes) return null;
                    var groupId = descriptor.Select[selectOrdinal].Value;
                    for (var i = 0, ilen = dsr.DataShapes.length; i < ilen; i++) {
                        var dataShape = dsr.DataShapes[i];
                        for (var j = 0, jlen = dataShape.PrimaryHierarchy.length; j < jlen; j++) {
                            var member = dataShape.PrimaryHierarchy[j];
                            if (member.Instances && member.Instances.length) {
                                if (findCalculation(member.Instances[0].Calculations, groupId)) return member.Instances.length;
                            }
                        }
                    }
                }
                DataShapeUtility.getCalculationInstanceCount = getCalculationInstanceCount;
                function describeDataType(type, category) {
                    type = type || 0;
                    var primitiveType = 0;
                    switch (type) {
                      case 2048:
                        primitiveType = 1;
                        break;

                      case 1:
                        primitiveType = 3;
                        break;

                      case data.SemanticType.Integer:
                        primitiveType = 4;
                        break;

                      case 4096:
                        primitiveType = 5;
                        break;

                      case data.SemanticType.Date:
                        primitiveType = 6;
                        break;

                      case 4:
                        primitiveType = 7;
                        break;

                      case 8:
                        primitiveType = 9;
                        break;

                      case data.SemanticType.Year:
                        primitiveType = 4;
                        debug.assert(!category || category === "Year", "Unexpected category for Year type.");
                        category = "Year";
                        break;

                      case data.SemanticType.Month:
                        primitiveType = 4;
                        debug.assert(!category || category === "Month", "Unexpected category for Month type.");
                        category = "Month";
                        break;
                    }
                    return powerbi.ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);
                }
                DataShapeUtility.describeDataType = describeDataType;
                function increaseLimitForPrimarySegmentation(dataShapeBinding, count) {
                    var limits = dataShapeBinding.Limits;
                    if (limits) {
                        var limitCount = count - 5;
                        for (var i = 0, len = limits.length; i < len; i++) {
                            var limit = limits[i];
                            if (limit.Target.Primary !== undefined) {
                                limit.Count = limitCount;
                            }
                        }
                    }
                }
                DataShapeUtility.increaseLimitForPrimarySegmentation = increaseLimitForPrimarySegmentation;
                function getTopLevelSecondaryDynamicMember(dataShape, dataShapeExpressions) {
                    debug.assertValue(dataShape, "dataShape");
                    var hierarchy = dataShape.SecondaryHierarchy;
                    if (!hierarchy) return null;
                    if (!dataShapeExpressions || !dataShapeExpressions.Secondary) return DataShapeUtility.getDynamicMemberFallback(hierarchy);
                    return DataShapeUtility.getDynamicMember(hierarchy, dataShapeExpressions.Secondary.Groupings, 0);
                }
                DataShapeUtility.getTopLevelSecondaryDynamicMember = getTopLevelSecondaryDynamicMember;
                function getTopLevelPrimaryDynamicMember(dataShape, dataShapeExpressions, useTopLevelCalculations) {
                    debug.assertValue(dataShape, "dataShape");
                    var hierarchy = dataShape.PrimaryHierarchy;
                    if (!hierarchy) return null;
                    var hasTopLevelCalcs;
                    if (useTopLevelCalculations) hasTopLevelCalcs = dataShape.Calculations !== undefined;
                    if (!dataShapeExpressions || !dataShapeExpressions.Primary) return DataShapeUtility.getDynamicMemberFallback(hierarchy, hasTopLevelCalcs);
                    return DataShapeUtility.getDynamicMember(hierarchy, dataShapeExpressions.Primary.Groupings, 0, hasTopLevelCalcs);
                }
                DataShapeUtility.getTopLevelPrimaryDynamicMember = getTopLevelPrimaryDynamicMember;
                function getDynamicMember(dataShapeMembers, axisGroupings, groupDepth, hasTopLevelCalculations) {
                    debug.assertValue(dataShapeMembers, "dataShapeMembers");
                    if (dataShapeMembers.length === 0) return null;
                    if (!axisGroupings || axisGroupings.length === 0) return DataShapeUtility.getDynamicMemberFallback(dataShapeMembers, hasTopLevelCalculations);
                    var dynamicMemberId = axisGroupings[groupDepth].Member;
                    if (!dynamicMemberId) return DataShapeUtility.getDynamicMemberFallback(dataShapeMembers, hasTopLevelCalculations);
                    for (var i = 0; i < dataShapeMembers.length; i++) {
                        if (dataShapeMembers[i].Id === dynamicMemberId) return dataShapeMembers[i];
                    }
                    return null;
                }
                DataShapeUtility.getDynamicMember = getDynamicMember;
                function getDynamicMemberFallback(dataShapeMembers, hasTopLevelCalculations) {
                    if (dataShapeMembers.length === 2) {
                        return dataShapeMembers[1];
                    }
                    if (hasTopLevelCalculations === undefined || hasTopLevelCalculations === true) return dataShapeMembers[0];
                    return null;
                }
                DataShapeUtility.getDynamicMemberFallback = getDynamicMemberFallback;
            })(DataShapeUtility = _dsr.DataShapeUtility || (_dsr.DataShapeUtility = {}));
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var DsrClientError = function() {
        function DsrClientError(oDataError) {
            this.oDataError = oDataError;
            this.oDataCode = this.parseCode();
        }
        Object.defineProperty(DsrClientError.prototype, "code", {
            get: function() {
                return this.oDataCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DsrClientError.prototype, "ignorable", {
            get: function() {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        DsrClientError.prototype.getDetails = function(resourceProvider) {
            var values = this.oDataError["azure:values"];
            var azureDetails = null;
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    if (values[i].details) {
                        azureDetails = values[i].details;
                        break;
                    }
                }
            }
            var details = DsrClientError.getErrorDetailsFromStatusCode(this.code, resourceProvider);
            var key = details.additionalErrorInfo[0].errorInfoKey;
            if (!DsrClientError.isCodeKnown(this.code) && azureDetails) details.additionalErrorInfo = [];
            if (azureDetails) {
                var detailsKey = details.additionalErrorInfo.length === 0 ? key : resourceProvider.get("DsrError_MoreInfo");
                details.additionalErrorInfo.push({
                    errorInfoKey: detailsKey,
                    errorInfoValue: azureDetails
                });
            }
            return details;
        };
        DsrClientError.getErrorDetailsFromStatusCode = function(code, resourceProvider) {
            var key = resourceProvider.get("DsrError_Key");
            var val = resourceProvider.get("DsrError_UnknownErrorValue");
            var message = resourceProvider.get("DsrError_Message");
            switch (code) {
              case "ErrorLoadingModel":
                key = resourceProvider.get("DsrError_LoadingModelKey");
                val = resourceProvider.get("DsrError_LoadingModelValue");
                break;

              case "InvalidDataShapeNoOutputData":
                val = resourceProvider.get("DsrError_InvalidDataShapeValue");
                break;

              case "InvalidUnconstrainedJoin":
                key = resourceProvider.get("DsrError_InvalidUnconstrainedJoinKey");
                val = resourceProvider.get("DsrError_InvalidUnconstrainedJoinValue");
                break;

              case "ModelUnavailable":
                val = resourceProvider.get("DsrError_ModelUnavailableValue");
                break;

              case "OverlappingKeysOnOppositeHierarchies":
                key = resourceProvider.get("DsrError_OverlappingKeysKey");
                val = resourceProvider.get("DsrError_OverlappingKeysValue");
                break;

              case "rsQueryMemoryLimitExceeded":
              case "rsQueryTimeoutExceeded":
                key = resourceProvider.get("DsrError_ResourcesExceededKey");
                val = resourceProvider.get("DsrError_ResourcesExceededValue");
                message = resourceProvider.get("DsrError_ResourcesExceededMessage");
                break;

              case "rsDataShapeProcessingError":
              case "rsDataShapeQueryGenerationError":
              case "rsDataShapeQueryTranslationError":
              case "rsErrorExecutingCommand":
                break;
            }
            var details = {
                message: message,
                additionalErrorInfo: [ {
                    errorInfoKey: key,
                    errorInfoValue: val
                } ]
            };
            return details;
        };
        DsrClientError.prototype.parseCode = function() {
            var code = this.oDataError.code;
            var values = this.oDataError["azure:values"];
            var additionalMessages = [];
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    if (values[i].additionalMessages) {
                        additionalMessages = values[i].additionalMessages;
                    }
                }
            }
            if (additionalMessages.length > 0) {
                for (var i = 0; i < additionalMessages.length; i++) {
                    if (DsrClientError.isCodeKnown(additionalMessages[i].Code)) {
                        code = additionalMessages[i].Code;
                    }
                }
            }
            return code;
        };
        DsrClientError.isCodeKnown = function(code) {
            switch (code) {
              case "ErrorLoadingModel":
              case "InvalidDataShapeNoOutputData":
              case "InvalidUnconstrainedJoin":
              case "ModelUnavailable":
              case "OverlappingKeysOnOppositeHierarchies":
              case "rsQueryMemoryLimitExceeded":
              case "rsQueryTimeoutExceeded":
                return true;

              default:
                return false;
            }
        };
        return DsrClientError;
    }();
    powerbi.DsrClientError = DsrClientError;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            var DsrDataProvider = function() {
                function DsrDataProvider(host, communication, delayedResultHandler, timerFactory) {
                    debug.assertValue(host, "host");
                    this.proxy = new dsr.ExecuteSemanticQueryProxy(host, communication, delayedResultHandler, timerFactory);
                }
                DsrDataProvider.prototype.execute = function(options) {
                    return this.proxy.execute(options);
                };
                DsrDataProvider.prototype.transform = function(obj) {
                    if (obj === undefined) return {
                        dataView: {
                            metadata: {
                                columns: []
                            },
                            error: {
                                code: DsrDataProvider.undefinedData
                            }
                        }
                    };
                    return dsr.read(obj);
                };
                DsrDataProvider.prototype.stopCommunication = function() {
                    this.proxy.stopCommunication();
                };
                DsrDataProvider.prototype.resumeCommunication = function() {
                    this.proxy.resumeCommunication();
                };
                DsrDataProvider.prototype.clearCache = function() {
                    this.proxy.clearCache();
                };
                DsrDataProvider.prototype.rewriteCacheEntries = function(rewriter) {
                    this.proxy.rewriteCacheEntries(rewriter);
                };
                DsrDataProvider.undefinedData = "UndefinedData";
                return DsrDataProvider;
            }();
            dsr.DsrDataProvider = DsrDataProvider;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            (function(LimitType) {
                LimitType[LimitType["Unknown"] = -1] = "Unknown";
                LimitType[LimitType["Top"] = 0] = "Top";
                LimitType[LimitType["Bottom"] = 1] = "Bottom";
                LimitType[LimitType["Sample"] = 2] = "Sample";
            })(dsr.LimitType || (dsr.LimitType = {}));
            var LimitType = dsr.LimitType;
            var DsrLimitsWarning = function() {
                function DsrLimitsWarning(queryBindingDescriptor) {
                    this.queryBindingDescriptor = queryBindingDescriptor;
                }
                DsrLimitsWarning.prototype.getDetails = function(resourceProvider) {
                    var limitType = -1;
                    var type1 = -1;
                    var type2 = -1;
                    var groupings1 = [];
                    var groupings2 = [];
                    var groupings = [];
                    var numberOfTypes = 0;
                    var limits = this.queryBindingDescriptor.Limits;
                    if (limits) {
                        if (limits.Primary) {
                            type1 = DsrLimitsWarning.getLimitType(limits.Primary);
                            groupings1 = this.queryBindingDescriptor.Expressions.Primary.Groupings;
                        }
                        if (limits.Secondary) {
                            type2 = DsrLimitsWarning.getLimitType(limits.Secondary);
                            groupings2 = this.queryBindingDescriptor.Expressions.Secondary.Groupings;
                        }
                        if (type1 !== -1 && type2 !== -1) {
                            limitType = type1;
                            groupings = groupings1;
                            numberOfTypes = 2;
                        } else if (type1 !== -1 || type2 !== -1) {
                            if (type1 === -1) {
                                limitType = type2;
                                type2 = -1;
                                groupings = groupings2;
                                groupings2 = [];
                            } else {
                                limitType = type1;
                                type2 = -1;
                                groupings = groupings1;
                                groupings2 = [];
                            }
                            numberOfTypes = 1;
                        }
                    }
                    var limitInfoValue = limitType === -1 ? resourceProvider.get("DsrLimitWarning_TooMuchDataValMultipleColumns") : this.getDetailedMessage(groupings, limitType, DsrLimitsWarning.getDefaultDetailedMessage(limitType, resourceProvider), resourceProvider);
                    if (numberOfTypes > 1 && groupings2.length > 0) {
                        var secondString = this.getDetailedMessage(groupings2, type2, "", resourceProvider);
                        if (secondString !== "") limitInfoValue = limitInfoValue + " " + secondString;
                    }
                    var message = DsrLimitsWarning.getMessage(limitType, resourceProvider);
                    var key = DsrLimitsWarning.getKey(limitType, resourceProvider);
                    var details = {
                        message: message,
                        additionalErrorInfo: [ {
                            errorInfoKey: key,
                            errorInfoValue: limitInfoValue
                        } ]
                    };
                    return details;
                };
                DsrLimitsWarning.getMessage = function(type, resourceProvider) {
                    var message;
                    switch (type) {
                      case 2:
                        message = resourceProvider.get("DsrLimitWarning_RepresentativeSampleMessage");
                        break;

                      case 0:
                      case 1:
                      default:
                        message = resourceProvider.get("DsrLimitWarning_TooMuchDataMessage");
                        break;
                    }
                    return message;
                };
                DsrLimitsWarning.getKey = function(type, resourceProvider) {
                    var key;
                    switch (type) {
                      case 2:
                        key = resourceProvider.get("DsrLimitWarning_RepresentativeSampleKey");
                        break;

                      case 0:
                      case 1:
                      default:
                        key = resourceProvider.get("DsrLimitWarning_TooMuchDataKey");
                        break;
                    }
                    return key;
                };
                DsrLimitsWarning.prototype.getDetailedMessage = function(groupings, type, defaultString, resourceProvider) {
                    if (!groupings || groupings.length !== 1) {
                        return defaultString;
                    }
                    var keys = groupings[0].Keys;
                    for (var i = 0; i < keys.length; i++) {
                        var currentKey = keys[i];
                        if (currentKey.Select !== null && currentKey.Select !== undefined) {
                            var colName = this.columnNameFromIndex(currentKey.Select);
                            if (colName) {
                                var format = DsrLimitsWarning.getDetailedMessageFormatForOneColumn(type, resourceProvider);
                                return jsCommon.StringExtensions.format(format, colName);
                            } else {
                                return defaultString;
                            }
                        }
                    }
                    return defaultString;
                };
                DsrLimitsWarning.getDetailedMessageFormatForOneColumn = function(type, resourceProvider) {
                    switch (type) {
                      case 2:
                        return resourceProvider.get("DsrLimitWarning_RepresentativeSampleVal");

                      case 0:
                      case 1:
                      default:
                        return resourceProvider.get("DsrLimitWarning_TooMuchDataVal");
                    }
                };
                DsrLimitsWarning.getDefaultDetailedMessage = function(type, resourceProvider) {
                    switch (type) {
                      case 2:
                        return resourceProvider.get("DsrLimitWarning_RepresentativeSampleValMultipleColumns");

                      case 0:
                      case 1:
                      default:
                        return resourceProvider.get("DsrLimitWarning_TooMuchDataValMultipleColumns");
                    }
                };
                DsrLimitsWarning.getLimitType = function(limitDescriptor) {
                    var type = -1;
                    if (limitDescriptor.Top) type = 0; else if (limitDescriptor.Bottom) type = 1; else if (limitDescriptor.Sample) type = 2;
                    return type;
                };
                return DsrLimitsWarning;
            }();
            dsr.DsrLimitsWarning = DsrLimitsWarning;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(_dsr) {
            function read(arg) {
                debug.assertValue(arg, "arg");
                var dataObj = arg;
                if (typeof arg === "string") dataObj = JSON.parse(arg);
                return readDsr(dataObj.descriptor, dataObj.dsr, dataObj.schemaName);
            }
            _dsr.read = read;
            function readDsr(descriptor, dsr, schemaName) {
                debug.assertAnyValue(descriptor, "descriptor");
                debug.assertValue(dsr, "dsr");
                if (!dsr.DataShapes || dsr.DataShapes.length !== 1) return null;
                var dataShape = dsr.DataShapes[0];
                var oDataError = dataShape["odata.error"];
                if (oDataError) {
                    var clientError = new powerbi.DsrClientError(dataShape["odata.error"]);
                    var result = {
                        error: clientError
                    };
                    return result;
                }
                var dsrReaderResult = {
                    dataView: loadStrategy(new DsrReaderContext(descriptor.Select, schemaName)).read(descriptor.Expressions, dataShape)
                };
                if (dataShape.RestartTokens) dsrReaderResult.restartToken = dataShape.RestartTokens;
                if (dataShape.DataLimitsExceeded && dataShape.DataLimitsExceeded.length > 0) dsrReaderResult.warning = new _dsr.DsrLimitsWarning(descriptor);
                return dsrReaderResult;
            }
            _dsr.readDsr = readDsr;
            function loadStrategy(context) {
                debug.assertValue(context, "context");
                var primaryDepth = 0, secondaryDepth = 0, selects = context.selects;
                for (var i = 0, len = selects.length; i < len; i++) {
                    var select = selects[i];
                    if (select) {
                        if (select.Depth != null) primaryDepth = Math.max(primaryDepth, select.Depth + 1);
                        if (select.SecondaryDepth != null) secondaryDepth = Math.max(secondaryDepth, select.SecondaryDepth + 1);
                    }
                }
                if (secondaryDepth >= 1 && primaryDepth === 1) return new DsrWithPivotedColumnsStrategy(context);
                return new DsrToTreeStrategy(context);
            }
            function ensureTreeNodeValues(node, ordinal) {
                debug.assertValue(node, "node");
                var values = node.values;
                if (!values) values = node.values = {};
                var value = values[ordinal];
                if (!value) value = values[ordinal] = {};
                return value;
            }
            var DsrToMatrixParser;
            (function(DsrToMatrixParser) {
                var MemberType;
                (function(MemberType) {
                    MemberType[MemberType["Undetermined"] = 0] = "Undetermined";
                    MemberType[MemberType["GroupDynamic"] = 1] = "GroupDynamic";
                    MemberType[MemberType["MeasureStatic"] = 2] = "MeasureStatic";
                    MemberType[MemberType["SubtotalStatic"] = 3] = "SubtotalStatic";
                    MemberType[MemberType["Unsupported"] = 4] = "Unsupported";
                })(MemberType || (MemberType = {}));
                function parse(context, dataShapeExprs, dataShape, metadata) {
                    debug.assertValue(context, "context");
                    debug.assertValue(dataShape, "dataShape");
                    debug.assertValue(metadata, "metadata");
                    var primaryLevelSources = [], secondaryLevelSources = [], measures = [];
                    if (!processMetadata(context, primaryLevelSources, secondaryLevelSources, measures, metadata.columns)) return null;
                    var intersectionToSecondaryAggIdx = [];
                    var secondaryRoot = parseSecondaryTree(context, secondaryLevelSources, measures.length, dataShapeExprs, dataShape, intersectionToSecondaryAggIdx);
                    var primaryRoot = parsePrimaryTree(context, primaryLevelSources, dataShapeExprs, dataShape, intersectionToSecondaryAggIdx);
                    var rows = {
                        root: primaryRoot,
                        levels: primaryLevelSources
                    };
                    var columns = {
                        root: secondaryRoot,
                        levels: secondaryLevelSources
                    };
                    var result = {
                        rows: rows,
                        columns: columns,
                        valueSources: measures
                    };
                    return result;
                }
                DsrToMatrixParser.parse = parse;
                function createHierarchyLevel(metadataColumns) {
                    debug.assertValue(metadataColumns, "metadataColumns");
                    var levels = {
                        sources: []
                    };
                    for (var i = 0, ilen = metadataColumns.length; i < ilen; i++) levels.sources.push(metadataColumns[i]);
                    return levels;
                }
                function getOrCreateColumnMetadata(context, metadataColumns, index) {
                    debug.assertValue(metadataColumns, "metadataColumns");
                    for (var i = 0, ilen = metadataColumns.length; i < ilen; i++) {
                        var metadataColumn = metadataColumns[i];
                        if (metadataColumn && metadataColumn.index === index && metadataColumn.groupName === undefined) return metadataColumn;
                    }
                    var newMetadataColumn = context.columnMetadata(index);
                    metadataColumns.push(newMetadataColumn);
                    return newMetadataColumn;
                }
                function processMetadata(context, primaryLevelSources, secondaryLevelSources, measures, metadataColumns) {
                    debug.assertValue(metadataColumns, "metadataColumns");
                    var selects = context.selects;
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select) continue;
                        if (select.Kind === 2) {
                            var measureMetadata = getOrCreateColumnMetadata(context, metadataColumns, i);
                            measures.push(measureMetadata);
                        } else if (select.Depth != null) {
                            if (primaryLevelSources[select.Depth] != null) return false;
                            primaryLevelSources[select.Depth] = createHierarchyLevel([ getOrCreateColumnMetadata(context, metadataColumns, i) ]);
                        } else if (select.SecondaryDepth != null) {
                            if (secondaryLevelSources[select.SecondaryDepth] != null) return false;
                            secondaryLevelSources[select.SecondaryDepth] = createHierarchyLevel([ getOrCreateColumnMetadata(context, metadataColumns, i) ]);
                        }
                    }
                    if (measures.length > 1 || measures.length > 0 && (primaryLevelSources.length === 0 || secondaryLevelSources.length === 0)) secondaryLevelSources.push(createHierarchyLevel(measures));
                    return true;
                }
                function parsePrimaryTree(context, levelSources, dataShapeExprs, dataShape, intersectionToSecondaryAggIdx) {
                    if (!dataShape.PrimaryHierarchy || dataShape.PrimaryHierarchy.length === 0) return;
                    var primaryAxisGroupings;
                    if (dataShapeExprs && dataShapeExprs.Primary) primaryAxisGroupings = dataShapeExprs.Primary.Groupings;
                    var maxPrimaryAggIdx = 0;
                    var maxSecondaryAggIdx = 0;
                    if (dataShapeExprs) {
                        maxPrimaryAggIdx = getMaxAggIdx(dataShapeExprs.Primary);
                        maxSecondaryAggIdx = getMaxAggIdx(dataShapeExprs.Secondary);
                    }
                    var measureSelects = context.selects.filter(function(s) {
                        return s && s.Kind === 2;
                    });
                    return parseTree(context, levelSources, dataShape.PrimaryHierarchy, primaryAxisGroupings, function(memberType, instance, node, depth) {
                        return parseIntersections(memberType, measureSelects, instance, node, intersectionToSecondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx);
                    });
                }
                function parseSecondaryTree(context, levelSources, measureCount, dataShapeExprs, dataShape, intersectionToSecondaryAggIdx) {
                    if (!dataShape.SecondaryHierarchy || dataShape.SecondaryHierarchy.length === 0) {
                        var root = {};
                        addMeasureHeaders(root, measureCount, 0, false);
                        return root;
                    }
                    var secondaryAxisGroupings;
                    if (dataShapeExprs && dataShapeExprs.Secondary) secondaryAxisGroupings = dataShapeExprs.Secondary.Groupings;
                    return parseTree(context, levelSources, dataShape.SecondaryHierarchy, secondaryAxisGroupings, function(memberType, instance, node, depth) {
                        if (depth < levelSources.length) {
                            if (node.isSubtotal) {
                                var innermostLevelIndex = levelSources.length - 1;
                                var measureCount = levelSources[innermostLevelIndex].sources.length;
                                if (measureCount > 1) addMeasureHeaders(node, measureCount, innermostLevelIndex, true);
                            } else {
                                debug.assert(depth === levelSources.length - 1, "We only support one extra level in the column hierarchy (for measures)");
                                var level = levelSources[depth];
                                addMeasureHeaders(node, level.sources.length, depth, false);
                            }
                        }
                        intersectionToSecondaryAggIdx.push(getAggIdxForNode(node));
                    });
                }
                function getAggIdxForNode(node) {
                    debug.assertValue(node, "node");
                    return node.isSubtotal ? node.level : node.level + 1;
                }
                function getMaxAggIdx(axis) {
                    debug.assertAnyValue(axis, "axis");
                    if (axis && axis.Groupings) return axis.Groupings.length;
                    return 0;
                }
                function computeAggIdx(primaryAggIdx, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx) {
                    return primaryAggIdx + (maxSecondaryAggIdx - secondaryAggIdx) * (maxPrimaryAggIdx + 1);
                }
                function addMeasureHeaders(root, count, depth, isSubtotal) {
                    root.children = [];
                    for (var i = 0; i < count; i++) {
                        var child = {
                            level: depth
                        };
                        if (i > 0) child.levelSourceIndex = i;
                        root.children.push(child);
                        if (isSubtotal) child.isSubtotal = true;
                    }
                }
                function parseTree(context, levelSources, rootMembers, axisGroupings, leafMemberCallback) {
                    debug.assertValue(context, "context");
                    var root = {};
                    parseRecursive(context, levelSources, root, rootMembers, axisGroupings, 0, leafMemberCallback);
                    return root;
                }
                function parseRecursive(context, levelSources, node, members, axisGroupings, depth, leafMemberCallback) {
                    debug.assertValue(context, "context");
                    debug.assertValue(levelSources, "levelSources");
                    debug.assertValue(node, "node");
                    debug.assertValue(depth, "depth");
                    if (!members) return;
                    var selects = context.selects;
                    for (var i = 0, ilen = members.length; i < ilen; i++) {
                        var member = members[i];
                        var memberType = 0;
                        for (var j = 0, jlen = member.Instances.length; j < jlen; j++) {
                            var instance = member.Instances[j];
                            if (memberType === 0) {
                                var memberType = getMemberType(selects, axisGroupings, depth, member, instance);
                                if (memberType === 4) break;
                            }
                            var nestedNode = {
                                level: depth
                            };
                            if (!node.children) node.children = [];
                            node.children.push(nestedNode);
                            if (memberType === 1) {
                                var value = getGroupValue(selects, instance.Calculations);
                                if (value != null) nestedNode.value = value;
                            } else if (memberType === 3) {
                                nestedNode.isSubtotal = true;
                            }
                            if (instance.RestartFlag && instance.RestartFlag === 1) nestedNode.isMerge = true;
                            if (axisGroupings && memberType === 1) {
                                node.childIdentityFields = context.readKeys(axisGroupings, depth);
                                nestedNode.identity = context.readIdentity(axisGroupings, instance, depth);
                            }
                            var nestedMembers = instance.Members;
                            if (nestedMembers && nestedMembers.length > 0) {
                                parseRecursive(context, levelSources, nestedNode, nestedMembers, axisGroupings, depth + 1, leafMemberCallback);
                            } else {
                                if (leafMemberCallback) leafMemberCallback(memberType, instance, nestedNode, depth + 1);
                            }
                        }
                    }
                }
                function getGroupValue(selects, calculations) {
                    debug.assertValue(selects, "selects");
                    debug.assertValue(calculations, "calculations");
                    for (var i = 0, ilen = selects.length; i < ilen; i++) {
                        var select = selects[i];
                        if (select && select.Value && select.Kind === 1) {
                            var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, select.Value);
                            if (value != null) return value;
                        }
                    }
                }
                function getMemberType(selects, axisGroupings, groupDepth, member, instance) {
                    debug.assertValue(selects, "selects");
                    debug.assertValue(member, "member");
                    if (axisGroupings && axisGroupings.length > groupDepth && member.Id != null) {
                        var grouping = axisGroupings[groupDepth];
                        if (member.Id === grouping.Member) return 1;
                        if (member.Id === grouping.SubtotalMember) return 3;
                    }
                    var calculations = instance.Calculations;
                    if (calculations) {
                        var measureFound = false;
                        for (var i = 0, ilen = selects.length; i < ilen; i++) {
                            var select = selects[i];
                            if (!select) continue;
                            if (_dsr.DataShapeUtility.findCalculation(calculations, select.Value)) {
                                if (select.Kind === 1) return 1;
                                if (!measureFound && select.Kind === 2) measureFound = true;
                            }
                        }
                        if (measureFound) return 2;
                    }
                    return 4;
                }
                function readAndAddMeasureValues(rowMemberType, measureSelects, calculations, node, valueIndex, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx) {
                    debug.assertValue(measureSelects, "selects");
                    debug.assertValue(node, "node");
                    if (!calculations) return;
                    var measureIndex = 0;
                    for (var i = 0, ilen = measureSelects.length; i < ilen; i++) {
                        var select = measureSelects[i];
                        debug.assert(select.Kind === 2, "measureSelects is expected to have measure select bindings only");
                        var measureValue = ensureTreeNodeValues(node, valueIndex.index);
                        var result = null;
                        if (rowMemberType !== 3) result = _dsr.DataShapeUtility.findAndParseCalculation(calculations, select.Value);
                        if (result == null) {
                            var primaryAggIdx = getAggIdxForNode(node);
                            var subtotal = findSubtotalValue(calculations, select, primaryAggIdx, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx);
                            if (subtotal !== undefined) result = subtotal;
                        }
                        measureValue.value = result;
                        if (measureIndex > 0) measureValue.valueSourceIndex = measureIndex;
                        valueIndex.index++;
                        measureIndex++;
                    }
                }
                function parseIntersections(rowMemberType, measureSelects, instance, node, intersectionToSecondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx) {
                    debug.assertValue(instance, "instance");
                    debug.assertValue(node, "node");
                    debug.assertValue(intersectionToSecondaryAggIdx, "intersectionToSecondaryAggIdx");
                    var intersections = instance.Intersections;
                    var valueIndex = {
                        index: 0
                    };
                    if (intersections) {
                        for (var i = 0, ilen = intersections.length; i < ilen; i++) {
                            if (intersections[i].Calculations) {
                                var secondaryAggIdx = intersectionToSecondaryAggIdx[i];
                                readAndAddMeasureValues(rowMemberType, measureSelects, intersections[i].Calculations, node, valueIndex, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx);
                            }
                        }
                    } else {
                        readAndAddMeasureValues(rowMemberType, measureSelects, instance.Calculations, node, valueIndex, 0, maxPrimaryAggIdx, maxSecondaryAggIdx);
                    }
                }
                function findSubtotalValue(calculations, select, primaryAggIdx, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx) {
                    var subtotals = select.Subtotal;
                    if (subtotals) {
                        var AggIdx = computeAggIdx(primaryAggIdx, secondaryAggIdx, maxPrimaryAggIdx, maxSecondaryAggIdx);
                        if (AggIdx < subtotals.length) {
                            return _dsr.DataShapeUtility.findAndParseCalculation(calculations, subtotals[AggIdx]);
                        }
                    }
                    return undefined;
                }
            })(DsrToMatrixParser || (DsrToMatrixParser = {}));
            var DsrToTreeStrategy = function() {
                function DsrToTreeStrategy(context) {
                    debug.assertValue(context, "context");
                    this._context = context;
                }
                DsrToTreeStrategy.prototype.read = function(dataShapeExprs, dataShape) {
                    debug.assertValue(dataShape, "dataShape");
                    var metadata = this.readMetadata(dataShape.IsComplete);
                    var dataView = {
                        metadata: metadata
                    };
                    var root = this.parseTree(dataShapeExprs, dataShape);
                    debug.assertValue(root, "root");
                    dataView.tree = {
                        root: root
                    };
                    var categorical = this.categorize(metadata, root);
                    if (categorical) dataView.categorical = categorical;
                    var single = this.createSingleValue(metadata, root);
                    if (single) dataView.single = single;
                    var table = this.createTable(metadata, root);
                    if (table) dataView.table = table;
                    var matrix = DsrToMatrixParser.parse(this._context, dataShapeExprs, dataShape, dataView.metadata);
                    if (matrix) dataView.matrix = matrix;
                    return dataView;
                };
                DsrToTreeStrategy.prototype.readMetadata = function(isComplete) {
                    var metadata = {
                        columns: []
                    };
                    var context = this._context, selects = context.selects;
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select) continue;
                        var columnMetadata = context.columnMetadata(i);
                        metadata.columns.push(columnMetadata);
                    }
                    if (!isComplete) metadata.segment = {};
                    return metadata;
                };
                DsrToTreeStrategy.prototype.parseTree = function(dataShapeExprs, dataShape) {
                    var root = {};
                    var aggregateCalcs = dataShape.Calculations || DsrToTreeStrategy.getFirstInstanceCalcs(dataShape.PrimaryHierarchy[0]), dynamicMember;
                    dynamicMember = _dsr.DataShapeUtility.getTopLevelPrimaryDynamicMember(dataShape, dataShapeExprs, true);
                    var primaryAxisGroupings;
                    if (dataShapeExprs && dataShapeExprs.Primary) primaryAxisGroupings = dataShapeExprs.Primary.Groupings;
                    this.parseRecursive(root, aggregateCalcs, dynamicMember, primaryAxisGroupings, 0);
                    return root;
                };
                DsrToTreeStrategy.prototype.parseRecursive = function(node, aggregateCalcs, dynamicMember, primaryAxisGroupings, depth) {
                    debug.assertValue(node, "node");
                    debug.assertValue(depth, "depth");
                    var context = this._context;
                    if (aggregateCalcs) this.parseValues(context.selects, node, aggregateCalcs, depth);
                    if (dynamicMember) {
                        var dynamicMemberInstances = dynamicMember.Instances, dynamicMemberInstancesLength = dynamicMemberInstances.length, aggregator;
                        if (dynamicMemberInstancesLength) {
                            node.children = [];
                            if (depth === 0) aggregator = TreeNodeValueAggregateComputer.create(node, context.selects);
                        }
                        if (primaryAxisGroupings) {
                            node.childIdentityFields = context.readKeys(primaryAxisGroupings, depth);
                        }
                        for (var i = 0; i < dynamicMemberInstancesLength; i++) {
                            var instance = dynamicMemberInstances[i];
                            var nestedNode = {};
                            node.children.push(nestedNode);
                            if (instance.RestartFlag && instance.RestartFlag === 1) nestedNode.isMerge = true;
                            this.parseValues(context.selects, nestedNode, instance.Calculations, depth, aggregator);
                            if (primaryAxisGroupings) {
                                nestedNode.identity = context.readIdentity(primaryAxisGroupings, instance, depth);
                            }
                            var nestedMembers = instance.Members;
                            if (nestedMembers && nestedMembers.length) {
                                var dynamicChild = _dsr.DataShapeUtility.getDynamicMember(nestedMembers, primaryAxisGroupings, depth + 1);
                                this.parseRecursive(nestedNode, DsrToTreeStrategy.getFirstInstanceCalcs(nestedMembers[0]), dynamicChild, primaryAxisGroupings, depth + 1);
                            }
                        }
                        if (aggregator) aggregator.complete();
                    }
                };
                DsrToTreeStrategy.getFirstInstanceCalcs = function(member) {
                    if (member.Instances.length > 0) return member.Instances[0].Calculations;
                    return null;
                };
                DsrToTreeStrategy.prototype.parseValues = function(selects, node, calculations, depth, aggregator) {
                    debug.assertValue(node, "node");
                    debug.assertValue(calculations, "calculations");
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select) continue;
                        if (select.Subtotal) {
                            var id = select.Subtotal[depth];
                            if (id) {
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, id);
                                if (value !== undefined) ensureTreeNodeValues(node, i).subtotal = value;
                            }
                        }
                        if (select.Max) {
                            var id = select.Max[depth];
                            if (id) {
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, id);
                                if (value !== undefined) ensureTreeNodeValues(node, i).max = value;
                            }
                        }
                        if (select.Min) {
                            var id = select.Min[depth];
                            if (id) {
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, id);
                                if (value !== undefined) ensureTreeNodeValues(node, i).min = value;
                            }
                        }
                        if (select.Count) {
                            var id = select.Count[depth];
                            if (id) {
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, id);
                                if (value !== undefined) ensureTreeNodeValues(node, i).count = value;
                            }
                        }
                        if (select.Value) {
                            var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, select.Value);
                            if (value !== undefined) {
                                if (select.Kind === 1) {
                                    node.name = value;
                                } else {
                                    node.value = value;
                                    if (aggregator) aggregator.add(i, value);
                                }
                                ensureTreeNodeValues(node, i).value = value;
                            }
                        }
                        if (select.Highlight) {
                            var highlight = _dsr.DataShapeUtility.findAndParseCalculation(calculations, select.Highlight.Value);
                            if (highlight !== undefined) {
                                ensureTreeNodeValues(node, i).highlight = highlight;
                            }
                        }
                    }
                };
                DsrToTreeStrategy.prototype.categorize = function(metadata, root) {
                    debug.assertValue(metadata, "metadata");
                    if (powerbi.DataViewAnalysis.countGroups(metadata.columns) > 1) return null;
                    var view = {}, categoryColumn, categoryIdx;
                    for (var j = 0, jlen = metadata.columns.length; j < jlen; j++) {
                        var metadataColumn = metadata.columns[j];
                        if (!metadataColumn.isMeasure) {
                            categoryColumn = metadataColumn;
                            categoryIdx = metadataColumn.index;
                            continue;
                        }
                        var column = {
                            source: metadataColumn,
                            values: []
                        };
                        this.populateMeasureData(root, column, metadataColumn.index);
                        if (!view.values) view.values = data.DataViewTransform.createValueColumns();
                        view.values.push(column);
                    }
                    if (categoryColumn) {
                        var nodes = root.children;
                        var category = {
                            source: categoryColumn,
                            values: []
                        };
                        var categoryIdentity;
                        if (nodes) {
                            for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                                var node = nodes[i];
                                category.values.push(node.values[categoryIdx].value);
                                this.writeCategoricalValues(metadata, node, view.values);
                                if (node.identity) {
                                    if (!categoryIdentity) categoryIdentity = [];
                                    categoryIdentity.push(node.identity);
                                }
                                if (node.isMerge) {
                                    var viewSegment = view;
                                    viewSegment.lastMergeIndex = i;
                                }
                            }
                        }
                        if (categoryIdentity) category.identity = categoryIdentity;
                        if (root.childIdentityFields) category.identityFields = root.childIdentityFields;
                        view.categories = [ category ];
                    } else {
                        this.writeCategoricalValues(metadata, root, view.values);
                    }
                    return view;
                };
                DsrToTreeStrategy.prototype.createTable = function(metadata, root) {
                    debug.assertValue(metadata, "metadata");
                    var maxDepth;
                    var selects = this._context.selects;
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select) continue;
                        var depth = selects[i].Depth;
                        if (depth >= 0) maxDepth = Math.max(depth, maxDepth || 0);
                    }
                    if (maxDepth > 0) {
                        return null;
                    }
                    var lastMergeIndex;
                    var rows = [], selectsLength = selects.length, identity;
                    if (maxDepth >= 0) {
                        var nodes = root.children;
                        if (nodes) {
                            for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                                var node = nodes[i];
                                this.toTableRow(node, selectsLength, rows);
                                if (node.isMerge) lastMergeIndex = i;
                                if (node.identity) {
                                    if (!identity) identity = [];
                                    identity.push(node.identity);
                                }
                            }
                        }
                    } else {
                        debug.assert(powerbi.DataViewAnalysis.countGroups(metadata.columns) === 0, "groups.length=0");
                        this.toTableRow(root, selectsLength, rows);
                    }
                    var totals = this.toTotals(root, selectsLength);
                    var table = {
                        rows: rows,
                        columns: metadata.columns
                    };
                    if (identity) table.identity = identity;
                    if (totals) table.totals = totals;
                    if (lastMergeIndex >= 0) {
                        var tableSegment = table;
                        tableSegment.lastMergeIndex = lastMergeIndex;
                    }
                    return table;
                };
                DsrToTreeStrategy.prototype.toTableRow = function(node, selectsLength, rows) {
                    var row = [];
                    for (var j = 0; j < selectsLength; j++) {
                        var nodeValue = node.values[j];
                        if (!nodeValue) continue;
                        row.push(nodeValue.value);
                    }
                    rows.push(row);
                };
                DsrToTreeStrategy.prototype.toTotals = function(root, selectsLength) {
                    var totals = [];
                    var values = root.values;
                    var hasAtLeastOneTotal = false;
                    if (values) {
                        var selects = this._context.selects;
                        for (var j = 0; j < selectsLength; j++) {
                            if (!selects[j]) continue;
                            var measureData = values[j];
                            var subtotal = measureData ? measureData.subtotal : null;
                            hasAtLeastOneTotal = hasAtLeastOneTotal || subtotal != null;
                            totals.push(subtotal);
                        }
                    }
                    return hasAtLeastOneTotal ? totals : null;
                };
                DsrToTreeStrategy.prototype.writeCategoricalValues = function(metadata, node, values) {
                    var columns = metadata.columns;
                    var idx = 0;
                    for (var j = 0, jlen = columns.length; j < jlen; j++) {
                        var column = columns[j];
                        if (!column.isMeasure) continue;
                        var nodeValues = node.values[column.index];
                        var measureValues = values[idx++];
                        measureValues.values.push(nodeValues.value);
                        if (nodeValues.highlight !== undefined) {
                            if (!measureValues.highlights) measureValues.highlights = [];
                            measureValues.highlights.push(nodeValues.highlight);
                        }
                    }
                };
                DsrToTreeStrategy.prototype.populateMeasureData = function(node, column, index) {
                    debug.assertValue(node, "node");
                    if (!node.values) return;
                    var measureData = node.values[index];
                    if (measureData) {
                        if (measureData.min !== undefined) column.min = measureData.min;
                        if (measureData.max !== undefined) column.max = measureData.max;
                        if (measureData.subtotal !== undefined) column.subtotal = measureData.subtotal;
                        if (measureData.maxLocal !== undefined) column.maxLocal = measureData.maxLocal;
                        if (measureData.minLocal !== undefined) column.minLocal = measureData.minLocal;
                    }
                };
                DsrToTreeStrategy.prototype.createSingleValue = function(metadata, root) {
                    debug.assertValue(metadata, "metadata");
                    debug.assertValue(root, "root");
                    if (root.values) {
                        var columns = metadata.columns, measureColumn = null;
                        for (var j = 0, jlen = columns.length; j < jlen; j++) {
                            if (!columns[j].isMeasure) continue;
                            if (measureColumn) return null;
                            measureColumn = columns[j];
                        }
                        if (!measureColumn) return null;
                        var measureValues = root.values[measureColumn.index];
                        if (!measureValues) return null;
                        var value = powerbi.DataViewAnalysis.countGroups(metadata.columns) === 0 ? measureValues.value : measureValues.subtotal;
                        if (value === undefined) return null;
                        return {
                            value: value
                        };
                    }
                    return null;
                };
                return DsrToTreeStrategy;
            }();
            var DsrWithPivotedColumnsStrategy = function() {
                function DsrWithPivotedColumnsStrategy(context) {
                    debug.assertValue(context, "context");
                    this._context = context;
                    this._categorySelects = [];
                    this._primaryMeasureSelects = [];
                    this._measureSelects = [];
                    this._secondarySelects = [];
                    this._categoryColumn = null;
                    this._seriesColumn = null;
                }
                DsrWithPivotedColumnsStrategy.prototype.read = function(dataShapeExprs, dataShape) {
                    debug.assertValue(dataShape, "dataShape");
                    var dataView = {
                        metadata: this.readMetadata(dataShape.IsComplete)
                    };
                    var categorical = this.categorize(dataShape, dataView.metadata, dataShapeExprs);
                    if (categorical) dataView.categorical = categorical;
                    var matrix = DsrToMatrixParser.parse(this._context, dataShapeExprs, dataShape, dataView.metadata);
                    if (matrix) dataView.matrix = matrix;
                    return dataView;
                };
                DsrWithPivotedColumnsStrategy.prototype.readMetadata = function(isComplete) {
                    var metadata = {
                        columns: []
                    };
                    var context = this._context, selects = context.selects;
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select) continue;
                        if (select.Kind === 2) {
                            if (select.Depth === 0) this._primaryMeasureSelects.push(select); else this._measureSelects.push(select);
                            continue;
                        }
                        debug.assert(select.Kind === 1, "Unexpected Select.Kind");
                        var columnMetadata = context.columnMetadata(i);
                        metadata.columns.push(columnMetadata);
                        if (select.SecondaryDepth >= 0) {
                            this._secondarySelects.push(select);
                            this._secondaryDepth = Math.max(this._secondaryDepth || 0, select.SecondaryDepth);
                            this._seriesColumn = columnMetadata;
                        } else {
                            this._categoryColumn = columnMetadata;
                            this._categorySelects.push(select);
                        }
                    }
                    if (!isComplete) metadata.segment = {};
                    return metadata;
                };
                DsrWithPivotedColumnsStrategy.prototype.categorize = function(dataShape, metadata, dataShapeExprs) {
                    debug.assertValue(dataShape, "dataShape");
                    debug.assertValue(metadata, "metadata");
                    if (this._secondaryDepth !== 0 || this._categorySelects.length !== 1 || this._measureSelects.length < 1) return null;
                    var primaryAxisGroupings;
                    var secondaryAxisGroupings;
                    if (dataShapeExprs) {
                        if (dataShapeExprs.Primary) primaryAxisGroupings = dataShapeExprs.Primary.Groupings;
                        if (dataShapeExprs.Secondary) secondaryAxisGroupings = dataShapeExprs.Secondary.Groupings;
                    }
                    var secondaryDynamicTopLevel = _dsr.DataShapeUtility.getTopLevelSecondaryDynamicMember(dataShape, dataShapeExprs);
                    var values = this.readColumnsFromSecondary(secondaryDynamicTopLevel, metadata, secondaryAxisGroupings, dataShape.Calculations);
                    var primaryDynamicTopLevel = _dsr.DataShapeUtility.getTopLevelPrimaryDynamicMember(dataShape, dataShapeExprs);
                    var categoriesResult = this.readCategoriesAndValues(primaryDynamicTopLevel, metadata, values, primaryAxisGroupings);
                    var result = {
                        categories: categoriesResult.categories,
                        values: values
                    };
                    if (categoriesResult.lastMergeIndex !== undefined) result.lastMergeIndex = categoriesResult.lastMergeIndex;
                    return result;
                };
                DsrWithPivotedColumnsStrategy.prototype.readColumnsFromSecondary = function(secondaryMember, metadata, secondaryAxisGroupings, aggregateCalculations) {
                    debug.assertValue(secondaryMember, "secondaryMember");
                    debug.assertValue(metadata, "metadata");
                    var valueIdentityFields, context = this._context;
                    if (secondaryAxisGroupings) valueIdentityFields = context.readKeys(secondaryAxisGroupings, 0);
                    var values = data.DataViewTransform.createValueColumns([], valueIdentityFields), allSelects = context.selects, measureSelectsLen = this._measureSelects.length;
                    var instances = secondaryMember.Instances, instanceCount = instances.length;
                    if (instanceCount) {
                        for (var i = 0; i < instanceCount; i++) {
                            var instance = instances[i], calcs = instance.Calculations, identity;
                            if (secondaryAxisGroupings) identity = context.readIdentity(secondaryAxisGroupings, instance, 0);
                            for (var j = 0, jlen = this._secondarySelects.length; j < jlen; j++) {
                                var secondarySelect = this._secondarySelects[j], label = _dsr.DataShapeUtility.findAndParseCalculation(calcs, secondarySelect.Value);
                                for (var k = 0; k < measureSelectsLen; k++) {
                                    var measureSelect = this._measureSelects[k];
                                    var columnMetadata = context.columnMetadata(allSelects.indexOf(measureSelect));
                                    if (label !== undefined) columnMetadata.groupName = label;
                                    metadata.columns.push(columnMetadata);
                                    var column = {
                                        source: columnMetadata,
                                        values: []
                                    };
                                    if (identity) column.identity = identity;
                                    this.addColumnAggregates(aggregateCalculations, measureSelect, column);
                                    values.push(column);
                                }
                            }
                        }
                    } else {
                        for (var k = 0; k < measureSelectsLen; k++) {
                            var measureSelect = this._measureSelects[k];
                            var columnMetadata = context.columnMetadata(allSelects.indexOf(measureSelect));
                            metadata.columns.push(columnMetadata);
                            var column = {
                                source: columnMetadata,
                                values: []
                            };
                            this.addColumnAggregates(aggregateCalculations, measureSelect, column);
                            values.push(column);
                        }
                    }
                    for (var k = 0, klen = this._primaryMeasureSelects.length; k < klen; k++) {
                        var primaryMeasureSelect = this._primaryMeasureSelects[k];
                        var columnMetadata = context.columnMetadata(allSelects.indexOf(primaryMeasureSelect));
                        metadata.columns.push(columnMetadata);
                        var column = {
                            source: columnMetadata,
                            values: []
                        };
                        values.push(column);
                    }
                    if (this._seriesColumn) {
                        values.source = this._seriesColumn;
                    }
                    return values;
                };
                DsrWithPivotedColumnsStrategy.prototype.addColumnAggregates = function(calcs, measureSelect, column) {
                    if (calcs) {
                        if (measureSelect.Max) {
                            column.max = _dsr.DataShapeUtility.findAndParseCalculation(calcs, measureSelect.Max[0]);
                        }
                        if (measureSelect.Min) {
                            column.min = _dsr.DataShapeUtility.findAndParseCalculation(calcs, measureSelect.Min[0]);
                        }
                    }
                };
                DsrWithPivotedColumnsStrategy.prototype.readCategoriesAndValues = function(primaryMember, metadata, values, primaryAxisGroupings) {
                    debug.assertValue(primaryMember, "primaryMember");
                    debug.assertValue(values, "values");
                    var categorySelectIdx = 0, context = this._context, select = this._categorySelects[categorySelectIdx], category = {
                        source: this._categoryColumn,
                        values: []
                    }, instances = primaryMember.Instances, identities;
                    if (primaryAxisGroupings) {
                        identities = category.identity = [];
                        category.identityFields = context.readKeys(primaryAxisGroupings, 0);
                    }
                    var primaryMeasureSelects = this._primaryMeasureSelects;
                    var lastMergeIndex;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        var instance = instances[i];
                        if (instance.RestartFlag === 1) lastMergeIndex = i;
                        category.values.push(_dsr.DataShapeUtility.findAndParseCalculation(instance.Calculations, select.Value));
                        if (identities) identities.push(context.readIdentity(primaryAxisGroupings, instance, 0));
                        var intersections = instance.Intersections, valueIdx = 0;
                        for (var j = 0, jlen = intersections.length; j < jlen; j++) {
                            var calculations = intersections[j].Calculations;
                            for (var k = 0, klen = this._measureSelects.length; k < klen; k++) {
                                var measureSelect = this._measureSelects[k];
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, measureSelect.Value);
                                if (value === undefined) continue;
                                var valueCol = values[valueIdx++];
                                valueCol.values.push(value);
                                if (measureSelect.Highlight) {
                                    if (!valueCol.highlights) valueCol.highlights = [];
                                    var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, measureSelect.Highlight.Value);
                                    valueCol.highlights.push(value);
                                }
                            }
                        }
                        for (var j = 0, jlen = primaryMeasureSelects.length; j < jlen; j++) {
                            var measureSelect = primaryMeasureSelects[j];
                            var value = _dsr.DataShapeUtility.findAndParseCalculation(instance.Calculations, measureSelect.Value);
                            var valueCol = values[valueIdx++];
                            valueCol.values.push(value);
                            if (measureSelect.Highlight) {
                                if (!valueCol.highlights) valueCol.highlights = [];
                                var value = _dsr.DataShapeUtility.findAndParseCalculation(calculations, measureSelect.Highlight.Value);
                                valueCol.highlights.push(value);
                            }
                        }
                    }
                    return {
                        categories: [ category ],
                        lastMergeIndex: lastMergeIndex
                    };
                };
                return DsrWithPivotedColumnsStrategy;
            }();
            var DsrReaderContext = function() {
                function DsrReaderContext(selects, schemaName) {
                    debug.assertValue(selects, "selects");
                    debug.assertAnyValue(schemaName, "schemaName");
                    this.selects = selects;
                    this.schema = schemaName;
                    this.cacheItems = [];
                }
                DsrReaderContext.prototype.columnMetadata = function(selectIndex) {
                    debug.assertValue(selectIndex, "selectIndex");
                    var select = this.selects[selectIndex];
                    debug.assertValue(select, "select");
                    var column = {
                        displayName: "",
                        index: selectIndex
                    };
                    if (select.Format) column.format = select.Format;
                    column.type = _dsr.DataShapeUtility.describeDataType(select.Type, select.DataCategory);
                    if (select.Kind === 2) column.isMeasure = true;
                    return column;
                };
                DsrReaderContext.prototype.readIdentity = function(axisGroupings, instance, depth) {
                    debug.assertValue(axisGroupings, "axisGroupings");
                    debug.assertValue(depth, "depth");
                    var keyExprs = this.readKeys(axisGroupings, depth), expr;
                    var groupingKeys = axisGroupings[depth].Keys;
                    for (var i = 0, len = groupingKeys.length; i < len; i++) {
                        var key = groupingKeys[i], calcId = key.Calc || this.selects[key.Select].Value, valueExpr = _dsr.DataShapeUtility.findAndParseCalculationToSQExpr(instance.Calculations, calcId);
                        var exprToAdd = data.SQExprBuilder.equal(keyExprs[i], valueExpr);
                        expr = expr ? data.SQExprBuilder.and(expr, exprToAdd) : exprToAdd;
                    }
                    return data.createDataViewScopeIdentity(expr);
                };
                DsrReaderContext.prototype.readKeys = function(axisGroupings, depth) {
                    debug.assertValue(axisGroupings, "axisGroupings");
                    debug.assertValue(depth, "depth");
                    var axisCache = this.getAxisCache(axisGroupings);
                    var keys = axisCache.exprs[depth];
                    if (keys === undefined) {
                        keys = axisCache.exprs[depth] = [];
                        var groupingKeys = axisGroupings[depth].Keys;
                        for (var i = 0, len = groupingKeys.length; i < len; i++) keys.push(this.convertKey(groupingKeys[i]));
                    }
                    return keys;
                };
                DsrReaderContext.prototype.getAxisCache = function(axisGroupings) {
                    debug.assertValue(axisGroupings, "axisGroupings");
                    var cacheItems = this.cacheItems;
                    for (var i = 0, len = cacheItems.length; i < len; i++) {
                        var item = cacheItems[i];
                        if (item.axisGroupings === axisGroupings) return item;
                    }
                    item = {
                        axisGroupings: axisGroupings,
                        exprs: []
                    };
                    cacheItems.push(item);
                    return item;
                };
                DsrReaderContext.prototype.convertKey = function(key) {
                    debug.assertValue(key, "key");
                    var source = key.Source;
                    return data.SQExprBuilder.fieldDef({
                        schema: this.schema,
                        entity: source.Entity || source.EntitySet,
                        column: source.Property
                    });
                };
                return DsrReaderContext;
            }();
            var TreeNodeValueAggregateComputer = function() {
                function TreeNodeValueAggregateComputer(node, length, aggregators) {
                    debug.assertValue(node, "node");
                    debug.assertValue(length, "length");
                    debug.assertValue(aggregators, "aggregators");
                    this.node = node;
                    this.length = length;
                    this.aggregators = aggregators;
                }
                TreeNodeValueAggregateComputer.create = function(node, selects) {
                    var nodeValues = node.values, foundAggregate = false, aggregators = {};
                    for (var i = 0, len = selects.length; i < len; i++) {
                        var select = selects[i];
                        if (!select || select.Kind !== 2) continue;
                        var valueAggregators, nodeMeasureValue;
                        if (nodeValues && (nodeMeasureValue = nodeValues[i])) {
                            valueAggregators = [];
                            if (nodeMeasureValue.min === undefined) valueAggregators.push(new MinTreeNodeValueAggregator());
                            if (nodeMeasureValue.max === undefined) valueAggregators.push(new MaxTreeNodeValueAggregator());
                            if (valueAggregators.length === 0) continue;
                        } else {
                            valueAggregators = [ new MinTreeNodeValueAggregator(), new MaxTreeNodeValueAggregator() ];
                        }
                        aggregators[i] = valueAggregators;
                        foundAggregate = true;
                    }
                    if (foundAggregate) return new TreeNodeValueAggregateComputer(node, len, aggregators);
                };
                TreeNodeValueAggregateComputer.prototype.add = function(index, value) {
                    var aggregators = this.aggregators[index];
                    if (!aggregators) return;
                    for (var i = 0, len = aggregators.length; i < len; i++) aggregators[i].update(value);
                };
                TreeNodeValueAggregateComputer.prototype.complete = function() {
                    var allAggregators = this.aggregators, node = this.node;
                    for (var selectIndex = 0, len = this.length; selectIndex < len; selectIndex++) {
                        var aggregators = allAggregators[selectIndex];
                        if (!aggregators) continue;
                        for (var aggregatorIndex = 0, aggregatorsLength = aggregators.length; aggregatorIndex < aggregatorsLength; aggregatorIndex++) {
                            var aggregator = aggregators[aggregatorIndex], aggregatedValue = aggregator.value();
                            if (aggregatedValue !== undefined) ensureTreeNodeValues(node, selectIndex)[aggregator.name] = aggregatedValue;
                        }
                    }
                };
                return TreeNodeValueAggregateComputer;
            }();
            var MaxTreeNodeValueAggregator = function() {
                function MaxTreeNodeValueAggregator() {}
                Object.defineProperty(MaxTreeNodeValueAggregator.prototype, "name", {
                    get: function() {
                        return "maxLocal";
                    },
                    enumerable: true,
                    configurable: true
                });
                MaxTreeNodeValueAggregator.prototype.update = function(value) {
                    if (typeof value !== "number" || isNaN(value)) return;
                    var current = this.current;
                    this.current = current === undefined ? value : Math.max(current, value);
                };
                MaxTreeNodeValueAggregator.prototype.value = function() {
                    return this.current;
                };
                return MaxTreeNodeValueAggregator;
            }();
            var MinTreeNodeValueAggregator = function() {
                function MinTreeNodeValueAggregator() {}
                Object.defineProperty(MinTreeNodeValueAggregator.prototype, "name", {
                    get: function() {
                        return "minLocal";
                    },
                    enumerable: true,
                    configurable: true
                });
                MinTreeNodeValueAggregator.prototype.update = function(value) {
                    if (typeof value !== "number" || isNaN(value)) return;
                    var current = this.current;
                    this.current = current === undefined ? value : Math.min(current || 0, value);
                };
                MinTreeNodeValueAggregator.prototype.value = function() {
                    return this.current;
                };
                return MinTreeNodeValueAggregator;
            }();
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            var JsonComparer = jsCommon.JsonComparer;
            var ExecuteSemanticQueryBatcher = function() {
                function ExecuteSemanticQueryBatcher(preferredMaxBatches, onBatchExecute, timerFactory) {
                    this.maxBatches = preferredMaxBatches;
                    this.queryExecuteCallback = onBatchExecute;
                    this.pending = [];
                    this.timerFactory = timerFactory || jsCommon.TimerPromiseFactory.instance;
                }
                ExecuteSemanticQueryBatcher.prototype.enqueue = function(queudQuery) {
                    var _this = this;
                    this.pending.push(queudQuery);
                    if (!this.currentBatchDeferred) {
                        this.currentBatchDeferred = $.Deferred();
                        this.timerFactory.create(0).done(function() {
                            var batches = _this.createBatches();
                            _this.clearPending();
                            _this.queryExecuteCallback(batches);
                            _this.currentBatchDeferred.resolve();
                            _this.currentBatchDeferred = undefined;
                        });
                    }
                    return this.currentBatchDeferred.promise();
                };
                ExecuteSemanticQueryBatcher.prototype.clearPending = function() {
                    this.pending = [];
                };
                ExecuteSemanticQueryBatcher.prototype.createBatches = function() {
                    var batches = [];
                    var queriesByDataSource = this.sortQueriesByDataSource();
                    if (queriesByDataSource.length >= this.maxBatches) {
                        for (var i = 0, ilen = queriesByDataSource.length; i < ilen; ++i) {
                            batches.push(this.createBatchFromDataSourceGroup(queriesByDataSource[i]));
                        }
                    } else {
                        batches = this.splitDataSourcesIntoBatches(queriesByDataSource, this.maxBatches);
                    }
                    return batches;
                };
                ExecuteSemanticQueryBatcher.prototype.sortQueriesByDataSource = function() {
                    var dataSourceGroups = [];
                    var queries = this.pending;
                    for (var i = 0, ilen = queries.length; i < ilen; ++i) {
                        var query = queries[i];
                        if (!query.execution.rejected()) {
                            var dataSourceGroup = this.findDataSourceGroup(query.options.dataSource, dataSourceGroups, query.options.cacheResponseOnServer);
                            if (dataSourceGroup) {
                                dataSourceGroup.queuedExecutions.push(query);
                            } else {
                                var newDataSourceGroup = {
                                    dataSource: query.options.dataSource,
                                    queuedExecutions: [ query ],
                                    cacheResponseOnServer: query.options.cacheResponseOnServer
                                };
                                dataSourceGroups.push(newDataSourceGroup);
                            }
                        }
                    }
                    return dataSourceGroups;
                };
                ExecuteSemanticQueryBatcher.prototype.findDataSourceGroup = function(dataSource, dataSourceGroups, shouldCache) {
                    for (var i = 0, ilen = dataSourceGroups.length; i < ilen; ++i) {
                        var dataSourceGroup = dataSourceGroups[i];
                        if (JsonComparer.equals(dataSource, dataSourceGroup.dataSource) && dataSourceGroup.cacheResponseOnServer === shouldCache) return dataSourceGroup;
                    }
                    return null;
                };
                ExecuteSemanticQueryBatcher.prototype.createBatchFromDataSourceGroup = function(dataSourceGroup) {
                    var commands = [];
                    var promises = [];
                    var queuedExecutions = dataSourceGroup.queuedExecutions;
                    for (var i = 0, ilen = queuedExecutions.length; i < ilen; ++i) {
                        var query = queuedExecutions[i];
                        var queryOptions = queuedExecutions[i].options;
                        commands.push(queryOptions.command);
                        promises.push(query.deferred);
                    }
                    return {
                        dataSource: dataSourceGroup.dataSource,
                        commands: commands,
                        promises: promises,
                        cacheResponseOnServer: dataSourceGroup.cacheResponseOnServer
                    };
                };
                ExecuteSemanticQueryBatcher.prototype.splitDataSourcesIntoBatches = function(dataSourceGroups, maxBatches) {
                    var batches = [];
                    for (var i = 0, ilen = dataSourceGroups.length; i < ilen; ++i) {
                        batches.push(this.createBatchFromDataSourceGroup(dataSourceGroups[i]));
                    }
                    batches = this.splitBatches(batches, maxBatches);
                    return batches;
                };
                ExecuteSemanticQueryBatcher.prototype.splitBatches = function(initialBatches, maxBatches) {
                    var batches = initialBatches.slice();
                    while (batches.length < maxBatches) {
                        var splitCandidate;
                        for (var i = 0, ilen = batches.length; i < ilen; ++i) {
                            var batch = batches[i];
                            if (batch.commands.length > 1) {
                                if (!splitCandidate || splitCandidate.commands.length < batch.commands.length) splitCandidate = batch;
                            }
                        }
                        if (splitCandidate) {
                            batches.push(this.splitBatch(splitCandidate));
                            splitCandidate = null;
                        } else {
                            return batches;
                        }
                    }
                    return batches;
                };
                ExecuteSemanticQueryBatcher.prototype.splitBatch = function(batch) {
                    var queryCount = batch.commands.length;
                    var commands = batch.commands.splice(queryCount / 2);
                    var promises = batch.promises.splice(queryCount / 2);
                    return {
                        dataSource: batch.dataSource,
                        commands: commands,
                        promises: promises,
                        cacheResponseOnServer: batch.cacheResponseOnServer
                    };
                };
                return ExecuteSemanticQueryBatcher;
            }();
            dsr.ExecuteSemanticQueryBatcher = ExecuteSemanticQueryBatcher;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(_data) {
        var dsr;
        (function(dsr) {
            function createExecuteSemanticQueryProxyHttpCommunication(httpService) {
                return new ExecuteSemanticQueryProxyHttpCommunication(httpService);
            }
            dsr.createExecuteSemanticQueryProxyHttpCommunication = createExecuteSemanticQueryProxyHttpCommunication;
            var ExecuteSemanticQueryProxy = function() {
                function ExecuteSemanticQueryProxy(host, communication, delayedResultHandler, timerFactory, preferredMaxConnections) {
                    var _this = this;
                    if (preferredMaxConnections === void 0) {
                        preferredMaxConnections = ExecuteSemanticQueryProxy.defaultPreferredMaxConnections;
                    }
                    debug.assertValue(host, "host");
                    this.promiseFactory = host.promiseFactory();
                    this.communication = communication;
                    this.delayedResultHandler = delayedResultHandler ? delayedResultHandler : new DefaultDelayedQueryResultHandler();
                    this.batcher = new dsr.ExecuteSemanticQueryBatcher(preferredMaxConnections, function(batches) {
                        for (var i = 0, ilen = batches.length; i < ilen; ++i) _this.executeBatch(batches[i]);
                    }, timerFactory);
                    this.queryCache = new powerbi.RejectablePromiseCache(this.promiseFactory);
                }
                ExecuteSemanticQueryProxy.prototype.execute = function(options) {
                    var deferred = this.promiseFactory.defer();
                    var execution = powerbi.RejectablePromise2(deferred);
                    if (options.dataSource) {
                        var cacheKey = this.generateCacheKey(options);
                        if (this.queryCache.hasCacheEntry(cacheKey)) return this.queryCache.bindCacheEntry(cacheKey);
                        var deferredPromise = this.queryCache.createCacheEntry(cacheKey);
                        var queuedExecution = {
                            options: options,
                            deferred: deferredPromise.deferred,
                            execution: deferredPromise.promise
                        };
                        if (this.isCommunicationStopped) {
                            this.pausedQueries = this.pausedQueries || [];
                            this.pausedQueries.push(queuedExecution);
                        } else {
                            this.batcher.enqueue(queuedExecution);
                        }
                        return this.queryCache.bindCacheEntry(cacheKey);
                    } else {
                        deferred.resolve(options.command);
                    }
                    return execution;
                };
                ExecuteSemanticQueryProxy.prototype.stopCommunication = function() {
                    this.isCommunicationStopped = true;
                };
                ExecuteSemanticQueryProxy.prototype.resumeCommunication = function() {
                    this.isCommunicationStopped = false;
                    var pausedQueries = this.pausedQueries;
                    if (!pausedQueries) return;
                    for (var i = 0, length = pausedQueries.length; i < length; i++) {
                        var queuedExecution = pausedQueries[i];
                        if (queuedExecution.execution.pending()) this.batcher.enqueue(queuedExecution);
                    }
                    this.pausedQueries = undefined;
                };
                ExecuteSemanticQueryProxy.prototype.rewriteCacheEntries = function(rewriter) {
                    rewriteSemanticQueryCacheEntries(rewriter, this.queryCache);
                };
                ExecuteSemanticQueryProxy.prototype.clearCache = function() {
                    this.queryCache.clearAllEntries();
                };
                ExecuteSemanticQueryProxy.prototype.generateCacheKey = function(options) {
                    if (options.dataSource) {
                        var dataSource = options.dataSource;
                        var objectKey = {
                            dbName: dataSource.dbName,
                            vsName: dataSource.vsName,
                            schemaName: dataSource.schemaName,
                            command: options.command
                        };
                        return cacheKeyObjectToString(objectKey);
                    }
                    return;
                };
                ExecuteSemanticQueryProxy.prototype.executeBatch = function(batch) {
                    var _this = this;
                    debug.assertValue(batch, "batch");
                    debug.assert(batch.commands.length === batch.promises.length, "Commands & promises sizes must match.");
                    var promises = batch.promises;
                    var schemaName = batch.dataSource.schemaName;
                    this.communication.execute(batch.commands, batch.dataSource, batch.cacheResponseOnServer).then(function(result) {
                        return _this.onSuccess(result, promises, schemaName);
                    }, function(result) {
                        return _this.onError(promises);
                    });
                };
                ExecuteSemanticQueryProxy.prototype.onSuccess = function(result, executions, schemaName) {
                    debug.assertValue(result, "result");
                    debug.assertValue(executions, "executions");
                    debug.assert(result.jobIds.length === executions.length, "Results & promises sizes must match");
                    var jobIds = result.jobIds;
                    var jobIdToExecution = {};
                    for (var i = 0, ilen = executions.length; i < ilen; ++i) {
                        jobIdToExecution[jobIds[i]] = executions[i];
                    }
                    var results = result.results;
                    for (var i = 0, ilen = results.length; i < ilen; ++i) {
                        var queryResultWithJobId = results[i];
                        var queryResult = queryResultWithJobId.result;
                        var execution = jobIdToExecution[queryResultWithJobId.jobId];
                        var data = queryResult.data;
                        var error = queryResult.error;
                        if (data) {
                            var dsrData = {
                                descriptor: data.descriptor,
                                dsr: data.dsr,
                                schemaName: schemaName
                            };
                            execution.resolve(dsrData);
                        } else if (error) {
                            var errorFactory = new _data.ServiceErrorToClientError(error);
                            execution.reject(errorFactory);
                        } else if (queryResult.asyncResult) {
                            this.delayedResultHandler.registerDelayedResult(queryResultWithJobId.jobId, execution, schemaName);
                        }
                    }
                };
                ExecuteSemanticQueryProxy.prototype.onError = function(executions) {
                    debug.assertValue(executions, "executions");
                    for (var i = 0, len = executions.length; i < len; i++) {
                        executions[i].reject();
                    }
                };
                ExecuteSemanticQueryProxy.defaultPreferredMaxConnections = 4;
                return ExecuteSemanticQueryProxy;
            }();
            dsr.ExecuteSemanticQueryProxy = ExecuteSemanticQueryProxy;
            function rewriteSemanticQueryCacheEntries(rewriter, queryCache) {
                var cacheRewriter = {};
                if (rewriter.rewriteCacheKey) cacheRewriter.rewriteKey = function(cacheKey) {
                    var objectKey = JSON.parse(cacheKey);
                    var newKey = rewriter.rewriteCacheKey(objectKey);
                    if (newKey !== objectKey) return cacheKeyObjectToString(newKey);
                    return cacheKey;
                };
                if (rewriter.rewriteCacheResult) cacheRewriter.rewriteResult = function(result, cacheKey) {
                    var objectKey = JSON.parse(cacheKey);
                    var data = result;
                    var rewrittenResult = rewriter.rewriteCacheResult({
                        descriptor: data.descriptor,
                        dsr: data.dsr,
                        schemaName: objectKey.schemaName
                    });
                    return {
                        descriptor: rewrittenResult.descriptor,
                        dsr: rewrittenResult.dsr
                    };
                };
                queryCache.rewriteAllEntries(cacheRewriter);
            }
            dsr.rewriteSemanticQueryCacheEntries = rewriteSemanticQueryCacheEntries;
            function cacheKeyObjectToString(objectKey) {
                return objectKey && JSON.stringify(objectKey);
            }
            var ExecuteSemanticQueryProxyHttpCommunication = function() {
                function ExecuteSemanticQueryProxyHttpCommunication(httpService) {
                    debug.assertValue(httpService, "httpService");
                    this.httpService = httpService;
                }
                ExecuteSemanticQueryProxyHttpCommunication.prototype.execute = function(commands, dataSource, cacheResponse) {
                    var requestOptions = this.httpService.powerbiRequestOptions();
                    var executeSemanticQueryRequest = {
                        semanticQueryDataShapeCommands: commands,
                        databaseName: dataSource.dbName,
                        virtualServerName: dataSource.vsName,
                        modelId: dataSource.modelId
                    };
                    if (cacheResponse) {
                        executeSemanticQueryRequest.commands = commands.map(function(command) {
                            return {
                                Command: command,
                                CacheKey: JSON.stringify(command)
                            };
                        });
                    }
                    return this.httpService.post(ExecuteSemanticQueryProxyHttpCommunication.uri, executeSemanticQueryRequest, requestOptions).then(function(result) {
                        return result.data;
                    });
                };
                ExecuteSemanticQueryProxyHttpCommunication.uri = "/explore/querydata";
                return ExecuteSemanticQueryProxyHttpCommunication;
            }();
            var DefaultDelayedQueryResultHandler = function() {
                function DefaultDelayedQueryResultHandler() {}
                DefaultDelayedQueryResultHandler.prototype.registerDelayedResult = function(jobId, deferred, schemaName) {
                    debug.assertFail("Apps that want to support delayed query results need to specify an IExecuteSemanticQueryDelayedResultHandler implementation");
                    deferred.reject(new powerbi.UnknownClientError());
                };
                DefaultDelayedQueryResultHandler.prototype.setQueryResolver = function(resolver) {};
                return DefaultDelayedQueryResultHandler;
            }();
        })(dsr = _data.dsr || (_data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            function traverseQueryBindingDescriptorWithArg(descriptor, visitor, arg) {
                debug.assertValue(visitor, "visitor");
                debug.assertValue(descriptor, "descriptor");
                visitor.visitDescriptor(descriptor, arg);
                var selects = descriptor.Select;
                if (selects && selects.length) for (var i = 0, length = selects.length; i < length; i++) visitor.visitSelect(selects[i], arg);
                var expressions = descriptor.Expressions;
                if (expressions) traverseExpressions(expressions, visitor, arg);
            }
            dsr.traverseQueryBindingDescriptorWithArg = traverseQueryBindingDescriptorWithArg;
            function traverseExpressions(expressions, visitor, arg) {
                debug.assertValue(expressions, "expressions");
                visitor.visitExpressions(expressions, arg);
                debug.assertValue(expressions.Primary, "Primary");
                traverseDataShapeExpressionsAxis(expressions.Primary, visitor, arg);
                var secondary = expressions.Secondary;
                if (secondary) traverseDataShapeExpressionsAxis(secondary, visitor, arg);
            }
            function traverseDataShapeExpressionsAxis(axis, visitor, arg) {
                debug.assertValue(axis, "axis");
                visitor.visitDataShapeExpressionsAxis(axis, arg);
                var groupings = axis.Groupings;
                debug.assertValue(groupings, "groupings");
                for (var i = 0, length = groupings.length; i < length; i++) traverseDataShapeExpressionsAxisGrouping(groupings[i], visitor, arg);
            }
            function traverseDataShapeExpressionsAxisGrouping(grouping, visitor, arg) {
                debug.assertValue(grouping, "grouping");
                visitor.visitDataShapeExpressionsAxisGrouping(grouping, arg);
                var keys = grouping.Keys;
                debug.assertValue(keys, "keys");
                for (var i = 0, length = keys.length; i < length; i++) traverseDataShapeExpressionsAxisGroupingKey(keys[i], visitor, arg);
            }
            function traverseDataShapeExpressionsAxisGroupingKey(groupingKey, visitor, arg) {
                debug.assertValue(groupingKey, "groupingKey");
                visitor.visitDataShapeExpressionsAxisGroupingKey(groupingKey, arg);
                debug.assertValue(groupingKey.Source, "Source");
                visitor.visitConceptualPropertyReference(groupingKey.Source, arg);
            }
            var DefaultQueryBindingDescriptorVisitor = function() {
                function DefaultQueryBindingDescriptorVisitor() {}
                DefaultQueryBindingDescriptorVisitor.prototype.visitDescriptor = function(discriptor, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitSelect = function(select, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitExpressions = function(expressions, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitDataShapeExpressionsAxis = function(axis, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitDataShapeExpressionsAxisGrouping = function(grouping, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitDataShapeExpressionsAxisGroupingKey = function(groupingKey, arg) {};
                DefaultQueryBindingDescriptorVisitor.prototype.visitConceptualPropertyReference = function(propertyRef, arg) {};
                return DefaultQueryBindingDescriptorVisitor;
            }();
            dsr.DefaultQueryBindingDescriptorVisitor = DefaultQueryBindingDescriptorVisitor;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            function createQueryCacheHandler() {
                return new QueryCacheHandler();
            }
            dsr.createQueryCacheHandler = createQueryCacheHandler;
            var QueryCacheHandler = function() {
                function QueryCacheHandler() {}
                QueryCacheHandler.prototype.apply = function(queryProxy, changes) {
                    var rewriter = new QueryCacheRewriter(changes);
                    queryProxy.rewriteCacheEntries("dsr", rewriter);
                };
                return QueryCacheHandler;
            }();
            var QueryCacheRewriter = function() {
                function QueryCacheRewriter(changes) {
                    this.descriptorRewriters = createQueryBindingDescriptorRewriters(changes);
                    this.schemaRewriters = data.createSchemaChangeRewriters(changes);
                }
                QueryCacheRewriter.prototype.rewriteCacheKey = function(cacheKey) {
                    var SemanticQuerySerializer = data.services.SemanticQuerySerializer;
                    var rewriters = this.schemaRewriters;
                    var command = cacheKey.command;
                    var query = SemanticQuerySerializer.deserializeQuery(command.Query);
                    for (var i = 0, length = rewriters.length; i < length; i++) query = query.rewrite(rewriters[i]);
                    command.Query = SemanticQuerySerializer.serializeQuery(query);
                    cacheKey.command = command;
                    return cacheKey;
                };
                QueryCacheRewriter.prototype.rewriteCacheResult = function(result) {
                    var rewriters = this.descriptorRewriters;
                    for (var i = 0, length = rewriters.length; i < length; i++) {
                        var rewriter = rewriters[i];
                        dsr.traverseQueryBindingDescriptorWithArg(result.descriptor, rewriter, result.schemaName);
                    }
                    return result;
                };
                return QueryCacheRewriter;
            }();
            function createQueryBindingDescriptorRewriters(changes) {
                debug.assertValue(changes, "changes");
                var rewriters = [];
                for (var i = 0, length = changes.length; i < length; i++) {
                    var change = changes[i];
                    if (change.entityRename) {
                        rewriters.push(new QueryBindingDescriptorEntityRewriter(change.entityRename));
                    }
                    if (change.propertyRename) {
                        rewriters.push(new QueryBindingDescriptorPropertyRewriter(change.propertyRename));
                    }
                }
                return rewriters;
            }
            var QueryBindingDescriptorEntityRewriter = function(_super) {
                __extends(QueryBindingDescriptorEntityRewriter, _super);
                function QueryBindingDescriptorEntityRewriter(change) {
                    _super.call(this);
                    this.change = change;
                }
                QueryBindingDescriptorEntityRewriter.prototype.visitConceptualPropertyReference = function(propertyRef, schemaName) {
                    if (this.change.schema === schemaName && propertyRef.Entity === this.change.before) propertyRef.Entity = this.change.after;
                };
                return QueryBindingDescriptorEntityRewriter;
            }(dsr.DefaultQueryBindingDescriptorVisitor);
            var QueryBindingDescriptorPropertyRewriter = function(_super) {
                __extends(QueryBindingDescriptorPropertyRewriter, _super);
                function QueryBindingDescriptorPropertyRewriter(change) {
                    _super.call(this);
                    this.change = change;
                }
                QueryBindingDescriptorPropertyRewriter.prototype.visitConceptualPropertyReference = function(propertyRef, schemaName) {
                    if (this.change.schema === schemaName && propertyRef.Property === this.change.before) propertyRef.Property = this.change.after;
                };
                return QueryBindingDescriptorPropertyRewriter;
            }(dsr.DefaultQueryBindingDescriptorVisitor);
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            var ArrayExtensions = jsCommon.ArrayExtensions;
            var QueryDescription = function() {
                function QueryDescription(metadata, binding) {
                    debug.assertValue(metadata, "metadata");
                    debug.assertValue(metadata.Select, "metadata.Select");
                    debug.assertValue(binding, "binding");
                    debug.assertValue(binding.Select, "binding.Select");
                    debug.assert(metadata.Select.length === binding.Select.length, "Metadata and Binding should have same number of select items.");
                    this._metadata = metadata;
                    this._binding = binding;
                }
                QueryDescription.prototype.getSelectRestatements = function() {
                    return this.getRestatements();
                };
                QueryDescription.prototype.getGroupRestatements = function() {
                    return this.getRestatements(1);
                };
                QueryDescription.prototype.getMeasureRestatements = function() {
                    return this.getRestatements(2);
                };
                QueryDescription.prototype.getFilterRestatements = function() {
                    var filters = this._metadata.Filters;
                    if (ArrayExtensions.isUndefinedOrEmpty(filters)) return null;
                    var restatements = [];
                    for (var i = 0, len = filters.length; i < len; i++) {
                        var filter = filters[i];
                        restatements.push(filter ? filter.Restatement : "");
                    }
                    return ArrayExtensions.emptyToNull(restatements);
                };
                QueryDescription.prototype.getRestatements = function(kind) {
                    var metadata = this._metadata;
                    var binding = this._binding;
                    var restatements = [];
                    for (var i = 0, len = binding.Select.length; i < len; i++) {
                        var selectBinding = binding.Select[i], selectMetadata = metadata.Select[i];
                        if (!selectBinding) continue;
                        if (kind === undefined || selectBinding.Kind === kind) {
                            restatements.push(selectMetadata.Restatement || "");
                        }
                    }
                    return ArrayExtensions.emptyToNull(restatements);
                };
                return QueryDescription;
            }();
            dsr.QueryDescription = QueryDescription;
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var dsr;
        (function(dsr) {
            function createQueryGenerator() {
                return new QueryGenerator(data.services.SemanticQuerySerializer);
            }
            dsr.createQueryGenerator = createQueryGenerator;
            var QueryGeneratorConstants = function() {
                function QueryGeneratorConstants() {}
                QueryGeneratorConstants.DefaultDataVolume = 3;
                return QueryGeneratorConstants;
            }();
            var QueryGenerator = function() {
                function QueryGenerator(serializer) {
                    debug.assertValue(serializer, "serializer");
                    this.serializer = serializer;
                }
                QueryGenerator.prototype.run = function(options) {
                    debug.assertValue(options, "options");
                    var query = options.query, mappings = options.mappings, highlightFilter = options.highlightFilter;
                    var indicesByName = Impl.getIndicesByName(query);
                    var mergedQueries = dsr.mergeMappings(mappings, options.projections, indicesByName);
                    var dataVolume = options.dataVolume;
                    if (!dataVolume) dataVolume = QueryGeneratorConstants.DefaultDataVolume;
                    var dataShapeBinding = generateDataShapeBinding(this.serializer, options.projections, indicesByName, mergedQueries.mapping, highlightFilter, dataVolume, options.restartToken);
                    var queryDefinition = this.serializer.serializeQuery(query);
                    return {
                        command: {
                            Query: queryDefinition,
                            Binding: dataShapeBinding
                        },
                        splits: mergedQueries.splits
                    };
                };
                return QueryGenerator;
            }();
            function generateDataShapeBinding(serializer, projections, indicesByName, mapping, highlightFilter, dataVolume, restartToken) {
                var binding = Impl.generateBaseDataShapeBinding(projections, indicesByName, mapping, dataVolume);
                if (binding) {
                    binding.Version = 1;
                    if (restartToken && binding.DataReduction && binding.DataReduction.Primary && binding.DataReduction.Primary.Window) {
                        binding.DataReduction.Primary.Window.RestartTokens = restartToken;
                    }
                    if (highlightFilter) binding.Highlights = [ serializer.serializeFilter(highlightFilter) ];
                }
                return binding;
            }
            dsr.generateDataShapeBinding = generateDataShapeBinding;
            var Impl;
            (function(Impl) {
                function generateBaseDataShapeBinding(projections, indicesByName, mapping, dataVolume) {
                    debug.assertValue(projections, "projections");
                    debug.assertValue(indicesByName, "indicesByName");
                    debug.assertValue(mapping, "mapping");
                    if (mapping.categorical) return forCategorical(projections, indicesByName, mapping.categorical, dataVolume);
                    if (mapping.table) return forTable(projections, indicesByName, mapping.table, dataVolume);
                    if (mapping.matrix) return forMatrix(projections, indicesByName, mapping.matrix, dataVolume);
                }
                Impl.generateBaseDataShapeBinding = generateBaseDataShapeBinding;
                function forCategorical(projections, indicesByName, mapping, dataVolume) {
                    debug.assertValue(projections, "projections");
                    debug.assertValue(indicesByName, "indicesByName");
                    debug.assertValue(mapping, "mapping");
                    var result = {
                        Primary: {
                            Groupings: [ {
                                Projections: []
                            } ]
                        }
                    };
                    var primaryDataReduction, secondaryDataReduction;
                    var primaryProjections = result.Primary.Groupings[0].Projections, hasCategories = false;
                    if (mapping.categories) {
                        var categories = mapping.categories;
                        pushIfAnyBind(primaryProjections, projections, indicesByName, categories);
                        pushIfAnyFor(primaryProjections, projections, indicesByName, categories);
                        hasCategories = primaryProjections.length > 0;
                        if (hasCategories) primaryDataReduction = buildDataReductionAlgorithm(categories.dataReductionAlgorithm);
                    }
                    if (mapping.values) {
                        var valuesGrouped = mapping.values;
                        if (valuesGrouped.group) {
                            var valueGroupingProjections = projections[valuesGrouped.group.by.role];
                            if (valueGroupingProjections && valueGroupingProjections.length > 0) {
                                var visualGroupingTarget;
                                if (hasCategories && !containsAllProjections(valueGroupingProjections, primaryProjections, indicesByName)) {
                                    result.Secondary = {
                                        Groupings: [ {
                                            Projections: []
                                        } ]
                                    };
                                    visualGroupingTarget = result.Secondary.Groupings[0].Projections;
                                    secondaryDataReduction = buildDataReductionAlgorithm(valuesGrouped.group.dataReductionAlgorithm);
                                } else {
                                    visualGroupingTarget = primaryProjections;
                                    primaryDataReduction = buildDataReductionAlgorithm(valuesGrouped.group.dataReductionAlgorithm);
                                }
                                pushIfAny(visualGroupingTarget, valueGroupingProjections, indicesByName);
                            }
                            for (var i = 0, len = valuesGrouped.group.select.length; i < len; i++) pushIfAnyRole(primaryProjections, projections, indicesByName, valuesGrouped.group.select[i]);
                            var valuesList = mapping.values;
                            if (valuesList.select) {
                                var valuesListProjections = [];
                                pushIfAnyRole(primaryProjections, projections, indicesByName, mapping.values, valuesListProjections);
                                pushIfAnySelect(primaryProjections, projections, indicesByName, mapping.values, valuesListProjections);
                                if (result.Secondary) result.Secondary.Groupings[0].SuppressedProjections = valuesListProjections;
                            }
                        } else {
                            pushIfAnyRole(primaryProjections, projections, indicesByName, mapping.values);
                            pushIfAnySelect(primaryProjections, projections, indicesByName, mapping.values);
                        }
                    }
                    buildDataReduction(result, dataVolume, primaryDataReduction, secondaryDataReduction);
                    return result;
                }
                function forTable(projections, indicesByName, mapping, dataVolume) {
                    debug.assertValue(projections, "projections");
                    debug.assertValue(indicesByName, "indicesByName");
                    debug.assertValue(mapping, "mapping");
                    var rows = mapping.rows;
                    var primaryProjections = [];
                    pushIfAnyRole(primaryProjections, projections, indicesByName, rows);
                    pushIfAnySelect(primaryProjections, projections, indicesByName, rows);
                    if (primaryProjections.length > 0) {
                        var result = {
                            Primary: {
                                Groupings: [ {
                                    Projections: primaryProjections
                                } ]
                            }
                        };
                        var hasRowsRoleMapping = rows;
                        if (hasRowsRoleMapping) setSubtotals(result.Primary.Groupings, hasRowsRoleMapping);
                        var hasReductionAlgorithm = rows;
                        if (hasReductionAlgorithm) {
                            var reductionAlgorithm = buildDataReductionAlgorithm(hasReductionAlgorithm.dataReductionAlgorithm);
                            buildDataReduction(result, dataVolume, reductionAlgorithm);
                        }
                        return result;
                    }
                }
                function forMatrix(projections, indicesByName, mapping, dataVolume) {
                    debug.assertValue(projections, "projections");
                    debug.assertValue(indicesByName, "indicesByName");
                    debug.assertValue(mapping, "mapping");
                    var result = {
                        Primary: {
                            Groupings: []
                        }
                    };
                    var primaryDataReduction, secondaryDataReduction;
                    var primaryGroupings = result.Primary.Groupings, hasRowGroups = false, hasColumnGroups = false;
                    if (mapping.rows) {
                        pushIfAnyForWithSeparateGroup(primaryGroupings, projections, indicesByName, mapping.rows);
                        hasRowGroups = primaryGroupings.length > 0;
                        if (hasRowGroups) {
                            primaryDataReduction = buildDataReductionAlgorithm(mapping.rows.dataReductionAlgorithm);
                            setSubtotals(primaryGroupings, mapping.rows);
                        }
                    }
                    if (mapping.columns) {
                        var groupings = [];
                        pushIfAnyForWithSeparateGroup(groupings, projections, indicesByName, mapping.columns);
                        hasColumnGroups = groupings.length > 0;
                        if (hasColumnGroups) {
                            setSubtotals(groupings, mapping.columns);
                            if (!hasRowGroups) {
                                result.Primary.Groupings = groupings;
                                primaryDataReduction = buildDataReductionAlgorithm(mapping.columns.dataReductionAlgorithm);
                            } else {
                                result.Secondary = {
                                    Groupings: groupings
                                };
                                secondaryDataReduction = buildDataReductionAlgorithm(mapping.columns.dataReductionAlgorithm);
                            }
                        }
                    }
                    if (mapping.values) {
                        var targetGroupings = hasColumnGroups ? result.Secondary && result.Secondary.Groupings ? result.Secondary.Groupings : [] : primaryGroupings;
                        groupCount = targetGroupings.length;
                        if (groupCount === 0) var groupCount = targetGroupings.push({
                            Projections: []
                        });
                        var innermostGroupingProjections = targetGroupings[groupCount - 1].Projections;
                        var projectionsPushed = pushIfAnyRole(innermostGroupingProjections, projections, indicesByName, mapping.values);
                        if (projectionsPushed > 0 && hasColumnGroups && !result.Secondary) result.Secondary = {
                            Groupings: targetGroupings
                        };
                    }
                    buildDataReduction(result, dataVolume, primaryDataReduction, secondaryDataReduction);
                    return result;
                }
                function convertSubtotalType(dataViewRoleForMapping) {
                    switch (dataViewRoleForMapping.for.in.subtotalType) {
                      case 1:
                        return 1;

                      case 2:
                        return 2;

                      case 0:
                        return 0;
                    }
                }
                function setSubtotals(groupings, dataViewRoleForMapping) {
                    var subtotal = convertSubtotalType(dataViewRoleForMapping);
                    if (subtotal != null) {
                        for (var i = 0, ilen = groupings.length; i < ilen; i++) groupings[i].Subtotal = subtotal;
                    }
                }
                function getIndicesByName(query) {
                    debug.assertValue(query, "query");
                    var result = {}, select = query.select();
                    for (var i = 0, len = select.length; i < len; i++) result[select[i].name] = i;
                    return result;
                }
                Impl.getIndicesByName = getIndicesByName;
                function containsAllProjections(projectionsToAdd, existingProjections, indicesByName) {
                    for (var i = 0, len = projectionsToAdd.length; i < len; i++) {
                        var queryReference = projectionsToAdd[i].queryRef, queryIndex = indicesByName[queryReference];
                        if (existingProjections.indexOf(queryIndex) < 0) return false;
                    }
                    return true;
                }
                function pushIfAnyRole(indices, projections, indicesByName, mapping, addedProjectionIndices) {
                    debug.assertValue(indices, "indices");
                    debug.assertValue(projections, "projections");
                    return pushIfAnyBind(indices, projections, indicesByName, mapping, addedProjectionIndices) + pushIfAnyFor(indices, projections, indicesByName, mapping, addedProjectionIndices);
                }
                function pushIfAnyBind(indices, projections, indicesByName, bindMapping, addedProjectionIndices) {
                    debug.assertValue(indices, "indices");
                    debug.assertValue(projections, "projections");
                    if (bindMapping && bindMapping.bind) return pushIfAny(indices, projections[bindMapping.bind.to.role], indicesByName, addedProjectionIndices);
                    return 0;
                }
                function pushIfAnyFor(indices, projections, indicesByName, forMapping, addedProjectionIndices) {
                    debug.assertValue(indices, "indices");
                    debug.assertValue(projections, "projections");
                    if (forMapping && forMapping.for) return pushIfAny(indices, projections[forMapping.for.in.role], indicesByName, addedProjectionIndices);
                    return 0;
                }
                function pushIfAnySelect(indices, projections, indicesByName, selectMapping, addedProjectionIndices) {
                    debug.assertValue(indices, "indices");
                    debug.assertValue(projections, "projections");
                    if (selectMapping && selectMapping.select) {
                        var result = 0;
                        for (var i = 0, len = selectMapping.select.length; i < len; i++) result += pushIfAnyRole(indices, projections, indicesByName, selectMapping.select[i], addedProjectionIndices);
                        return result;
                    }
                    return 0;
                }
                function pushIfAny(indices, projections, indicesByName, addedProjectionIndices) {
                    debug.assertValue(indices, "indices");
                    debug.assertValue(indicesByName, "indicesByName");
                    if (!projections) return 0;
                    for (var i = 0, len = projections.length; i < len; i++) {
                        var queryReference = projections[i].queryRef, queryIndex = indicesByName[queryReference];
                        if (indices.indexOf(queryIndex) >= 0) continue;
                        indices.push(queryIndex);
                        if (addedProjectionIndices) addedProjectionIndices.push(queryIndex);
                    }
                    return indices.length;
                }
                function pushIfAnyForWithSeparateGroup(groupings, projections, indicesByName, forMapping) {
                    debug.assertValue(groupings, "groupings");
                    debug.assertValue(projections, "projections");
                    debug.assertValue(indicesByName, "indicesByName");
                    if (!forMapping || !forMapping.for) return;
                    var items = projections[forMapping.for.in.role];
                    if (items) {
                        for (var i = 0, len = items.length; i < len; i++) {
                            var queryReference = items[i].queryRef, queryIndex = indicesByName[queryReference];
                            if (!groupings.some(function(g) {
                                return g.Projections.indexOf(queryIndex) >= 0;
                            })) groupings.push({
                                Projections: [ queryIndex ]
                            });
                        }
                    }
                }
                function buildDataReduction(binding, dataVolume, primary, secondary) {
                    if (!primary && !secondary) return;
                    binding.DataReduction = {};
                    if (dataVolume) binding.DataReduction.DataVolume = dataVolume;
                    if (primary) binding.DataReduction.Primary = primary;
                    if (secondary) binding.DataReduction.Secondary = secondary;
                }
                function buildDataReductionAlgorithm(reduction) {
                    if (!reduction) return;
                    var result;
                    if (reduction.top) {
                        result = {
                            Top: {}
                        };
                        if (reduction.top.count) result.Top.Count = reduction.top.count;
                    }
                    if (reduction.bottom) {
                        result = {
                            Bottom: {}
                        };
                        if (reduction.bottom.count) result.Bottom.Count = reduction.bottom.count;
                    }
                    if (reduction.sample) {
                        result = {
                            Sample: {}
                        };
                        if (reduction.sample.count) result.Sample.Count = reduction.sample.count;
                    }
                    if (reduction.window) {
                        result = {
                            Window: {}
                        };
                        if (reduction.window.count) result.Window.Count = reduction.window.count;
                    }
                    return result;
                }
            })(Impl || (Impl = {}));
        })(dsr = data.dsr || (data.dsr = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var segmentation;
        (function(segmentation) {
            var DataViewMerger;
            (function(DataViewMerger) {
                function mergeDataViews(source, segment) {
                    if (!areColumnArraysMergeEquivalent(source.metadata.columns, segment.metadata.columns)) {
                        debug.assertFail("Cannot merge data views with different metadata columns");
                    }
                    if (!segment.metadata.segment) delete source.metadata.segment;
                    if (source.table && segment.table) mergeTables(source.table, segment.table);
                    if (source.categorical && segment.categorical) mergeCategorical(source.categorical, segment.categorical);
                    if (source.tree && segment.tree) mergeTreeNodes(source.tree.root, segment.tree.root, true);
                    if (source.matrix && segment.matrix) mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false);
                }
                DataViewMerger.mergeDataViews = mergeDataViews;
                function mergeTables(source, segment) {
                    debug.assertValue(source, "source");
                    debug.assertValue(segment, "segment");
                    if (segment.rows.length === 0) return;
                    merge(source.rows, segment.rows, segment.lastMergeIndex + 1);
                }
                DataViewMerger.mergeTables = mergeTables;
                function mergeCategorical(source, segment) {
                    debug.assertValue(source, "source");
                    debug.assertValue(segment, "segment");
                    if (source.categories && segment.categories) {
                        var segmentCategoriesLength = segment.categories.length;
                        debug.assert(source.categories.length === segmentCategoriesLength, "Source and segment categories have different lengths.");
                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {
                            var segmentCategory = segment.categories[categoryIndex];
                            var sourceCategory = source.categories[categoryIndex];
                            debug.assert(areColumnsMergeEquivalent(sourceCategory.source, segmentCategory.source), "Source and segment category have different sources.");
                            if (!sourceCategory.values && segmentCategory.values) {
                                sourceCategory.values = [];
                                debug.assert(!sourceCategory.identity, "Source category is missing values but has identities.");
                            }
                            if (segmentCategory.values) {
                                merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);
                            }
                            if (!sourceCategory.identity && segmentCategory.identity) {
                                sourceCategory.identity = [];
                            }
                            if (segmentCategory.identity) {
                                merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);
                            }
                        }
                    }
                    if (source.values && segment.values) {
                        var segmentValuesLength = segment.values.length;
                        debug.assert(source.values.length === segmentValuesLength, "Source and segment values have different lengths.");
                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {
                            var segmentValue = segment.values[valueIndex];
                            var sourceValue = source.values[valueIndex];
                            debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), "Source and segment value have different sources.");
                            if (!sourceValue.values && segmentValue.values) {
                                sourceValue.values = [];
                            }
                            if (segmentValue.values) {
                                merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);
                            }
                            if (segmentValue.highlights) {
                                merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);
                            }
                        }
                    }
                }
                DataViewMerger.mergeCategorical = mergeCategorical;
                function merge(source, segment, index) {
                    if (index >= segment.length) return segment;
                    var result = [];
                    if (index !== undefined) result = segment.splice(0, index);
                    Array.prototype.push.apply(source, segment);
                    return result;
                }
                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {
                    debug.assertValue(sourceRoot, "sourceRoot");
                    debug.assertValue(segmentRoot, "segmentRoot");
                    if (!segmentRoot.children || segmentRoot.children.length === 0) return;
                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {
                        sourceRoot.children = segmentRoot.children;
                        return;
                    }
                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, "Source tree has different structure than segment.");
                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);
                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];
                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);
                    if (mergedChildren.length > 0) mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);
                }
                DataViewMerger.mergeTreeNodes = mergeTreeNodes;
                function areColumnsMergeEquivalent(sourceColumn, segmentColumn) {
                    debug.assertValue(sourceColumn, "sourceColumn");
                    debug.assertValue(segmentColumn, "segmentColumn");
                    if (sourceColumn.displayName !== segmentColumn.displayName) return false;
                    if (sourceColumn.isMeasure !== segmentColumn.isMeasure) return false;
                    if (sourceColumn.type !== segmentColumn.type) return false;
                    return true;
                }
                function areColumnArraysMergeEquivalent(sourceColumns, segmentColumns) {
                    debug.assertValue(sourceColumns, "sourceColumns");
                    debug.assertValue(segmentColumns, "segmentColumns");
                    if (sourceColumns.length !== segmentColumns.length) return false;
                    for (var i = 0; i < sourceColumns.length; i++) if (!areColumnsMergeEquivalent(sourceColumns[i], segmentColumns[i])) return false;
                    return true;
                }
                DataViewMerger.areColumnArraysMergeEquivalent = areColumnArraysMergeEquivalent;
                function findFirstAppendIndex(children) {
                    if (children.length === 0) return 0;
                    var i = 0;
                    for (;i < children.length; i++) {
                        var childSegment = children[i];
                        if (!childSegment.isMerge) break;
                    }
                    return i;
                }
            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));
        })(segmentation = data.segmentation || (data.segmentation = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var SQExprConverter;
        (function(SQExprConverter) {
            function asScopeIdsContainer(filter, fieldSQExprs) {
                debug.assertValue(filter, "filter");
                debug.assertValue(fieldSQExprs, "fieldSQExprs");
                debug.assert(fieldSQExprs.length === 1, "There should be exactly 1 field expression.");
                var filterItems = filter.conditions();
                debug.assert(filterItems.length === 1, "There should be exactly 1 filter expression.");
                var filterItem = filterItems[0];
                if (filterItem) {
                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs[0]);
                    if (filterItem.accept(visitor)) return visitor.getResult();
                }
            }
            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;
            function getFirstComparandValue(identity) {
                debug.assertValue(identity, "identity");
                var comparandExpr = identity.expr.accept(new FindComparandVisitor());
                if (comparandExpr) return comparandExpr.value;
            }
            SQExprConverter.getFirstComparandValue = getFirstComparandValue;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        var FilterScopeIdsCollectorVisitor = function(_super) {
            __extends(FilterScopeIdsCollectorVisitor, _super);
            function FilterScopeIdsCollectorVisitor(fieldSQExpr) {
                _super.call(this);
                this.isRoot = true;
                this.isNot = false;
                this.valueExprs = [];
                this.fieldExpr = data.SQExprBuilder.removeEntityVariables(fieldSQExpr);
            }
            FilterScopeIdsCollectorVisitor.prototype.getResult = function() {
                debug.assertValue(this.fieldExpr, "fieldExpr");
                var valueExprs = this.valueExprs, scopeIds = [];
                for (var i = 0, len = valueExprs.length; i < len; i++) {
                    scopeIds.push(FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExpr, valueExprs[i]));
                }
                return {
                    isNot: this.isNot,
                    scopeIds: scopeIds
                };
            };
            FilterScopeIdsCollectorVisitor.getScopeIdentity = function(fieldExpr, valueExpr) {
                debug.assertValue(valueExpr, "valueExpr");
                debug.assertValue(fieldExpr, "fieldExpr");
                return data.createDataViewScopeIdentity(data.SQExprBuilder.equal(fieldExpr, valueExpr));
            };
            FilterScopeIdsCollectorVisitor.prototype.visitOr = function(expr) {
                this.isRoot = false;
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitNot = function(expr) {
                if (!this.isRoot) return this.unsupportedSQExpr();
                this.isNot = true;
                return expr.arg.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function(expr) {
                if (this.isRoot && expr.type.primitiveType === 0) return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function(expr) {
                this.isRoot = false;
                if (expr.kind !== 0) return this.unsupportedSQExpr();
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function(expr) {
                if (this.isRoot) return this.unsupportedSQExpr();
                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);
                return data.SQExpr.equals(this.fieldExpr, fixedExpr);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function(expr) {
                return this.unsupportedSQExpr();
            };
            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function() {
                return false;
            };
            return FilterScopeIdsCollectorVisitor;
        }(data.DefaultSQExprVisitor);
        var FindComparandVisitor = function(_super) {
            __extends(FindComparandVisitor, _super);
            function FindComparandVisitor() {
                _super.apply(this, arguments);
            }
            FindComparandVisitor.prototype.visitAnd = function(expr) {
                return expr.left.accept(this) || expr.right.accept(this);
            };
            FindComparandVisitor.prototype.visitCompare = function(expr) {
                if (expr.kind === 0) {
                    if (expr.right instanceof data.SQConstantExpr) return expr.right;
                    if (expr.left instanceof data.SQConstantExpr) return expr.left;
                }
            };
            return FindComparandVisitor;
        }(data.DefaultSQExprVisitor);
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var ScopeIdentityKeyExtractor;
        (function(ScopeIdentityKeyExtractor) {
            function run(expr) {
                var extractor = new KeyExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed) return null;
                return ArrayExtensions.emptyToNull(extractor.keys);
            }
            ScopeIdentityKeyExtractor.run = run;
            var KeyExtractorImpl = function(_super) {
                __extends(KeyExtractorImpl, _super);
                function KeyExtractorImpl() {
                    _super.apply(this, arguments);
                    this.keys = [];
                }
                KeyExtractorImpl.prototype.visitAnd = function(expr) {
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                KeyExtractorImpl.prototype.visitCompare = function(expr) {
                    if (expr.kind !== 0) {
                        this.visitDefault(expr);
                        return;
                    }
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                KeyExtractorImpl.prototype.visitColumnRef = function(expr) {
                    this.keys.push(expr);
                };
                KeyExtractorImpl.prototype.visitConstant = function(expr) {};
                KeyExtractorImpl.prototype.visitDefault = function(expr) {
                    this.malformed = true;
                };
                return KeyExtractorImpl;
            }(data.DefaultSQExprVisitor);
        })(ScopeIdentityKeyExtractor = data.ScopeIdentityKeyExtractor || (data.ScopeIdentityKeyExtractor = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var SQExprConverter;
        (function(SQExprConverter) {
            function asSQFieldDef(sqExpr) {
                return sqExpr.accept(SQFieldDefinitionBuilder.instance);
            }
            SQExprConverter.asSQFieldDef = asSQFieldDef;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        var SQExprBuilder;
        (function(SQExprBuilder) {
            function fieldDef(fieldDef) {
                return wrapAggr(fieldDef) || wrapColumn(fieldDef) || wrapMeasure(fieldDef) || wrapEntity(fieldDef);
            }
            SQExprBuilder.fieldDef = fieldDef;
            function wrapAggr(fieldDef) {
                var aggr = fieldDef.aggregate;
                if (aggr !== undefined) {
                    var expr = wrapColumn(fieldDef) || wrapEntity(fieldDef);
                    if (expr) return SQExprBuilder.aggregate(expr, aggr);
                }
            }
            function wrapColumn(fieldDef) {
                var column = fieldDef.column;
                if (column) {
                    var entityExpr = wrapEntity(fieldDef);
                    if (entityExpr) return SQExprBuilder.columnRef(entityExpr, column);
                }
            }
            function wrapMeasure(fieldDef) {
                var measure = fieldDef.measure;
                if (measure) {
                    var entityExpr = wrapEntity(fieldDef);
                    if (entityExpr) return SQExprBuilder.measureRef(entityExpr, measure);
                }
            }
            function wrapEntity(fieldDef) {
                return SQExprBuilder.entity(fieldDef.schema, fieldDef.entity, fieldDef.entityVar);
            }
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        var SQFieldDefinitionBuilder = function(_super) {
            __extends(SQFieldDefinitionBuilder, _super);
            function SQFieldDefinitionBuilder() {
                _super.apply(this, arguments);
            }
            SQFieldDefinitionBuilder.prototype.visitColumnRef = function(expr) {
                var sourceRef = expr.source.accept(this);
                if (sourceRef) {
                    sourceRef.column = expr.ref;
                    return sourceRef;
                }
            };
            SQFieldDefinitionBuilder.prototype.visitMeasureRef = function(expr) {
                var sourceRef = expr.source.accept(this);
                if (sourceRef) {
                    sourceRef.measure = expr.ref;
                    return sourceRef;
                }
            };
            SQFieldDefinitionBuilder.prototype.visitAggr = function(expr) {
                var sourceRef = expr.arg.accept(this);
                if (sourceRef) {
                    sourceRef.aggregate = expr.func;
                    return sourceRef;
                }
            };
            SQFieldDefinitionBuilder.prototype.visitEntity = function(expr) {
                var fieldDef = {
                    schema: expr.schema,
                    entity: expr.entity
                };
                if (expr.variable) fieldDef.entityVar = expr.variable;
                return fieldDef;
            };
            SQFieldDefinitionBuilder.instance = new SQFieldDefinitionBuilder();
            return SQFieldDefinitionBuilder;
        }(data.DefaultSQExprVisitor);
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var DateExtensions = jsCommon.DateExtensions;
        var StringExtensions = jsCommon.StringExtensions;
        var PrimitiveValueEncoding;
        (function(PrimitiveValueEncoding) {
            function decimal(value) {
                debug.assertValue(value, "value");
                return value + "M";
            }
            PrimitiveValueEncoding.decimal = decimal;
            function double(value) {
                debug.assertValue(value, "value");
                return value + "D";
            }
            PrimitiveValueEncoding.double = double;
            function integer(value) {
                debug.assertValue(value, "value");
                return value + "L";
            }
            PrimitiveValueEncoding.integer = integer;
            function dateTime(value) {
                debug.assertValue(value, "value");
                var date = new Date(value.getTime() - value.getTimezoneOffset() * 6e4);
                var dateTimeString = date.toISOString();
                if (jsCommon.StringExtensions.endsWith(dateTimeString, "Z")) dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);
                return "datetime'" + dateTimeString + "'";
            }
            PrimitiveValueEncoding.dateTime = dateTime;
            function text(value) {
                debug.assertValue(value, "value");
                return "'" + value.replace("'", "''") + "'";
            }
            PrimitiveValueEncoding.text = text;
            function nullEncoding() {
                return "null";
            }
            PrimitiveValueEncoding.nullEncoding = nullEncoding;
            function boolean(value) {
                return value ? "true" : "false";
            }
            PrimitiveValueEncoding.boolean = boolean;
            function parseValue(dsqValue) {
                return parseValueHelper(dsqValue);
            }
            PrimitiveValueEncoding.parseValue = parseValue;
            function parseValueToSQExpr(dsqValue) {
                return parseValueHelper(dsqValue, true);
            }
            PrimitiveValueEncoding.parseValueToSQExpr = parseValueToSQExpr;
            function parseValueHelper(dsqValue, toSQExpr) {
                if (typeof dsqValue === "string") {
                    if (StringExtensions.endsWith(dsqValue, "L")) {
                        var intValue = parseInt(dsqValue, 10);
                        return toSQExpr ? data.SQExprBuilder.integer(intValue, dsqValue) : intValue;
                    }
                    if (StringExtensions.endsWith(dsqValue, "D")) {
                        var doubleValue = parseFloatExtended(dsqValue);
                        return toSQExpr ? data.SQExprBuilder.double(doubleValue, dsqValue) : doubleValue;
                    }
                    if (StringExtensions.endsWith(dsqValue, "M")) {
                        var decimalValue = parseFloatExtended(dsqValue);
                        return toSQExpr ? data.SQExprBuilder.decimal(decimalValue, dsqValue) : decimalValue;
                    }
                    if (StringExtensions.endsWith(dsqValue, "'")) {
                        if (dsqValue.charAt(0) === "'") {
                            var stringValue = dsqValue.substring(1, dsqValue.length - 1).replace("''", "'");
                            return toSQExpr ? data.SQExprBuilder.text(stringValue, dsqValue) : stringValue;
                        }
                        if (dsqValue.indexOf("datetime'") === 0) {
                            var isoDate = dsqValue.substring(9, dsqValue.length - 1);
                            var dateValue = DateExtensions.parseIsoDate(isoDate);
                            return toSQExpr ? data.SQExprBuilder.dateTime(dateValue, dsqValue) : dateValue;
                        }
                    }
                    if (dsqValue === "null") return toSQExpr ? data.SQExprBuilder.nullConstant() : null;
                    if (dsqValue === "true") return toSQExpr ? data.SQExprBuilder.boolean(true) : true;
                    if (dsqValue === "false") return toSQExpr ? data.SQExprBuilder.boolean(false) : false;
                }
                if (typeof dsqValue === "boolean") return toSQExpr ? data.SQExprBuilder.boolean(dsqValue) : dsqValue;
                if (dsqValue == null) return toSQExpr ? data.SQExprBuilder.nullConstant() : null;
                return dsqValue;
            }
            function parseFloatExtended(value) {
                var rawResult = parseFloat(value);
                if (isNaN(rawResult)) {
                    return parseFloat(value.replace("INF", "Infinity"));
                }
                return rawResult;
            }
        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        (function(SemanticQueryVersions) {
            SemanticQueryVersions[SemanticQueryVersions["Version0"] = 0] = "Version0";
            SemanticQueryVersions[SemanticQueryVersions["Version1"] = 1] = "Version1";
            SemanticQueryVersions[SemanticQueryVersions["Version2"] = 2] = "Version2";
        })(data.SemanticQueryVersions || (data.SemanticQueryVersions = {}));
        var SemanticQueryVersions = data.SemanticQueryVersions;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var SQExprRewriter = function() {
            function SQExprRewriter() {}
            SQExprRewriter.prototype.visitColumnRef = function(expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return expr;
                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitMeasureRef = function(expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return expr;
                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitAggr = function(expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return expr;
                return new data.SQAggregationExpr(rewrittenArg, expr.func);
            };
            SQExprRewriter.prototype.visitEntity = function(expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitAnd = function(orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight) return orig;
                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitBetween = function(orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);
                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper) return orig;
                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);
            };
            SQExprRewriter.prototype.visitIn = function(orig) {
                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;
                for (var i = 0, len = origValues.length; i < len; i++) {
                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);
                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues) rewrittenValues = ArrayExtensions.take(origValues, i);
                    if (rewrittenValues) rewrittenValues.push(rewrittenValueTuple);
                }
                if (origArgs === rewrittenArgs && !rewrittenValues) return orig;
                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);
            };
            SQExprRewriter.prototype.rewriteAll = function(origExprs) {
                debug.assertValue(origExprs, "origExprs");
                var rewrittenResult;
                for (var i = 0, len = origExprs.length; i < len; i++) {
                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);
                    if (origExpr !== rewrittenExpr && !rewrittenResult) rewrittenResult = ArrayExtensions.take(origExprs, i);
                    if (rewrittenResult) rewrittenResult.push(rewrittenExpr);
                }
                return rewrittenResult || origExprs;
            };
            SQExprRewriter.prototype.visitOr = function(orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight) return orig;
                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitCompare = function(orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight) return orig;
                return new data.SQCompareExpr(orig.kind, rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitContains = function(orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight) return orig;
                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitExists = function(orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return orig;
                return new data.SQExistsExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitNot = function(orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return orig;
                return new data.SQNotExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitStartsWith = function(orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight) return orig;
                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitConstant = function(expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitDateSpan = function(orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return orig;
                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);
            };
            SQExprRewriter.prototype.visitDateAdd = function(orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg) return orig;
                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);
            };
            SQExprRewriter.prototype.visitNow = function(orig) {
                return orig;
            };
            return SQExprRewriter;
        }();
        data.SQExprRewriter = SQExprRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        function createSchemaChangeRewriters(changes) {
            debug.assertValue(changes, "changes");
            var rewriters = [];
            for (var i = 0, length = changes.length; i < length; i++) {
                var change = changes[i];
                if (change.entityRename) {
                    rewriters.push(new EntityRenameRewriter(change.entityRename));
                }
                if (change.propertyRename) {
                    rewriters.push(new PropertyRenameRewriter(change.propertyRename));
                }
            }
            return rewriters;
        }
        data.createSchemaChangeRewriters = createSchemaChangeRewriters;
        var EntityRenameRewriter = function(_super) {
            __extends(EntityRenameRewriter, _super);
            function EntityRenameRewriter(change) {
                debug.assertValue(change, "change");
                _super.call(this);
                this.change = change;
            }
            EntityRenameRewriter.prototype.visitEntity = function(expr) {
                var change = this.change;
                if (expr.schema === change.schema && expr.entity === change.before) return new data.SQEntityExpr(expr.schema, change.after, expr.variable);
                return expr;
            };
            return EntityRenameRewriter;
        }(data.SQExprRewriter);
        var PropertyRenameRewriter = function(_super) {
            __extends(PropertyRenameRewriter, _super);
            function PropertyRenameRewriter(change) {
                debug.assertValue(change, "change");
                _super.call(this);
                this.change = change;
            }
            PropertyRenameRewriter.prototype.visitColumnRef = function(expr) {
                var change = this.change;
                if (this.matches(change, expr)) return new data.SQColumnRefExpr(expr.source, change.after);
                return expr;
            };
            PropertyRenameRewriter.prototype.visitMeasureRef = function(expr) {
                var change = this.change;
                if (this.matches(change, expr)) return new data.SQMeasureRefExpr(expr.source, change.after);
                return expr;
            };
            PropertyRenameRewriter.prototype.matches = function(change, expr) {
                debug.assertValue(change, "change");
                debug.assertValue(expr, "expr");
                var fieldDef = expr.asFieldDef();
                debug.assertValue(fieldDef, "fieldDef");
                return fieldDef.schema === change.schema && fieldDef.entity === change.entity && expr.ref === change.before;
            };
            return PropertyRenameRewriter;
        }(data.SQExprRewriter);
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var StringExtensions = jsCommon.StringExtensions;
        var SQExpr = function() {
            function SQExpr() {}
            SQExpr.prototype.asFieldDef = function() {
                return data.SQExprConverter.asSQFieldDef(this);
            };
            SQExpr.equals = function(x, y, ignoreCase) {
                return SQExprEqualityVisitor.run(x, y, ignoreCase);
            };
            SQExpr.prototype.validate = function(schema) {
                var validator = new SQExprValidationVisitor(schema);
                this.accept(validator);
                return validator.errors;
            };
            SQExpr.prototype.accept = function(visitor, arg) {
                debug.assertFail("abstract method");
                return;
            };
            SQExpr.prototype.getMetadata = function(federatedSchema) {
                debug.assertValue(federatedSchema, "federatedSchema");
                var field = this.asFieldDef();
                if (!field) return;
                if (field.column || field.measure) return this.getMetadataForProperty(field, federatedSchema);
                return SQExpr.getMetadataForEntity(field, federatedSchema);
            };
            SQExpr.prototype.getDefaultAggregate = function(federatedSchema, forceAggregation) {
                if (forceAggregation === void 0) {
                    forceAggregation = false;
                }
                debug.assertValue(federatedSchema, "federatedSchema");
                var property = this.getConceptualProperty(federatedSchema);
                if (!property) return;
                var aggregate;
                if (property && property.kind === 0) {
                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;
                    if ((property.type.integer || property.type.numeric) && propertyDefaultAggregate !== 1) {
                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);
                        if (aggregate === undefined) aggregate = defaultAggregateForDataType(property.type);
                    }
                    if (aggregate === undefined && forceAggregation) {
                        aggregate = 5;
                    }
                }
                return aggregate;
            };
            SQExpr.prototype.getKeyColumns = function(schema) {
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this);
                if (!columnRefExpr) return;
                var property = this.getConceptualProperty(schema);
                if (!property) return;
                var keySQExprs = [];
                var keys = property.column ? property.column.keys : undefined;
                if (keys && keys.length > 0) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));
                    }
                } else keySQExprs.push(columnRefExpr);
                return keySQExprs;
            };
            SQExpr.prototype.getConceptualProperty = function(federatedSchema) {
                var field = this.asFieldDef();
                if (!field) return;
                return federatedSchema.schema(field.schema).findProperty(field.entity, field.column || field.measure);
            };
            SQExpr.prototype.getMetadataForProperty = function(field, federatedSchema) {
                debug.assertValue(field, "field");
                debug.assertValue(federatedSchema, "federatedSchema");
                var property = this.getConceptualProperty(federatedSchema);
                if (!property) return;
                var format = property.format;
                var type = property.type;
                if (field.aggregate === 2 || field.aggregate === 5) {
                    type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);
                    format = undefined;
                }
                return {
                    kind: property.kind === 1 || field.aggregate !== undefined ? 1 : 0,
                    type: type,
                    format: format,
                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,
                    aggregate: field.aggregate,
                    defaultAggregate: property.column ? property.column.defaultAggregate : null
                };
            };
            SQExpr.getMetadataForEntity = function(field, federatedSchema) {
                debug.assertValue(field, "field");
                debug.assertValue(federatedSchema, "federatedSchema");
                var entity = federatedSchema.schema(field.schema).entities.withName(field.entity);
                if (!entity) return;
                if (field.aggregate === 2 || field.aggregate === 5) {
                    return {
                        kind: 1,
                        type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),
                        format: undefined,
                        idOnEntityKey: false,
                        aggregate: field.aggregate
                    };
                }
            };
            return SQExpr;
        }();
        data.SQExpr = SQExpr;
        (function(FieldKind) {
            FieldKind[FieldKind["Column"] = 0] = "Column";
            FieldKind[FieldKind["Measure"] = 1] = "Measure";
        })(data.FieldKind || (data.FieldKind = {}));
        var FieldKind = data.FieldKind;
        function defaultAggregateForDataType(type) {
            if (type.integer || type.numeric) return 0;
            return 2;
        }
        data.defaultAggregateForDataType = defaultAggregateForDataType;
        function defaultAggregateToQueryAggregateFunction(aggregate) {
            switch (aggregate) {
              case 6:
                return 1;

              case 3:
                return 5;

              case 7:
                return 2;

              case 5:
                return 4;

              case 4:
                return 3;

              case 2:
                return 0;

              default:
                return;
            }
        }
        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;
        var SQEntityExpr = function(_super) {
            __extends(SQEntityExpr, _super);
            function SQEntityExpr(schema, entity, variable) {
                debug.assertValue(entity, "entity");
                _super.call(this);
                this.schema = schema;
                this.entity = entity;
                if (variable) this.variable = variable;
            }
            SQEntityExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitEntity(this, arg);
            };
            return SQEntityExpr;
        }(SQExpr);
        data.SQEntityExpr = SQEntityExpr;
        var SQPropRefExpr = function(_super) {
            __extends(SQPropRefExpr, _super);
            function SQPropRefExpr(source, ref) {
                debug.assertValue(source, "source");
                debug.assertValue(ref, "ref");
                _super.call(this);
                this.source = source;
                this.ref = ref;
            }
            return SQPropRefExpr;
        }(SQExpr);
        data.SQPropRefExpr = SQPropRefExpr;
        var SQColumnRefExpr = function(_super) {
            __extends(SQColumnRefExpr, _super);
            function SQColumnRefExpr(source, ref) {
                _super.call(this, source, ref);
            }
            SQColumnRefExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitColumnRef(this, arg);
            };
            return SQColumnRefExpr;
        }(SQPropRefExpr);
        data.SQColumnRefExpr = SQColumnRefExpr;
        var SQMeasureRefExpr = function(_super) {
            __extends(SQMeasureRefExpr, _super);
            function SQMeasureRefExpr(source, ref) {
                _super.call(this, source, ref);
            }
            SQMeasureRefExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitMeasureRef(this, arg);
            };
            return SQMeasureRefExpr;
        }(SQPropRefExpr);
        data.SQMeasureRefExpr = SQMeasureRefExpr;
        var SQAggregationExpr = function(_super) {
            __extends(SQAggregationExpr, _super);
            function SQAggregationExpr(arg, func) {
                debug.assertValue(arg, "arg");
                debug.assertValue(func, "func");
                _super.call(this);
                this.arg = arg;
                this.func = func;
            }
            SQAggregationExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitAggr(this, arg);
            };
            return SQAggregationExpr;
        }(SQExpr);
        data.SQAggregationExpr = SQAggregationExpr;
        var SQAndExpr = function(_super) {
            __extends(SQAndExpr, _super);
            function SQAndExpr(left, right) {
                debug.assertValue(left, "left");
                debug.assertValue(right, "right");
                _super.call(this);
                this.left = left;
                this.right = right;
            }
            SQAndExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitAnd(this, arg);
            };
            return SQAndExpr;
        }(SQExpr);
        data.SQAndExpr = SQAndExpr;
        var SQBetweenExpr = function(_super) {
            __extends(SQBetweenExpr, _super);
            function SQBetweenExpr(arg, lower, upper) {
                debug.assertValue(arg, "arg");
                debug.assertValue(lower, "lower");
                debug.assertValue(upper, "upper");
                _super.call(this);
                this.arg = arg;
                this.lower = lower;
                this.upper = upper;
            }
            SQBetweenExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitBetween(this, arg);
            };
            return SQBetweenExpr;
        }(SQExpr);
        data.SQBetweenExpr = SQBetweenExpr;
        var SQInExpr = function(_super) {
            __extends(SQInExpr, _super);
            function SQInExpr(args, values) {
                debug.assertValue(args, "args");
                debug.assertValue(values, "values");
                _super.call(this);
                this.args = args;
                this.values = values;
            }
            SQInExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitIn(this, arg);
            };
            return SQInExpr;
        }(SQExpr);
        data.SQInExpr = SQInExpr;
        var SQOrExpr = function(_super) {
            __extends(SQOrExpr, _super);
            function SQOrExpr(left, right) {
                debug.assertValue(left, "left");
                debug.assertValue(right, "right");
                _super.call(this);
                this.left = left;
                this.right = right;
            }
            SQOrExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitOr(this, arg);
            };
            return SQOrExpr;
        }(SQExpr);
        data.SQOrExpr = SQOrExpr;
        var SQCompareExpr = function(_super) {
            __extends(SQCompareExpr, _super);
            function SQCompareExpr(kind, left, right) {
                debug.assertValue(kind, "kind");
                debug.assertValue(left, "left");
                debug.assertValue(right, "right");
                _super.call(this);
                this.kind = kind;
                this.left = left;
                this.right = right;
            }
            SQCompareExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitCompare(this, arg);
            };
            return SQCompareExpr;
        }(SQExpr);
        data.SQCompareExpr = SQCompareExpr;
        var SQContainsExpr = function(_super) {
            __extends(SQContainsExpr, _super);
            function SQContainsExpr(left, right) {
                debug.assertValue(left, "left");
                debug.assertValue(right, "right");
                _super.call(this);
                this.left = left;
                this.right = right;
            }
            SQContainsExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitContains(this, arg);
            };
            return SQContainsExpr;
        }(SQExpr);
        data.SQContainsExpr = SQContainsExpr;
        var SQStartsWithExpr = function(_super) {
            __extends(SQStartsWithExpr, _super);
            function SQStartsWithExpr(left, right) {
                debug.assertValue(left, "left");
                debug.assertValue(right, "right");
                _super.call(this);
                this.left = left;
                this.right = right;
            }
            SQStartsWithExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitStartsWith(this, arg);
            };
            return SQStartsWithExpr;
        }(SQExpr);
        data.SQStartsWithExpr = SQStartsWithExpr;
        var SQExistsExpr = function(_super) {
            __extends(SQExistsExpr, _super);
            function SQExistsExpr(arg) {
                debug.assertValue(arg, "arg");
                _super.call(this);
                this.arg = arg;
            }
            SQExistsExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitExists(this, arg);
            };
            return SQExistsExpr;
        }(SQExpr);
        data.SQExistsExpr = SQExistsExpr;
        var SQNotExpr = function(_super) {
            __extends(SQNotExpr, _super);
            function SQNotExpr(arg) {
                debug.assertValue(arg, "arg");
                _super.call(this);
                this.arg = arg;
            }
            SQNotExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitNot(this, arg);
            };
            return SQNotExpr;
        }(SQExpr);
        data.SQNotExpr = SQNotExpr;
        var SQConstantExpr = function(_super) {
            __extends(SQConstantExpr, _super);
            function SQConstantExpr(type, value, valueEncoded) {
                debug.assertValue(type, "type");
                _super.call(this);
                this.type = type;
                this.value = value;
                this.valueEncoded = valueEncoded;
            }
            SQConstantExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitConstant(this, arg);
            };
            return SQConstantExpr;
        }(SQExpr);
        data.SQConstantExpr = SQConstantExpr;
        var SQDateSpanExpr = function(_super) {
            __extends(SQDateSpanExpr, _super);
            function SQDateSpanExpr(unit, arg) {
                debug.assertValue(unit, "unit");
                debug.assertValue(arg, "arg");
                _super.call(this);
                this.unit = unit;
                this.arg = arg;
            }
            SQDateSpanExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitDateSpan(this, arg);
            };
            return SQDateSpanExpr;
        }(SQExpr);
        data.SQDateSpanExpr = SQDateSpanExpr;
        var SQDateAddExpr = function(_super) {
            __extends(SQDateAddExpr, _super);
            function SQDateAddExpr(unit, amount, arg) {
                debug.assertValue(unit, "unit");
                debug.assertValue(amount, "amount");
                debug.assertValue(arg, "arg");
                _super.call(this);
                this.unit = unit;
                this.arg = arg;
                this.amount = amount;
            }
            SQDateAddExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitDateAdd(this, arg);
            };
            return SQDateAddExpr;
        }(SQExpr);
        data.SQDateAddExpr = SQDateAddExpr;
        var SQNowExpr = function(_super) {
            __extends(SQNowExpr, _super);
            function SQNowExpr() {
                _super.call(this);
            }
            SQNowExpr.prototype.accept = function(visitor, arg) {
                return visitor.visitNow(this, arg);
            };
            return SQNowExpr;
        }(SQExpr);
        data.SQNowExpr = SQNowExpr;
        var SQExprBuilder;
        (function(SQExprBuilder) {
            function entity(schema, entity, variable) {
                return new SQEntityExpr(schema, entity, variable);
            }
            SQExprBuilder.entity = entity;
            function columnRef(source, prop) {
                return new SQColumnRefExpr(source, prop);
            }
            SQExprBuilder.columnRef = columnRef;
            function measureRef(source, prop) {
                return new SQMeasureRefExpr(source, prop);
            }
            SQExprBuilder.measureRef = measureRef;
            function aggregate(source, aggregate) {
                return new SQAggregationExpr(source, aggregate);
            }
            SQExprBuilder.aggregate = aggregate;
            function and(left, right) {
                return new SQAndExpr(left, right);
            }
            SQExprBuilder.and = and;
            function between(arg, lower, upper) {
                return new SQBetweenExpr(arg, lower, upper);
            }
            SQExprBuilder.between = between;
            function inExpr(args, values) {
                return new SQInExpr(args, values);
            }
            SQExprBuilder.inExpr = inExpr;
            function or(left, right) {
                return new SQOrExpr(left, right);
            }
            SQExprBuilder.or = or;
            function compare(kind, left, right) {
                return new SQCompareExpr(kind, left, right);
            }
            SQExprBuilder.compare = compare;
            function contains(left, right) {
                return new SQContainsExpr(left, right);
            }
            SQExprBuilder.contains = contains;
            function exists(arg) {
                return new SQExistsExpr(arg);
            }
            SQExprBuilder.exists = exists;
            function equal(left, right) {
                return compare(0, left, right);
            }
            SQExprBuilder.equal = equal;
            function not(arg) {
                return new SQNotExpr(arg);
            }
            SQExprBuilder.not = not;
            function startsWith(left, right) {
                return new SQStartsWithExpr(left, right);
            }
            SQExprBuilder.startsWith = startsWith;
            function nullConstant() {
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(0), null, data.PrimitiveValueEncoding.nullEncoding());
            }
            SQExprBuilder.nullConstant = nullConstant;
            function now() {
                return new SQNowExpr();
            }
            SQExprBuilder.now = now;
            function boolean(value) {
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(5), value, data.PrimitiveValueEncoding.boolean(value));
            }
            SQExprBuilder.boolean = boolean;
            function dateAdd(unit, amount, arg) {
                return new SQDateAddExpr(unit, amount, arg);
            }
            SQExprBuilder.dateAdd = dateAdd;
            function dateTime(value, valueEncoded) {
                if (valueEncoded === undefined) valueEncoded = data.PrimitiveValueEncoding.dateTime(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);
            }
            SQExprBuilder.dateTime = dateTime;
            function dateSpan(unit, arg) {
                return new SQDateSpanExpr(unit, arg);
            }
            SQExprBuilder.dateSpan = dateSpan;
            function decimal(value, valueEncoded) {
                if (valueEncoded === undefined) valueEncoded = data.PrimitiveValueEncoding.decimal(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);
            }
            SQExprBuilder.decimal = decimal;
            function double(value, valueEncoded) {
                if (valueEncoded === undefined) valueEncoded = data.PrimitiveValueEncoding.double(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);
            }
            SQExprBuilder.double = double;
            function integer(value, valueEncoded) {
                if (valueEncoded === undefined) valueEncoded = data.PrimitiveValueEncoding.integer(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);
            }
            SQExprBuilder.integer = integer;
            function text(value, valueEncoded) {
                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), "Incorrect encoded value specified.");
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(1), value, valueEncoded || data.PrimitiveValueEncoding.text(value));
            }
            SQExprBuilder.text = text;
            function setAggregate(expr, aggregate) {
                return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);
            }
            SQExprBuilder.setAggregate = setAggregate;
            function removeAggregate(expr) {
                return SQExprRemoveAggregateRewriter.rewrite(expr);
            }
            SQExprBuilder.removeAggregate = removeAggregate;
            function removeEntityVariables(expr) {
                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);
            }
            SQExprBuilder.removeEntityVariables = removeEntityVariables;
            function createExprWithAggregate(expr, schema, aggregateNonNumericFields) {
                debug.assertValue(expr, "expr");
                debug.assertValue(expr, "schema");
                var defaultAggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);
                if (defaultAggregate !== undefined) expr = SQExprBuilder.aggregate(expr, defaultAggregate);
                return expr;
            }
            SQExprBuilder.createExprWithAggregate = createExprWithAggregate;
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        var SQExprInfo;
        (function(SQExprInfo) {
            function getAggregate(expr) {
                return SQExprAggregateInfoVisitor.getAggregate(expr);
            }
            SQExprInfo.getAggregate = getAggregate;
        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));
        var SQExprEqualityVisitor = function() {
            function SQExprEqualityVisitor(ignoreCase) {
                this.ignoreCase = ignoreCase;
            }
            SQExprEqualityVisitor.run = function(x, y, ignoreCase) {
                x = x || null;
                y = y || null;
                if (x === y) return true;
                if (!x !== !y) return false;
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                if (ignoreCase) return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);
                return x.accept(SQExprEqualityVisitor.instance, y);
            };
            SQExprEqualityVisitor.prototype.visitColumnRef = function(expr, comparand) {
                return comparand instanceof SQColumnRefExpr && expr.ref === comparand.ref && this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitMeasureRef = function(expr, comparand) {
                return comparand instanceof SQMeasureRefExpr && expr.ref === comparand.ref && this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitAggr = function(expr, comparand) {
                return comparand instanceof SQAggregationExpr && expr.func === comparand.func && this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitBetween = function(expr, comparand) {
                return comparand instanceof SQBetweenExpr && this.equals(expr.arg, comparand.arg) && this.equals(expr.lower, comparand.lower) && this.equals(expr.upper, comparand.upper);
            };
            SQExprEqualityVisitor.prototype.visitIn = function(expr, comparand) {
                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args)) return false;
                var values = expr.values, compareValues = comparand.values;
                if (values.length !== compareValues.length) return false;
                for (var i = 0, len = values.length; i < len; i++) {
                    if (!this.equalsAll(values[i], compareValues[i])) return false;
                }
                return true;
            };
            SQExprEqualityVisitor.prototype.visitEntity = function(expr, comparand) {
                return comparand instanceof SQEntityExpr && expr.schema === comparand.schema && expr.entity === comparand.entity && this.optionalEqual(expr.variable, comparand.variable);
            };
            SQExprEqualityVisitor.prototype.visitAnd = function(expr, comparand) {
                return comparand instanceof SQAndExpr && this.equals(expr.left, comparand.left) && this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitOr = function(expr, comparand) {
                return comparand instanceof SQOrExpr && this.equals(expr.left, comparand.left) && this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitCompare = function(expr, comparand) {
                return comparand instanceof SQCompareExpr && expr.kind === comparand.kind && this.equals(expr.left, comparand.left) && this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitContains = function(expr, comparand) {
                return comparand instanceof SQContainsExpr && this.equals(expr.left, comparand.left) && this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitDateSpan = function(expr, comparand) {
                return comparand instanceof SQDateSpanExpr && expr.unit === comparand.unit && this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitDateAdd = function(expr, comparand) {
                return comparand instanceof SQDateAddExpr && expr.unit === comparand.unit && expr.amount === comparand.amount && this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitExists = function(expr, comparand) {
                return comparand instanceof SQExistsExpr && this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNot = function(expr, comparand) {
                return comparand instanceof SQNotExpr && this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNow = function(expr, comparand) {
                return comparand instanceof SQNowExpr;
            };
            SQExprEqualityVisitor.prototype.visitStartsWith = function(expr, comparand) {
                return comparand instanceof SQStartsWithExpr && this.equals(expr.left, comparand.left) && this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitConstant = function(expr, comparand) {
                if (comparand instanceof SQConstantExpr && expr.type === comparand.type) return expr.type.text && this.ignoreCase ? StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) : expr.valueEncoded === comparand.valueEncoded;
                return false;
            };
            SQExprEqualityVisitor.prototype.optionalEqual = function(x, y) {
                if (x && y) return x === y;
                return true;
            };
            SQExprEqualityVisitor.prototype.equals = function(x, y) {
                return x.accept(this, y);
            };
            SQExprEqualityVisitor.prototype.equalsAll = function(x, y) {
                var len = x.length;
                if (len !== y.length) return false;
                for (var i = 0; i < len; i++) {
                    if (!this.equals(x[i], y[i])) return false;
                }
                return true;
            };
            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(false);
            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);
            return SQExprEqualityVisitor;
        }();
        var SQExprRootRewriter = function(_super) {
            __extends(SQExprRootRewriter, _super);
            function SQExprRootRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRootRewriter.prototype.visitDefault = function(expr) {
                return expr;
            };
            return SQExprRootRewriter;
        }(data.DefaultSQExprVisitor);
        (function(SQExprValidationError) {
            SQExprValidationError[SQExprValidationError["invalidAggregateFunction"] = 0] = "invalidAggregateFunction";
            SQExprValidationError[SQExprValidationError["invalidSchemaReference"] = 1] = "invalidSchemaReference";
            SQExprValidationError[SQExprValidationError["invalidEntityReference"] = 2] = "invalidEntityReference";
            SQExprValidationError[SQExprValidationError["invalidColumnReference"] = 3] = "invalidColumnReference";
            SQExprValidationError[SQExprValidationError["invalidMeasureReference"] = 4] = "invalidMeasureReference";
            SQExprValidationError[SQExprValidationError["invalidLeftOperandType"] = 5] = "invalidLeftOperandType";
            SQExprValidationError[SQExprValidationError["invalidRightOperandType"] = 6] = "invalidRightOperandType";
        })(data.SQExprValidationError || (data.SQExprValidationError = {}));
        var SQExprValidationError = data.SQExprValidationError;
        var SQExprValidationVisitor = function(_super) {
            __extends(SQExprValidationVisitor, _super);
            function SQExprValidationVisitor(schema) {
                debug.assertValue(schema, "schema");
                _super.call(this);
                this.schema = schema;
            }
            SQExprValidationVisitor.prototype.visitColumnRef = function(expr) {
                var fieldDef = expr.asFieldDef();
                if (fieldDef) {
                    var entity = this.validateEntity(fieldDef.schema, fieldDef.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldDef.column);
                        if (!prop || prop.kind !== 0) this.register(3);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitMeasureRef = function(expr) {
                var fieldDef = expr.asFieldDef();
                if (fieldDef) {
                    var entity = this.validateEntity(fieldDef.schema, fieldDef.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldDef.measure);
                        if (!prop || prop.kind !== 1) this.register(4);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitAggr = function(expr) {
                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(aggregateExpr.arg);
                if (columnRefExpr) {
                    var supportedFuncs = data.SQExprUtils.getSupportedAggregates(columnRefExpr, false, this.schema);
                    if (supportedFuncs.indexOf(expr.func) < 0) this.register(0);
                }
                return aggregateExpr;
            };
            SQExprValidationVisitor.prototype.visitEntity = function(expr) {
                this.validateEntity(expr.schema, expr.entity);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitContains = function(expr) {
                var left = expr.left;
                var right = expr.right;
                if (!(left instanceof SQColumnRefExpr)) this.register(5); else if (!(right instanceof SQConstantExpr) || !right.type.text) this.register(6);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitStartsWith = function(expr) {
                var left = expr.left;
                var right = expr.right;
                if (!(left instanceof SQColumnRefExpr)) this.register(5); else if (!(right instanceof SQConstantExpr) || !right.type.text) this.register(6);
                return expr;
            };
            SQExprValidationVisitor.prototype.validateEntity = function(schemaName, entityName) {
                var schema = this.schema.schema(schemaName);
                if (schema) {
                    var entity = schema.entities.withName(entityName);
                    if (entity) return entity;
                    this.register(2);
                } else {
                    this.register(1);
                }
            };
            SQExprValidationVisitor.prototype.register = function(error) {
                if (!this.errors) this.errors = [];
                this.errors.push(error);
            };
            return SQExprValidationVisitor;
        }(data.SQExprRewriter);
        var SQExprAggregateInfoVisitor = function(_super) {
            __extends(SQExprAggregateInfoVisitor, _super);
            function SQExprAggregateInfoVisitor() {
                _super.apply(this, arguments);
            }
            SQExprAggregateInfoVisitor.prototype.visitAggr = function(expr) {
                return expr.func;
            };
            SQExprAggregateInfoVisitor.prototype.visitDefault = function(expr) {
                return;
            };
            SQExprAggregateInfoVisitor.getAggregate = function(expr) {
                var visitor = new SQExprAggregateInfoVisitor();
                return expr.accept(visitor);
            };
            return SQExprAggregateInfoVisitor;
        }(data.DefaultSQExprVisitor);
        var SQExprColumnRefInfoVisitor = function(_super) {
            __extends(SQExprColumnRefInfoVisitor, _super);
            function SQExprColumnRefInfoVisitor() {
                _super.apply(this, arguments);
            }
            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function(expr) {
                return expr;
            };
            SQExprColumnRefInfoVisitor.prototype.visitDefault = function(expr) {
                return;
            };
            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function(expr) {
                var visitor = new SQExprColumnRefInfoVisitor();
                return expr.accept(visitor);
            };
            return SQExprColumnRefInfoVisitor;
        }(data.DefaultSQExprVisitor);
        var SQExprChangeAggregateRewriter = function(_super) {
            __extends(SQExprChangeAggregateRewriter, _super);
            function SQExprChangeAggregateRewriter(func) {
                debug.assertValue(func, "func");
                _super.call(this);
                this.func = func;
            }
            SQExprChangeAggregateRewriter.prototype.visitAggr = function(expr) {
                if (expr.func === this.func) return expr;
                return new SQAggregationExpr(expr.arg, this.func);
            };
            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function(expr) {
                return new SQAggregationExpr(expr, this.func);
            };
            SQExprChangeAggregateRewriter.rewrite = function(expr, func) {
                debug.assertValue(expr, "expr");
                debug.assertValue(func, "func");
                var rewriter = new SQExprChangeAggregateRewriter(func);
                return expr.accept(rewriter);
            };
            return SQExprChangeAggregateRewriter;
        }(SQExprRootRewriter);
        var SQExprRemoveAggregateRewriter = function(_super) {
            __extends(SQExprRemoveAggregateRewriter, _super);
            function SQExprRemoveAggregateRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRemoveAggregateRewriter.prototype.visitAggr = function(expr) {
                return expr.arg;
            };
            SQExprRemoveAggregateRewriter.rewrite = function(expr) {
                debug.assertValue(expr, "expr");
                return expr.accept(SQExprRemoveAggregateRewriter.instance);
            };
            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();
            return SQExprRemoveAggregateRewriter;
        }(SQExprRootRewriter);
        var SQExprRemoveEntityVariablesRewriter = function(_super) {
            __extends(SQExprRemoveEntityVariablesRewriter, _super);
            function SQExprRemoveEntityVariablesRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function(expr) {
                if (expr.variable) return SQExprBuilder.entity(expr.schema, expr.entity);
                return expr;
            };
            SQExprRemoveEntityVariablesRewriter.rewrite = function(expr) {
                debug.assertValue(expr, "expr");
                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);
            };
            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();
            return SQExprRemoveEntityVariablesRewriter;
        }(data.SQExprRewriter);
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var StringExtensions = jsCommon.StringExtensions;
        var SQExprUtils;
        (function(SQExprUtils) {
            function getSupportedAggregates(expr, isGroupingOnly, schema) {
                var emptyList = [];
                var metadata = getMetadataForUnderlyingType(expr, schema);
                if (!metadata) {
                    return emptyList;
                }
                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey, Agg = data.QueryAggregateFunction;
                if (!valueType) return emptyList;
                if (fieldKind === 1) return emptyList;
                if (isGroupingOnly) return emptyList;
                if (valueType.numeric || valueType.integer) {
                    if (metadata.defaultAggregate === 1) {
                        return [ 2, 5 ];
                    } else {
                        return [ 0, 1, 3, 4, 2, 5 ];
                    }
                } else if (valueType.text || valueType.bool || valueType.dateTime) {
                    if (isPropertyIdentity) return [ 5 ];
                    return [ 2, 5 ];
                }
                debug.assertFail("Unexpected expr or role.");
                return emptyList;
            }
            SQExprUtils.getSupportedAggregates = getSupportedAggregates;
            function indexOfExpr(items, searchElement) {
                debug.assertValue(items, "items");
                debug.assertValue(searchElement, "searchElement");
                for (var i = 0, len = items.length; i < len; i++) {
                    if (data.SQExpr.equals(items[i], searchElement)) return i;
                }
                return -1;
            }
            SQExprUtils.indexOfExpr = indexOfExpr;
            function sequenceEqual(x, y) {
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                var len = x.length;
                if (len !== y.length) return false;
                for (var i = 0; i < len; i++) {
                    if (!data.SQExpr.equals(x[i], y[i])) return false;
                }
                return true;
            }
            SQExprUtils.sequenceEqual = sequenceEqual;
            function uniqueName(namedItems, expr) {
                debug.assertValue(namedItems, "namedItems");
                var names = {};
                for (var i = 0, len = namedItems.length; i < len; i++) names[namedItems[i].name] = true;
                return StringExtensions.findUniqueName(names, defaultName(expr));
            }
            SQExprUtils.uniqueName = uniqueName;
            function defaultName(expr, fallback) {
                if (fallback === void 0) {
                    fallback = "select";
                }
                if (!expr) return fallback;
                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);
            }
            SQExprUtils.defaultName = defaultName;
            function getMetadataForUnderlyingType(expr, schema) {
                var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);
                if (!metadata) metadata = expr.getMetadata(schema);
                return metadata;
            }
            var SQExprDefaultNameGenerator = function(_super) {
                __extends(SQExprDefaultNameGenerator, _super);
                function SQExprDefaultNameGenerator() {
                    _super.apply(this, arguments);
                }
                SQExprDefaultNameGenerator.prototype.visitEntity = function(expr) {
                    return expr.entity;
                };
                SQExprDefaultNameGenerator.prototype.visitColumnRef = function(expr) {
                    return expr.source.accept(this) + "." + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function(expr, fallback) {
                    return expr.source.accept(this) + "." + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitAggr = function(expr, fallback) {
                    return data.QueryAggregateFunction[expr.func] + "(" + expr.arg.accept(this) + ")";
                };
                SQExprDefaultNameGenerator.prototype.visitDefault = function(expr, fallback) {
                    return fallback || "expr";
                };
                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();
                return SQExprDefaultNameGenerator;
            }(data.DefaultSQExprVisitorWithArg);
        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var SemanticQueryRewriter = function() {
            function SemanticQueryRewriter(exprRewriter) {
                this.exprRewriter = exprRewriter;
            }
            SemanticQueryRewriter.prototype.rewriteFrom = function(fromValue) {
                var fromContents = {};
                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();
                for (var i = 0, len = originalFromKeys.length; i < len; i++) {
                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);
                    fromContents[keyName] = {
                        schema: updatedEntityExpr.schema,
                        entity: updatedEntityExpr.entity
                    };
                }
                return new data.SQFrom(fromContents);
            };
            SemanticQueryRewriter.prototype.rewriteSelect = function(selectItems, from) {
                debug.assertValue(from, "from");
                if (!selectItems || selectItems.length === 0) return;
                var select = [];
                for (var i = 0, len = selectItems.length; i < len; i++) {
                    var item = selectItems[i];
                    select.push({
                        name: item.name,
                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)
                    });
                }
                return select;
            };
            SemanticQueryRewriter.prototype.rewriteOrderBy = function(orderByItems, from) {
                debug.assertValue(from, "from");
                if (!orderByItems || orderByItems.length === 0) return;
                var orderBy = [];
                for (var i = 0, len = orderByItems.length; i < len; i++) {
                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);
                    orderBy.push({
                        direction: item.direction,
                        expr: updatedExpr
                    });
                }
                return orderBy;
            };
            SemanticQueryRewriter.prototype.rewriteWhere = function(whereItems, from) {
                var _this = this;
                debug.assertValue(from, "from");
                if (!whereItems || whereItems.length === 0) return;
                var where = [];
                for (var i = 0, len = whereItems.length; i < len; i++) {
                    var originalWhere = whereItems[i];
                    var updatedWhere = {
                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from)
                    };
                    if (originalWhere.target) updatedWhere.target = originalWhere.target.map(function(e) {
                        return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from);
                    });
                    where.push(updatedWhere);
                }
                return where;
            };
            return SemanticQueryRewriter;
        }();
        data.SemanticQueryRewriter = SemanticQueryRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var SemanticQuery = function() {
            function SemanticQuery(from, where, orderBy, select) {
                debug.assertValue(from, "from");
                debug.assertValue(select, "select");
                this.fromValue = from;
                this.whereItems = where;
                this.orderByItems = orderBy;
                this.selectItems = select;
            }
            SemanticQuery.create = function() {
                if (!SemanticQuery.empty) SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, []);
                return SemanticQuery.empty;
            };
            SemanticQuery.createWithTrimmedFrom = function(from, where, orderBy, select) {
                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());
                if (where) {
                    for (var i = 0, len = where.length; i < len; i++) {
                        var filter = where[i];
                        filter.condition.accept(unreferencedKeyFinder);
                        var filterTarget = filter.target;
                        if (filterTarget) {
                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++) if (filterTarget[j]) filterTarget[j].accept(unreferencedKeyFinder);
                        }
                    }
                }
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++) orderBy[i].expr.accept(unreferencedKeyFinder);
                }
                for (var i = 0, len = select.length; i < len; i++) select[i].expr.accept(unreferencedKeyFinder);
                var unreferencedKeys = unreferencedKeyFinder.result();
                for (var i = 0, len = unreferencedKeys.length; i < len; i++) from.remove(unreferencedKeys[i]);
                return new SemanticQuery(from, where, orderBy, select);
            };
            SemanticQuery.prototype.from = function() {
                return this.fromValue.clone();
            };
            SemanticQuery.prototype.select = function(values) {
                if (arguments.length === 0) return this.getSelect();
                return this.setSelect(values);
            };
            SemanticQuery.prototype.getSelect = function() {
                return ArrayExtensions.extendWithName(this.selectItems.map(function(s) {
                    return {
                        name: s.name,
                        expr: s.expr
                    };
                }));
            };
            SemanticQuery.prototype.setSelect = function(values) {
                var selectItems = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    selectItems.push({
                        name: value.name,
                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)
                    });
                }
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems);
            };
            SemanticQuery.prototype.removeSelect = function(expr) {
                debug.assertValue(expr, "expr");
                var originalItems = this.selectItems, selectItems = [];
                for (var i = 0, len = originalItems.length; i < len; i++) {
                    var originalExpr = originalItems[i];
                    if (data.SQExpr.equals(originalExpr.expr, expr)) continue;
                    selectItems.push(originalExpr);
                }
                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems);
            };
            SemanticQuery.prototype.removeOrderBy = function(expr) {
                var sorts = this.orderBy();
                for (var i = sorts.length - 1; i >= 0; i--) {
                    if (data.SQExpr.equals(sorts[i].expr, expr)) sorts.splice(i, 1);
                }
                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems);
            };
            SemanticQuery.prototype.selectNameOf = function(expr) {
                var index = data.SQExprUtils.indexOfExpr(this.selectItems.map(function(s) {
                    return s.expr;
                }), expr);
                if (index >= 0) return this.selectItems[index].name;
            };
            SemanticQuery.prototype.setSelectAt = function(index, expr) {
                debug.assertValue(expr, "expr");
                if (index >= this.selectItems.length) return;
                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;
                select[index] = {
                    name: originalName,
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)
                };
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select);
            };
            SemanticQuery.prototype.addSelect = function(expr) {
                debug.assertValue(expr, "expr");
                var selectItems = this.select(), from = this.fromValue.clone();
                selectItems.push({
                    name: data.SQExprUtils.uniqueName(selectItems, expr),
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)
                });
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems);
            };
            SemanticQuery.prototype.orderBy = function(values) {
                if (arguments.length === 0) return this.getOrderBy();
                return this.setOrderBy(values);
            };
            SemanticQuery.prototype.getOrderBy = function() {
                var result = [];
                var orderBy = this.orderByItems;
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++) {
                        var clause = orderBy[i];
                        result.push({
                            expr: clause.expr,
                            direction: clause.direction
                        });
                    }
                }
                return result;
            };
            SemanticQuery.prototype.setOrderBy = function(values) {
                debug.assertValue(values, "values");
                var updatedOrderBy = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var clause = values[i];
                    updatedOrderBy.push({
                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),
                        direction: clause.direction
                    });
                }
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems);
            };
            SemanticQuery.prototype.where = function(values) {
                if (arguments.length === 0) return this.getWhere();
                return this.setWhere(values);
            };
            SemanticQuery.prototype.getWhere = function() {
                var result = [];
                var whereItems = this.whereItems;
                if (whereItems) {
                    for (var i = 0, len = whereItems.length; i < len; i++) result.push(whereItems[i]);
                }
                return result;
            };
            SemanticQuery.prototype.setWhere = function(values) {
                debug.assertValue(values, "values");
                var updatedWhere = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var filter = values[i];
                    var updatedFilter = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from)
                    };
                    var filterTarget = filter.target;
                    if (filterTarget) {
                        updatedFilter.target = [];
                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++) if (filterTarget[j]) {
                            var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);
                            updatedFilter.target.push(updatedTarget);
                        }
                    }
                    updatedWhere.push(updatedFilter);
                }
                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems);
            };
            SemanticQuery.prototype.addWhere = function(filter) {
                debug.assertValue(filter, "filter");
                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();
                for (var i = 0, len = incomingWhere.length; i < len; i++) {
                    var clause = incomingWhere[i];
                    var updatedClause = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from)
                    };
                    if (clause.target) updatedClause.target = clause.target.map(function(t) {
                        return SQExprRewriterWithSourceRenames.rewrite(t, from);
                    });
                    updatedWhere.push(updatedClause);
                }
                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems);
            };
            SemanticQuery.prototype.rewrite = function(exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                var from = rewriter.rewriteFrom(this.fromValue);
                var where = rewriter.rewriteWhere(this.whereItems, from);
                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);
                var select = rewriter.rewriteSelect(this.selectItems, from);
                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select);
            };
            return SemanticQuery;
        }();
        data.SemanticQuery = SemanticQuery;
        var SemanticFilter = function() {
            function SemanticFilter(from, where) {
                debug.assertValue(from, "from");
                debug.assertValue(where, "where");
                this.fromValue = from;
                this.whereItems = where;
            }
            SemanticFilter.fromSQExpr = function(contract) {
                debug.assertValue(contract, "contract");
                var from = new SQFrom();
                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);
                var where = [ {
                    condition: rewrittenContract
                } ];
                return new SemanticFilter(from, where);
            };
            SemanticFilter.prototype.from = function() {
                return this.fromValue.clone();
            };
            SemanticFilter.prototype.conditions = function() {
                var expressions = [];
                var where = this.whereItems;
                for (var i = 0, len = where.length; i < len; i++) {
                    var filter = where[i];
                    expressions.push(filter.condition);
                }
                return expressions;
            };
            SemanticFilter.prototype.where = function() {
                var result = [];
                var whereItems = this.whereItems;
                for (var i = 0, len = whereItems.length; i < len; i++) result.push(whereItems[i]);
                return result;
            };
            SemanticFilter.prototype.rewrite = function(exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                var from = rewriter.rewriteFrom(this.fromValue);
                var where = rewriter.rewriteWhere(this.whereItems, from);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.merge = function(filters) {
                if (ArrayExtensions.isUndefinedOrEmpty(filters)) return null;
                if (filters.length === 1) return filters[0];
                var firstFilter = filters[0];
                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);
                for (var i = 1, len = filters.length; i < len; i++) SemanticFilter.applyFilter(filters[i], from, where);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.applyFilter = function(filter, from, where) {
                debug.assertValue(filter, "filter");
                debug.assertValue(from, "from");
                debug.assertValue(where, "where");
                var filterWhereItems = filter.whereItems;
                for (var i = 0; i < filterWhereItems.length; i++) {
                    var filterWhereItem = filterWhereItems[i];
                    var updatedWhereItem = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from)
                    };
                    if (filterWhereItem.target) updatedWhereItem.target = filterWhereItem.target.map(function(e) {
                        return SQExprRewriterWithSourceRenames.rewrite(e, from);
                    });
                    where.push(updatedWhereItem);
                }
            };
            return SemanticFilter;
        }();
        data.SemanticFilter = SemanticFilter;
        var SQFrom = function() {
            function SQFrom(items) {
                this.items = items || {};
            }
            SQFrom.prototype.keys = function() {
                return Object.keys(this.items);
            };
            SQFrom.prototype.entity = function(key) {
                return this.items[key];
            };
            SQFrom.prototype.ensureEntity = function(entity, desiredVariableName) {
                debug.assertValue(entity, "entity");
                var keys = this.keys();
                for (var i = 0, len = keys.length; i < len; i++) {
                    var key = keys[i], item = this.items[key];
                    if (item && entity.entity === item.entity && entity.schema === item.schema) return {
                        name: key
                    };
                }
                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;
                while (this.items[uniqueName]) {
                    uniqueName = candidateName + i++;
                }
                this.items[uniqueName] = entity;
                return {
                    name: uniqueName,
                    "new": true
                };
            };
            SQFrom.prototype.remove = function(key) {
                delete this.items[key];
            };
            SQFrom.prototype.candidateName = function(ref) {
                debug.assertValue(ref, "ref");
                var idx = ref.lastIndexOf(".");
                if (idx >= 0 && idx !== ref.length - 1) ref = ref.substr(idx + 1);
                return ref.substring(0, 1).toLowerCase();
            };
            SQFrom.prototype.clone = function() {
                var cloned = new SQFrom();
                $.extend(cloned.items, this.items);
                return cloned;
            };
            return SQFrom;
        }();
        data.SQFrom = SQFrom;
        var SQExprRewriterWithSourceRenames = function(_super) {
            __extends(SQExprRewriterWithSourceRenames, _super);
            function SQExprRewriterWithSourceRenames(renames) {
                debug.assertValue(renames, "renames");
                _super.call(this);
                this.renames = renames;
            }
            SQExprRewriterWithSourceRenames.prototype.visitEntity = function(expr) {
                var updatedName = this.renames[expr.entity];
                if (updatedName) return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);
                return _super.prototype.visitEntity.call(this, expr);
            };
            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function(filter) {
                debug.assertValue(filter, "filter");
                var updatedTargets = undefined;
                if (filter.target) updatedTargets = this.rewriteArray(filter.target);
                var updatedCondition = filter.condition.accept(this);
                if (filter.condition === updatedCondition && filter.target === updatedTargets) return filter;
                var updatedFilter = {
                    condition: updatedCondition
                };
                if (updatedTargets) updatedFilter.target = updatedTargets;
                return updatedFilter;
            };
            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function(exprs) {
                debug.assertValue(exprs, "exprs");
                var updatedExprs;
                for (var i = 0, len = exprs.length; i < len; i++) {
                    var expr = exprs[i], rewrittenExpr = expr.accept(this);
                    if (expr !== rewrittenExpr && !updatedExprs) updatedExprs = ArrayExtensions.take(exprs, i);
                    if (updatedExprs) updatedExprs.push(rewrittenExpr);
                }
                return updatedExprs || exprs;
            };
            SQExprRewriterWithSourceRenames.rewrite = function(expr, from) {
                debug.assertValue(expr, "expr");
                debug.assertValue(from, "from");
                var renames = QuerySourceRenameDetector.run(expr, from);
                var rewriter = new SQExprRewriterWithSourceRenames(renames);
                return expr.accept(rewriter);
            };
            return SQExprRewriterWithSourceRenames;
        }(data.SQExprRewriter);
        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;
        var QuerySourceRenameDetector = function(_super) {
            __extends(QuerySourceRenameDetector, _super);
            function QuerySourceRenameDetector(from) {
                debug.assertValue(from, "from");
                _super.call(this);
                this.from = from;
                this.renames = {};
            }
            QuerySourceRenameDetector.run = function(expr, from) {
                var detector = new QuerySourceRenameDetector(from);
                expr.accept(detector);
                return detector.renames;
            };
            QuerySourceRenameDetector.prototype.visitEntity = function(expr) {
                var existingEntity = this.from.entity(expr.variable);
                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity) return;
                var actualEntity = this.from.ensureEntity({
                    schema: expr.schema,
                    entity: expr.entity
                }, expr.variable);
                this.renames[expr.entity] = actualEntity.name;
            };
            return QuerySourceRenameDetector;
        }(data.DefaultSQExprVisitorWithTraversal);
        var UnreferencedKeyFinder = function(_super) {
            __extends(UnreferencedKeyFinder, _super);
            function UnreferencedKeyFinder(keys) {
                debug.assertValue(keys, "keys");
                _super.call(this);
                this.keys = keys;
            }
            UnreferencedKeyFinder.prototype.visitEntity = function(expr) {
                var index = this.keys.indexOf(expr.variable);
                if (index >= 0) this.keys.splice(index, 1);
            };
            UnreferencedKeyFinder.prototype.result = function() {
                return this.keys;
            };
            return UnreferencedKeyFinder;
        }(data.DefaultSQExprVisitorWithTraversal);
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var SemanticQueryBuilder = function() {
            function SemanticQueryBuilder(from) {
                debug.assertValue(from, "from");
                this.from = from;
                this.selectItems = [];
            }
            SemanticQueryBuilder.prototype.addWhere = function(filter) {
                debug.assertValue(filter, "filter");
                if (!this.whereItems) this.whereItems = [];
                this.whereItems.push(filter);
            };
            SemanticQueryBuilder.prototype.addOrderBy = function(sort) {
                debug.assertValue(sort, "sort");
                if (!this.orderByItems) this.orderByItems = [];
                this.orderByItems.push(sort);
            };
            SemanticQueryBuilder.prototype.addSelect = function(select) {
                debug.assertValue(select, "select");
                this.selectItems.push(select);
            };
            SemanticQueryBuilder.prototype.toQuery = function() {
                return new data.SemanticQuery(this.from, this.whereItems, this.orderByItems, this.selectItems);
            };
            SemanticQueryBuilder.prototype.toFilter = function() {
                debug.assert(!this.orderByItems && this.selectItems.length === 0, "toFilter must not have orderBy/select specified.");
                if (this.from && this.whereItems) return new data.SemanticFilter(this.from, this.whereItems);
            };
            return SemanticQueryBuilder;
        }();
        data.SemanticQueryBuilder = SemanticQueryBuilder;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(_data) {
        var JsonComparer = jsCommon.JsonComparer;
        var TimerPromiseFactory = jsCommon.TimerPromiseFactory;
        function createDataProxy(promiseFactory, dataProviderFactory) {
            return new DataProxy(promiseFactory, dataProviderFactory);
        }
        _data.createDataProxy = createDataProxy;
        function createSingleExecutableDataProxy(dataProxy, promiseFactory, timerFactory) {
            return new SingleExecutionDataProxy(dataProxy, promiseFactory, timerFactory);
        }
        _data.createSingleExecutableDataProxy = createSingleExecutableDataProxy;
        var DataProxy = function() {
            function DataProxy(promiseFactory, dataProviderFactory) {
                this.providerHost = {
                    promiseFactory: function() {
                        return promiseFactory;
                    }
                };
                this.dataProviderFactory = dataProviderFactory;
                this.dataProviders = {};
            }
            DataProxy.prototype.execute = function(options) {
                debug.assertValue(options, "options");
                var provider = this.getProvider(options.type);
                return provider.execute(options.query);
            };
            DataProxy.prototype.getProvider = function(type) {
                var provider = this.dataProviders[type];
                if (provider) return provider;
                var plugin = this.dataProviderFactory.getPlugin(type);
                if (plugin) return this.dataProviders[type] = new DataProviderWrapper(plugin, this.providerHost.promiseFactory(), this.providerHost);
            };
            DataProxy.prototype.stopCommunication = function(providerType) {
                var provider = this.getProvider(providerType);
                provider.stopCommunication();
            };
            DataProxy.prototype.resumeCommunication = function(providerType) {
                var provider = this.getProvider(providerType);
                provider.resumeCommunication();
            };
            DataProxy.prototype.clearCache = function(providerType) {
                var provider = this.getProvider(providerType);
                provider.clearCache();
            };
            DataProxy.prototype.rewriteCacheEntries = function(providerType, rewriter) {
                var provider = this.getProvider(providerType);
                provider.rewriteCacheEntries(rewriter);
            };
            return DataProxy;
        }();
        var SingleExecutionDataProxy = function() {
            function SingleExecutionDataProxy(proxy, promiseFactory, timerFactory) {
                this.proxy = proxy;
                this.promiseFactory = promiseFactory;
                this.timerFactory = timerFactory || TimerPromiseFactory.instance;
            }
            SingleExecutionDataProxy.prototype.execute = function(options) {
                var _this = this;
                var previousExecution = this.lastExecute;
                if (previousExecution && previousExecution.promise.pending()) {
                    if (JsonComparer.equals(options, previousExecution.query)) return previousExecution.promise;
                    this.lastExecute.promise.reject(new powerbi.IgnorableClientError());
                }
                var deferred = this.promiseFactory.defer();
                var promise = powerbi.RejectablePromise2(deferred);
                var currentExecution = this.lastExecute = {
                    query: options,
                    deferred: deferred,
                    promise: promise
                };
                if (!this.queuedExecution) {
                    this.queuedExecution = true;
                    this.timerFactory.create(0).done(function() {
                        _this.queuedExecution = false;
                        var execution = _this.lastExecute;
                        var proxyPromise = _this.proxy.execute(execution.query);
                        proxyPromise.then(function(result) {
                            return execution.deferred.resolve(result);
                        }, function(reason) {
                            return execution.deferred.reject(reason);
                        });
                        execution.promise.catch(function() {
                            return proxyPromise.reject();
                        });
                    });
                }
                promise.finally(function() {
                    if (currentExecution === _this.lastExecute) _this.lastExecute = undefined;
                });
                return promise;
            };
            return SingleExecutionDataProxy;
        }();
        var DataProviderWrapper = function() {
            function DataProviderWrapper(plugin, promiseFactory, host) {
                debug.assertValue(plugin, "plugin");
                debug.assertValue(promiseFactory, "promiseFactory");
                debug.assertValue(host, "host");
                this.name = plugin.name;
                this.promiseFactory = promiseFactory;
                this.provider = plugin.create(host);
            }
            DataProviderWrapper.prototype.execute = function(options) {
                var _this = this;
                debug.assertValue(options, "options");
                var dataViewDeferred = this.promiseFactory.defer();
                var provider = this.provider;
                if (provider.execute) {
                    var providerExecution = provider.execute(options);
                    dataViewDeferred.promise.catch(function() {
                        return providerExecution.reject(new _data.InvalidDataResponseClientError());
                    });
                    providerExecution.then(function(data) {
                        if (data) {
                            var transformed = _this.transform(data);
                            if (transformed.error) {
                                dataViewDeferred.reject(transformed.error);
                            }
                            dataViewDeferred.resolve({
                                dataProviderResult: transformed,
                                dataViewSource: {
                                    data: data
                                }
                            });
                        } else {
                            dataViewDeferred.reject(new _data.InvalidDataFormatClientError());
                        }
                    }, function(error) {
                        dataViewDeferred.reject(error);
                    });
                    var promise = powerbi.RejectablePromise2(dataViewDeferred);
                    promise.catch(function(error) {
                        return providerExecution.reject(error || new _data.InvalidDataResponseClientError());
                    });
                    return promise;
                } else {
                    if (options.command) dataViewDeferred.resolve({
                        dataProviderResult: this.transform(options.command)
                    }); else dataViewDeferred.reject();
                }
                return powerbi.RejectablePromise2(dataViewDeferred);
            };
            DataProviderWrapper.prototype.stopCommunication = function() {
                var provider = this.provider;
                if (provider.stopCommunication) provider.stopCommunication();
            };
            DataProviderWrapper.prototype.resumeCommunication = function() {
                var provider = this.provider;
                if (provider.resumeCommunication) provider.resumeCommunication();
            };
            DataProviderWrapper.prototype.clearCache = function() {
                var provider = this.provider;
                if (provider.clearCache) provider.clearCache();
            };
            DataProviderWrapper.prototype.rewriteCacheEntries = function(rewriter) {
                var provider = this.provider;
                if (provider.rewriteCacheEntries) provider.rewriteCacheEntries(rewriter);
            };
            DataProviderWrapper.prototype.transform = function(data) {
                var provider = this.provider;
                if (provider.transform) return provider.transform(data);
                var defaultDataView = {
                    metadata: {
                        columns: []
                    }
                };
                defaultDataView[this.name] = data;
                return {
                    dataView: defaultDataView
                };
            };
            return DataProviderWrapper;
        }();
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var StringExtensions = jsCommon.StringExtensions;
    var Formatting = jsCommon.Formatting;
    var FormattingEncoder;
    (function(FormattingEncoder) {
        function preserveEscaped(format, specialChars) {
            var length = specialChars.length;
            for (var i = 0; i < length; i++) {
                var oldText = "\\" + specialChars[i];
                var newText = String.fromCharCode(57344 + i);
                format = StringExtensions.replaceAll(format, oldText, newText);
            }
            return format;
        }
        FormattingEncoder.preserveEscaped = preserveEscaped;
        function restoreEscaped(format, specialChars) {
            var length = specialChars.length;
            for (var i = 0; i < length; i++) {
                var oldText = String.fromCharCode(57344 + i);
                var newText = specialChars[i];
                format = StringExtensions.replaceAll(format, oldText, newText);
            }
            return StringExtensions.replaceAll(format, "\\", "");
        }
        FormattingEncoder.restoreEscaped = restoreEscaped;
        function preserveLiterals(format, literals) {
            format = StringExtensions.replaceAll(format, '"', "'");
            for (var i = 0; ;i++) {
                var fromIndex = format.indexOf("'");
                if (fromIndex < 0) {
                    break;
                }
                var toIndex = format.indexOf("'", fromIndex + 1);
                if (toIndex < 0) {
                    break;
                }
                var literal = format.substring(fromIndex, toIndex + 1);
                literals.push(literal.substring(1, toIndex - fromIndex));
                var token = String.fromCharCode(57600 + i);
                format = format.replace(literal, token);
            }
            return format;
        }
        FormattingEncoder.preserveLiterals = preserveLiterals;
        function restoreLiterals(format, literals) {
            var count = literals.length;
            for (var i = 0; i < count; i++) {
                var token = String.fromCharCode(57600 + i);
                var literal = literals[i];
                format = format.replace(token, literal);
            }
            return format;
        }
        FormattingEncoder.restoreLiterals = restoreLiterals;
    })(FormattingEncoder || (FormattingEncoder = {}));
    var FormattingService = function() {
        function FormattingService() {}
        FormattingService.prototype.formatValue = function(value, format, culture) {
            if (value === undefined || value === null) {
                return "";
            }
            var gculture = this.getCulture(culture);
            if (DateTimeFormat.canFormat(value)) {
                return DateTimeFormat.format(value, format, gculture);
            } else if (NumberFormat.canFormat(value)) {
                return NumberFormat.format(value, format, gculture);
            } else {
                return value.toString();
            }
        };
        FormattingService.prototype.format = function(formatWithIndexedTokens, args, culture) {
            var _this = this;
            if (!formatWithIndexedTokens) {
                return "";
            }
            var result = formatWithIndexedTokens.replace(/({{)|(}})|{(\d+[^}]*)}/g, function(match, left, right, argToken) {
                if (left) {
                    return "{";
                } else if (right) {
                    return "}";
                } else {
                    var parts = argToken.split(":");
                    var argIndex = parseInt(parts[0], 10);
                    var argFormat = parts[1];
                    return _this.formatValue(args[argIndex], argFormat, culture);
                }
                return "";
            });
            return result;
        };
        FormattingService.prototype.isStandardNumberFormat = function(format) {
            return NumberFormat.isStandardFormat(format);
        };
        FormattingService.prototype.formatNumberWithCustomOverride = function(value, format, nonScientificOverrideFormat, culture) {
            var gculture = this.getCulture(culture);
            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);
        };
        FormattingService.prototype.dateFormatString = function(unit) {
            return this._dateTimeScaleFormatInfo.getFormatString(unit);
        };
        FormattingService.prototype.setCurrentCulture = function(cultureSelector) {
            if (this._currentCultureSelector !== cultureSelector) {
                this._currentCulture = this.getCulture(cultureSelector);
                this._currentCultureSelector = cultureSelector;
                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);
            }
        };
        FormattingService.prototype.getCulture = function(cultureSelector) {
            if (cultureSelector == null) {
                if (this._currentCulture == null) {
                    this.initialize();
                }
                return this._currentCulture;
            } else {
                var culture = Globalize.findClosestCulture(cultureSelector);
                if (!culture) culture = Globalize.culture("en-US");
                return culture;
            }
        };
        FormattingService.prototype.initialize = function() {
            var cultureName = this.getUrlParam("language") || window["cultureInfo"] || window.navigator.userLanguage || window.navigator["language"] || Globalize.culture().name;
            this.setCurrentCulture(cultureName);
            var calendarName = this.getUrlParam("calendar");
            if (calendarName) {
                var culture = this._currentCulture;
                var c = culture.calendars[calendarName];
                if (c) {
                    culture.calendar = c;
                }
            }
        };
        FormattingService.prototype.getUrlParam = function(name) {
            var param = window.location.search.match(RegExp("[?&]" + name + "=([^&]*)"));
            return param ? param[1] : undefined;
        };
        return FormattingService;
    }();
    var DateTimeFormat;
    (function(DateTimeFormat) {
        var _currentCachedFormat;
        var _currentCachedProcessedFormat;
        function canFormat(value) {
            var result = value instanceof Date;
            return result;
        }
        DateTimeFormat.canFormat = canFormat;
        function format(value, format, culture) {
            format = format || "G";
            var isStandard = format.length === 1;
            try {
                if (isStandard) {
                    return formatDateStandard(value, format, culture);
                } else {
                    return formatDateCustom(value, format, culture);
                }
            } catch (e) {
                return formatDateStandard(value, "G", culture);
            }
        }
        DateTimeFormat.format = format;
        function formatDateStandard(value, format, culture) {
            var patterns = culture.calendar.patterns;
            ensurePatterns(culture.calendar);
            var output = Formatting.findDateFormat(value, format, culture.name);
            if (output.format.length === 1) format = patterns[output.format]; else format = output.format;
            culture = Globalize.culture("en-US");
            return Globalize.format(output.value, format, culture);
        }
        function formatDateCustom(value, format, culture) {
            var result;
            var literals = [];
            format = FormattingEncoder.preserveEscaped(format, "\\dfFghHKmstyz:/%'\"");
            format = FormattingEncoder.preserveLiterals(format, literals);
            format = StringExtensions.replaceAll(format, '"', "'");
            if (format.indexOf("F") > -1) {
                format = StringExtensions.replaceAll(format, "FFFF", "FFF");
                var milliseconds = value.getMilliseconds();
                if (milliseconds % 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FFF", "fff");
                }
                format = StringExtensions.replaceAll(format, "FFF", "FF");
                if (milliseconds % 100 / 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FF", "ff");
                }
                format = StringExtensions.replaceAll(format, "FF", "F");
                if (milliseconds % 1e3 / 100 >= 1) {
                    format = StringExtensions.replaceAll(format, "F", "f");
                }
                format = StringExtensions.replaceAll(format, "F", "");
                if (format === "" || format === "%") return "";
            }
            format = processCustomDateTimeFormat(format);
            result = Globalize.format(value, format, culture);
            result = localize(result, culture.calendar);
            result = FormattingEncoder.restoreLiterals(result, literals);
            result = FormattingEncoder.restoreEscaped(result, "\\dfFghHKmstyz:/%'\"");
            return result;
        }
        function processCustomDateTimeFormat(format) {
            if (format === _currentCachedFormat) {
                return _currentCachedProcessedFormat;
            }
            _currentCachedFormat = format;
            format = Formatting.fixDateTimeFormat(format);
            _currentCachedProcessedFormat = format;
            return format;
        }
        function localize(value, dictionary) {
            var timeSeparator = dictionary[":"];
            if (timeSeparator === ":") {
                return value;
            }
            var result = "";
            var count = value.length;
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                  case ":":
                    result += timeSeparator;
                    break;

                  default:
                    result += char;
                    break;
                }
            }
            return result;
        }
        function ensurePatterns(calendar) {
            var patterns = calendar.patterns;
            if (patterns["g"] === undefined) {
                patterns["g"] = patterns["f"].replace(patterns["D"], patterns["d"]);
                patterns["G"] = patterns["F"].replace(patterns["D"], patterns["d"]);
            }
        }
    })(DateTimeFormat || (DateTimeFormat = {}));
    var NumberFormat;
    (function(NumberFormat) {
        var _lastCustomFormatMeta;
        function canFormat(value) {
            var result = typeof value === "number";
            return result;
        }
        NumberFormat.canFormat = canFormat;
        function isStandardFormat(format) {
            debug.assertValue(format, "format");
            var standardFormatRegex = /^[a-z]\d{0,2}$/gi;
            return standardFormatRegex.test(format);
        }
        NumberFormat.isStandardFormat = isStandardFormat;
        function format(value, format, culture) {
            format = format || "G";
            try {
                if (isStandardFormat(format)) return formatNumberStandard(value, format, culture);
                return formatNumberCustom(value, format, culture);
            } catch (e) {
                return Globalize.format(value, undefined, culture);
            }
        }
        NumberFormat.format = format;
        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {
            debug.assertValue(value, "value");
            debug.assertValue(format, "format");
            debug.assertValue(nonScientificOverrideFormat, "nonScientificOverrideFormat");
            debug.assertValue(culture, "culture");
            debug.assert(!isStandardFormat(format), "Standard format");
            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);
        }
        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;
        function formatNumberStandard(value, format, culture) {
            var result;
            var precision = format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined;
            var numberFormatInfo = culture.numberFormat;
            var formatChar = format.charAt(0);
            switch (formatChar) {
              case "e":
              case "E":
                if (precision === undefined) {
                    precision = 6;
                }
                var mantissaDecimalDigits = StringExtensions.repeat("0", precision);
                format = "0." + mantissaDecimalDigits + formatChar + "+000";
                result = formatNumberCustom(value, format, culture);
                break;

              case "f":
              case "F":
                result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);
                result = localize(result, numberFormatInfo);
                break;

              case "g":
              case "G":
                var abs = Math.abs(value);
                if (abs === 0 || 1e-4 <= abs && abs < 1e15) {
                    result = precision !== undefined ? value.toPrecision(precision) : value.toString();
                } else {
                    result = precision !== undefined ? value.toExponential(precision) : value.toExponential();
                    result = result.replace("e", "E");
                }
                result = localize(result, numberFormatInfo);
                break;

              case "r":
              case "R":
                result = value.toString();
                result = localize(result, numberFormatInfo);
                break;

              case "x":
              case "X":
                result = value.toString(16);
                if (formatChar === "X") {
                    result = result.toUpperCase();
                }
                if (precision !== undefined) {
                    var actualPrecision = result.length;
                    var isNegative = value < 0;
                    if (isNegative) {
                        actualPrecision--;
                    }
                    var paddingZerosCount = precision - actualPrecision;
                    if (paddingZerosCount > 0) {
                        var paddingZeros = StringExtensions.repeat("0", paddingZerosCount);
                    }
                    if (isNegative) {
                        result = "-" + paddingZeros + result.substr(1);
                    } else {
                        result = paddingZeros + result;
                    }
                }
                result = localize(result, numberFormatInfo);
                break;

              default:
                result = Globalize.format(value, format, culture);
            }
            return result;
        }
        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {
            var result;
            var numberFormatInfo = culture.numberFormat;
            if (isFinite(value)) {
                var signSpecificFormats = format.split(";");
                if (signSpecificFormats.length > 1) {
                    var negativeFormat = format;
                    var positiveFormat = format;
                    var zeroFormat = format;
                    if (signSpecificFormats.length === 2) {
                        positiveFormat = zeroFormat = signSpecificFormats[0];
                        negativeFormat = signSpecificFormats[1];
                    } else {
                        positiveFormat = signSpecificFormats[0];
                        negativeFormat = signSpecificFormats[1];
                        zeroFormat = signSpecificFormats[2];
                    }
                    if (value > 0) {
                        format = positiveFormat;
                    } else if (value === 0) {
                        format = zeroFormat;
                    } else {
                        format = negativeFormat;
                    }
                    value = Math.abs(value);
                }
                var formatMeta = getCustomFormatMetadata(format);
                if (formatMeta.hasEscapes) {
                    format = FormattingEncoder.preserveEscaped(format, "\\0#.,%‰");
                }
                var literals = [];
                if (formatMeta.hasQuotes) {
                    format = FormattingEncoder.preserveLiterals(format, literals);
                }
                if (formatMeta.hasE && !nonScientificOverrideFormat) {
                    var scientificMatch = /e[+-]*0+/gi.exec(format);
                    if (scientificMatch) {
                        var formatM = format.substr(0, scientificMatch.index);
                        var formatE = format.substr(scientificMatch.index + scientificMatch[0].indexOf("0"));
                        var precision = getCustomFormatPrecision(formatM, formatMeta);
                        var scale = getCustomFormatScale(formatM, formatMeta);
                        if (scale !== 1) {
                            value = value * scale;
                        }
                        var s = value.toExponential(precision);
                        var indexOfE = s.indexOf("e");
                        var mantissa = s.substr(0, indexOfE);
                        var exp = s.substr(indexOfE + 1);
                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);
                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);
                        if (resultE.charAt(0) === "+" && scientificMatch[0].charAt(1) !== "+") {
                            resultE = resultE.substr(1);
                        }
                        var e = scientificMatch[0].charAt(0);
                        result = resultM + e + resultE;
                    }
                }
                if (result === undefined) {
                    var valueFormatted;
                    if (nonScientificOverrideFormat) {
                        valueFormatted = powerbi.formattingService.format(nonScientificOverrideFormat, [ value ], culture.name);
                    } else {
                        var precision = getCustomFormatPrecision(format, formatMeta);
                        var scale = getCustomFormatScale(format, formatMeta);
                        if (scale !== 1) {
                            value = value * scale;
                        }
                        valueFormatted = toNonScientific(value, precision);
                    }
                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, !!nonScientificOverrideFormat);
                }
                if (formatMeta.hasQuotes) {
                    result = FormattingEncoder.restoreLiterals(result, literals);
                }
                if (formatMeta.hasEscapes) {
                    result = FormattingEncoder.restoreEscaped(result, "\\0#.,%‰");
                }
                _lastCustomFormatMeta = formatMeta;
            } else {
                return Globalize.format(value, undefined);
            }
            return result;
        }
        function toNonScientific(value, precision) {
            var result = "";
            var precisionZeros = 0;
            if (precision > 16) {
                precisionZeros = precision - 16;
                precision = 16;
            }
            var digitsBeforeDecimalPoint = powerbi.Double.log10(Math.abs(value));
            if (digitsBeforeDecimalPoint < 16) {
                if (digitsBeforeDecimalPoint > 0) {
                    var maxPrecision = 16 - digitsBeforeDecimalPoint;
                    if (precision > maxPrecision) {
                        precisionZeros += precision - maxPrecision;
                        precision = maxPrecision;
                    }
                }
                result = value.toFixed(precision);
            } else if (digitsBeforeDecimalPoint === 16) {
                result = value.toFixed(0);
                precisionZeros += precision;
                if (precisionZeros > 0) {
                    result += ".";
                }
            } else {
                result = value.toExponential(15);
                var indexOfE = result.indexOf("e");
                if (indexOfE > 0) {
                    var indexOfDot = result.indexOf(".");
                    var mantissa = result.substr(0, indexOfE);
                    var exp = result.substr(indexOfE + 1);
                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);
                    result = mantissa.replace(".", "") + StringExtensions.repeat("0", powerZeros);
                    if (precision > 0) {
                        result = result + "." + StringExtensions.repeat("0", precision);
                    }
                }
            }
            if (precisionZeros > 0) {
                result = result + StringExtensions.repeat("0", precisionZeros);
            }
            return result;
        }
        function getCustomFormatMetadata(format) {
            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {
                return _lastCustomFormatMeta;
            }
            var result = {
                format: format,
                hasEscapes: false,
                hasQuotes: false,
                hasE: false,
                hasCommas: false,
                hasDots: false,
                hasPercent: false,
                hasPermile: false,
                precision: -1,
                scale: -1
            };
            var length = format.length;
            for (var i = 0; i < length; i++) {
                var c = format.charAt(i);
                switch (c) {
                  case "\\":
                    result.hasEscapes = true;
                    break;

                  case "'":
                  case '"':
                    result.hasQuotes = true;
                    break;

                  case "e":
                  case "E":
                    result.hasE = true;
                    break;

                  case ",":
                    result.hasCommas = true;
                    break;

                  case ".":
                    result.hasDots = true;
                    break;

                  case "%":
                    result.hasPercent = true;
                    break;

                  case "‰":
                    result.hasPermile = true;
                    break;
                }
            }
            return result;
        }
        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;
        function getCustomFormatPrecision(format, formatMeta) {
            if (formatMeta.precision > -1) {
                return formatMeta.precision;
            }
            var result = 0;
            if (formatMeta.hasDots) {
                var dotIndex = format.indexOf(".");
                if (dotIndex > -1) {
                    var count = format.length;
                    for (var i = dotIndex; i < count; i++) {
                        var char = format.charAt(i);
                        if (char === "#" || char === "0") result++;
                    }
                    result = Math.min(19, result);
                }
            }
            formatMeta.precision = result;
            return result;
        }
        function getCustomFormatScale(format, formatMeta) {
            if (formatMeta.scale > -1) {
                return formatMeta.scale;
            }
            var result = 1;
            if (formatMeta.hasPercent && format.indexOf("%") > -1) {
                result = result * 100;
            }
            if (formatMeta.hasPermile && format.indexOf("‰") > -1) {
                result = result * 1e3;
            }
            if (formatMeta.hasCommas) {
                var dotIndex = format.indexOf(".");
                if (dotIndex === -1) {
                    dotIndex = format.length;
                }
                for (var i = dotIndex - 1; i > -1; i--) {
                    var char = format.charAt(i);
                    if (char === ",") {
                        result = result / 1e3;
                    } else {
                        break;
                    }
                }
            }
            formatMeta.scale = result;
            return result;
        }
        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, suppressModifyValue) {
            var formatParts = format.split(".", 2);
            if (formatParts.length === 2) {
                var wholeFormat = formatParts[0];
                var fractionFormat = formatParts[1];
                var valueParts = value.split(".", 2);
                var wholeValue = valueParts[0];
                var fractionValue = valueParts.length === 2 ? valueParts[1].replace(/0+$/, "") : "";
                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);
                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);
                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === "") return wholeFormattedValue + fractionFormattedValue.value;
                return wholeFormattedValue + numberFormatInfo["."] + fractionFormattedValue.value;
            }
            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);
        }
        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {
            var groupSymbolIndex = format.indexOf(",");
            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf("0"), format.lastIndexOf("#")) && numberFormatInfo[","];
            var groupDigitCount = 0;
            var groupIndex = 0;
            var groupSizes = numberFormatInfo.groupSizes || [ 3 ];
            var groupSize = groupSizes[0];
            var groupSeparator = numberFormatInfo[","];
            var sign = "";
            var firstChar = value.charAt(0);
            if (firstChar === "+" || firstChar === "-") {
                sign = numberFormatInfo[firstChar];
                value = value.substr(1);
            }
            var isZero = value === "0";
            var result = "";
            var leftBuffer = "";
            var vi = value.length - 1;
            var fmtOnly = true;
            for (var fi = format.length - 1; fi > -1; fi--) {
                var formatChar = format.charAt(fi);
                switch (formatChar) {
                  case "0":
                  case "#":
                    fmtOnly = false;
                    if (leftBuffer !== "") {
                        result = leftBuffer + result;
                        leftBuffer = "";
                    }
                    if (!suppressModifyValue) {
                        if (vi > -1 || formatChar === "0") {
                            if (enableGroups) {
                                if (groupDigitCount === groupSize) {
                                    result = groupSeparator + result;
                                    groupIndex++;
                                    if (groupIndex < groupSizes.length) {
                                        groupSize = groupSizes[groupIndex];
                                    }
                                    groupDigitCount = 1;
                                } else {
                                    groupDigitCount++;
                                }
                            }
                        }
                        if (vi > -1) {
                            if (isZero && formatChar === "#") {} else {
                                result = value.charAt(vi) + result;
                            }
                            vi--;
                        } else if (formatChar !== "#") {
                            result = formatChar + result;
                        }
                    }
                    break;

                  case ",":
                    break;

                  default:
                    leftBuffer = formatChar + leftBuffer;
                    break;
                }
            }
            if (!suppressModifyValue) {
                if (vi > -1 && result !== "") {
                    if (enableGroups) {
                        while (vi > -1) {
                            if (groupDigitCount === groupSize) {
                                result = groupSeparator + result;
                                groupIndex++;
                                if (groupIndex < groupSizes.length) {
                                    groupSize = groupSizes[groupIndex];
                                }
                                groupDigitCount = 1;
                            } else {
                                groupDigitCount++;
                            }
                            result = value.charAt(vi) + result;
                            vi--;
                        }
                    } else {
                        result = value.substr(0, vi + 1) + result;
                    }
                }
                return sign + leftBuffer + result;
            }
            if (fmtOnly) return sign + leftBuffer;
            return sign + leftBuffer + value;
        }
        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {
            var vi = 0;
            var fCount = format.length;
            var vCount = value.length;
            if (suppressModifyValue) {
                debug.assert(fCount > 0, "Empty formatting string");
                if (format.charAt(fCount - 1) !== "0" && format.charAt(fCount - 1) !== "#") return {
                    value: value + format.charAt(fCount - 1),
                    fmtOnly: value === ""
                };
                return {
                    value: value,
                    fmtOnly: value === ""
                };
            }
            var result = "", fmtOnly = true;
            for (var fi = 0; fi < fCount; fi++) {
                var formatChar = format.charAt(fi);
                if (vi < vCount) {
                    switch (formatChar) {
                      case "0":
                      case "#":
                        result += value[vi++];
                        fmtOnly = false;
                        break;

                      default:
                        result += formatChar;
                    }
                } else {
                    if (formatChar !== "#") {
                        result += formatChar;
                        fmtOnly = fmtOnly && formatChar !== "0";
                    }
                }
            }
            return {
                value: result,
                fmtOnly: fmtOnly
            };
        }
        function localize(value, dictionary) {
            var plus = dictionary["+"];
            var minus = dictionary["-"];
            var dot = dictionary["."];
            var comma = dictionary[","];
            if (plus === "+" && minus === "-" && dot === "." && comma === ",") {
                return value;
            }
            var count = value.length;
            var result = "";
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                  case "+":
                    result = result + plus;
                    break;

                  case "-":
                    result = result + minus;
                    break;

                  case ".":
                    result = result + dot;
                    break;

                  case ",":
                    result = result + comma;
                    break;

                  default:
                    result = result + char;
                    break;
                }
            }
            return result;
        }
    })(NumberFormat = powerbi.NumberFormat || (powerbi.NumberFormat = {}));
    var DateTimeScaleFormatInfo = function() {
        function DateTimeScaleFormatInfo(culture) {
            var calendar = culture.calendar;
            var patterns = calendar.patterns;
            var monthAbbreviations = calendar["months"]["namesAbbr"];
            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];
            var yearMonthPattern = patterns["Y"];
            var monthDayPattern = patterns["M"];
            var fullPattern = patterns["f"];
            var longTimePattern = patterns["T"];
            var shortTimePattern = patterns["t"];
            var separator = fullPattern.indexOf(",") > -1 ? ", " : " ";
            var hasYearSymbol = yearMonthPattern.indexOf("yyyy'") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === "'";
            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : "yyyy";
            var yearPos = fullPattern.indexOf("yy");
            var monthPos = fullPattern.indexOf("MMMM");
            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? yearPos > monthPos ? "MMM yyyy" : "yyyy MMM" : yearMonthPattern;
            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace("MMMM", "MMM") : monthDayPattern;
            var minutePos = fullPattern.indexOf("mm");
            var pmPos = fullPattern.indexOf("tt");
            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(":mm ", "") : shortTimePattern;
            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;
            this.MinutePattern = shortTimePattern;
            this.SecondPattern = longTimePattern;
            this.MillisecondPattern = longTimePattern.replace("ss", "ss.fff");
            switch (culture.name) {
              case "fi-FI":
                this.DayPattern = this.DayPattern.replace("'ta'", "");
                this.HourPattern = this.HourPattern.replace("'ta'", "");
                break;
            }
        }
        DateTimeScaleFormatInfo.prototype.getFormatString = function(unit) {
            switch (unit) {
              case 0:
                return this.YearPattern;

              case 1:
                return this.MonthPattern;

              case 2:
              case 3:
                return this.DayPattern;

              case 4:
                return this.HourPattern;

              case 5:
                return this.MinutePattern;

              case 6:
                return this.SecondPattern;

              case 7:
                return this.MillisecondPattern;
            }
            debug.assertFail("Unexpected unit: " + unit);
        };
        return DateTimeScaleFormatInfo;
    }();
    powerbi.formattingService = new FormattingService();
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var services;
        (function(services) {
            var wireContracts;
            (function(wireContracts) {})(wireContracts = services.wireContracts || (services.wireContracts = {}));
            var DataViewObjectSerializer;
            (function(DataViewObjectSerializer) {
                function deserializeObjects(input, descriptors) {
                    debug.assertAnyValue(input, "input");
                    if (!input || !descriptors) return;
                    var result = {};
                    for (var objectName in input) {
                        var descriptor = descriptors[objectName];
                        if (!descriptor) continue;
                        var objectEntries = input[objectName], resultEntries = result[objectName] = [];
                        for (var i = 0, len = objectEntries.length; i < len; i++) resultEntries.push(deserializeObject(objectEntries[i], descriptor));
                    }
                    return result;
                }
                DataViewObjectSerializer.deserializeObjects = deserializeObjects;
                function deserializeObject(input, descriptor) {
                    debug.assertAnyValue(input, "input");
                    if (!input) return;
                    var result = {
                        properties: deserializeObjectProperties(input.properties, descriptor.properties)
                    };
                    var selector = deserializeSelector(input.selector);
                    if (selector) result.selector = selector;
                    return result;
                }
                function deserializeSelector(input) {
                    debug.assertAnyValue(input, "input");
                    if (!input) return;
                    var result = {};
                    if (input.data) result.data = input.data.map(function(v) {
                        return deserializeDataRepetitionSelector(v);
                    });
                    if (input.metadata) result.metadata = input.metadata;
                    if (input.id) result.id = input.id;
                    return result;
                }
                function deserializeDataRepetitionSelector(input) {
                    debug.assertValue(input, "input");
                    if (input.scopeId) return data.createDataViewScopeIdentity(services.SemanticQuerySerializer.deserializeExpr(input.scopeId));
                    if (input.wildcard) return data.DataViewScopeWildcard.fromExprs(input.wildcard.map(services.SemanticQuerySerializer.deserializeExpr));
                }
                function deserializeObjectProperties(input, descriptors) {
                    debug.assertAnyValue(input, "input");
                    if (!input) return;
                    var result = {};
                    for (var propertyName in input) {
                        var propertyValue = deserializeObjectProperty(input[propertyName], descriptors[propertyName]);
                        if (propertyValue !== undefined) result[propertyName] = propertyValue;
                    }
                    return result;
                }
                function deserializeObjectProperty(input, descriptor) {
                    debug.assertAnyValue(input, "input");
                    debug.assertAnyValue(descriptor, "descriptor");
                    if (!descriptor) return;
                    var type = parseType(descriptor.type);
                    if (type.value) return deserializePropertyValueType(input, type.value);
                    return deserializePropertyStructuralType(input, type.structural);
                }
                function deserializePropertyValueType(input, type) {
                    debug.assertValue(type, "type");
                    if (type.primitiveType !== undefined) {
                        if (input.expr) return services.SemanticQuerySerializer.deserializeExpr(input.expr);
                    }
                }
                function deserializePropertyStructuralType(input, type) {
                    debug.assertValue(type, "type");
                    if (type.fill && type.fill.solid && type.fill.solid.color && input) {
                        var fillDefn = input;
                        if (fillDefn.solid && fillDefn.solid.color) {
                            return {
                                solid: {
                                    color: deserializePropertyValueType(fillDefn.solid.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                                }
                            };
                        }
                        return;
                    }
                    if (type.fillRule) {
                        var fillRuleDefinition = input;
                        var deserializedFillRuleDefinition = getParsedFillRule(fillRuleDefinition, deserializePropertyValueType);
                        if (deserializedFillRuleDefinition) {
                            return deserializedFillRuleDefinition;
                        }
                    }
                    if (type.filter && input && input.filter) return services.SemanticQuerySerializer.deserializeFilter(input.filter);
                    return input;
                }
                function serializeObjects(contract, descriptors) {
                    debug.assertAnyValue(contract, "contract");
                    debug.assertAnyValue(descriptors, "descriptors");
                    if (!contract || !descriptors) return;
                    var result = {};
                    for (var objectName in contract) {
                        var descriptor = descriptors[objectName];
                        if (!descriptor) continue;
                        var objectEntries = contract[objectName], resultEntries = result[objectName] = [];
                        for (var i = 0, len = objectEntries.length; i < len; i++) resultEntries.push(serializeObject(objectEntries[i], descriptor));
                    }
                    return result;
                }
                DataViewObjectSerializer.serializeObjects = serializeObjects;
                function serializeObject(contract, descriptor) {
                    debug.assertAnyValue(contract, "contract");
                    debug.assertValue(descriptor, "descriptor");
                    if (!contract) return;
                    var properties = serializeObjectProperties(contract.properties, descriptor.properties);
                    if (!properties) return;
                    var result = {
                        properties: properties
                    };
                    var selector = serializeSelector(contract.selector);
                    if (selector) result.selector = selector;
                    return result;
                }
                function serializeSelector(contract) {
                    debug.assertAnyValue(contract, "contract");
                    if (!contract) return;
                    var result = {};
                    if (contract.data) result.data = contract.data.map(function(v) {
                        return serializeDataRepetitionSelector(v);
                    });
                    if (contract.metadata) result.metadata = contract.metadata;
                    if (contract.id) result.id = contract.id;
                    return result;
                }
                function serializeDataRepetitionSelector(contract) {
                    debug.assertValue(contract, "contract");
                    var scopeId = contract;
                    if (scopeId.expr) {
                        return {
                            scopeId: services.SemanticQuerySerializer.serializeExpr(scopeId.expr)
                        };
                    }
                    var wildcard = contract;
                    if (wildcard.exprs) {
                        return {
                            wildcard: wildcard.exprs.map(services.SemanticQuerySerializer.serializeExpr)
                        };
                    }
                }
                function serializeObjectProperties(contract, descriptors) {
                    debug.assertAnyValue(contract, "contract");
                    debug.assertValue(descriptors, "descriptors");
                    if (!contract) return;
                    var result = {};
                    for (var propertyName in contract) {
                        var propertyValue = serializeObjectProperty(contract[propertyName], descriptors[propertyName]);
                        if (propertyValue !== undefined) result[propertyName] = propertyValue;
                    }
                    return result;
                }
                function serializeObjectProperty(contract, descriptor) {
                    debug.assertAnyValue(contract, "contract");
                    debug.assertAnyValue(descriptor, "descriptor");
                    if (!descriptor) return;
                    var type = parseType(descriptor.type);
                    if (type.value) return serializePropertyValueType(contract, type.value);
                    return serializePropertyStructuralType(contract, type.structural);
                }
                function serializePropertyValueType(contract, type) {
                    debug.assertValue(type, "type");
                    if (type.primitiveType !== undefined) {
                        if (contract instanceof data.SQExpr) {
                            return {
                                expr: services.SemanticQuerySerializer.serializeExpr(contract)
                            };
                        }
                    }
                }
                function serializePropertyStructuralType(contract, type) {
                    debug.assertValue(type, "type");
                    if (type.fill && type.fill.solid && type.fill.solid.color && contract) {
                        var fillDefn = contract;
                        return {
                            solid: {
                                color: serializePropertyValueType(fillDefn.solid.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            }
                        };
                    }
                    if (type.fillRule) {
                        var fillRuleDefinition = contract;
                        var serializedFillRuleDefinition = getParsedFillRule(fillRuleDefinition, serializePropertyValueType);
                        if (serializedFillRuleDefinition) {
                            return serializedFillRuleDefinition;
                        }
                    }
                    if (type.filter && contract) return {
                        filter: services.SemanticQuerySerializer.serializeFilter(contract)
                    };
                    return contract;
                }
                function parseType(typeDescriptor) {
                    debug.assertValue(typeDescriptor, "typeDescriptor");
                    var valueType = powerbi.ValueType.fromDescriptor(typeDescriptor);
                    if (valueType.primitiveType !== 0) return {
                        value: valueType
                    };
                    return {
                        structural: typeDescriptor
                    };
                }
                function getParsedFillRule(fillRuleDefn, serializationDelegate) {
                    if (fillRuleDefn.linearGradient2) {
                        var gradient = fillRuleDefn.linearGradient2;
                        var linearGradient2 = {
                            max: {
                                color: serializationDelegate(gradient.max.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            },
                            min: {
                                color: serializationDelegate(gradient.min.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            }
                        };
                        if (gradient.max.value) {
                            linearGradient2.max.value = serializationDelegate(gradient.max.value, powerbi.ValueType.fromPrimitiveTypeAndCategory(3));
                        }
                        if (gradient.min.value) {
                            linearGradient2.min.value = serializationDelegate(gradient.min.value, powerbi.ValueType.fromPrimitiveTypeAndCategory(3));
                        }
                        return {
                            linearGradient2: linearGradient2
                        };
                    }
                    if (fillRuleDefn.linearGradient3) {
                        var gradient = fillRuleDefn.linearGradient3;
                        var linearGradient3 = {
                            max: {
                                color: serializationDelegate(gradient.max.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            },
                            mid: {
                                color: serializationDelegate(gradient.mid.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            },
                            min: {
                                color: serializationDelegate(gradient.min.color, powerbi.ValueType.fromPrimitiveTypeAndCategory(1))
                            }
                        };
                        if (gradient.max.value) {
                            linearGradient3.max.value = serializationDelegate(gradient.max.value, powerbi.ValueType.fromPrimitiveTypeAndCategory(3));
                        }
                        if (gradient.mid.value) {
                            linearGradient3.mid.value = serializationDelegate(gradient.mid.value, powerbi.ValueType.fromPrimitiveTypeAndCategory(3));
                        }
                        if (gradient.min.value) {
                            linearGradient3.min.value = serializationDelegate(gradient.min.value, powerbi.ValueType.fromPrimitiveTypeAndCategory(3));
                        }
                        return {
                            linearGradient3: linearGradient3
                        };
                    }
                    return null;
                }
            })(DataViewObjectSerializer = services.DataViewObjectSerializer || (services.DataViewObjectSerializer = {}));
        })(services = data.services || (data.services = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var services;
        (function(services) {
            var SemanticQuerySerializer;
            (function(SemanticQuerySerializer) {
                var StringExtensions = jsCommon.StringExtensions;
                function serializeQuery(query) {
                    debug.assertValue(query, "query");
                    var queryFrom = [], from = query.from(), fromKeys = from.keys();
                    for (var i = 0, len = fromKeys.length; i < len; i++) {
                        var key = fromKeys[i], entity = from.entity(key);
                        queryFrom.push({
                            Name: key,
                            Entity: entity.entity,
                            Schema: entity.schema
                        });
                    }
                    var queryWhere, whereItems = query.where();
                    if (whereItems && whereItems.length) {
                        queryWhere = [];
                        for (var i = 0, len = whereItems.length; i < len; i++) {
                            var filter = whereItems[i];
                            var queryFilter = {
                                Condition: QueryExpressionBuilder.create(filter.condition)
                            };
                            if (filter.target) queryFilter.Target = filter.target.map(QueryExpressionBuilder.create);
                            queryWhere.push(queryFilter);
                        }
                    }
                    var queryOrderBy, orderByItems = query.orderBy();
                    if (orderByItems && orderByItems.length) {
                        queryOrderBy = [];
                        for (var i = 0, len = orderByItems.length; i < len; i++) {
                            var clause = orderByItems[i];
                            queryOrderBy.push({
                                Direction: clause.direction,
                                Expression: QueryExpressionBuilder.create(clause.expr)
                            });
                        }
                    }
                    var querySelect = [], selectItems = query.select();
                    for (var i = 0, len = selectItems.length; i < len; i++) querySelect.push(QueryExpressionBuilder.createNamed(selectItems[i]));
                    var contract = {
                        Version: 2,
                        From: queryFrom,
                        Select: querySelect
                    };
                    if (queryWhere) contract.Where = queryWhere;
                    if (queryOrderBy) contract.OrderBy = queryOrderBy;
                    return contract;
                }
                SemanticQuerySerializer.serializeQuery = serializeQuery;
                function deserializeQuery(contract) {
                    debug.assertValue(contract, "contract");
                    var queryVersion = contract.Version ? contract.Version : 0;
                    var upgradeToV1 = queryVersion < 1;
                    var from = Deserializer.from(contract.From);
                    var builder = new data.SemanticQueryBuilder(from);
                    var where = contract.Where;
                    if (where) {
                        for (var i = 0, len = where.length; i < len; i++) {
                            var whereItem = Deserializer.filter(where[i], from);
                            if (whereItem) {
                                if (upgradeToV1) {
                                    whereItem = FilterTargetUpgrader.Upgrade(queryVersion, whereItem);
                                }
                                builder.addWhere(whereItem);
                            }
                        }
                    }
                    var orderBy = contract.OrderBy;
                    if (orderBy) {
                        for (var i = 0, len = orderBy.length; i < len; i++) builder.addOrderBy(Deserializer.sort(orderBy[i], from));
                    }
                    var select = contract.Select, selectNames = {};
                    for (var i = 0, len = select.length; i < len; i++) {
                        builder.addSelect(Deserializer.select(select[i], selectNames, from));
                    }
                    return builder.toQuery();
                }
                SemanticQuerySerializer.deserializeQuery = deserializeQuery;
                function serializeFilter(filter) {
                    var queryFrom = [], from = filter.from(), fromKeys = from.keys();
                    for (var i = 0, len = fromKeys.length; i < len; i++) {
                        var key = fromKeys[i], entity = from.entity(key);
                        queryFrom.push({
                            Name: key,
                            Entity: entity.entity,
                            Schema: entity.schema
                        });
                    }
                    var queryWhere = [], where = filter.where();
                    for (var i = 0, len = where.length; i < len; i++) {
                        var filterClause = where[i];
                        var queryClause = {
                            Condition: QueryExpressionBuilder.create(filterClause.condition)
                        };
                        if (filterClause.target) queryClause.Target = filterClause.target.map(QueryExpressionBuilder.create);
                        queryWhere.push(queryClause);
                    }
                    var contract = {
                        Version: 2,
                        From: queryFrom,
                        Where: queryWhere
                    };
                    return contract;
                }
                SemanticQuerySerializer.serializeFilter = serializeFilter;
                function deserializeFilter(contract) {
                    debug.assertValue(contract, "contract");
                    var filterVersion = contract.Version ? contract.Version : 0;
                    var upgradeToV1 = filterVersion < 1;
                    var from = Deserializer.from(contract.From);
                    var builder = new data.SemanticQueryBuilder(from);
                    var where = contract.Where;
                    for (var i = 0, len = where.length; i < len; i++) {
                        var whereItem = Deserializer.filter(where[i], from);
                        if (whereItem) {
                            if (upgradeToV1) {
                                whereItem = FilterTargetUpgrader.Upgrade(filterVersion, whereItem);
                            }
                            builder.addWhere(whereItem);
                        }
                    }
                    return builder.toFilter();
                }
                SemanticQuerySerializer.deserializeFilter = deserializeFilter;
                function serializeExpr(contract) {
                    debug.assertValue(contract, "contract");
                    return QueryExpressionBuilder.createStandalone(contract);
                }
                SemanticQuerySerializer.serializeExpr = serializeExpr;
                function deserializeExpr(input) {
                    debug.assertValue(input, "input");
                    return ExprBuilder.createStandalone(input);
                }
                SemanticQuerySerializer.deserializeExpr = deserializeExpr;
                var Deserializer;
                (function(Deserializer) {
                    function from(contract) {
                        debug.assertValue(contract, "contract");
                        var items = {};
                        for (var i = 0, len = contract.length; i < len; i++) {
                            var source = contract[i];
                            items[source.Name] = {
                                entity: source.Entity,
                                schema: source.Schema
                            };
                        }
                        return new data.SQFrom(items);
                    }
                    Deserializer.from = from;
                    function filter(contract, from) {
                        debug.assertValue(contract, "contract");
                        debug.assertValue(from, "from");
                        var condition = ExprBuilder.create(contract.Condition, from);
                        if (!condition) return;
                        var sqFilter = {
                            condition: condition
                        };
                        if (contract.Target) sqFilter.target = contract.Target.map(function(t) {
                            return ExprBuilder.create(t, from);
                        });
                        return sqFilter;
                    }
                    Deserializer.filter = filter;
                    function sort(contract, from) {
                        debug.assertValue(contract, "contract");
                        debug.assertValue(from, "from");
                        return {
                            direction: contract.Direction,
                            expr: ExprBuilder.create(contract.Expression, from)
                        };
                    }
                    Deserializer.sort = sort;
                    function select(contract, selectNames, from) {
                        debug.assertValue(contract, "contract");
                        debug.assertValue(from, "from");
                        var expr = ExprBuilder.create(contract, from);
                        var name = contract.Name || StringExtensions.findUniqueName(selectNames, data.SQExprUtils.defaultName(expr));
                        selectNames[name] = true;
                        return {
                            name: name,
                            expr: expr
                        };
                    }
                    Deserializer.select = select;
                })(Deserializer || (Deserializer = {}));
                var QueryExpressionBuilder = function() {
                    function QueryExpressionBuilder(standalone) {
                        this.standalone = standalone;
                    }
                    QueryExpressionBuilder.create = function(expr) {
                        return expr.accept(QueryExpressionBuilder.instance);
                    };
                    QueryExpressionBuilder.createNamed = function(namedExpr) {
                        var container = namedExpr.expr.accept(QueryExpressionBuilder.instance);
                        if (namedExpr.name) container.Name = namedExpr.name;
                        return container;
                    };
                    QueryExpressionBuilder.createStandalone = function(expr) {
                        return expr.accept(QueryExpressionBuilder.standaloneInstance);
                    };
                    QueryExpressionBuilder.prototype.visitColumnRef = function(expr) {
                        return {
                            Column: {
                                Expression: expr.source.accept(this),
                                Property: expr.ref
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitMeasureRef = function(expr) {
                        return {
                            Measure: {
                                Expression: expr.source.accept(this),
                                Property: expr.ref
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitAggr = function(expr) {
                        return {
                            Aggregation: {
                                Expression: expr.arg.accept(this),
                                Function: expr.func
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitBetween = function(expr) {
                        return {
                            Between: {
                                Expression: expr.arg.accept(this),
                                LowerBound: expr.lower.accept(this),
                                UpperBound: expr.upper.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitIn = function(expr) {
                        var values = expr.values, valuesSerialized = [];
                        for (var i = 0, len = values.length; i < len; i++) valuesSerialized.push(this.serializeAll(values[i]));
                        return {
                            In: {
                                Expressions: this.serializeAll(expr.args),
                                Values: valuesSerialized
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitEntity = function(expr) {
                        debug.assertValue(expr, "expr");
                        var sourceRef;
                        if (this.standalone) {
                            var standaloneExpr = {
                                Schema: expr.schema,
                                Entity: expr.entity
                            };
                            sourceRef = standaloneExpr;
                        } else {
                            debug.assertValue(expr.variable, "expr.variable");
                            sourceRef = {
                                Source: expr.variable
                            };
                        }
                        return {
                            SourceRef: sourceRef
                        };
                    };
                    QueryExpressionBuilder.prototype.visitAnd = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            And: {
                                Left: expr.left.accept(this),
                                Right: expr.right.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitOr = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Or: {
                                Left: expr.left.accept(this),
                                Right: expr.right.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitCompare = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Comparison: {
                                ComparisonKind: expr.kind,
                                Left: expr.left.accept(this),
                                Right: expr.right.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitContains = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Contains: {
                                Left: expr.left.accept(this),
                                Right: expr.right.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitDateAdd = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            DateAdd: {
                                Expression: expr.arg.accept(this),
                                Amount: expr.amount,
                                TimeUnit: expr.unit
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitDateSpan = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            DateSpan: {
                                Expression: expr.arg.accept(this),
                                TimeUnit: expr.unit
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitExists = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Exists: {
                                Expression: expr.arg.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitNot = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Not: {
                                Expression: expr.arg.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitNow = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            Now: {}
                        };
                    };
                    QueryExpressionBuilder.prototype.visitStartsWith = function(expr) {
                        debug.assertValue(expr, "expr");
                        return {
                            StartsWith: {
                                Left: expr.left.accept(this),
                                Right: expr.right.accept(this)
                            }
                        };
                    };
                    QueryExpressionBuilder.prototype.visitConstant = function(expr) {
                        debug.assertValue(expr, "expr");
                        switch (expr.type.primitiveType) {
                          case 5:
                          case 7:
                          case 2:
                          case 4:
                          case 3:
                          case 0:
                          case 1:
                            return {
                                Literal: {
                                    Value: expr.valueEncoded
                                }
                            };

                          default:
                            debug.assertFail("Unrecognized kind: " + expr.type.primitiveType);
                        }
                    };
                    QueryExpressionBuilder.prototype.serializeAll = function(exprs) {
                        var result = [];
                        for (var i = 0, len = exprs.length; i < len; i++) result.push(exprs[i].accept(this));
                        return result;
                    };
                    QueryExpressionBuilder.instance = new QueryExpressionBuilder();
                    QueryExpressionBuilder.standaloneInstance = new QueryExpressionBuilder(true);
                    return QueryExpressionBuilder;
                }();
                (function(VisualFilterKind) {
                    VisualFilterKind[VisualFilterKind["Column"] = 0] = "Column";
                    VisualFilterKind[VisualFilterKind["Measure"] = 1] = "Measure";
                    VisualFilterKind[VisualFilterKind["Exists"] = 2] = "Exists";
                })(SemanticQuerySerializer.VisualFilterKind || (SemanticQuerySerializer.VisualFilterKind = {}));
                var VisualFilterKind = SemanticQuerySerializer.VisualFilterKind;
                var FilterKindDetector = function(_super) {
                    __extends(FilterKindDetector, _super);
                    function FilterKindDetector() {
                        _super.call(this);
                        this.filterKind = 0;
                    }
                    FilterKindDetector.run = function(expr) {
                        debug.assertValue(expr, "expr");
                        var detector = new FilterKindDetector();
                        expr.accept(detector);
                        return detector.filterKind;
                    };
                    FilterKindDetector.prototype.visitMeasureRef = function(expr) {
                        this.filterKind = 1;
                    };
                    FilterKindDetector.prototype.visitExists = function(expr) {
                        this.filterKind = 2;
                    };
                    FilterKindDetector.prototype.visitAggr = function(expr) {
                        this.filterKind = 1;
                    };
                    return FilterKindDetector;
                }(data.DefaultSQExprVisitorWithTraversal);
                SemanticQuerySerializer.FilterKindDetector = FilterKindDetector;
                var FilterTargetUpgrader = function() {
                    function FilterTargetUpgrader() {}
                    FilterTargetUpgrader.Upgrade = function(fromVersion, filter) {
                        if (!filter) return null;
                        if (!filter.condition) return null;
                        var filterKind = FilterKindDetector.run(filter.condition);
                        if (fromVersion === 0 && filterKind !== 2) {
                            return {
                                condition: filter.condition
                            };
                        }
                        return filter;
                    };
                    return FilterTargetUpgrader;
                }();
                var ExprBuilder;
                (function(ExprBuilder) {
                    function create(contract, from) {
                        debug.assertValue(contract, "contract");
                        return fromColumnRef(contract.Column, from) || fromMeasureRef(contract.Measure, from) || fromSourceRef(contract.SourceRef, from) || fromAggr(contract.Aggregation, from) || fromAnd(contract.And, from) || fromBetween(contract.Between, from) || fromIn(contract.In, from) || fromOr(contract.Or, from) || fromContains(contract.Contains, from) || fromCompare(contract.Comparison, from) || fromDateAdd(contract.DateAdd, from) || fromDateSpan(contract.DateSpan, from) || fromExists(contract.Exists, from) || fromNot(contract.Not, from) || fromNow(contract.Now) || fromStartsWith(contract.StartsWith, from) || fromLiteral(contract.Literal) || createConst(contract);
                    }
                    ExprBuilder.create = create;
                    function createStandalone(contract) {
                        return create(contract, null);
                    }
                    ExprBuilder.createStandalone = createStandalone;
                    function createArray(contracts, from) {
                        var result = [];
                        for (var i = 0, len = contracts.length; i < len; i++) result.push(create(contracts[i], from));
                        return result;
                    }
                    function createConst(contract) {
                        return fromBool(contract.Boolean) || fromDateTime(contract.DateTime) || fromDateTimeSecond(contract.DateTimeSecond) || fromDateTime(contract.Date) || fromDecimal(contract.Decimal) || fromInteger(contract.Integer) || fromNull(contract.Null) || fromNumber(contract.Number) || fromString(contract.String);
                    }
                    ExprBuilder.createConst = createConst;
                    function fromSourceRef(contract, from) {
                        if (!contract) return;
                        if (from) {
                            var sourceRef = contract;
                            var sourceName = sourceRef.Source;
                            var entity = from.entity(sourceName);
                            if (entity) return data.SQExprBuilder.entity(entity.schema, entity.entity, sourceName);
                        } else {
                            var entityRef = contract;
                            return data.SQExprBuilder.entity(entityRef.Schema, entityRef.Entity);
                        }
                    }
                    function fromColumnRef(contract, from) {
                        if (contract) {
                            var source = create(contract.Expression, from);
                            if (source) return data.SQExprBuilder.columnRef(source, contract.Property);
                        }
                    }
                    function fromMeasureRef(contract, from) {
                        if (contract) {
                            var source = create(contract.Expression, from);
                            if (source) return data.SQExprBuilder.measureRef(source, contract.Property);
                        }
                    }
                    function fromAggr(contract, from) {
                        if (contract) return data.SQExprBuilder.aggregate(create(contract.Expression, from), contract.Function);
                    }
                    function fromAnd(contract, from) {
                        if (contract) return data.SQExprBuilder.and(create(contract.Left, from), create(contract.Right, from));
                    }
                    function fromBetween(contract, from) {
                        if (contract) {
                            return data.SQExprBuilder.between(create(contract.Expression, from), create(contract.LowerBound, from), create(contract.UpperBound, from));
                        }
                    }
                    function fromIn(contract, from) {
                        if (contract) {
                            return data.SQExprBuilder.inExpr(createArray(contract.Expressions, from), contract.Values.map(function(v) {
                                return createArray(v, from);
                            }));
                        }
                    }
                    function fromOr(contract, from) {
                        if (contract) return data.SQExprBuilder.or(create(contract.Left, from), create(contract.Right, from));
                    }
                    function fromContains(contract, from) {
                        if (contract) {
                            var left = create(contract.Left, from);
                            var right = create(contract.Right, from);
                            if (left && right) return data.SQExprBuilder.contains(left, right);
                        }
                    }
                    function fromCompare(contract, from) {
                        if (contract) {
                            var left = create(contract.Left, from);
                            var right = create(contract.Right, from);
                            if (left && right) return data.SQExprBuilder.compare(contract.ComparisonKind, left, right);
                        }
                    }
                    function fromDateAdd(contract, from) {
                        if (contract) {
                            var expression = create(contract.Expression, from);
                            return data.SQExprBuilder.dateAdd(contract.TimeUnit, contract.Amount, expression);
                        }
                    }
                    function fromDateSpan(contract, from) {
                        if (contract) {
                            var expression = create(contract.Expression, from);
                            return data.SQExprBuilder.dateSpan(contract.TimeUnit, expression);
                        }
                    }
                    function fromExists(contract, from) {
                        if (contract) {
                            var arg = create(contract.Expression, from);
                            if (arg) return data.SQExprBuilder.exists(arg);
                        }
                    }
                    function fromNot(contract, from) {
                        if (contract) {
                            var arg = create(contract.Expression, from);
                            if (arg) return data.SQExprBuilder.not(arg);
                        }
                    }
                    function fromNow(contract) {
                        if (contract) return data.SQExprBuilder.now();
                    }
                    function fromStartsWith(contract, from) {
                        if (contract) {
                            var left = create(contract.Left, from);
                            var right = create(contract.Right, from);
                            if (left && right) return data.SQExprBuilder.startsWith(left, right);
                        }
                    }
                    function fromBool(contract) {
                        if (contract) return data.SQExprBuilder.boolean(contract.Value);
                    }
                    function fromDateTime(contract) {
                        if (contract) {
                            var date = fromDateTimeString(contract);
                            if (date) return data.SQExprBuilder.dateTime(date);
                        }
                    }
                    function fromDateTimeSecond(contract) {
                        if (contract) {
                            var date = fromDateTimeString(contract);
                            return data.SQExprBuilder.dateSpan(5, data.SQExprBuilder.dateTime(date));
                        }
                    }
                    function fromDecimal(contract) {
                        if (contract) {
                            var value = contract.Value;
                            return data.SQExprBuilder.decimal(value);
                        }
                    }
                    function fromInteger(contract) {
                        if (contract) {
                            var value = contract.Value;
                            return data.SQExprBuilder.integer(value);
                        }
                    }
                    function fromNull(contract) {
                        if (contract) return data.SQExprBuilder.nullConstant();
                    }
                    function fromNumber(contract) {
                        if (contract) return data.PrimitiveValueEncoding.parseValueToSQExpr(contract.Value);
                    }
                    function fromString(contract) {
                        if (contract) {
                            var value = contract.Value;
                            return data.SQExprBuilder.text(value);
                        }
                    }
                    function fromDateTimeString(contract) {
                        debug.assertValue(contract, "contract");
                        return jsCommon.DateExtensions.tryDeserializeDate(contract.Value);
                    }
                    function fromLiteral(contract) {
                        if (contract) return data.PrimitiveValueEncoding.parseValueToSQExpr(contract.Value);
                    }
                })(ExprBuilder || (ExprBuilder = {}));
            })(SemanticQuerySerializer = services.SemanticQuerySerializer || (services.SemanticQuerySerializer = {}));
        })(services = data.services || (data.services = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var data;
    (function(data) {
        var SQExprShortSerializer;
        (function(SQExprShortSerializer) {
            function serialize(expr) {
                return JSON.stringify(expr.accept(SQExprSerializer.instance));
            }
            SQExprShortSerializer.serialize = serialize;
            function serializeArray(exprs) {
                var str = "[";
                for (var i = 0, len = exprs.length; i < len; i++) {
                    if (i > 0) str += ",";
                    str += SQExprShortSerializer.serialize(exprs[i]);
                }
                return str + "]";
            }
            SQExprShortSerializer.serializeArray = serializeArray;
            var SQExprSerializer = function(_super) {
                __extends(SQExprSerializer, _super);
                function SQExprSerializer() {
                    _super.apply(this, arguments);
                }
                SQExprSerializer.prototype.visitColumnRef = function(expr) {
                    return {
                        col: {
                            s: expr.source.accept(this),
                            r: expr.ref
                        }
                    };
                };
                SQExprSerializer.prototype.visitMeasureRef = function(expr) {
                    return {
                        measure: {
                            s: expr.source.accept(this),
                            r: expr.ref
                        }
                    };
                };
                SQExprSerializer.prototype.visitAggr = function(expr) {
                    return {
                        agg: {
                            a: expr.arg.accept(this),
                            f: expr.func
                        }
                    };
                };
                SQExprSerializer.prototype.visitEntity = function(expr) {
                    debug.assertValue(expr, "expr");
                    debug.assertValue(expr.entity, "expr.entity");
                    return {
                        e: expr.entity
                    };
                };
                SQExprSerializer.prototype.visitAnd = function(expr) {
                    debug.assertValue(expr, "expr");
                    return {
                        and: {
                            l: expr.left.accept(this),
                            r: expr.right.accept(this)
                        }
                    };
                };
                SQExprSerializer.prototype.visitCompare = function(expr) {
                    debug.assertValue(expr, "expr");
                    return {
                        comp: {
                            k: expr.kind,
                            l: expr.left.accept(this),
                            r: expr.right.accept(this)
                        }
                    };
                };
                SQExprSerializer.prototype.visitConstant = function(expr) {
                    debug.assertValue(expr, "expr");
                    return {
                        "const": {
                            t: expr.type.primitiveType,
                            v: expr.value
                        }
                    };
                };
                SQExprSerializer.prototype.visitDefault = function(expr) {
                    debug.assertFail("Unexpected expression type found in DataViewScopeIdentity.");
                    return;
                };
                SQExprSerializer.instance = new SQExprSerializer();
                return SQExprSerializer;
            }(data.DefaultSQExprVisitor);
        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var yAxisPosition;
    (function(yAxisPosition) {
        yAxisPosition.left = "Left";
        yAxisPosition.right = "Right";
        function members() {
            return [ {
                value: yAxisPosition.left,
                displayName: function(resources) {
                    return resources.get("Visual_yAxis_Left");
                }
            }, {
                value: yAxisPosition.right,
                displayName: function(resources) {
                    return resources.get("Visual_yAxis_Right");
                }
            } ];
        }
        yAxisPosition.members = members;
    })(yAxisPosition = powerbi.yAxisPosition || (powerbi.yAxisPosition = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var visualStyles;
        (function(visualStyles) {
            function create(dataColors) {
                if (dataColors === undefined) dataColors = new visuals.DataColorPalette();
                return {
                    titleText: {
                        color: {
                            value: "rgba(51,51,51,1)"
                        }
                    },
                    subTitleText: {
                        color: {
                            value: "rgba(145,145,145,1)"
                        }
                    },
                    colorPalette: {
                        dataColors: dataColors
                    },
                    labelText: {
                        color: {
                            value: "rgba(51,51,51,1)"
                        },
                        fontSize: "11px"
                    },
                    isHighContrast: false
                };
            }
            visualStyles.create = create;
        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var AnimatorCommon;
        (function(AnimatorCommon) {
            AnimatorCommon.MinervaAnimationDuration = 250;
        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        var NullAnimator = function() {
            function NullAnimator() {}
            NullAnimator.prototype.animate = function(options) {
                return null;
            };
            return NullAnimator;
        }();
        visuals.NullAnimator = NullAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WebColumnChartAnimator = function() {
            function WebColumnChartAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebColumnChartAnimator.prototype.animate = function(options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {} else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                } else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                } else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebColumnChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                var data = options.viewModel;
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                });
                var hasHighlights = data.hasHighlights;
                shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS.class.concat(d.highlight ? " highlight" : "");
                }).attr(options.layout.shapeLayoutWithoutHighlights);
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var endStyleApplied = false;
                var shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                });
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS.class.concat(d.highlight ? " highlight" : "");
                });
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights).each("end", function() {
                    if (!endStyleApplied) {
                        shapes.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false);
                        });
                        endStyleApplied = true;
                    }
                }).remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebColumnChartAnimator.prototype.animateDefaultShapes = function(data, series, layout, itemCS) {
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function(d) {
                    return d.data;
                }, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", function(d) {
                    return itemCS.class.concat(d.highlight ? " highlight" : "");
                });
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, data.hasHighlights);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebColumnChartAnimator.prototype.animateDefaultDataLabels = function(options) {
                var dataLabels;
                if (options.viewModel.labelSettings.show) {
                    dataLabels = visuals.ColumnUtil.drawDefaultLabels(options.series, options.labelGraphicsContext, options.labelLayout, options.viewPort, true, this.animationDuration);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            return WebColumnChartAnimator;
        }();
        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WebDonutChartAnimator = function() {
            function WebDonutChartAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebDonutChartAnimator.prototype.animate = function(options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {} else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                } else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                } else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebDonutChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return value.data.highlightRatio != null;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                highlightShapes.enter().insert("path").classed("slice-highlight", true).each(function(d) {
                    this._current = d;
                });
                highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights);
                }).attr(options.layout.shapeLayout).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = this.animateDefaultHighlightShapes(options);
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                var endStylesApplied = false;
                var shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                shapes.enter().insert("path").classed("slice", true).each(function(d) {
                    this._current = d;
                });
                shapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, d.data.selected, !d.data.selected);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return value.data.highlightRatio != null;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                highlightShapes.enter().insert("path").classed("slice-highlight", true).each(function(d) {
                    this._current = d;
                });
                highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(false, true, false, true);
                }).transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).each("end", function(d) {
                    if (!endStylesApplied) {
                        shapes.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false);
                        });
                        highlightShapes.remove();
                        endStylesApplied = true;
                    }
                });
                highlightShapes.exit().remove();
                visuals.DonutChart.drawDefaultCategoryLabels(options.graphicsContext, options.viewModel, options.layout, options.sliceWidthRatio, options.radius, options.viewport);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebDonutChartAnimator.prototype.animateDefaultShapes = function(options) {
                var shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                shapes.enter().insert("path").classed("slice", true).each(function(d) {
                    this._current = d;
                });
                shapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, options.viewModel.hasHighlights);
                }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function(options) {
                var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                    return value.data.highlightRatio != null;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                highlightShapes.enter().insert("path").classed("slice-highlight", true).each(function(d) {
                    this._current = d;
                });
                highlightShapes.style("fill", function(d) {
                    return d.data.color ? d.data.color : options.colors.getColor(d.data.identity.getKey()).value;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights);
                }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            return WebDonutChartAnimator;
        }();
        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WebFunnelAnimator = function() {
            function WebFunnelAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebFunnelAnimator.prototype.animate = function(options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {} else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                } else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                } else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebFunnelAnimator.prototype.animateNormalToHighlighted = function(options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                var shapes = options.shapeGraphicsContext.selectAll("rect").data(data.slices, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? "funnelBar highlight" : "funnelBar";
                }).attr(layout.shapeLayoutWithoutHighlights);
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout);
                shapes.exit().remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var data = options.viewModel;
                var layout = options.layout;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                var shapes = this.animateDefaultShapes(data, data.slices, options.shapeGraphicsContext, layout);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToNormal = function(options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions);
                var shapes = options.shapeGraphicsContext.selectAll("rect").data(data.slices, function(d) {
                    return d.key;
                });
                var endStyleApplied = false;
                shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? "funnelBar highlight" : "funnelBar";
                });
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights);
                }).transition().duration(this.animationDuration).attr(layout.shapeLayoutWithoutHighlights);
                var exitShapes = shapes.exit();
                exitShapes.transition().duration(this.animationDuration).attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights).each("end", function(d, i) {
                    if (!endStyleApplied) {
                        shapes.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false);
                        });
                        endStyleApplied = true;
                    }
                }).remove();
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels
                };
            };
            WebFunnelAnimator.prototype.animateDefaultAxis = function(graphicsContext, axisOptions) {
                var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio);
                var xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right");
                graphicsContext.classed("axis", true).transition().duration(this.animationDuration).attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
            };
            WebFunnelAnimator.prototype.animateDefaultShapes = function(data, slices, graphicsContext, layout) {
                var hasHighlights = data.hasHighlights;
                var shapes = graphicsContext.selectAll("rect").data(slices, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? "funnelBar highlight" : "funnelBar";
                });
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights);
                    };
                }).transition().duration(this.animationDuration).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebFunnelAnimator.prototype.animateDefaultDataLabels = function(options) {
                var dataLabels;
                if (options.viewModel.dataLabelsSettings.show) {
                    dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(options.slicesWithoutHighlights, options.labelGraphicsContext, options.labelLayout, true, this.animationDuration);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            return WebFunnelAnimator;
        }();
        visuals.WebFunnelAnimator = WebFunnelAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WebTreemapAnimator = function() {
            function WebTreemapAnimator() {
                this.animationDuration = visuals.AnimatorCommon.MinervaAnimationDuration;
            }
            WebTreemapAnimator.prototype.animate = function(options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                    labels: null
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {} else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                } else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                } else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebTreemapAnimator.prototype.animateNormalToHighlighted = function(options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights);
                var highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", visuals.Treemap.layout.highlightShapeClass).attr(visuals.Treemap.layout.shapeLayout);
                highlightShapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, true);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, true);
                }).transition().duration(this.animationDuration).attr(visuals.Treemap.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights);
                options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                    return d.key + "highlight";
                });
                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights);
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToNormal = function(options) {
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                var shapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(options.nodes, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", visuals.Treemap.layout.shapeClass);
                shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, false);
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, d.selected, !d.selected);
                }).attr(visuals.Treemap.layout.shapeLayout);
                shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.nodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", visuals.Treemap.layout.highlightShapeClass);
                highlightShapes.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, true);
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, true, d.selected, !d.selected);
                }).transition().duration(this.animationDuration).attr(hasSelection ? visuals.Treemap.layout.zeroShapeLayout : visuals.Treemap.layout.shapeLayout).each("end", function(d, i) {
                    if (i === 0) {
                        shapes.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                        });
                        highlightShapes.remove();
                    }
                });
                highlightShapes.exit().remove();
                var labeledNodes = options.viewModel.dataLabelsSettings.show ? options.labeledNodes : [];
                var labels = this.animateDefaultLabels(options.labelGraphicsContext, labeledNodes);
                return {
                    failed: false,
                    labels: labels,
                    shapes: shapes,
                    highlightShapes: highlightShapes
                };
            };
            WebTreemapAnimator.prototype.animateDefaultShapes = function(context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = false;
                var shapes = context.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(nodes, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", visuals.Treemap.layout.shapeClass);
                shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(visuals.Treemap.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(nodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", visuals.Treemap.layout.highlightShapeClass);
                highlightShapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return visuals.Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(visuals.Treemap.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            WebTreemapAnimator.prototype.animateDefaultLabels = function(context, nodes) {
                var labels = context.selectAll("text").data(nodes, function(d) {
                    return d.key;
                });
                labels.enter().append("text").attr("class", visuals.Treemap.layout.labelClass);
                labels.transition().duration(this.animationDuration).attr(visuals.Treemap.layout.labelLayout).text(visuals.Treemap.layout.labelText);
                labels.exit().remove();
                return labels;
            };
            return WebTreemapAnimator;
        }();
        visuals.WebTreemapAnimator = WebTreemapAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ColumnChartWebBehavior = function() {
            function ColumnChartWebBehavior() {}
            ColumnChartWebBehavior.prototype.select = function(hasSelection, selection, labels, hasHighlights) {
                selection.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                });
                visuals.dataLabelUtils.setHighlightedLabelsOpacity(labels, hasSelection, hasHighlights);
            };
            return ColumnChartWebBehavior;
        }();
        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DataDotChartWebBehavior = function() {
            function DataDotChartWebBehavior() {}
            DataDotChartWebBehavior.prototype.select = function(hasSelection, selection) {
                selection.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false);
                });
            };
            return DataDotChartWebBehavior;
        }();
        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DonutChartWebBehavior = function() {
            function DonutChartWebBehavior(options) {
                this.allowDrilldown = options.allowDrilldown;
                this.visual = options.visual;
                this.svg = options.clearCatcher;
                this.isDrilled = false;
            }
            DonutChartWebBehavior.prototype.select = function(hasSelection, selection, highlighted, hasHighlights, data) {
                if (hasSelection && this.allowDrilldown) {
                    var dataToShow = !this.isDrilled ? data : undefined;
                    this.visual.setDrilldown(dataToShow);
                    this.isDrilled = !this.isDrilled;
                } else {
                    selection.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, highlighted, !highlighted && hasSelection, !d.data.selected && hasHighlights);
                    });
                }
            };
            DonutChartWebBehavior.prototype.mouseOver = function(data) {
                this.setDataLabelStyle(data, false);
            };
            DonutChartWebBehavior.prototype.mouseOut = function(data) {
                this.setDataLabelStyle(data, true);
            };
            DonutChartWebBehavior.prototype.setDataLabelStyle = function(data, dimmed) {
                var text = this.svg.selectAll("text").filter(function(d) {
                    return d.data.identity.getKey() === data.identity.getKey();
                });
                var polyline = this.svg.selectAll("polyline").filter(function(d) {
                    return d.data.identity.getKey() === data.identity.getKey();
                });
                text.style("opacity", function(d) {
                    return dimmed && d.data.isLabelOverlapping ? 0 : 1;
                });
                polyline.style("opacity", function(d) {
                    return dimmed && d.data.isLabelOverlapping ? 0 : visuals.DonutChart.PolylineOpacity;
                });
            };
            return DonutChartWebBehavior;
        }();
        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var FunnelWebBehavior = function() {
            function FunnelWebBehavior() {}
            FunnelWebBehavior.prototype.select = function(hasSelection, selection, hasHighlights) {
                selection.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                });
            };
            return FunnelWebBehavior;
        }();
        visuals.FunnelWebBehavior = FunnelWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var LineChartWebBehavior = function() {
            function LineChartWebBehavior() {}
            LineChartWebBehavior.prototype.select = function(hasSelection, lines, dots, areas) {
                lines.style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                });
                dots.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                });
                if (areas) areas.style("fill-opacity", function(d) {
                    return hasSelection && !d.selected ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity;
                });
            };
            return LineChartWebBehavior;
        }();
        visuals.LineChartWebBehavior = LineChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var MapBehavior = function() {
            function MapBehavior() {}
            MapBehavior.prototype.select = function(hasSelection, bubbles, slices, shapes) {
                if (bubbles) {
                    bubbles.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                        }
                    });
                }
                if (slices) {
                    slices.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false);
                        }
                    });
                }
                if (shapes) {
                    shapes.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                        }
                    });
                }
            };
            return MapBehavior;
        }();
        visuals.MapBehavior = MapBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        (function(DragType) {
            DragType[DragType["Drag"] = 0] = "Drag";
            DragType[DragType["DragEnd"] = 1] = "DragEnd";
        })(visuals.DragType || (visuals.DragType = {}));
        var DragType = visuals.DragType;
        var ScatterChartWebBehavior = function() {
            function ScatterChartWebBehavior() {}
            ScatterChartWebBehavior.prototype.select = function(hasSelection, datapoints) {
                datapoints.style("fill-opacity", function(d) {
                    return d.size != null ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                });
                datapoints.style("stroke-opacity", function(d) {
                    return visuals.ScatterChart.getBubbleOpacity(d, hasSelection);
                });
            };
            return ScatterChartWebBehavior;
        }();
        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
        var ScatterChartMobileBehavior = function() {
            function ScatterChartMobileBehavior() {}
            ScatterChartMobileBehavior.prototype.setOptions = function(options) {
                this.data = options.data;
                this.mainGraphicsContext = options.mainContext;
                this.xAxisProperties = options.xAxisProperties;
                this.yAxisProperties = options.yAxisProperties;
                this.host = options.host;
            };
            ScatterChartMobileBehavior.prototype.select = function(hasSelection, datapoints, dataPoint, index) {
                this.selectDotByIndex(index);
            };
            ScatterChartMobileBehavior.prototype.selectRoot = function() {
                var marker = jsCommon.PerformanceUtil.create("selectRoot");
                this.onClick();
                marker.end();
            };
            ScatterChartMobileBehavior.prototype.drag = function(t) {
                switch (t) {
                  case 0:
                    this.onDrag();
                    break;

                  case 1:
                    this.onClick();
                    break;

                  default:
                    debug.assertFail("Unknown Drag Type");
                }
            };
            ScatterChartMobileBehavior.prototype.onDrag = function() {
                var xy = this.getMouseCoordinates();
                this.moveCrosshairToXY(xy.x, xy.y);
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDot(selectedIndex);
                this.updateLegend(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.onClick = function() {
                var xy = this.getMouseCoordinates();
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDotByIndex(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.getMouseCoordinates = function() {
                var mainGfxContext = this.mainGraphicsContext;
                var x = 0;
                var y = parseInt(mainGfxContext.attr("height"), 10);
                y = y || 0;
                try {
                    var mouse = d3.mouse(mainGfxContext.node());
                    x = mouse[0];
                    y = mouse[1];
                } catch (e) {}
                return {
                    x: x,
                    y: y
                };
            };
            ScatterChartMobileBehavior.prototype.selectDotByIndex = function(index) {
                this.selectDot(index);
                this.moveCrosshairToIndexDot(index);
                this.updateLegend(index);
            };
            ScatterChartMobileBehavior.prototype.selectDot = function(dotIndex) {
                var _this = this;
                var root = this.mainGraphicsContext;
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({
                    selected: false,
                    notSelected: true
                });
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function(d, i) {
                    var dataPoints = _this.data.dataPoints;
                    debug.assert(dataPoints.length > dotIndex, "dataPoints length:" + dataPoints.length + "is smaller than index:" + dotIndex);
                    var currentPoint = dataPoints[dotIndex];
                    return d.x === currentPoint.x && d.y === currentPoint.y;
                }).classed({
                    selected: true,
                    notSelected: false
                });
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function(index) {
                var dataPoints = this.data.dataPoints;
                var root = this.mainGraphicsContext;
                debug.assert(dataPoints.length > index, "dataPoints length:" + dataPoints.length + "is smaller than index:" + index);
                var x = this.xAxisProperties.scale(dataPoints[index].x);
                var y = this.yAxisProperties.scale(dataPoints[index].y);
                if (this.crosshair == null) {
                    var width = +root.attr("width");
                    var height = +root.attr("height");
                    this.crosshair = this.drawCrosshair(root, x, y, width, height);
                    this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector);
                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                } else {
                    this.moveCrosshairToXY(x, y);
                }
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function(x, y) {
                this.crosshairHorizontal.attr({
                    y1: y,
                    y2: y
                });
                this.crosshairVertical.attr({
                    x1: x,
                    x2: x
                });
            };
            ScatterChartMobileBehavior.prototype.drawCrosshair = function(addTo, x, y, width, height) {
                var crosshair = addTo.append("g");
                crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, true);
                crosshair.append("line").classed(ScatterChartMobileBehavior.Horizontal.class, true).attr({
                    x1: 0,
                    x2: width,
                    y1: y,
                    y2: y
                });
                crosshair.append("line").classed(ScatterChartMobileBehavior.Vertical.class, true).attr({
                    x1: x,
                    x2: x,
                    y1: height,
                    y2: 0
                });
                return crosshair;
            };
            ScatterChartMobileBehavior.prototype.findClosestDotIndex = function(x, y) {
                var selectedIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var dataPoints = this.data.dataPoints;
                var xAxisPropertiesScale = this.xAxisProperties.scale;
                var yAxisPropertiesScale = this.yAxisProperties.scale;
                for (var i in dataPoints) {
                    var currentPoint = dataPoints[i];
                    var circleX = xAxisPropertiesScale(currentPoint.x);
                    var circleY = yAxisPropertiesScale(currentPoint.y);
                    var horizontalDistance = circleX - x;
                    var verticalDistance = circleY - y;
                    var distanceSqrd = horizontalDistance * horizontalDistance + verticalDistance * verticalDistance;
                    if (minDistance === Number.MAX_VALUE) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    } else if (minDistance && minDistance > distanceSqrd) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                }
                return selectedIndex;
            };
            ScatterChartMobileBehavior.prototype.updateLegend = function(dotIndex) {
                if (this.lastDotIndex == null || this.lastDotIndex !== dotIndex) {
                    var legendItems = this.createLegendDataPoints(dotIndex);
                    this.host.updateLegend(legendItems);
                    this.lastDotIndex = dotIndex;
                }
            };
            ScatterChartMobileBehavior.prototype.createLegendDataPoints = function(dotIndex) {
                var formatStringProp = visuals.scatterChartProps.general.formatString;
                var legendItems = [];
                var data = this.data;
                debug.assert(data.dataPoints.length > dotIndex, "dataPoints length:" + data.dataPoints.length + "is smaller than index:" + dotIndex);
                var point = data.dataPoints[dotIndex];
                var blank = visuals.valueFormatter.format(null);
                var title = blank;
                var legendData = data.legendData;
                debug.assertValue(legendData, "legendData");
                debug.assertValue(legendData.dataPoints, "legendData");
                var legendDataPoints = legendData.dataPoints;
                if (point.category !== blank) {
                    title = point.category;
                } else if (point.radius.sizeMeasure != null) {
                    title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
                } else if (legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank) {
                    title = legendDataPoints[dotIndex].label;
                }
                if (data.xCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0,
                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                if (data.yCol !== undefined && data.yCol !== null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0,
                        label: visuals.valueFormatter.format(data.axesLabels.y),
                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                if (data.size !== undefined && data.size !== null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        icon: 0,
                        label: visuals.valueFormatter.format(data.size.displayName),
                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                return {
                    dataPoints: legendItems
                };
            };
            ScatterChartMobileBehavior.CrosshairClassName = "crosshair";
            ScatterChartMobileBehavior.ScatterChartCircleTagName = "circle";
            ScatterChartMobileBehavior.DotClassName = "dot";
            ScatterChartMobileBehavior.DotClassSelector = "." + ScatterChartMobileBehavior.DotClassName;
            ScatterChartMobileBehavior.Horizontal = {
                "class": "horizontal",
                selector: ".horizontal"
            };
            ScatterChartMobileBehavior.Vertical = {
                "class": "vertical",
                selector: ".vertical"
            };
            return ScatterChartMobileBehavior;
        }();
        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var SlicerWebBehavior = function() {
            function SlicerWebBehavior() {}
            SlicerWebBehavior.prototype.select = function(selectionLabels) {
                selectionLabels.style({
                    color: function(d) {
                        if (d.selected) return visuals.Slicer.DefaultStyleProperties.slicerText.selectionColor; else return visuals.Slicer.DefaultStyleProperties.slicerText.color;
                    }
                });
            };
            SlicerWebBehavior.prototype.mouseInteractions = function(selectionLabels) {
                selectionLabels.style({
                    color: function(d) {
                        if (d.mouseOver) return visuals.Slicer.DefaultStyleProperties.slicerText.hoverColor;
                        if (d.mouseOut) {
                            if (d.selected) return visuals.Slicer.DefaultStyleProperties.slicerText.selectionColor; else return visuals.Slicer.DefaultStyleProperties.slicerText.color;
                        }
                    }
                });
            };
            SlicerWebBehavior.prototype.clearSlicers = function(selectionLabels, slicerItemInputs) {
                slicerItemInputs.selectAll("input").property("checked", false);
                selectionLabels.style("color", visuals.Slicer.DefaultStyleProperties.slicerText.color);
            };
            return SlicerWebBehavior;
        }();
        visuals.SlicerWebBehavior = SlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var LegendWebBehavior = function() {
            function LegendWebBehavior() {}
            LegendWebBehavior.prototype.select = function(hasSelection, legendIcons) {
                if (hasSelection) {
                    legendIcons.style({
                        fill: function(d) {
                            if (!d.selected) return LegendWebBehavior.selectedLegendColor; else return d.color;
                        }
                    });
                } else {
                    legendIcons.style({
                        fill: function(d) {
                            return d.color;
                        }
                    });
                }
            };
            LegendWebBehavior.selectedLegendColor = "#A6A6A6";
            return LegendWebBehavior;
        }();
        visuals.LegendWebBehavior = LegendWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var TreemapWebBehavior = function() {
            function TreemapWebBehavior() {}
            TreemapWebBehavior.prototype.select = function(hasSelection, datapoints, hasHighlights) {
                datapoints.style("fill", function(d) {
                    return visuals.Treemap.getFill(d, false);
                }).style("fill-opacity", function(d) {
                    return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, false);
                });
            };
            return TreemapWebBehavior;
        }();
        visuals.TreemapWebBehavior = TreemapWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WaterfallChartWebBehavior = function() {
            function WaterfallChartWebBehavior() {}
            WaterfallChartWebBehavior.prototype.select = function(hasSelection, selection) {
                selection.style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false);
                });
            };
            return WaterfallChartWebBehavior;
        }();
        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var fallBackDomain = [ 0, 10 ];
        var fallbackDateDomain = [ new Date(2014, 1, 1).getTime(), new Date(2015, 1, 1).getTime() ];
        var AxisHelper;
        (function(AxisHelper) {
            var XLabelOffsetForOrdinal = 25;
            var XLabelOffsetForNonOrdinal = 10;
            var TextHeightConstant = 10;
            var MinTickCount = 2;
            var DefaultBestTickCount = 3;
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                if (availableWidth < 250) return 3;
                return 6;
            }
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                if (availableWidth < 150) return 3;
                return 6;
            }
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
                if (isNaN(min) || isNaN(max)) return DefaultBestTickCount;
                debug.assert(min <= max, "min value needs to be less or equal to max value");
                if (maxTickCount <= 1 || max <= 1 && min >= -1) return maxTickCount;
                if (min === max) {
                    if (!!isDateTime) return 1;
                    return DefaultBestTickCount;
                }
                if (hasNonIntegerData(valuesMetadata)) return maxTickCount;
                return Math.min(max - min + 1, maxTickCount);
            }
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
                        return true;
                    }
                }
                return false;
            }
            AxisHelper.hasNonIntegerData = hasNonIntegerData;
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar) {
                if (!isScalar || isOrdinalScale(scale)) {
                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
                } else if (isDateTime(axisType)) {
                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
                }
                return getRecommendedTickValuesForALinearRange(maxTicks, scale);
            }
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                if (maxTicks <= 0) return tickLabels;
                var len = labels.length;
                if (maxTicks > len) return labels;
                for (var i = 0, step = Math.floor(len / maxTicks); i < len; i += step) {
                    tickLabels.push(labels[i]);
                }
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
            function getRecommendedTickValuesForALinearRange(maxTicks, scale) {
                var tickLabels = [];
                if (maxTicks === 0) return tickLabels;
                var linearScale = scale;
                if (linearScale.ticks) {
                    tickLabels = linearScale.ticks(maxTicks);
                    if (tickLabels.length > maxTicks && maxTicks > 1) tickLabels = linearScale.ticks(maxTicks - 1);
                    if (tickLabels.length < MinTickCount) {
                        tickLabels = linearScale.ticks(maxTicks + 1);
                    }
                    return tickLabels;
                }
                debug.assertFail("must pass a linear scale to this method");
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForALinearRange = getRecommendedTickValuesForALinearRange;
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                tickLabels = dateTimeTickLabels.map(function(d) {
                    return d.getTime();
                });
                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                return tickLabels;
            }
            function normalizeLinearDomain(domain) {
                if (isNaN(domain.min) || isNaN(domain.max)) {
                    domain.min = fallBackDomain[0];
                    domain.max = fallBackDomain[1];
                } else if (domain.min === 0 && domain.max === 0) {
                    domain.max = fallBackDomain[1];
                } else if (domain.min === domain.max) {
                    domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * .8;
                    domain.max = domain.max < 0 ? domain.max * .8 : domain.max * 1.2;
                } else {
                    if (Math.abs(domain.min) < 1e-4 && domain.min / (domain.max - domain.min) < 1e-4) {
                        domain.min = 0;
                    }
                }
                return domain;
            }
            AxisHelper.normalizeLinearDomain = normalizeLinearDomain;
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0 || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
                    return {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    };
                }
                return {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            AxisHelper.getMargin = getMargin;
            function getTickLabelMargins(viewport, leftMarginLimit, textMeasurer, xAxisProperties, y1AxisProperties, rotateX, maxHeight, properties, y2AxisProperties, scrollbarVisible, showOnRight, renderXAxis, renderYAxes, renderY2Axis) {
                debug.assertValue(viewport, "viewport");
                debug.assertValue(textMeasurer, "textMeasurer");
                debug.assertValue(xAxisProperties, "xAxis");
                debug.assertValue(y1AxisProperties, "yAxis");
                var xLabels = xAxisProperties.values;
                var yLeftLabels = y1AxisProperties.values;
                var xAxisType = xAxisProperties.axisType;
                var maxLeft = 0;
                var maxRight = 0;
                var xMax = 0;
                var labelOffset = isOrdinal(xAxisType) ? XLabelOffsetForOrdinal : XLabelOffsetForNonOrdinal;
                var xLabelPadding = 0;
                if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                if (getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0 || getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
                    var rotation;
                    if (scrollbarVisible) rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar; else rotation = LabelLayoutStrategy.DefaultRotation;
                    for (var i = 0, len = yLeftLabels.length; i < len; i++) {
                        properties.text = yLeftLabels[i];
                        maxLeft = Math.max(maxLeft, textMeasurer(properties));
                    }
                    if (y2AxisProperties) {
                        var yRightLabels = y2AxisProperties.values;
                        for (var i = 0, len = yRightLabels.length; i < len; i++) {
                            properties.text = yRightLabels[i];
                            maxRight = Math.max(maxRight, textMeasurer(properties));
                        }
                    }
                    for (var i = 0, len = xLabels.length; i < len; i++) {
                        var height;
                        properties.text = xLabels[i];
                        var size = textMeasurer(properties);
                        if (rotateX) {
                            height = size * rotation.sine;
                        } else {
                            height = TextHeightConstant;
                            if (i === 0) {
                                var width = size / 2 - labelOffset - xLabelPadding;
                                maxLeft = Math.max(maxLeft, width);
                            } else if (i === len - 1) {
                                var width = size / 2;
                                maxRight = Math.max(maxRight, width);
                            }
                        }
                        xMax = Math.max(xMax, height);
                    }
                }
                if (showOnRight) {
                    var temp = maxLeft;
                    maxLeft = maxRight;
                    maxRight = temp;
                }
                var calulatedMargins = {
                    xMax: Math.min(maxHeight, Math.ceil(xMax)),
                    yLeft: Math.min(Math.ceil(maxLeft), leftMarginLimit),
                    yRight: Math.ceil(maxRight)
                };
                if (!renderYAxes) {
                    calulatedMargins.yLeft = 0;
                    calulatedMargins.yRight = 0;
                }
                if (!renderY2Axis && showOnRight) {
                    calulatedMargins.yLeft = 0;
                }
                if (!renderY2Axis && !showOnRight) {
                    calulatedMargins.yRight = 0;
                }
                if (!renderXAxis) {
                    calulatedMargins.xMax = 0;
                }
                return calulatedMargins;
            }
            AxisHelper.getTickLabelMargins = getTickLabelMargins;
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({
                    text: true
                });
            }
            AxisHelper.createOrdinalType = createOrdinalType;
            function isOrdinal(type) {
                return !!(type && (type.text || type.bool));
            }
            AxisHelper.isOrdinal = isOrdinal;
            function isOrdinalScale(scale) {
                return typeof scale.invert === "undefined";
            }
            AxisHelper.isOrdinalScale = isOrdinalScale;
            function isDateTime(type) {
                return !!(type && type.dateTime);
            }
            AxisHelper.isDateTime = isDateTime;
            function invertScale(scale, x) {
                if (isOrdinalScale(scale)) {
                    return invertOrdinalScale(scale, x);
                }
                return scale.invert(x);
            }
            AxisHelper.invertScale = invertScale;
            function extent(scale) {
                if (isOrdinalScale(scale)) {
                    return scale.rangeExtent();
                }
                return scale.range();
            }
            AxisHelper.extent = extent;
            function invertOrdinalScale(scale, x) {
                var leftEdges = scale.range();
                var width = scale.rangeBand();
                var j;
                for (j = 0; x > leftEdges[j] + width && leftEdges.length - 1 > j; j++) ;
                return scale.domain()[j];
            }
            AxisHelper.invertOrdinalScale = invertOrdinalScale;
            function getOrdinalScaleClosestDataPointIndex(scale, x) {
                var index = 0;
                var range = scale.range();
                var distance = Math.abs(x - range[0]);
                for (var j = 1; j < range.length; j++) {
                    var currentDistance = Math.abs(x - range[j]);
                    if (distance > currentDistance) {
                        distance = currentDistance;
                        index = j;
                    }
                }
                return index;
            }
            AxisHelper.getOrdinalScaleClosestDataPointIndex = getOrdinalScaleClosestDataPointIndex;
            function diffScaled(scale, value1, value2) {
                debug.assertValue(scale, "scale");
                var value = scale(value1) - scale(value2);
                if (value === 0) return 0;
                if (value < 0) return Math.min(value, -1);
                return Math.max(value, 1);
            }
            AxisHelper.diffScaled = diffScaled;
            function createDomain(data, axisType, isScalar, forcedScalarDomain) {
                var userMin, userMax;
                if (forcedScalarDomain && forcedScalarDomain.length === 2) {
                    userMin = forcedScalarDomain[0];
                    userMax = forcedScalarDomain[1];
                }
                if (isScalar && !isOrdinal(axisType)) return createScalarDomain(data, userMin, userMax, axisType);
                return createOrdinalDomain(data);
            }
            AxisHelper.createDomain = createDomain;
            function ensureValuesInRange(values, min, max) {
                debug.assert(min <= max, "min must be less or equal to max");
                var filteredValues = values.filter(function(v) {
                    return v >= min && v <= max;
                });
                if (filteredValues.length < 2) filteredValues = [ min, max ];
                return filteredValues;
            }
            AxisHelper.ensureValuesInRange = ensureValuesInRange;
            function getCategoryValueType(metadataColumn) {
                return metadataColumn && columnDataTypeHasValue(metadataColumn.type) ? metadataColumn.type : powerbi.ValueType.fromDescriptor({
                    text: true
                });
            }
            AxisHelper.getCategoryValueType = getCategoryValueType;
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;
                var formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp);
                var dataType = this.getCategoryValueType(metaDataColumn);
                var scaleResult = this.createScale(options);
                var scale = scaleResult.scale;
                var bestTickCount = scaleResult.bestTickCount;
                var scaleDomain = scale.domain();
                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
                    var oldSpan = dataDomain[1] - dataDomain[0];
                    var newSpan = scaleDomain[1] - scaleDomain[0];
                    if (oldSpan > 0 && newSpan > 0) {
                        categoryThickness = categoryThickness * oldSpan / newSpan;
                    }
                }
                var tickValues;
                if (isScalar && bestTickCount === 1) {
                    tickValues = [ dataDomain[0] ];
                } else {
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar);
                }
                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);
                var axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(tickValues);
                var formattedTickValues = [];
                if (metaDataColumn) formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);
                if (!isScalar && categoryThickness) {
                    xLabelMaxWidth = categoryThickness;
                } else {
                    var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                    var xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;
                }
                return {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: null,
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding
                };
            }
            AxisHelper.createAxis = createAxis;
            function createScale(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness;
                var dataType = this.getCategoryValueType(metaDataColumn);
                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                var scalarDomain = dataDomain.slice();
                var bestTickCount = maxTicks;
                var scale;
                if (dataDomain == null || dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) {
                    dataDomain = fallBackDomain;
                    dataType = powerbi.ValueType.fromDescriptor({
                        numeric: true
                    });
                    scale = createLinearScale(pixelSpan, dataDomain, outerPadding, bestTickCount);
                } else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = forcedTickCount !== undefined ? maxTicks !== 0 ? forcedTickCount : 0 : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [ metaDataColumn ], maxTicks, dataType.dateTime);
                        var normalizedRange = AxisHelper.normalizeLinearDomain({
                            min: dataDomain[0],
                            max: dataDomain[dataDomain.length - 1]
                        });
                        scalarDomain = [ normalizedRange.min, normalizedRange.max ];
                    }
                    if (isScalar && dataType.numeric && !dataType.dateTime) {
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, bestTickCount);
                    } else if (isScalar && dataType.dateTime) {
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null);
                    } else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                        bestTickCount = maxTicks === 0 ? 0 : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianChart.MinOrdinalRectThickness);
                    } else {
                        debug.assertFail("unsupported dataType, something other than text or numeric");
                    }
                }
                if (isVertical && isScalar) {
                    scale.range(scale.range().reverse());
                }
                visuals.ColumnUtil.normalizeInfinityInScale(scale);
                return {
                    scale: scale,
                    bestTickCount: bestTickCount
                };
            }
            AxisHelper.createScale = createScale;
            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                if (useTickIntervalForDisplayUnits === void 0) {
                    useTickIntervalForDisplayUnits = false;
                }
                var formatter;
                if (dataType.dateTime) {
                    if (isScalar) {
                        var value = new Date(scaleDomain[0]);
                        var value2 = new Date(scaleDomain[1]);
                        if (bestTickCount === 1) value = value2 = new Date(dataDomain[0]);
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount
                        });
                    } else {
                        if (getValueFn == null) {
                            debug.assertFail("getValueFn must be supplied for ordinal datetime tickValues");
                        }
                        var minDate = getValueFn(0, dataType);
                        var maxDate = getValueFn(scaleDomain.length - 1, dataType);
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: minDate,
                            value2: maxDate,
                            tickCount: bestTickCount
                        });
                    }
                } else {
                    if (getValueFn == null && !isScalar) {
                        debug.assertFail("getValueFn must be supplied for ordinal tickValues");
                    }
                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var domainMin = tickValues[tickValues.length - 1] - tickValues[0];
                        var domainMax = 0;
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: domainMin,
                            value2: domainMax,
                            allowFormatBeautification: true
                        });
                    } else {
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                return formatter;
            }
            function formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                var formattedTickValues = [];
                if (formatter) {
                    if (getValueFn && !(dataType.numeric && isScalar)) {
                        axis.tickFormat(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        });
                        formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        });
                    } else {
                        axis.tickFormat(function(d) {
                            return formatter.format(d);
                        });
                        formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(d);
                        });
                    }
                } else {
                    formattedTickValues = tickValues.map(function(d) {
                        return getValueFn(d, dataType);
                    });
                }
                return formattedTickValues;
            }
            AxisHelper.formatAxisTickValues = formatAxisTickValues;
            function createScalarDomain(data, userMin, userMax, axisType) {
                debug.assertValue(data, "data");
                if (data.length === 0) {
                    if (axisType.dateTime) return fallbackDateDomain; else return fallBackDomain;
                }
                var defaultMinX = d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d.categoryValue;
                    });
                });
                var defaultMaxX = d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d.categoryValue;
                    });
                });
                var minX, maxX;
                if (typeof userMin === "number") {
                    minX = userMin;
                } else {
                    minX = defaultMinX;
                }
                if (typeof userMax === "number") {
                    maxX = userMax;
                } else {
                    maxX = defaultMaxX;
                }
                if (minX > maxX) {
                    minX = defaultMinX;
                    maxX = defaultMaxX;
                }
                return [ minX, maxX ];
            }
            function createValueDomain(data, includeZero) {
                debug.assertValue(data, "data");
                if (data.length === 0) return fallBackDomain;
                var minY = d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d.value;
                    });
                });
                var maxY = d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d.value;
                    });
                });
                if (includeZero) return [ Math.min(minY, 0), Math.max(maxY, 0) ];
                return [ minY, maxY ];
            }
            AxisHelper.createValueDomain = createValueDomain;
            function createOrdinalDomain(data) {
                if (ArrayExtensions.isUndefinedOrEmpty(data)) return [];
                return data[0].data.map(function(d) {
                    return d.categoryIndex;
                });
            }
            var LabelLayoutStrategy;
            (function(LabelLayoutStrategy) {
                function willRotate(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (labels.length === 0) return false;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined ? axisProperties.xLabelMaxWidth : availableWidth / labels.length;
                    return labels.some(function(d) {
                        properties.text = d;
                        return textMeasurer(properties) > labelMaxWidth;
                    });
                }
                LabelLayoutStrategy.willRotate = willRotate;
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: "rotate(-35)",
                    dy: "-0.5em"
                };
                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(Math.PI * (90 / 180)),
                    cosine: Math.cos(Math.PI * (90 / 180)),
                    tangent: Math.tan(Math.PI * (90 / 180)),
                    transform: "rotate(-90)",
                    dy: "-0.8em"
                };
                function rotate(text, availableWidth, maxBottomMargin, svgEllipsis, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var rotatedLength;
                    var defaultRotation;
                    if (scrollbarVisible) defaultRotation = LabelLayoutStrategy.DefaultRotationWithScrollbar; else defaultRotation = LabelLayoutStrategy.DefaultRotation;
                    if (needRotate) {
                        rotatedLength = maxBottomMargin / defaultRotation.sine;
                    }
                    text.each(function() {
                        var text = d3.select(this);
                        if (needRotate) {
                            var textContentIndex = axisProperties.values.indexOf(this.textContent);
                            var allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (textContentIndex + .5);
                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                            if (needEllipsis || allowedLength < rotatedLength) {
                                svgEllipsis(text[0][0], Math.min(allowedLength, rotatedLength));
                            }
                            text.style("text-anchor", "end").attr({
                                dx: "-0.5em",
                                dy: defaultRotation.dy,
                                transform: defaultRotation.transform
                            });
                        } else {
                            text.style("text-anchor", "middle").attr({
                                dx: "0em",
                                dy: "1em",
                                transform: "rotate(0)"
                            });
                        }
                    });
                }
                LabelLayoutStrategy.rotate = rotate;
                function clip(text, availableWidth, svgEllipsis) {
                    if (text.size() === 0) return;
                    text.each(function() {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    });
                }
                LabelLayoutStrategy.clip = clip;
            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
            var ToolTip;
            (function(ToolTip) {
                var calloutHtml = '<div class="callout triangle-border ms-font-mi">' + '<div class="textArea"/>' + "</div>";
                function createCallout() {
                    return $(calloutHtml);
                }
                ToolTip.createCallout = createCallout;
                function clearCallout(callout) {
                    callout.find(".destroyme").remove();
                }
                ToolTip.clearCallout = clearCallout;
                function renderCallout(callout, x, rangeEnd, leftMargin) {
                    var calloutBleed = 0;
                    var calloutWidth = callout.width();
                    var calloutHalfWidth = calloutWidth / 2;
                    var xOffset = leftMargin - calloutHalfWidth - 10;
                    var innerTriangleOffset = 2;
                    var left;
                    var triangleLeftBefore;
                    var triangleLeftAfter;
                    if (x + (calloutHalfWidth - calloutBleed) > rangeEnd) {
                        left = rangeEnd + xOffset - (calloutHalfWidth - calloutBleed);
                        triangleLeftBefore = calloutWidth - innerTriangleOffset - calloutBleed - (rangeEnd - x);
                        triangleLeftAfter = calloutWidth - calloutBleed - (rangeEnd - x);
                    } else if (x > calloutHalfWidth - calloutBleed) {
                        left = x + xOffset;
                        triangleLeftBefore = calloutHalfWidth - innerTriangleOffset;
                        triangleLeftAfter = calloutHalfWidth;
                    } else {
                        left = calloutHalfWidth - calloutBleed + xOffset;
                        triangleLeftBefore = x + calloutBleed - innerTriangleOffset;
                        triangleLeftAfter = x + calloutBleed;
                    }
                    renderCalloutImpl(callout, left, triangleLeftBefore, triangleLeftAfter);
                }
                ToolTip.renderCallout = renderCallout;
                function renderCalloutImpl(callout, left, triangleLeftBefore, triangleLeftAfter) {
                    callout.css("left", left + "px");
                    callout.find(".destroyme").remove();
                    callout.append('<style class="destroyme">.triangle-border:before{left:' + triangleLeftBefore + "px;}</style>");
                    callout.append('<style class="destroyme">.triangle-border:after{left:' + triangleLeftAfter + "px;}</style>");
                }
            })(ToolTip = AxisHelper.ToolTip || (AxisHelper.ToolTip = {}));
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                if (outerPaddingRatio === void 0) {
                    outerPaddingRatio = 0;
                }
                var scale = d3.scale.ordinal().rangeBands([ 0, pixelSpan ], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio).domain(dataDomain);
                return scale;
            }
            AxisHelper.createOrdinalScale = createOrdinalScale;
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                if (outerPadding === void 0) {
                    outerPadding = 0;
                }
                var scale = d3.scale.linear().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]);
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            AxisHelper.createLinearScale = createLinearScale;
            function getRangeForColumn(sizeColumn) {
                var result = {};
                if (sizeColumn) {
                    result.min = sizeColumn.min == null ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal : sizeColumn.min;
                    result.max = sizeColumn.max == null ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal : sizeColumn.max;
                }
                return result;
            }
            AxisHelper.getRangeForColumn = getRangeForColumn;
            function combineDomain(forcedDomain, domain) {
                var combinedDomain = [ domain[0], domain[1] ];
                if (forcedDomain && forcedDomain.length === 2) {
                    if (forcedDomain[0] != null) {
                        combinedDomain[0] = forcedDomain[0];
                    }
                    if (forcedDomain[1] != null) {
                        combinedDomain[1] = forcedDomain[1];
                    }
                    if (combinedDomain[0] > combinedDomain[1]) {
                        combinedDomain = domain;
                    }
                }
                return combinedDomain;
            }
            AxisHelper.combineDomain = combineDomain;
            function scaleShouldClamp(combinedDomain, domain) {
                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
            }
            AxisHelper.scaleShouldClamp = scaleShouldClamp;
            function normalizeNonFiniteNumber(value) {
                if (isNaN(value)) return null; else if (value === Number.POSITIVE_INFINITY) return Number.MAX_VALUE; else if (value === Number.NEGATIVE_INFINITY) return -Number.MAX_VALUE;
                return value;
            }
            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var CartesianHelper;
        (function(CartesianHelper) {
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata) return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects["categoryAxis"];
                    if (categoryAxisObject) {
                        toReturn = {
                            show: categoryAxisObject["show"],
                            axisType: categoryAxisObject["axisType"],
                            start: categoryAxisObject["start"],
                            end: categoryAxisObject["end"],
                            showAxisTitle: categoryAxisObject["showAxisTitle"] == null ? axisTitleOnByDefault : categoryAxisObject["showAxisTitle"],
                            axisStyle: categoryAxisObject["axisStyle"]
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata) return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects["valueAxis"];
                    if (valueAxisObject) {
                        toReturn = {
                            show: valueAxisObject["show"],
                            position: valueAxisObject["position"],
                            start: valueAxisObject["start"],
                            end: valueAxisObject["end"],
                            showAxisTitle: valueAxisObject["showAxisTitle"] == null ? axisTitleOnByDefault : valueAxisObject["showAxisTitle"],
                            axisStyle: valueAxisObject["axisStyle"],
                            secShow: valueAxisObject["secShow"],
                            secPosition: valueAxisObject["secPosition"],
                            secStart: valueAxisObject["secStart"],
                            secEnd: valueAxisObject["secEnd"],
                            secShowAxisTitle: valueAxisObject["secShowAxisTitle"],
                            secAxisStyle: valueAxisObject["secAxisStyle"]
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
            function forceValueDomainToZero(valueAxisProperties) {
                if (valueAxisProperties["start"] == null) {
                    valueAxisProperties["start"] = 0;
                }
                if (valueAxisProperties["secStart"] == null) {
                    valueAxisProperties["secStart"] = 0;
                }
            }
            CartesianHelper.forceValueDomainToZero = forceValueDomainToZero;
            function isScalar(isScalar, xAxisCardProperties) {
                if (isScalar) {
                    isScalar = xAxisCardProperties && xAxisCardProperties["axisType"] ? xAxisCardProperties["axisType"] === powerbi.axisType.scalar : true;
                }
                return isScalar;
            }
            CartesianHelper.isScalar = isScalar;
        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
        var ColorHelper = function() {
            function ColorHelper(colors, fillProp, defaultDataPointColor) {
                this.colors = colors;
                this.fillProp = fillProp;
                this.defaultDataPointColor = defaultDataPointColor;
            }
            ColorHelper.prototype.getColorForSeriesValue = function(objects, fieldIds, value) {
                return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || this.colors.getColorByScale(SQExprShortSerializer.serializeArray(fieldIds || []), value).value;
            };
            ColorHelper.prototype.getColorForMeasure = function(objects, queryName) {
                return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || this.colors.getColor(queryName).value;
            };
            ColorHelper.normalizeSelector = function(selector, isSingleSeries) {
                debug.assertAnyValue(selector, "selector");
                if (selector && (isSingleSeries || selector.data)) return {
                    data: selector.data
                };
                return selector;
            };
            return ColorHelper;
        }();
        visuals.ColorHelper = ColorHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var rectName = "rect";
        var ColumnUtil;
        (function(ColumnUtil) {
            ColumnUtil.DimmedOpacity = .4;
            ColumnUtil.DefaultOpacity = 1;
            function getTickCount(min, max, valuesMetadata, maxTickCount, is100Pct, forcedTickCount) {
                return forcedTickCount !== undefined ? maxTickCount !== 0 ? forcedTickCount : 0 : visuals.AxisHelper.getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount);
            }
            ColumnUtil.getTickCount = getTickCount;
            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                if (isScalar) {
                    var min = xAxisCardProperties["start"];
                    var max = xAxisCardProperties["end"];
                    return ColumnUtil.transformDomain(dataView, min, max);
                }
                return dataView;
            }
            ColumnUtil.applyUserMinMax = applyUserMinMax;
            function transformDomain(dataView, min, max) {
                if (!dataView.categories || dataView.categories.length === 0) return dataView;
                if (typeof min !== "number" && typeof max !== "number") return dataView;
                var category = dataView.categories[0];
                var categoryValues = category.values;
                var categoryObjects = category.objects;
                var newcategoryValues = [];
                var newValues = [];
                var newObjects = [];
                if (typeof min !== "number") {
                    min = categoryValues[0];
                }
                if (typeof max !== "number") {
                    max = categoryValues[categoryValues.length - 1];
                }
                if (min > max) return dataView;
                for (var j = 0, len = dataView.values.length; j < len; j++) {
                    newValues.push([]);
                }
                for (var t = 0, len = categoryValues.length; t < len; t++) {
                    if (categoryValues[t] >= min && categoryValues[t] <= max) {
                        newcategoryValues.push(categoryValues[t]);
                        if (categoryObjects) {
                            newObjects.push(categoryObjects[t]);
                        }
                        if (dataView.values) {
                            for (var k = 0; k < dataView.values.length; k++) {
                                newValues[k].push(dataView.values[k].values[t]);
                            }
                        }
                    }
                }
                var resultDataView = powerbi.Prototype.inherit(dataView);
                var resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values);
                var resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories);
                var resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                resultDataViewCategories0.values = newcategoryValues;
                if (resultDataViewCategories0.objects) {
                    resultDataViewCategories0.objects = newObjects;
                }
                for (var t = 0, len = dataView.values.length; t < len; t++) {
                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                    measureArray.values = newValues[t];
                }
                return resultDataView;
            }
            ColumnUtil.transformDomain = transformDomain;
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax) {
                var categoryThickness = layout.categoryThickness;
                var isScalar = layout.isScalar;
                var outerPaddingRatio = layout.outerPaddingRatio;
                var dw = new DataWrapper(data, isScalar);
                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({
                    text: true
                }), isScalar, [ forcedXMin, forcedXMax ]);
                var axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatStringProp: visuals.columnChartProps.general.formatString,
                    outerPadding: categoryThickness * outerPaddingRatio,
                    isCategoryAxis: true,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function(index, type) {
                        return dw.lookupXValue(index, type);
                    }
                });
                layout.categoryThickness = axisProperties.categoryThickness;
                return axisProperties;
            }
            ColumnUtil.getCategoryAxis = getCategoryAxis;
            function applyInteractivity(columns, onDragStart) {
                debug.assertValue(columns, "columns");
                if (onDragStart) {
                    columns.attr("draggable", "true").on("dragstart", onDragStart);
                }
            }
            ColumnUtil.applyInteractivity = applyInteractivity;
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                if (hasPartialHighlights && !highlight || hasSelection && !selected) return ColumnUtil.DimmedOpacity;
                return ColumnUtil.DefaultOpacity;
            }
            ColumnUtil.getFillOpacity = getFillOpacity;
            function getClosestColumnIndex(coordinate, columnsCenters) {
                var currentIndex = 0;
                var distance = Number.MAX_VALUE;
                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    if (currentDistance < distance) {
                        distance = currentDistance;
                        currentIndex = i;
                    }
                }
                return currentIndex;
            }
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var lastColumnUndefined = typeof lastColumnIndex === "undefined";
                series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                    return d.categoryIndex !== selectedColumnIndex && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                }).transition().style("fill-opacity", ColumnUtil.DimmedOpacity);
                series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                    return d.categoryIndex === selectedColumnIndex;
                }).style("fill-opacity", ColumnUtil.DefaultOpacity);
            }
            ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity;
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var series = colGroupSelection.data(data.series, function(d) {
                    return d.key;
                });
                series.enter().append("g").classed(visuals.ColumnChart.SeriesClasses.class, true);
                series.exit().remove();
                return series;
            }
            ColumnUtil.drawSeries = drawSeries;
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros) {
                var dataSelector;
                if (filterZeros) {
                    dataSelector = function(d) {
                        var filteredData = _.filter(d.data, function(datapoint) {
                            return !!datapoint.value;
                        });
                        return filteredData;
                    };
                } else {
                    dataSelector = function(d) {
                        return d.data;
                    };
                }
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(dataSelector, function(d) {
                    return d.key;
                });
                var hasSelection = data.hasSelection;
                shapes.enter().append(rectName).attr("class", function(d) {
                    return itemCS.class.concat(d.highlight ? " highlight" : "");
                });
                shapes.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                }).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            }
            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (isAnimator === void 0) {
                    isAnimator = false;
                }
                if (series && series.data().length > 0) {
                    var seriesData = series.data();
                    var dataPoints = [];
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    }
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
            }
            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
            function normalizeInfinityInScale(scale) {
                var scaledDomain = scale.domain();
                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
                    if (scaledDomain[i] === Number.POSITIVE_INFINITY) scaledDomain[i] = Number.MAX_VALUE; else if (scaledDomain[i] === Number.NEGATIVE_INFINITY) scaledDomain[i] = -Number.MAX_VALUE;
                }
                scale.domain(scaledDomain);
            }
            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        (function(ClusteredUtil) {
            function createValueFormatter(valuesMetadata, interval) {
                return StackedUtil.createValueFormatter(valuesMetadata, false, interval);
            }
            ClusteredUtil.createValueFormatter = createValueFormatter;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, "mainGraphicsContext");
                debug.assertValue(itemCS, "itemCS");
                var cols = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        (function(StackedUtil) {
            var constants = {
                percentFormat: "0%",
                roundingError: 1e-4
            };
            function getSize(scale, size) {
                return visuals.AxisHelper.diffScaled(scale, 0, size);
            }
            StackedUtil.getSize = getSize;
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (data.length === 0) return defaultNumberRange;
                var min = d3.min(data, function(d) {
                    return d3.min(d.data, function(e) {
                        return e.position - e.valueAbsolute;
                    });
                });
                var max = d3.max(data, function(d) {
                    return d3.max(d.data, function(e) {
                        return e.position;
                    });
                });
                if (is100pct) {
                    min = powerbi.Double.roundToPrecision(min, constants.roundingError);
                    max = powerbi.Double.roundToPrecision(max, constants.roundingError);
                }
                return {
                    min: min,
                    max: max
                };
            }
            StackedUtil.calcValueDomain = calcValueDomain;
            function getValueAxis(data, is100Pct, size, scaleRange, forcedTickCount, forcedYDomain) {
                var valueDomain = calcValueDomain(data.series, is100Pct), min = valueDomain.min, max = valueDomain.max;
                var maxTickCount = visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(size);
                var bestTickCount = ColumnUtil.getTickCount(min, max, data.valuesMetadata, maxTickCount, is100Pct, forcedTickCount);
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({
                    min: min,
                    max: max
                });
                var valueDomainNorm = [ normalizedRange.min, normalizedRange.max ];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainNorm);
                var scale = d3.scale.linear().range(scaleRange).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainNorm));
                ColumnUtil.normalizeInfinityInScale(scale);
                var yTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, scale);
                var d3Axis = d3.svg.axis().scale(scale).tickValues(yTickValues);
                var yInterval = visuals.ColumnChart.getTickInterval(yTickValues);
                var yFormatter = StackedUtil.createValueFormatter(data.valuesMetadata, is100Pct, yInterval);
                d3Axis.tickFormat(yFormatter.format);
                var values = yTickValues.map(function(d) {
                    return yFormatter.format(d);
                });
                return {
                    axis: d3Axis,
                    scale: scale,
                    formatter: yFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({
                        numeric: true
                    }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
            }
            StackedUtil.getValueAxis = getValueAxis;
            function createValueFormatter(valuesMetadata, is100Pct, interval) {
                if (is100Pct) return visuals.valueFormatter.create({
                    format: constants.percentFormat,
                    value: interval,
                    value2: 0,
                    allowFormatBeautification: true
                });
                return visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    value: interval,
                    value2: 0,
                    allowFormatBeautification: true
                });
            }
            StackedUtil.createValueFormatter = createValueFormatter;
            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                debug.assertValue(dataView, "dataView");
                debug.assertValue(rowIdx, "rowIdx");
                var pos = 0, neg = 0;
                for (var i = 0; i < seriesCount; i++) {
                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                    if (value > 0) pos += value; else if (value < 0) neg -= value;
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? pos / absTotal / pos : 1,
                    neg: neg ? neg / absTotal / neg : 1
                };
            }
            StackedUtil.getStackedMultiplier = getStackedMultiplier;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, "mainGraphicsContext");
                debug.assertValue(itemCS, "itemCS");
                var bars = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                bars.exit().remove();
            }
            StackedUtil.clearColumns = clearColumns;
        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
        var DataWrapper = function() {
            function DataWrapper(columnChartData, isScalar) {
                this.data = columnChartData;
                this.isScalar = isScalar;
            }
            DataWrapper.prototype.lookupXValue = function(index, type) {
                debug.assertValue(this.data, "this.data");
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime && this.isScalar) return new Date(index);
                var data = this.data;
                if (type.text) {
                    debug.assert(index < data.categories.length, "category index out of range");
                    return data.categories[index];
                } else {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            if (this.data.hasHighlights) index = index * 2;
                            var dataPoint = seriesValues[index];
                            if (dataPoint) {
                                if (isDateTime) return new Date(dataPoint.categoryValue);
                                return dataPoint.categoryValue;
                            }
                        }
                    }
                }
                return index;
            };
            return DataWrapper;
        }();
        visuals.DataWrapper = DataWrapper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var converterHelper;
        (function(converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    return category.source && visuals.DataRoleHelper.hasRole(category.source, seriesRoleName) && visuals.DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return false;
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    var categoryValues = category.values;
                    return category.values.length > 0 ? {
                        categories: categoryValues,
                        categoryFormatter: visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                            value: categoryValues[0],
                            value2: categoryValues[categoryValues.length - 1],
                            displayUnitSystemType: 1
                        }),
                        categoryIdentities: category.identity,
                        categoryObjects: category.objects
                    } : {
                        categories: [],
                        categoryFormatter: {
                            format: visuals.valueFormatter.format
                        }
                    };
                }
                return defaultCategories();
            }
            converterHelper.getPivotedCategories = getPivotedCategories;
            function getSeriesName(source) {
                debug.assertValue(source, "source");
                return source.groupName !== undefined ? source.groupName : source.queryName;
            }
            converterHelper.getSeriesName = getSeriesName;
            function getFormattedLegendLabel(source, values, formatStringProp) {
                debug.assertValue(source, "source");
                debug.assertValue(values, "values");
                var sourceForFormat = source;
                var nameForFormat = source.displayName;
                if (source.groupName !== undefined) {
                    sourceForFormat = values.source;
                    nameForFormat = source.groupName;
                }
                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
            function defaultCategories() {
                return {
                    categories: [ null ],
                    categoryFormatter: {
                        format: visuals.valueFormatter.format
                    }
                };
            }
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null;
                var yAxisLabel = null;
                if (categoryAxisProperties) {
                    if (category && category.displayName) {
                        xAxisLabel = category.displayName;
                    }
                }
                if (valueAxisProperties) {
                    var valuesNames = [];
                    if (values) {
                        valuesNames = values.map(function(v) {
                            return v ? v.displayName : "";
                        }).filter(function(value, index, self) {
                            return value !== "" && self.indexOf(value) === index;
                        });
                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
                    }
                }
                return {
                    xAxisLabel: xAxisLabel,
                    yAxisLabel: yAxisLabel
                };
            }
            converterHelper.createAxesLabels = createAxesLabels;
        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        (function(PointLabelPosition) {
            PointLabelPosition[PointLabelPosition["Above"] = 0] = "Above";
            PointLabelPosition[PointLabelPosition["Bellow"] = 1] = "Bellow";
        })(visuals.PointLabelPosition || (visuals.PointLabelPosition = {}));
        var PointLabelPosition = visuals.PointLabelPosition;
        var dataLabelUtils;
        (function(dataLabelUtils) {
            dataLabelUtils.labelMargin = 8;
            dataLabelUtils.maxLabelWidth = 50;
            dataLabelUtils.defaultColumnLabelMargin = 5;
            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
            dataLabelUtils.LabelTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: "12px",
                fontWeight: "bold"
            };
            dataLabelUtils.defaultLabelColor = "#696969";
            dataLabelUtils.defaultInsideLabelColor = "#fff";
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
            var defaultLabelPrecision = 2;
            var labelsClass = {
                "class": "data-labels",
                selector: ".data-labels"
            };
            function getDefaultLabelSettings(show, labelColor) {
                if (show === void 0) {
                    show = false;
                }
                return {
                    show: show,
                    position: 0,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null
                };
            }
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultTreemapLabelSettings() {
                return getDefaultLabelSettings(true, "#fff");
            }
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(false);
                labelSettings.position = null;
                labelSettings.labelColor = isLabelPositionInside ? dataLabelUtils.defaultInsideLabelColor : null;
                return labelSettings;
            }
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null
                };
            }
            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function getDefaultDonutLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: true,
                    formatterOptions: null
                };
            }
            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration) {
                if (isAnimator === void 0) {
                    isAnimator = false;
                }
                debug.assertValue(data, "data could not be null or undefined");
                var dataLabelManager = new powerbi.DataLabelManager();
                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
                var labels = context.selectAll(labelsClass.selector).data(filteredData);
                labels.enter().append("text").classed(labelsClass.class, true);
                labels.attr({
                    x: function(d) {
                        return d.labelX;
                    },
                    y: function(d) {
                        return d.labelY;
                    }
                }).text(function(d) {
                    return d.labeltext;
                }).style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels.exit().remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            function drawDefaultLabelsForFunnelChart(data, context, layout, isAnimator, animationDuration) {
                if (isAnimator === void 0) {
                    isAnimator = false;
                }
                debug.assertValue(data, "data could not be null or undefined");
                var filteredData = data.filter(layout.filter);
                var labels = context.selectAll(labelsClass.selector).data(filteredData);
                labels.enter().append("text").classed(labelsClass.class, true);
                labels.attr(layout.labelLayout).text(layout.labelText).style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels.exit().remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForFunnelChart = drawDefaultLabelsForFunnelChart;
            function cleanDataLabels(context) {
                var empty = [];
                var labels = context.selectAll(labelsClass.selector).data(empty);
                labels.exit().remove();
            }
            dataLabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", function(d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                });
            }
            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(label, maxWidth, format) {
                var properties = {
                    text: powerbi.formattingService.formatValue(label, format),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                };
                maxWidth = maxWidth ? maxWidth : dataLabelUtils.maxLabelWidth;
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxWidth);
            }
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function(d) {
                        return getLabelFormattedText(d.labeltext);
                    },
                    labelLayout: {
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 ? d.y - margin : d.y + margin;
                        }
                    },
                    filter: function(d) {
                        return d != null && d.labeltext != null;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        }
                    }
                };
            }
            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions) {
                var value2 = null;
                if (data.labelSettings.displayUnits === 0 && axisFormatter && axisFormatter.displayUnit) value2 = axisFormatter.displayUnit.value;
                var formatOverride = isHundredPercent ? dataLabelUtils.hundredPercentFormat : null;
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(data.labelSettings, formatOverride, value2));
                var hasSelection = false;
                for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                    var dataPoints = data.series[i].data;
                    if (visuals.dataHasSelection(dataPoints)) hasSelection = true;
                }
                return {
                    labelText: function(d) {
                        return getLabelFormattedText(formatter.format(d.value), dataLabelUtils.maxLabelWidth);
                    },
                    labelLayout: labelLayoutXY,
                    filter: function(d) {
                        return d != null && d.value != null && d.value !== 0 && validateLabelsSize(d, axisOptions);
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "text-anchor": isColumn ? "middle" : "start",
                        "fill-opacity": function(d) {
                            var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights) < 1 ? 0 : 1;
                            return labelOpacity;
                        }
                    }
                };
            }
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            function validateLabelsSize(d, axisOptions) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var columnWidth = axisOptions.columnWidth;
                var properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                };
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.measureSvgTextHeight(properties);
                var shapeWidth, shapeHeight;
                var inside = false;
                switch (d.chartType) {
                  case visuals.ColumnChartType.stackedBar:
                    shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                    shapeHeight = columnWidth;
                    inside = d.lastSeries ? false : true;
                    break;

                  case visuals.ColumnChartType.hundredPercentStackedBar:
                    shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                    shapeHeight = columnWidth;
                    inside = true;
                    break;

                  case visuals.ColumnChartType.stackedColumn:
                    shapeWidth = columnWidth;
                    shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                    inside = d.lastSeries ? false : true;
                    break;

                  case visuals.ColumnChartType.hundredPercentStackedColumn:
                    shapeWidth = columnWidth;
                    shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                    inside = true;
                    break;

                  default:
                    return true;
                }
                if (inside && (textWidth > shapeWidth || textHeight > shapeHeight)) return false;
                return true;
            }
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function(d) {
                        return getLabelFormattedText(d.category);
                    },
                    labelLayout: {
                        x: function(d) {
                            return xScale(d.x);
                        },
                        y: function(d) {
                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 ? yScale(d.y) - margin : yScale(d.y) + margin;
                        }
                    },
                    filter: function(d) {
                        return d != null && d.category != null;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "fill-opacity": function(d) {
                            return visuals.ScatterChart.getBubbleOpacity(d, false);
                        },
                        "font-family": dataLabelUtils.LabelTextProperties.fontFamily,
                        "font-size": dataLabelUtils.LabelTextProperties.fontSize,
                        "font-weight": dataLabelUtils.LabelTextProperties.fontWeight
                    }
                };
            }
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar) {
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(labelSettings));
                return {
                    labelText: function(d) {
                        return getLabelFormattedText(formatter.format(d.value));
                    },
                    labelLayout: {
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex);
                        },
                        y: function(d) {
                            return labelSettings.position === 0 ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin;
                        }
                    },
                    filter: function(d) {
                        return d != null && d.value != null;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "fill-opacity": 1,
                        "font-family": dataLabelUtils.LabelTextProperties.fontFamily,
                        "font-size": dataLabelUtils.LabelTextProperties.fontSize,
                        "font-weight": dataLabelUtils.LabelTextProperties.fontWeight
                    }
                };
            }
            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            function getFunnelChartLabelLayout(data, axisOptions, innerTextHeightDelta, textMinimumPadding, labelSettings, currentViewport) {
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var marginLeft = axisOptions.margin.left;
                var halfRangeBandPlusDelta = axisOptions.xScale.rangeBand() / 2 + innerTextHeightDelta;
                var pixelSpan = axisOptions.verticalRange / 2;
                var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString);
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                var formatter = visuals.valueFormatter.create(dataLabelUtils.getLabelFormatterOptions(labelSettings, formatString));
                return {
                    labelText: function(d) {
                        var barWidth = Math.abs(yScale(d.value) - yScale(0));
                        var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - textMinimumPadding * 2;
                        var outsideAvailableSpace = pixelSpan - barWidth / 2 - textMinimumPadding;
                        var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                        return getLabelFormattedText(formatter.format(d.value), maximumTextSize);
                    },
                    labelLayout: {
                        y: function(d, i) {
                            return xScale(i) + halfRangeBandPlusDelta;
                        },
                        x: function(d) {
                            var barWidth = Math.abs(yScale(d.value) - yScale(0));
                            var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - textMinimumPadding * 2;
                            var outsideAvailableSpace = pixelSpan - barWidth / 2 - textMinimumPadding;
                            var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                            var properties = {
                                text: getLabelFormattedText(formatter.format(d.value), maximumTextSize),
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                            };
                            var textLength = textMeasurer(properties);
                            var labelPosition = labelSettings.position;
                            if (labelPosition === powerbi.labelPosition.outsideEnd && outsideAvailableSpace < textLength) labelPosition = powerbi.labelPosition.insideCenter; else if (labelPosition === powerbi.labelPosition.insideCenter && insideAvailableSpace < textLength) {
                                labelPosition = powerbi.labelPosition.outsideEnd;
                            }
                            switch (labelPosition) {
                              case powerbi.labelPosition.outsideEnd:
                                d.labelFill = d.labelFill === "#FFFFFF" ? d.color : d.labelFill;
                                return marginLeft + pixelSpan + barWidth / 2 + textMinimumPadding + textLength / 2;

                              default:
                                d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : "#FFFFFF";
                                return marginLeft + pixelSpan;
                            }
                        }
                    },
                    filter: function(d) {
                        return d != null && d.value != null;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        },
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, false, false, false);
                        }
                    }
                };
            }
            dataLabelUtils.getFunnelChartLabelLayout = getFunnelChartLabelLayout;
            function enumerateDataLabels(dataLabelsSettings, withPosition, withPrecision, withDisplayUnit, labelPositionObjects) {
                if (withPrecision === void 0) {
                    withPrecision = false;
                }
                if (withDisplayUnit === void 0) {
                    withDisplayUnit = false;
                }
                if (!dataLabelsSettings) return [];
                var instance = {
                    objectName: "labels",
                    selector: null,
                    properties: {
                        show: dataLabelsSettings.show,
                        color: dataLabelsSettings.labelColor
                    },
                    validValues: labelPositionObjects
                };
                if (withDisplayUnit) {
                    instance.properties["labelDisplayUnits"] = dataLabelsSettings.displayUnits;
                }
                if (withPrecision) {
                    instance.properties["labelPrecision"] = dataLabelsSettings.precision;
                }
                if (withPosition) {
                    instance.properties["labelPosition"] = dataLabelsSettings.position;
                }
                return [ instance ];
            }
            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(dataLabelsSettings, withFill, isDonutChart) {
                if (isDonutChart === void 0) {
                    isDonutChart = false;
                }
                var labelSettings = dataLabelsSettings ? dataLabelsSettings : isDonutChart ? getDefaultDonutLabelSettings() : getDefaultPointLabelSettings();
                var instance = {
                    objectName: "categoryLabels",
                    selector: null,
                    properties: {
                        show: isDonutChart ? labelSettings.showCategory : labelSettings.show
                    }
                };
                if (withFill) {
                    instance.properties["color"] = labelSettings.labelColor;
                }
                return [ instance ];
            }
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function getDefaultFunnelLabelSettings(defaultColor) {
                return {
                    show: true,
                    position: powerbi.labelPosition.insideCenter,
                    displayUnits: 0,
                    overrideDefaultColor: false,
                    precision: defaultLabelPrecision,
                    labelColor: defaultColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null
                };
            }
            dataLabelUtils.getDefaultFunnelLabelSettings = getDefaultFunnelLabelSettings;
            function getLabelFormatterOptions(labelSetting, formatOverride, value2) {
                var displayUnits = labelSetting.displayUnits === 1e3 ? 1e4 : labelSetting.displayUnits;
                if (formatOverride) {
                    return {
                        format: formatOverride,
                        precision: labelSetting.precision,
                        value: displayUnits,
                        value2: value2,
                        allowFormatBeautification: true
                    };
                }
                return {
                    format: labelSetting && labelSetting.formatterOptions ? labelSetting.formatterOptions.format : null,
                    precision: labelSetting.precision,
                    value: displayUnits,
                    value2: value2,
                    allowFormatBeautification: true
                };
            }
            dataLabelUtils.getLabelFormatterOptions = getLabelFormatterOptions;
            function getFormatterOptionsColumn(columns) {
                if (columns) {
                    return _.find(columns, function(col) {
                        return col.format != null;
                    });
                }
                return null;
            }
            dataLabelUtils.getFormatterOptionsColumn = getFormatterOptionsColumn;
        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DataRoleHelper;
        (function(DataRoleHelper) {
            function getMeasureIndexOfRole(grouped, roleName, defaultIndexIfNoRole) {
                if (grouped && grouped.length > 0) {
                    var firstGroup = grouped[0];
                    if (firstGroup.values && firstGroup.values.length > 0) {
                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {
                            var value = firstGroup.values[i];
                            if (value && value.source) {
                                if (hasRole(value.source, roleName)) return i;
                                if (len > defaultIndexIfNoRole) return defaultIndexIfNoRole;
                            }
                        }
                    }
                }
                return -1;
            }
            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;
            function hasRole(column, name) {
                var roles = column.roles;
                return roles && roles[name];
            }
            DataRoleHelper.hasRole = hasRole;
            function hasRoleInDataView(dataView, name) {
                return dataView != null && dataView.metadata != null && dataView.metadata.columns && _.any(dataView.metadata.columns, function(c) {
                    return c.roles && c.roles[name] !== undefined;
                });
            }
            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;
        })(DataRoleHelper = visuals.DataRoleHelper || (visuals.DataRoleHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var VisualInteractivityFactory;
        (function(VisualInteractivityFactory) {
            function buildInteractivityService(options) {
                if (options.interactivity && options.interactivity.selection) {
                    return visuals.createInteractivityService(options.host);
                } else if (options.interactivity && options.interactivity.isInteractiveLegend) {
                    return new visuals.MobileInteractivityService();
                }
                return null;
            }
            VisualInteractivityFactory.buildInteractivityService = buildInteractivityService;
        })(VisualInteractivityFactory = visuals.VisualInteractivityFactory || (visuals.VisualInteractivityFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
            var checker = new InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity);
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = function() {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                this.supportsNaN = supportsNaN;
                this.supportsNegativeInfinity = supportsNegativeInfinity;
                this.supportsPositiveInfinity = supportsPositiveInfinity;
            }
            InvalidDataValuesChecker.prototype.getWarningMessages = function(dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                if (this.hasNaN && !this.supportsNaN) {
                    warnings.push(new visuals.NaNNotSupportedWarning());
                }
                if (this.hasNegativeInfinity && !this.supportsNegativeInfinity || this.hasPositiveInfinity && !this.supportsPositiveInfinity) {
                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
                }
                if (this.hasOutOfRange) {
                    warnings.push(new visuals.ValuesOutOfRangeWarning());
                }
                return warnings;
            };
            InvalidDataValuesChecker.prototype.loadWarningStatus = function(dataViews) {
                this.hasNaN = false;
                this.hasNegativeInfinity = false;
                this.hasOutOfRange = false;
                this.hasPositiveInfinity = false;
                for (var k = 0; k < dataViews.length; k++) {
                    var dataView = dataViews[k];
                    var values = dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values : null;
                    if (!values) return;
                    var valueLength = values.length;
                    for (var i = 0; i < valueLength; i++) {
                        var value = values[i];
                        if (value.values) {
                            var valueValueLength = value.values.length;
                            for (var j = 0; j < valueValueLength; j++) {
                                var v = value.values[j];
                                if (isNaN(v)) this.hasNaN = true; else if (v === Number.POSITIVE_INFINITY) this.hasPositiveInfinity = true; else if (v === Number.NEGATIVE_INFINITY) this.hasNegativeInfinity = true; else if (v < -1e300 || v > 1e300) this.hasOutOfRange = true;
                            }
                        }
                    }
                }
            };
            return InvalidDataValuesChecker;
        }();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ListViewFactory;
        (function(ListViewFactory) {
            function createHTMLListView(options) {
                return new ListView(options, 1);
            }
            ListViewFactory.createHTMLListView = createHTMLListView;
            function createSVGListView(options) {
                return new ListView(options, 0);
            }
            ListViewFactory.createSVGListView = createSVGListView;
        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        var ListViewMode;
        (function(ListViewMode) {
            ListViewMode[ListViewMode["SVG"] = 0] = "SVG";
            ListViewMode[ListViewMode["HTML"] = 1] = "HTML";
        })(ListViewMode || (ListViewMode = {}));
        var ListView = function() {
            function ListView(options, mode) {
                var _this = this;
                this.options = options;
                this.mode = mode;
                this.options.baseContainer.style("overflow-y", "auto").on("scroll", function() {
                    return _this.render(false);
                });
                this.scrollContainer = options.baseContainer.append(mode === 0 ? "svg" : "div").attr("class", "scrollRegion");
                this.visibleGroupContainer = this.scrollContainer.append(mode === 0 ? "g" : "div").attr("class", "visibleGroup");
                ListView.SetDefaultOptions(options);
                this.position = 0;
            }
            ListView.SetDefaultOptions = function(options) {
                options.rowHeight = options.rowHeight || 1;
            };
            ListView.prototype.rowHeight = function(rowHeight) {
                this.options.rowHeight = rowHeight;
                return this;
            };
            ListView.prototype.data = function(data, dataIdFunction) {
                this._data = data;
                this._dataIdFunction = dataIdFunction;
                this._totalRows = data ? data.length : 0;
                return this;
            };
            ListView.prototype.viewport = function(viewport) {
                this.options.viewport = viewport;
                return this;
            };
            ListView.prototype.empty = function() {
                this._data = [];
                this.render(false, true);
            };
            ListView.prototype.render = function(sizeChanged, resetScrollbarPosition) {
                if (sizeChanged === void 0) {
                    sizeChanged = false;
                }
                if (resetScrollbarPosition === void 0) {
                    resetScrollbarPosition = false;
                }
                if (!(this._data && this.options)) return;
                var scrollTop;
                var options = this.options;
                var rowHeight = options.rowHeight;
                debug.assertValue(rowHeight, "rowHeight");
                debug.assert(rowHeight > 0, "rowHeight should be more than 0");
                if (resetScrollbarPosition) {
                    this.position = 0;
                    scrollTop = 0;
                    $(options.baseContainer.node()).scrollTop(scrollTop);
                } else scrollTop = options.baseContainer.node().scrollTop;
                if (sizeChanged) {
                    var height = options.viewport.height;
                    this.visibleRows = Math.ceil(height / rowHeight) + 1;
                }
                var totalHeight = Math.max(0, this._totalRows * rowHeight);
                this.scrollContainer.style("height", totalHeight + "px").attr("height", totalHeight);
                var lastPosition = this.position;
                var position = this.position = Math.floor(scrollTop / rowHeight);
                this.delta = position - lastPosition;
                this.scrollToFrame(position);
            };
            ListView.prototype.scrollToFrame = function(scrollPosition) {
                var options = this.options;
                var visibleGroupContainer = this.visibleGroupContainer;
                var totalRows = this._totalRows;
                var rowHeight = options.rowHeight;
                var visibleRows = this.visibleRows;
                var translateY = scrollPosition * rowHeight;
                visibleGroupContainer.attr("transform", function(d) {
                    return visuals.SVGUtil.translate(0, translateY);
                }).style("transform", function(d) {
                    return visuals.SVGUtil.translateWithPixels(0, translateY);
                });
                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows;
                var rowSelection = visibleGroupContainer.selectAll(".row").data(this._data.slice(position0, Math.min(position1, totalRows)), this._dataIdFunction);
                rowSelection.enter().append("g").classed("row", true).call(function(d) {
                    return options.enter(d);
                });
                rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll(".row:not(.transitioning)");
                rowUpdateSelection.call(function(d) {
                    return options.update(d);
                });
                if (this.mode === 0) {
                    rowUpdateSelection.each(function(d, i) {
                        var translate = visuals.SVGUtil.translate(0, i * rowHeight);
                        d3.select(this).attr("transform", function(d) {
                            return translate;
                        }).style("transform", function(d) {
                            return translate;
                        });
                    });
                }
                rowSelection.exit().call(function(d) {
                    return options.exit(d);
                }).remove();
                if (position1 >= totalRows * ListView.loadMoreDataThreshold) options.loadMoreData();
            };
            ListView.loadMoreDataThreshold = .8;
            return ListView;
        }();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Selector = powerbi.data.Selector;
        var SelectionId = function() {
            function SelectionId(selector, highlight) {
                this.selector = selector;
                this.highlight = highlight;
                this.key = JSON.stringify({
                    selector: selector ? Selector.getKey(selector) : null,
                    highlight: highlight
                });
            }
            SelectionId.prototype.equals = function(other) {
                if (!this.selector || !other.selector) {
                    return !this.selector === !other.selector && this.highlight === other.highlight;
                }
                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);
            };
            SelectionId.prototype.includes = function(other, ignoreHighlight) {
                if (ignoreHighlight === void 0) {
                    ignoreHighlight = false;
                }
                var thisSelector = this.selector;
                var otherSelector = other.selector;
                if (!thisSelector || !otherSelector) {
                    return false;
                }
                var thisData = thisSelector.data;
                var otherData = otherSelector.data;
                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata)) return false;
                if (!ignoreHighlight && this.highlight !== other.highlight) return false;
                if (thisData) {
                    if (!otherData) return false;
                    if (thisData.length > 0) {
                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {
                            var thisValue = thisData[i];
                            if (!otherData.some(function(otherValue) {
                                return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue);
                            })) return false;
                        }
                    }
                }
                return true;
            };
            SelectionId.prototype.getKey = function() {
                return this.key;
            };
            SelectionId.prototype.hasIdentity = function() {
                return this.selector && !!this.selector.data;
            };
            SelectionId.prototype.getSelector = function() {
                return this.selector;
            };
            SelectionId.createNull = function(highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                return new SelectionId(null, highlight);
            };
            SelectionId.createWithId = function(id, highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                var selector = null;
                if (id) {
                    selector = {
                        data: [ id ]
                    };
                }
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithMeasure = function(measureId, highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                var selector = {};
                if (measureId) selector.metadata = measureId;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdAndMeasure = function(id, measureId, highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                var selector = {};
                if (id) {
                    selector.data = [ id ];
                }
                if (measureId) selector.metadata = measureId;
                if (!id && !measureId) selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIds = function(id1, id2, highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                var selector = null;
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData) selector = {
                    data: selectorData
                };
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdsAndMeasure = function(id1, id2, measureId, highlight) {
                if (highlight === void 0) {
                    highlight = false;
                }
                var selector = {};
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData) selector.data = selectorData;
                if (measureId) selector.metadata = measureId;
                if (!id1 && !id2 && !measureId) selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithHighlight = function(original) {
                debug.assertValue(original, "original");
                debug.assert(!original.highlight, "!original.highlight");
                return new SelectionId(original.getSelector(), true);
            };
            SelectionId.idArray = function(id1, id2) {
                if (id1 || id2) {
                    var data = [];
                    if (id1) data.push(id1);
                    if (id2 && id2 !== id1) data.push(id2);
                    return data;
                }
            };
            return SelectionId;
        }();
        visuals.SelectionId = SelectionId;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        "use strict";
        var shapes;
        (function(shapes) {
            var Utility = jsCommon.Utility;
            var Point;
            (function(Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = point.x + offsetX >= 0 ? point.x + offsetX : 0;
                    var newPointY = point.y + offsetY >= 0 ? point.y + offsetY : 0;
                    return {
                        x: newPointX,
                        y: newPointY
                    };
                }
                Point.offset = offset;
                function equals(point, other) {
                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
                }
                Point.equals = equals;
                function clone(point) {
                    return point !== null ? {
                        x: point.x,
                        y: point.y
                    } : null;
                }
                Point.clone = clone;
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                Point.toString = toString;
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                Point.serialize = serialize;
                function getDistance(point, other) {
                    if (point === null || other === null) {
                        return null;
                    }
                    var diffX = other.x - point.x;
                    var diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                Point.getDistance = getDistance;
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 || point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y);
                }
                Point.equalWithPrecision = equalWithPrecision;
                function parsePoint(value, defaultValue) {
                    if (value === null) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else if (value === undefined) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else {
                        if (value.length === 2) {
                            return {
                                x: Utility.parseNumber(value[0]),
                                y: Utility.parseNumber(value[1])
                            };
                        } else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return defaultValue === undefined ? null : defaultValue;
                            }
                            return {
                                x: Utility.parseNumber(parts[0]),
                                y: Utility.parseNumber(parts[1])
                            };
                        } else if (value.length !== 2 && typeof value !== "string") {
                            return defaultValue === undefined ? null : defaultValue;
                        } else {
                            return {
                                x: Utility.parseNumber(value.x),
                                y: Utility.parseNumber(value.y)
                            };
                        }
                    }
                }
                Point.parsePoint = parsePoint;
            })(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            (function(Size) {
                function isEmpty(size) {
                    return size.width === 0 && size.height === 0;
                }
                Size.isEmpty = isEmpty;
                function equals(size, other) {
                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
                }
                Size.equals = equals;
                function clone(size) {
                    return size !== null ? {
                        width: size.width,
                        height: size.height
                    } : null;
                }
                Size.clone = clone;
                function inflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Size.inflate = inflate;
                function deflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width = result.width - padding.left - padding.right;
                        if (result.width < 0) {
                            result.width = 0;
                        }
                        result.height = result.height - padding.top - padding.bottom;
                        if (result.height < 0) {
                            result.height = 0;
                        }
                    }
                    return result;
                }
                Size.deflate = deflate;
                function combine(size, other) {
                    if (other) {
                        size.width = Math.max(size.width, other.width);
                        size.height = Math.max(size.height, other.height);
                    }
                    return size;
                }
                Size.combine = combine;
                function toRect(size) {
                    return {
                        left: 0,
                        top: 0,
                        width: size.width,
                        height: size.height
                    };
                }
                Size.toRect = toRect;
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                Size.toString = toString;
                function equal(size1, size2) {
                    return size1 === size2 || size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height;
                }
                Size.equal = equal;
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 || size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height);
                }
                Size.equalWithPrecision = equalWithPrecision;
                function parseSize(value, defaultValue) {
                    if (value === null) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else if (value === undefined) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else {
                        if (value.length === 2) {
                            return {
                                width: Utility.parseNumber(value[0]),
                                height: Utility.parseNumber(value[1])
                            };
                        } else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return defaultValue === undefined ? null : defaultValue;
                            }
                            return {
                                width: Utility.parseNumber(parts[0]),
                                height: Utility.parseNumber(parts[1])
                            };
                        } else if (value.length !== 2 && typeof value !== "string") {
                            return defaultValue === undefined ? null : defaultValue;
                        } else {
                            return {
                                width: Utility.parseNumber(value.width),
                                height: Utility.parseNumber(value.height)
                            };
                        }
                    }
                }
                Size.parseSize = parseSize;
            })(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            (function(Rect) {
                function getOffset(rect) {
                    return {
                        x: rect.left,
                        y: rect.top
                    };
                }
                Rect.getOffset = getOffset;
                function getSize(rect) {
                    return {
                        width: rect.width,
                        height: rect.height
                    };
                }
                Rect.getSize = getSize;
                function setSize(rect, value) {
                    rect.width = value.width;
                    rect.height = value.height;
                }
                Rect.setSize = setSize;
                function right(rect) {
                    return rect.left + rect.width;
                }
                Rect.right = right;
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                Rect.bottom = bottom;
                function topLeft(rect) {
                    return {
                        x: rect.left,
                        y: rect.top
                    };
                }
                Rect.topLeft = topLeft;
                function topRight(rect) {
                    return {
                        x: rect.left + rect.width,
                        y: rect.top
                    };
                }
                Rect.topRight = topRight;
                function bottomLeft(rect) {
                    return {
                        x: rect.left,
                        y: rect.top + rect.height
                    };
                }
                Rect.bottomLeft = bottomLeft;
                function bottomRight(rect) {
                    return {
                        x: rect.left + rect.width,
                        y: rect.top + rect.height
                    };
                }
                Rect.bottomRight = bottomRight;
                function equals(rect, other) {
                    return other !== undefined && other !== null && rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                Rect.equals = equals;
                function clone(rect) {
                    return rect !== null ? {
                        left: rect.left,
                        top: rect.top,
                        width: rect.width,
                        height: rect.height
                    } : null;
                }
                Rect.clone = clone;
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                Rect.toString = toString;
                function offset(rect, offsetX, offsetY) {
                    var newLeft = rect.left + offsetX >= 0 ? rect.left + offsetX : 0;
                    var newTop = rect.top + offsetY >= 0 ? rect.top + offsetY : 0;
                    return {
                        left: newLeft,
                        top: newTop,
                        width: rect.width,
                        height: rect.height
                    };
                }
                Rect.offset = offset;
                function inflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left -= padding.left;
                        result.top -= padding.top;
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.inflate = inflate;
                function deflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left += padding.left;
                        result.top += padding.top;
                        result.width -= padding.left + padding.right;
                        result.height -= padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.deflate = deflate;
                function inflateBy(rect, padding) {
                    return {
                        left: rect.left - padding,
                        top: rect.top - padding,
                        width: rect.width + padding + padding,
                        height: rect.height + padding + padding
                    };
                }
                Rect.inflateBy = inflateBy;
                function deflateBy(rect, padding) {
                    return {
                        left: rect.left + padding,
                        top: rect.top + padding,
                        width: rect.width - padding - padding,
                        height: rect.height - padding - padding
                    };
                }
                Rect.deflateBy = deflateBy;
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                Rect.getClosestPoint = getClosestPoint;
                function equal(rect1, rect2) {
                    return rect1 === rect2 || rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height;
                }
                Rect.equal = equal;
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 || rect1 !== undefined && rect2 !== undefined && powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) && powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height);
                }
                Rect.equalWithPrecision = equalWithPrecision;
                function isEmpty(rect) {
                    return rect === undefined || rect === null || rect.width === 0 && rect.height === 0;
                }
                Rect.isEmpty = isEmpty;
                function containsPoint(rect, point) {
                    if (rect === null || point === null) {
                        return false;
                    }
                    return rect.left <= point.x && point.x <= rect.left + rect.width && rect.top <= point.y && point.y <= rect.top + rect.height;
                }
                Rect.containsPoint = containsPoint;
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) {
                        return false;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    if (left > right) {
                        return false;
                    }
                    var top = Math.max(rect1.top, rect2.top);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return top <= bottom;
                }
                Rect.isIntersecting = isIntersecting;
                function intersect(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var top = Math.max(rect1.top, rect2.top);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    if (left <= right && top <= bottom) {
                        return {
                            left: left,
                            top: top,
                            width: right - left,
                            height: bottom - top
                        };
                    } else {
                        return {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        };
                    }
                }
                Rect.intersect = intersect;
                function combine(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.min(rect1.left, rect2.left);
                    var top = Math.min(rect1.top, rect2.top);
                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return {
                        left: left,
                        top: top,
                        width: right - left,
                        height: bottom - top
                    };
                }
                Rect.combine = combine;
                function parseRect(value, defaultValue) {
                    if (value === null) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else if (value === undefined) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else {
                        if (value.length === 4) {
                            return {
                                left: Utility.parseNumber(value[0]),
                                top: Utility.parseNumber(value[1]),
                                width: Utility.parseNumber(value[2]),
                                height: Utility.parseNumber(value[3])
                            };
                        } else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return defaultValue === undefined ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]),
                                top: Utility.parseNumber(parts[1]),
                                width: Utility.parseNumber(parts[2]),
                                height: Utility.parseNumber(parts[3])
                            };
                        } else if (value.length !== 4 && typeof value !== "string") {
                            return defaultValue === undefined ? null : defaultValue;
                        } else {
                            return {
                                left: Utility.parseNumber(value.left),
                                top: Utility.parseNumber(value.top),
                                width: Utility.parseNumber(value.width),
                                height: Utility.parseNumber(value.height)
                            };
                        }
                    }
                }
                Rect.parseRect = parseRect;
            })(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            (function(Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    if (other) {
                        result.left = thickness.left + other.left;
                        result.right = thickness.right + other.right;
                        result.bottom = thickness.bottom + other.bottom;
                        result.top = thickness.top + other.top;
                    }
                    return result;
                }
                Thickness.inflate = inflate;
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                Thickness.getWidth = getWidth;
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                Thickness.getHeight = getHeight;
                function clone(thickness) {
                    return thickness !== null ? {
                        left: thickness.left,
                        top: thickness.top,
                        right: thickness.right,
                        bottom: thickness.bottom
                    } : null;
                }
                Thickness.clone = clone;
                function equals(thickness, other) {
                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                Thickness.equals = equals;
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left;
                    thickness.left = temp;
                }
                Thickness.flipHorizontal = flipHorizontal;
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom;
                    thickness.bottom = top;
                }
                Thickness.flipVertical = flipVertical;
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                Thickness.toString = toString;
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                Thickness.toCssString = toCssString;
                function isEmpty(thickness) {
                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
                }
                Thickness.isEmpty = isEmpty;
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 || thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom;
                }
                Thickness.equal = equal;
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 || thickness1 !== undefined && thickness2 !== undefined && powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) && powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom);
                }
                Thickness.equalWithPrecision = equalWithPrecision;
                function parseThickness(value, defaultValue, resetValue) {
                    if (value === null) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else if (value === undefined) {
                        return defaultValue === undefined ? null : defaultValue;
                    } else {
                        if (value.length === 4) {
                            return {
                                left: Utility.parseNumber(value[0]),
                                top: Utility.parseNumber(value[1]),
                                right: Utility.parseNumber(value[2]),
                                bottom: Utility.parseNumber(value[3])
                            };
                        } else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return defaultValue === undefined ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]),
                                top: Utility.parseNumber(parts[1]),
                                right: Utility.parseNumber(parts[2]),
                                bottom: Utility.parseNumber(parts[3])
                            };
                        } else if (value.length !== 4 && typeof value !== "string") {
                            return defaultValue === undefined ? null : defaultValue;
                        } else {
                            return {
                                left: Utility.parseNumber(value.left),
                                top: Utility.parseNumber(value.top),
                                right: Utility.parseNumber(value.right),
                                bottom: Utility.parseNumber(value.bottom)
                            };
                        }
                    }
                }
                Thickness.parseThickness = parseThickness;
            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            (function(Vector) {
                function isEmpty(vector) {
                    return vector.x === 0 && vector.y === 0;
                }
                Vector.isEmpty = isEmpty;
                function equals(vector, other) {
                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
                }
                Vector.equals = equals;
                function clone(vector) {
                    return vector !== null ? {
                        x: vector.x,
                        y: vector.y
                    } : null;
                }
                Vector.clone = clone;
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                Vector.toString = toString;
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                Vector.getLength = getLength;
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                Vector.getLengthSqr = getLengthSqr;
                function scale(vector, scalar) {
                    return {
                        x: vector.x * scalar,
                        y: vector.y * scalar
                    };
                }
                Vector.scale = scale;
                function normalize(vector) {
                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
                }
                Vector.normalize = normalize;
                function rotate90DegCW(vector) {
                    return {
                        x: vector.y,
                        y: -vector.x
                    };
                }
                Vector.rotate90DegCW = rotate90DegCW;
                function rotate90DegCCW(vector) {
                    return {
                        x: -vector.y,
                        y: vector.x
                    };
                }
                Vector.rotate90DegCCW = rotate90DegCCW;
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return {
                        x: newX,
                        y: newY
                    };
                }
                Vector.rotate = rotate;
                function equal(vector1, vector2) {
                    return vector1 === vector2 || vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y;
                }
                Vector.equal = equal;
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 || vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y);
                }
                Vector.equalWithPrecision = equalWithPrecision;
                function add(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return {
                        x: vect1.x + vect2.x,
                        y: vect1.y + vect2.y
                    };
                }
                Vector.add = add;
                function subtract(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return {
                        x: vect1.x - vect2.x,
                        y: vect1.y - vect2.y
                    };
                }
                Vector.subtract = subtract;
                function dotProduct(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return vect1.x * vect2.x + vect1.y * vect2.y;
                }
                Vector.dotProduct = dotProduct;
                function getDeltaVector(p0, p1) {
                    if (!p0 || !p1) {
                        return undefined;
                    }
                    return {
                        x: p1.x - p0.x,
                        y: p1.y - p0.y
                    };
                }
                Vector.getDeltaVector = getDeltaVector;
            })(Vector = shapes.Vector || (shapes.Vector = {}));
        })(shapes = visuals.shapes || (visuals.shapes = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var SVGUtil;
        (function(SVGUtil) {
            SVGUtil.AlmostZero = 1e-6;
            function translate(x, y) {
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                return "translate(" + x + "," + y + ")";
            }
            SVGUtil.translate = translate;
            function translateXWithPixels(x) {
                debug.assertValue(x, "x");
                return "translateX(" + x + "px)";
            }
            SVGUtil.translateXWithPixels = translateXWithPixels;
            function translateWithPixels(x, y) {
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                return "translate(" + x + "px," + y + "px)";
            }
            SVGUtil.translateWithPixels = translateWithPixels;
            function translateAndRotate(x, y, px, py, angle) {
                debug.assertValue(x, "x");
                debug.assertValue(y, "y");
                debug.assertValue(px, "px");
                debug.assertValue(py, "py");
                debug.assertValue(angle, "angle");
                return "transform", "translate(" + x + "," + y + ")" + " rotate(" + angle + "," + px + "," + py + ")";
            }
            SVGUtil.translateAndRotate = translateAndRotate;
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function() {
                    return Infinity;
                };
                d3.timer.flush();
                Date.now = now;
            }
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
            function flushAllD3TransitionsIfNeeded(options) {
                if (!options) return;
                var animationOptions = options;
                var asVisualInitOptions = options;
                if (asVisualInitOptions.animation) animationOptions = asVisualInitOptions.animation;
                if (animationOptions && animationOptions.transitionImmediate) {
                    flushAllD3Transitions();
                }
            }
            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
            function ensureDAttribute(pathElement) {
                if (!pathElement.getAttribute("d")) {
                    pathElement.setAttribute("d", "");
                }
            }
            SVGUtil.ensureDAttribute = ensureDAttribute;
            function ensureValidSVGPoint(point) {
                if (isNaN(point.x)) {
                    point.x = 0;
                }
                if (isNaN(point.y)) {
                    point.y = 0;
                }
            }
            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
            function parseTranslateTransform(input) {
                if (!input || input.length === 0) {
                    return {
                        x: "0",
                        y: "0"
                    };
                }
                var translateCoordinates = input.split(/[\s,]+/);
                debug.assertValue(translateCoordinates, "translateCoordinates");
                debug.assert(translateCoordinates.length > 0, "translate array must atleast have one value");
                var yValue = "0";
                var xValue;
                var xCoord = translateCoordinates[0];
                if (translateCoordinates.length === 1) {
                    xValue = xCoord.substring(10, xCoord.length - 1);
                } else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1);
                    var xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            SVGUtil.parseTranslateTransform = parseTranslateTransform;
            function convertToPixelString(value) {
                return value + "px";
            }
            SVGUtil.convertToPixelString = convertToPixelString;
        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var TextUtil;
        (function(TextUtil) {
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(" ", "g"), "&nbsp");
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Utility = jsCommon.Utility;
        var UrlHelper;
        (function(UrlHelper) {
            function isValidUrl(columnItem, value) {
                return columnItem != null && columnItem.type != null && columnItem.type.misc != null && columnItem.type.misc.webUrl != null && columnItem.type.misc.webUrl && value != null && Utility.isValidUrl(value);
            }
            UrlHelper.isValidUrl = isValidUrl;
        })(UrlHelper = visuals.UrlHelper || (visuals.UrlHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var GradientUtils;
        (function(GradientUtils) {
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var DefaultMidColor = "#ffffff";
            function getFillRuleRole(objectDescs) {
                if (!objectDescs) return;
                for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type["fillRule"]) {
                            return propertyDesc.rule.inputRole;
                        }
                    }
                }
            }
            GradientUtils.getFillRuleRole = getFillRuleRole;
            function shouldShowGradient(visualConfig) {
                var isShowGradienCard = visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections["Gradient"] ? true : false;
                return isShowGradienCard;
            }
            GradientUtils.shouldShowGradient = shouldShowGradient;
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            if (value && value.solid && value.solid.color) {
                                value = value.solid.color;
                            }
                            gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values) {
                    var grouped = dataViewCategorical.values.grouped();
                    return visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Gradient");
                }
                return -1;
            }
            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRole = hasGradientRole;
            function getDefaultGradientSettings() {
                var colors = getDefaultColors();
                var gradientSettings = {
                    diverging: false,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: undefined,
                    midValue: undefined,
                    maxValue: undefined
                };
                return gradientSettings;
            }
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
            function getDefaultFillRuleDefinition() {
                return getLinearGradien2FillRuleDefinition();
            }
            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
            function updateFillRule(propertyName, propertyValue, definitions) {
                var dataPointProperties = definitions["dataPoint"][0].properties;
                var fillRule = dataPointProperties.fillRule;
                var numericValueExpr;
                if (!fillRule) {
                    return;
                }
                if ($.isNumeric(propertyValue)) {
                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
                }
                if (propertyName === "minColor") {
                    updateMinColor(fillRule, propertyValue);
                } else if (propertyName === "midColor") {
                    updateMidColor(fillRule, propertyValue);
                } else if (propertyName === "maxColor") {
                    updateMaxColor(fillRule, propertyValue);
                } else if (propertyName === "minValue") {
                    updateMinValue(fillRule, numericValueExpr);
                } else if (propertyName === "midValue") {
                    updateMidValue(fillRule, numericValueExpr);
                } else if (propertyName === "maxValue") {
                    updateMaxValue(fillRule, numericValueExpr);
                } else if (propertyName === "diverging") {
                    if (propertyValue) {
                        fillRule = getLinearGradien3FillRuleDefinition(fillRule);
                    } else {
                        fillRule = getLinearGradien2FillRuleDefinition(fillRule);
                    }
                    dataPointProperties.fillRule = fillRule;
                } else if (propertyName === "revertToDefault") {
                    fillRule = this.getDefaultFillRuleDefinition();
                    dataPointProperties.fillRule = fillRule;
                }
            }
            GradientUtils.updateFillRule = updateFillRule;
            function getGradientSettings(baseFillRule) {
                if (baseFillRule) {
                    return getGradientSettingsFromRule(baseFillRule);
                } else {
                    return getDefaultGradientSettings();
                }
            }
            GradientUtils.getGradientSettings = getGradientSettings;
            function getFillRule(objectDefinitions) {
                if (objectDefinitions && objectDefinitions["dataPoint"] && objectDefinitions["dataPoint"].length > 0 && objectDefinitions["dataPoint"][0].properties) {
                    return objectDefinitions["dataPoint"][0].properties["fillRule"];
                }
                return null;
            }
            GradientUtils.getFillRule = getFillRule;
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette();
                var maxColorInfo = dataColors.getColor(0);
                var colors = d3.scale.linear().domain([ 0, 100 ]).range([ "#ffffff", maxColorInfo.value ]);
                var maxColor = maxColorInfo.value;
                var minColor = colors(20);
                var midColor = DefaultMidColor;
                return {
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor;
                var minColor;
                var midColor = DefaultMidColor;
                var maxValue;
                var midValue;
                var minValue;
                var diverging = fillRule.linearGradient3 !== undefined;
                if (fillRule.linearGradient2) {
                    var maxColorExpr = fillRule.linearGradient2.max.color;
                    var minColorExpr = fillRule.linearGradient2.min.color;
                    var maxValueExpr = fillRule.linearGradient2.max.value;
                    var minValueExpr = fillRule.linearGradient2.min.value;
                    maxColor = maxColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                } else if (fillRule.linearGradient3) {
                    var maxColorExpr = fillRule.linearGradient3.max.color;
                    var midColorExpr = fillRule.linearGradient3.mid.color;
                    var minColorExpr = fillRule.linearGradient3.min.color;
                    var maxValueExpr = fillRule.linearGradient3.max.value;
                    var midValueExpr = fillRule.linearGradient3.mid.value;
                    var minValueExpr = fillRule.linearGradient3.min.value;
                    maxColor = maxColorExpr.value;
                    midColor = midColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (midValueExpr) {
                        midValue = midValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                return {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    minValue: minValue,
                    midValue: midValue,
                    maxValue: maxValue
                };
            }
            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
            function getLinearGradien2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient2: {
                        max: {
                            color: SQExprBuilder.text(gradientSettings.maxColor)
                        },
                        min: {
                            color: SQExprBuilder.text(gradientSettings.minColor)
                        }
                    }
                };
                return fillRuleDefinition;
            }
            function getLinearGradien3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient3: {
                        max: {
                            color: SQExprBuilder.text(gradientSettings.maxColor)
                        },
                        mid: {
                            color: SQExprBuilder.text(gradientSettings.midColor)
                        },
                        min: {
                            color: SQExprBuilder.text(gradientSettings.minColor)
                        }
                    }
                };
                return fillRuleDefinition;
            }
            function updateMinColor(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.color = SQExprBuilder.text(value);
                } else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.color = SQExprBuilder.text(value);
                }
            }
            function updateMidColor(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.color = SQExprBuilder.text(value);
                }
            }
            function updateMaxColor(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.color = SQExprBuilder.text(value);
                } else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.color = SQExprBuilder.text(value);
                }
            }
            function updateMinValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.value = value;
                } else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.value = value;
                }
            }
            function updateMidValue(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.value = value;
                }
            }
            function updateMaxValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.value = value;
                } else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.value = value;
                }
            }
        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var visualBackgroundHelper;
        (function(visualBackgroundHelper) {
            function getDefaultColor() {
                return "#FFF";
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultTransparency() {
                return 50;
            }
            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
            function getDefaultShow() {
                return true;
            }
            visualBackgroundHelper.getDefaultShow = getDefaultShow;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            visualBackgroundHelper.getDefaultValues = getDefaultValues;
        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var shapes = powerbi.visuals.shapes;
    (function(ContentPositions) {
        ContentPositions[ContentPositions["None"] = 0] = "None";
        ContentPositions[ContentPositions["TopLeft"] = 1] = "TopLeft";
        ContentPositions[ContentPositions["TopCenter"] = 2] = "TopCenter";
        ContentPositions[ContentPositions["TopRight"] = 4] = "TopRight";
        ContentPositions[ContentPositions["MiddleLeft"] = 8] = "MiddleLeft";
        ContentPositions[ContentPositions["MiddleCenter"] = 16] = "MiddleCenter";
        ContentPositions[ContentPositions["MiddleRight"] = 32] = "MiddleRight";
        ContentPositions[ContentPositions["BottomLeft"] = 64] = "BottomLeft";
        ContentPositions[ContentPositions["BottomCenter"] = 128] = "BottomCenter";
        ContentPositions[ContentPositions["BottomRight"] = 256] = "BottomRight";
        ContentPositions[ContentPositions["InsideCenter"] = 512] = "InsideCenter";
        ContentPositions[ContentPositions["InsideBase"] = 1024] = "InsideBase";
        ContentPositions[ContentPositions["InsideEnd"] = 2048] = "InsideEnd";
        ContentPositions[ContentPositions["OutsideBase"] = 4096] = "OutsideBase";
        ContentPositions[ContentPositions["OutsideEnd"] = 8192] = "OutsideEnd";
        ContentPositions[ContentPositions["All"] = ContentPositions.TopLeft | ContentPositions.TopCenter | ContentPositions.TopRight | ContentPositions.MiddleLeft | ContentPositions.MiddleCenter | ContentPositions.MiddleRight | ContentPositions.BottomLeft | ContentPositions.BottomCenter | ContentPositions.BottomRight | ContentPositions.InsideCenter | ContentPositions.InsideBase | ContentPositions.InsideEnd | ContentPositions.OutsideBase | ContentPositions.OutsideEnd] = "All";
    })(powerbi.ContentPositions || (powerbi.ContentPositions = {}));
    var ContentPositions = powerbi.ContentPositions;
    (function(RectOrientation) {
        RectOrientation[RectOrientation["None"] = 0] = "None";
        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
    })(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    var RectOrientation = powerbi.RectOrientation;
    (function(OutsidePlacement) {
        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
    })(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    var OutsidePlacement = powerbi.OutsidePlacement;
    var DataLabelManager = function() {
        function DataLabelManager() {
            this.movingStep = 3;
            this.hideOverlapped = true;
            this._defaultSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: 0,
                contentPosition: 128,
                outsidePlacement: 1,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128,
                opacity: 1
            };
        }
        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function() {
                return this._defaultSettings;
            },
            enumerable: true,
            configurable: true
        });
        DataLabelManager.prototype.hideCollidedLabels = function(viewport, data, layout) {
            this._size = {
                width: viewport.width,
                height: viewport.height
            };
            var arrangeGrid = new DataLabelArrangeGrid(this._size, data, layout);
            var filteredData = [];
            for (var i = 0, len = data.length; i < len; i++) {
                if (!layout.filter(data[i])) continue;
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]),
                    y: layout.labelLayout.y(data[i])
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, this._size)) {
                    data[i].labelX = position.left;
                    data[i].labelY = position.top;
                    arrangeGrid.add(info, position);
                    filteredData.push(data[i]);
                }
            }
            return filteredData;
        };
        DataLabelManager.prototype.getLabelInfo = function(source) {
            var settings = this._defaultSettings;
            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
            source.maximumMovingDistance += source.anchorMargin;
            return source;
        };
        DataLabelManager.prototype.calculateContentPositionFromPoint = function(anchorPoint, contentPosition, contentSize, offset) {
            var position = {
                x: 0,
                y: 0
            };
            if (anchorPoint) {
                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
                    position.x = anchorPoint.x;
                    switch (contentPosition) {
                      case 1:
                      case 8:
                      case 64:
                        position.x -= contentSize.width / 2;
                        break;

                      case 4:
                      case 32:
                      case 256:
                        position.x += contentSize.width / 2;
                        break;
                    }
                }
                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
                    position.y = anchorPoint.y;
                    switch (contentPosition) {
                      case 8:
                      case 16:
                      case 32:
                        position.y -= contentSize.height / 2;
                        break;

                      case 4:
                      case 1:
                      case 2:
                        position.y -= contentSize.height;
                        break;
                    }
                }
                if (offset !== undefined && isFinite(offset)) {
                    switch (contentPosition) {
                      case 1:
                        position.x -= offset;
                        position.y -= offset;
                        break;

                      case 8:
                        position.x -= offset;
                        break;

                      case 64:
                        position.x -= offset;
                        position.y += offset;
                        break;

                      case 2:
                        position.y -= offset;
                        break;

                      case 16:
                        break;

                      case 128:
                        position.y += offset;
                        break;

                      case 4:
                        position.x += offset;
                        position.y -= offset;
                        break;

                      case 32:
                        position.x += offset;
                        break;

                      case 256:
                        position.x += offset;
                        position.y += offset;
                        break;

                      default:
                        debug.assertFail("Unsupported content position.");
                        break;
                    }
                }
            }
            return {
                left: position.x,
                top: position.y,
                width: contentSize.width,
                height: contentSize.height
            };
        };
        DataLabelManager.prototype.calculateContentPositionFromRect = function(anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
              case 512:
                return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 2048:
                return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 1024:
                return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 8192:
                return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

              case 4096:
                return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);

              default:
                debug.assertFail("Unsupported ContentPosition.");
            }
            return {
                left: 0,
                top: 0,
                width: -1,
                height: -1
            };
        };
        DataLabelManager.prototype.handleInsideCenterPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case 1:
              case 2:
                return LocationConverter.middleVertical(contentSize, anchorRect, offset);

              case 3:
              case 4:
              default:
                return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        };
        DataLabelManager.prototype.handleInsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case 1:
                return LocationConverter.topInside(contentSize, anchorRect, offset);

              case 2:
                return LocationConverter.bottomInside(contentSize, anchorRect, offset);

              case 4:
                return LocationConverter.leftInside(contentSize, anchorRect, offset);

              case 3:
              default:
                return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        };
        DataLabelManager.prototype.handleInsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case 1:
                return LocationConverter.bottomInside(contentSize, anchorRect, offset);

              case 2:
                return LocationConverter.topInside(contentSize, anchorRect, offset);

              case 4:
                return LocationConverter.rightInside(contentSize, anchorRect, offset);

              case 3:
              default:
                return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        };
        DataLabelManager.prototype.handleOutsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case 1:
                return LocationConverter.topOutside(contentSize, anchorRect, offset);

              case 2:
                return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

              case 4:
                return LocationConverter.leftOutside(contentSize, anchorRect, offset);

              case 3:
              default:
                return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        };
        DataLabelManager.prototype.handleOutsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
              case 1:
                return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

              case 2:
                return LocationConverter.topOutside(contentSize, anchorRect, offset);

              case 4:
                return LocationConverter.rightOutside(contentSize, anchorRect, offset);

              case 3:
              default:
                return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        };
        DataLabelManager.prototype.calculateContentPosition = function(anchoredElementInfo, contentPosition, contentSize, offset) {
            if (contentPosition !== 2048 && contentPosition !== 512 && contentPosition !== 1024 && contentPosition !== 4096 && contentPosition !== 8192) {
                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
            }
            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        };
        DataLabelManager.prototype.hasCollisions = function(arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) {
                return true;
            }
            var intersection = {
                left: 0,
                top: position.height / 2,
                width: size.width,
                height: size.height
            };
            intersection = rect.inflate(intersection, {
                left: DataLabelManager.InflateAmount,
                top: 0,
                right: DataLabelManager.InflateAmount,
                bottom: 0
            });
            intersection = rect.intersect(intersection, position);
            if (rect.isEmpty(intersection)) return true;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
              case 1:
                return lessWithPrecision(intersection.width, position.width) || lessWithPrecision(intersection.height, position.height / 2);

              case 2:
                return lessWithPrecision(intersection.width, position.width / 2) || lessWithPrecision(intersection.height, position.height / 4);
            }
            return false;
        };
        DataLabelManager.isValid = function(rect) {
            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
        };
        DataLabelManager.DefaultAnchorMargin = 0;
        DataLabelManager.DefaultMaximumMovingDistance = 12;
        DataLabelManager.DefaultMinimumMovingDistance = 3;
        DataLabelManager.InflateAmount = 5;
        return DataLabelManager;
    }();
    powerbi.DataLabelManager = DataLabelManager;
    var DataLabelArrangeGrid = function() {
        function DataLabelArrangeGrid(size, elements, layout) {
            this._grid = [];
            if (size.width === 0 || size.height === 0) {
                this._cellSize = size;
                this._rowCount = this._colCount = 0;
            }
            this._cellSize = {
                width: 0,
                height: 0
            };
            for (var i = 0, len = elements.length; i < len; i++) {
                var child = elements[i];
                child.labeltext = layout.labelText(child);
                var properties = {
                    fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                    text: child.labeltext
                };
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.measureSvgTextHeight(properties)
                };
                var w = child.size.width * 2;
                var h = child.size.height * 2;
                if (w > this._cellSize.width) this._cellSize.width = w;
                if (h > this._cellSize.height) this._cellSize.height = h;
            }
            if (this._cellSize.width === 0) this._cellSize.width = size.width;
            if (this._cellSize.height === 0) this._cellSize.height = size.height;
            this._colCount = this.getGridRowColCount(this._cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this._rowCount = this.getGridRowColCount(this._cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this._cellSize.width = size.width / this._colCount;
            this._cellSize.height = size.height / this._rowCount;
            var grid = this._grid;
            for (var x = 0; x < this._colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this._rowCount; y++) {
                    grid[x][y] = [];
                }
            }
        }
        DataLabelArrangeGrid.prototype.add = function(element, rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this._grid;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    grid[x][y].push({
                        element: element,
                        rect: rect
                    });
                }
            }
        };
        DataLabelArrangeGrid.prototype.hasConflict = function(rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this._grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    for (var z = 0; z < grid[x][y].length; z++) {
                        var item = grid[x][y][z];
                        if (isIntersecting(item.rect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        DataLabelArrangeGrid.prototype.getGridRowColCount = function(step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        };
        DataLabelArrangeGrid.prototype.getGridIndexRect = function(rect) {
            var restrict = function(n, min, max) {
                return Math.min(Math.max(n, min), max);
            };
            return {
                left: restrict(Math.floor(rect.left / this._cellSize.width), 0, this._colCount),
                top: restrict(Math.floor(rect.top / this._cellSize.height), 0, this._rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this._cellSize.width), 0, this._colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this._cellSize.height), 0, this._rowCount)
            };
        };
        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
        return DataLabelArrangeGrid;
    }();
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    var LocationConverter;
    (function(LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside;
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomInside = bottomInside;
        function rightInside(size, rect, offset) {
            return {
                left: rect.left + rect.width - size.width - offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightInside = rightInside;
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftInside = leftInside;
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topOutside = topOutside;
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomOutside = bottomOutside;
        function rightOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightOutside = rightOutside;
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftOutside = leftOutside;
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2 + offset,
                top: rect.top + rect.height / 2 - size.height / 2,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleHorizontal = middleHorizontal;
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2 - size.width / 2,
                top: rect.top + rect.height / 2 - size.height / 2 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleVertical = middleVertical;
    })(LocationConverter || (LocationConverter = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var DateTimeSequence = function() {
        function DateTimeSequence(unit) {
            this.unit = unit;
            this.sequence = [];
            this.min = new Date("9999-12-31T23:59:59.999");
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        DateTimeSequence.prototype.add = function(date) {
            if (date < this.min) {
                this.min = date;
            }
            if (date > this.max) {
                this.max = date;
            }
            this.sequence.push(date);
        };
        DateTimeSequence.prototype.extendToCover = function(min, max) {
            var x = this.min;
            while (min < x) {
                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);
                this.sequence.splice(0, 0, x);
            }
            this.min = x;
            x = this.max;
            while (x < max) {
                x = DateTimeSequence.addInterval(x, this.interval, this.unit);
                this.sequence.push(x);
            }
            this.max = x;
        };
        DateTimeSequence.prototype.moveToCover = function(min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit);
            var count = Math.floor(delta / this.interval);
            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);
            this.sequence = [];
            this.sequence.push(this.min);
            this.max = this.min;
            while (this.max < max) {
                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);
                this.sequence.push(this.max);
            }
        };
        DateTimeSequence.calculate = function(dataMin, dataMax, expectedCount, unit) {
            if (!unit) {
                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);
            }
            switch (unit) {
              case 0:
                return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);

              case 1:
                return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);

              case 2:
                return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);

              case 3:
                return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);

              case 4:
                return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);

              case 5:
                return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);

              case 6:
                return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);

              case 7:
                return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);

              default:
                debug.assertFail("Unsupported DateTimeUnit");
            }
        };
        DateTimeSequence.calculateYears = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(!expectedCount || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "Expected count is out of range");
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);
            var yearsSequence = powerbi.NumericSequence.calculate(yearsRange, expectedCount, 0);
            var years = yearsSequence.sequence;
            var result = new DateTimeSequence(0);
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                if (year) {
                    result.add(new Date(year, 0, 1));
                }
            }
            result.interval = yearsSequence.interval;
            result.intervalOffset = yearsSequence.intervalOffset;
            return result;
        };
        DateTimeSequence.calculateMonths = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var minYear = dataMin.getFullYear();
            var maxYear = dataMax.getFullYear();
            var minMonth = dataMin.getMonth();
            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();
            var date = new Date(minYear, 0, 1);
            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [ 1, 2, 3, 6, 12 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 1);
            return result;
        };
        DateTimeSequence.calculateWeeks = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var firstDayOfWeek = 0;
            var minDayOfWeek = dataMin.getDay();
            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;
            var minDay = dataMin.getDate() - dayOffset;
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 2));
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 4, 8 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 2);
            return result;
        };
        DateTimeSequence.calculateDays = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, 3));
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 7, 14 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 3);
            return result;
        };
        DateTimeSequence.calculateHours = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 4));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 4));
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 3, 6, 12, 24 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 4);
            return result;
        };
        DateTimeSequence.calculateMinutes = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 5));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 5));
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 5);
            return result;
        };
        DateTimeSequence.calculateSeconds = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, 6));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, 6));
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [ 1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60 ]);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 6);
            return result;
        };
        DateTimeSequence.calculateMilliseconds = function(dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT, "expected count is out of range");
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());
            var min = DateTimeSequence.getDelta(date, dataMin, 7);
            var max = DateTimeSequence.getDelta(date, dataMax, 7);
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);
            var result = DateTimeSequence.fromNumericSequence(date, sequence, 7);
            return result;
        };
        DateTimeSequence.fromNumericSequence = function(date, sequence, unit) {
            var result = new DateTimeSequence(unit);
            for (var i = 0; i < sequence.sequence.length; i++) {
                var x = sequence.sequence[i];
                var d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            result.interval = sequence.interval;
            result.intervalOffset = sequence.intervalOffset;
            return result;
        };
        DateTimeSequence.addInterval = function(value, interval, unit) {
            interval = Math.round(interval);
            switch (unit) {
              case 0:
                return DateUtils.addYears(value, interval);

              case 1:
                return DateUtils.addMonths(value, interval);

              case 2:
                return DateUtils.addWeeks(value, interval);

              case 3:
                return DateUtils.addDays(value, interval);

              case 4:
                return DateUtils.addHours(value, interval);

              case 5:
                return DateUtils.addMinutes(value, interval);

              case 6:
                return DateUtils.addSeconds(value, interval);

              case 7:
                return DateUtils.addMilliseconds(value, interval);
            }
        };
        DateTimeSequence.getDelta = function(min, max, unit) {
            var delta = 0;
            switch (unit) {
              case 0:
                delta = max.getFullYear() - min.getFullYear();
                break;

              case 1:
                delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();
                break;

              case 2:
                delta = (max.getTime() - min.getTime()) / (7 * 24 * 36e5);
                break;

              case 3:
                delta = (max.getTime() - min.getTime()) / (24 * 36e5);
                break;

              case 4:
                delta = (max.getTime() - min.getTime()) / 36e5;
                break;

              case 5:
                delta = (max.getTime() - min.getTime()) / 6e4;
                break;

              case 6:
                delta = (max.getTime() - min.getTime()) / 1e3;
                break;

              case 7:
                delta = max.getTime() - min.getTime();
                break;
            }
            return delta;
        };
        DateTimeSequence.getIntervalUnit = function(min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, 3);
            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount) return 0;
            if (totalDays > 60 && totalDays > 7 * maxCount) return 1;
            if (totalDays > 14 && totalDays > 2 * maxCount) return 2;
            var totalHours = DateTimeSequence.getDelta(min, max, 4);
            if (totalDays > 2 && totalHours > 12 * maxCount) return 3;
            if (totalHours >= 24 && totalHours >= maxCount) return 4;
            var totalMinutes = DateTimeSequence.getDelta(min, max, 5);
            if (totalMinutes > 2 && totalMinutes >= maxCount) return 5;
            var totalSeconds = DateTimeSequence.getDelta(min, max, 6);
            if (totalSeconds > 2 && totalSeconds >= .8 * maxCount) return 6;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, 7);
            if (totalMilliseconds > 0) return 7;
            var date = min;
            if (date.getMilliseconds() !== 0) return 7;
            if (date.getSeconds() !== 0) return 6;
            if (date.getMinutes() !== 0) return 5;
            if (date.getHours() !== 0) return 4;
            if (date.getDate() !== 1) return 3;
            if (date.getMonth() !== 0) return 1;
            return 0;
        };
        DateTimeSequence.MIN_COUNT = 1;
        DateTimeSequence.MAX_COUNT = 1e3;
        return DateTimeSequence;
    }();
    powerbi.DateTimeSequence = DateTimeSequence;
    var DateUtils;
    (function(DateUtils) {
        var MonthDays = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
        var MonthDaysLeap = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
        function isLeap(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        function addYears(date, yearDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var isLeapDay = month === 2 && day === 29;
            var result = new Date(date.getTime());
            var year = year + yearDelta;
            if (isLeapDay && !isLeap(year)) {
                day = 28;
            }
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addYears = addYears;
        function addMonths(date, monthDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            year += (monthDelta - monthDelta % 12) / 12;
            month += monthDelta % 12;
            if (month > 11) {
                month = month % 12;
                year++;
            }
            day = Math.min(day, getMonthDays(year, month));
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addMonths = addMonths;
        function addWeeks(date, weeks) {
            return addDays(date, weeks * 7);
        }
        DateUtils.addWeeks = addWeeks;
        function addDays(date, days) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            result.setFullYear(year, month, day + days);
            return result;
        }
        DateUtils.addDays = addDays;
        function addHours(date, hours) {
            return new Date(date.getTime() + hours * 36e5);
        }
        DateUtils.addHours = addHours;
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 6e4);
        }
        DateUtils.addMinutes = addMinutes;
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + seconds * 1e3);
        }
        DateUtils.addSeconds = addSeconds;
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        DateUtils.addMilliseconds = addMilliseconds;
    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
})(powerbi || (powerbi = {}));

var __extends = this.__extends || function(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};

var powerbi;

(function(powerbi) {
    var maxExponent = 24;
    var defaultScientificBigNumbersBoundary = 1e14;
    var scientificSmallNumbersBoundary = 1e-4;
    var DisplayUnit = function() {
        function DisplayUnit() {}
        DisplayUnit.prototype.project = function(value) {
            if (this.value) {
                return value / this.value;
            } else {
                return value;
            }
        };
        DisplayUnit.prototype.reverseProject = function(value) {
            if (this.value) {
                return value * this.value;
            } else {
                return value;
            }
        };
        DisplayUnit.prototype.isApplicableTo = function(value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        };
        return DisplayUnit;
    }();
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = function() {
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            get: function() {
                return this.displayUnit ? this.displayUnit.title : undefined;
            },
            enumerable: true,
            configurable: true
        });
        DisplayUnitSystem.prototype.update = function(value) {
            if (value === undefined) return;
            this._unitBaseValue = value;
            this.displayUnit = this.findApplicableDisplayUnit(value);
        };
        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function(value) {
            var count = this.units.length;
            for (var i = 0; i < count; i++) {
                var unit = this.units[i];
                if (unit.isApplicableTo(value)) {
                    return unit;
                }
            }
            return undefined;
        };
        DisplayUnitSystem.prototype.format = function(value, format, decimals, trailingZeros) {
            if (!DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format)) {
                if (this.displayUnit) {
                    var projectedValue = this.displayUnit.project(value);
                    var nonScientificFormat = trailingZeros ? DisplayUnitSystem.getNonScientificFormatWithPrecision(this.displayUnit.labelFormat, decimals) : this.displayUnit.labelFormat;
                    return this.formatHelper(value, projectedValue, nonScientificFormat, format, decimals, trailingZeros);
                }
                if (decimals != null) {
                    if (trailingZeros && format && DisplayUnitSystem.NUMBER_FORMAT.test(format)) {
                        var formatWithPrecision = DisplayUnitSystem.getFormatWithPrecision(decimals);
                        format = format.replace(/0\.0*/g, formatWithPrecision);
                        return this.formatHelper(value, value, "", format, decimals, trailingZeros);
                    }
                    if (trailingZeros) {
                        var nonScientificFormat = DisplayUnitSystem.getNonScientificFormatWithPrecision("{0}", decimals);
                        return this.formatHelper(value, value, nonScientificFormat, format, decimals, trailingZeros);
                    }
                    return this.formatHelper(value, value, "", format, decimals, trailingZeros);
                }
            }
            format = this.removeFractionIfNecessary(format);
            return powerbi.formattingService.formatValue(value, format);
        };
        DisplayUnitSystem.prototype.formatHelper = function(value, projectedValue, nonScientificFormat, format, decimals, trailingZeros) {
            var precision = decimals != null ? powerbi.Double.pow10(decimals) : powerbi.Double.getPrecision(value);
            var x = powerbi.Double.roundToPrecision(projectedValue, precision);
            if (format && !powerbi.formattingService.isStandardNumberFormat(format)) return powerbi.formattingService.formatNumberWithCustomOverride(x, format, nonScientificFormat);
            var textFormat = trailingZeros ? DisplayUnitSystem.getFormatWithPrecision(decimals) : "G";
            var text = powerbi.formattingService.formatValue(x, textFormat);
            return powerbi.formattingService.format(nonScientificFormat, [ text ]);
        };
        DisplayUnitSystem.getNonScientificFormatWithPrecision = function(baseFormat, decimals) {
            if (!decimals || baseFormat === undefined) return baseFormat;
            var newFormat = "{0:" + DisplayUnitSystem.getFormatWithPrecision(decimals) + "}";
            return baseFormat.replace("{0}", newFormat);
        };
        DisplayUnitSystem.getFormatWithPrecision = function(decimals) {
            if (decimals == null) return "G";
            return "0." + jsCommon.StringExtensions.repeat("0", Math.abs(decimals));
        };
        DisplayUnitSystem.prototype.formatSingleValue = function(value, format, decimals) {
            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);
            return this.format(value, format, decimals);
        };
        DisplayUnitSystem.prototype.shouldUseValuePrecision = function(value) {
            if (this.units.length === 0) return true;
            return Math.abs(value) < this.units[0].applicableRangeMin;
        };
        DisplayUnitSystem.prototype.removeFractionIfNecessary = function(formatString) {
            if (formatString) {
                if (Math.abs(this._unitBaseValue) >= .01) {
                    formatString = formatString.replace(/^(p\d*)$/i, "p0");
                }
                if (Math.abs(this._unitBaseValue) >= 1) {
                    formatString = formatString.replace(/[#0]\.[#0]+$/, "0");
                    formatString = formatString.replace(/^(n\d*)$/i, "n0");
                    formatString = formatString.replace(/^(f\d*)$/i, "f0");
                    formatString = formatString.replace(/^(c\d*)$/i, "c0");
                }
            }
            return formatString;
        };
        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(.*\%)|(e\d*)$/i;
        DisplayUnitSystem.NUMBER_FORMAT = /#|0/;
        return DisplayUnitSystem;
    }();
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    var NoDisplayUnitSystem = function(_super) {
        __extends(NoDisplayUnitSystem, _super);
        function NoDisplayUnitSystem() {
            _super.call(this, []);
        }
        return NoDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    var DefaultDisplayUnitSystem = function(_super) {
        __extends(DefaultDisplayUnitSystem, _super);
        function DefaultDisplayUnitSystem(unitLookup) {
            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));
        }
        DefaultDisplayUnitSystem.prototype.format = function(data, format, decimals, trailingZeros) {
            if (!this.displayUnit && this.isScientific(data)) {
                if (!format || format.toUpperCase().indexOf("E") < 0) {
                    format = "0.######E+0";
                }
            }
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        DefaultDisplayUnitSystem.prototype.isScientific = function(value) {
            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary || -scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0;
        };
        DefaultDisplayUnitSystem.reset = function() {
            DefaultDisplayUnitSystem._units = null;
        };
        DefaultDisplayUnitSystem.getUnits = function(unitLookup) {
            if (!DefaultDisplayUnitSystem._units) {
                DefaultDisplayUnitSystem._units = createDisplayUnits(unitLookup, function(value, previousUnitValue, min) {
                    if (value - previousUnitValue >= 1e3) {
                        return value / 10;
                    }
                    return min;
                });
                DefaultDisplayUnitSystem._scientificBigNumbersBoundary = defaultScientificBigNumbersBoundary;
                for (var i = 0, len = DefaultDisplayUnitSystem._units.length; i < len; ++i) {
                    var unit = DefaultDisplayUnitSystem._units[i];
                    if (unit.applicableRangeMax > DefaultDisplayUnitSystem._scientificBigNumbersBoundary) {
                        DefaultDisplayUnitSystem._scientificBigNumbersBoundary = unit.applicableRangeMax;
                    }
                }
            }
            return DefaultDisplayUnitSystem._units;
        };
        return DefaultDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    var WholeUnitsDisplayUnitSystem = function(_super) {
        __extends(WholeUnitsDisplayUnitSystem, _super);
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));
        }
        WholeUnitsDisplayUnitSystem.reset = function() {
            WholeUnitsDisplayUnitSystem._units = null;
        };
        WholeUnitsDisplayUnitSystem.getUnits = function(unitLookup) {
            if (!WholeUnitsDisplayUnitSystem._units) {
                WholeUnitsDisplayUnitSystem._units = createDisplayUnits(unitLookup);
            }
            return WholeUnitsDisplayUnitSystem._units;
        };
        return WholeUnitsDisplayUnitSystem;
    }(DisplayUnitSystem);
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        var units = [];
        for (var i = 3; i < maxExponent; i++) {
            var names = unitLookup(i);
            if (names) addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                if (adjustMinBasedOnPreviousUnit) min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value;
            unit.applicableRangeMin = min;
            unit.applicableRangeMax = min * 1e3;
            unit.title = title;
            unit.labelFormat = labelFormat;
            units.push(unit);
        }
    }
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var NumericSequence = function() {
        function NumericSequence() {}
        NumericSequence.calculate = function(range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            debug.assertValue(range, "range");
            debug.assert(expectedCount === undefined || expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT, "expectedCount");
            debug.assert(minPower === undefined || minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP, "minPower");
            debug.assert(maxAllowedMargin === undefined || maxAllowedMargin >= 0, "maxAllowedMargin");
            var result = new NumericSequence();
            if (expectedCount === undefined) expectedCount = 10; else expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (minPower === undefined) minPower = powerbi.Double.MIN_EXP;
            if (useZeroRefPoint === undefined) useZeroRefPoint = false;
            if (maxAllowedMargin === undefined) maxAllowedMargin = 1;
            if (steps === undefined) steps = [ 1, 2, 5 ];
            if (range.forcedSingleStop) {
                result.interval = range.getSize();
                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);
                result.min = range.min;
                result.max = range.max;
                result.sequence = [ range.forcedSingleStop ];
                return result;
            }
            var interval = 0;
            var min = 0;
            var max = 9;
            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;
            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;
            var size = range.getSize();
            var exp = powerbi.Double.log10(size);
            var stepExp = powerbi.Double.log10(steps[0]);
            exp = exp - stepExp;
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp = exp - expectedCountExp;
            exp = Math.max(exp, minPower - stepExp + 1);
            if (interval !== 0) {
                var power = powerbi.Double.pow10(exp);
                var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval);
                min = roundRange.min;
                max = roundRange.max;
                var count = Math.floor(roundRange.getSize() / interval);
            } else {
                var dexp;
                for (dexp = 0; dexp < 3; dexp++) {
                    var e = exp + dexp;
                    var power = powerbi.Double.pow10(e);
                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                    var stepsCount = steps.length;
                    var stepPower = powerbi.Double.pow10(e - 1);
                    for (var i = 0; i < stepsCount; i++) {
                        var step = steps[i] * stepPower;
                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        roundRange.shrinkByStep(range, step);
                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1) roundRange.min -= step;
                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1) roundRange.max += step;
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);
                        if (count <= expectedCount || dexp === 2 && i === stepsCount - 1 || expectedCount === 1 && count === 2 && (step > range.getSize() || range.min < 0 && range.max > 0 && step * 2 >= range.getSize())) {
                            interval = step;
                            min = roundRange.min;
                            max = roundRange.max;
                            break;
                        }
                    }
                    if (interval !== 0) break;
                }
            }
            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {
                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);
                interval = (max - min) / count;
            }
            result.min = min;
            result.max = max;
            result.interval = interval;
            result.intervalOffset = min - range.min;
            result._maxAllowedMargin = maxAllowedMargin;
            result._canExtendMin = canExtendMin;
            result._canExtendMax = canExtendMax;
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [];
            var x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; i < count; i++) {
                x = powerbi.Double.roundToPrecision(x + interval, precision);
                sequence.push(x);
            }
            result.sequence = sequence;
            result.trimMinMax(range.min, range.max);
            return result;
        };
        NumericSequence.calculateUnits = function(min, max, maxCount, steps) {
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (min === max) {
                max = min + 1;
            }
            var stepCount = 0;
            var step = 0;
            for (var i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);
                var minStepCount = powerbi.Double.floorWithPrecision(min / step);
                stepCount = maxStepCount - minStepCount;
                if (stepCount <= maxCount) {
                    break;
                }
            }
            var offset = -min;
            offset = offset % step;
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset; ;x += step) {
                result.sequence.push(x);
                if (x >= max) break;
            }
            result.interval = step;
            result.intervalOffset = offset;
            result.min = result.sequence[0];
            result.max = result.sequence[result.sequence.length - 1];
            return result;
        };
        NumericSequence.prototype.trimMinMax = function(min, max) {
            var minMargin = (min - this.min) / this.interval;
            var maxMargin = (this.max - max) / this.interval;
            var marginPrecision = .001;
            if (!this._canExtendMin || minMargin > this._maxAllowedMargin && minMargin > marginPrecision) {
                this.min = min;
            }
            if (!this._canExtendMax || maxMargin > this._maxAllowedMargin && maxMargin > marginPrecision) {
                this.max = max;
            }
        };
        NumericSequence.MIN_COUNT = 1;
        NumericSequence.MAX_COUNT = 1e3;
        return NumericSequence;
    }();
    powerbi.NumericSequence = NumericSequence;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var NumericSequenceRange = function() {
        function NumericSequenceRange() {}
        NumericSequenceRange.prototype._ensureIncludeZero = function() {
            if (this.includeZero) {
                if (this.min > 0 && !this.hasFixedMin) {
                    this.min = 0;
                }
                if (this.max < 0 && !this.hasFixedMax) {
                    this.max = 0;
                }
            }
        };
        NumericSequenceRange.prototype._ensureNotEmpty = function() {
            if (this.min === this.max) {
                if (!this.min) {
                    this.min = 0;
                    this.max = NumericSequenceRange.DEFAULT_MAX;
                    this.hasFixedMin = true;
                    this.hasFixedMax = true;
                } else {
                    var value = this.min;
                    var exp = powerbi.Double.log10(Math.abs(value));
                    var step;
                    if (exp >= 0 && exp < 4) {
                        step = .5;
                        this.forcedSingleStop = value;
                    } else {
                        step = powerbi.Double.pow10(exp) / 2;
                        this.forcedSingleStop = null;
                    }
                    this.min = value - step;
                    this.max = value + step;
                }
            }
        };
        NumericSequenceRange.prototype._ensureDirection = function() {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max;
                this.max = temp;
            }
        };
        NumericSequenceRange.prototype.getSize = function() {
            return this.max - this.min;
        };
        NumericSequenceRange.prototype.shrinkByStep = function(range, step) {
            debug.assertValue(range, "range");
            debug.assert(step > 0, "step");
            var oldCount = this.min / step;
            var newCount = range.min / step;
            var deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step;
            oldCount = this.max / step;
            newCount = range.max / step;
            deltaCount = Math.ceil(newCount - oldCount);
            this.max += deltaCount * step;
        };
        NumericSequenceRange.calculate = function(dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            debug.assert(dataMin <= dataMax, "dataMin should be less or equal to dataMax.");
            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, "fixedMin should be less or equal to fixedMax.");
            var result = new NumericSequenceRange();
            result.includeZero = includeZero ? true : false;
            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);
            result.hasFixedMin = ValueUtil.hasValue(fixedMin);
            result.hasFixedMax = ValueUtil.hasValue(fixedMax);
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            if (result.hasFixedMin && result.hasFixedMax) {
                result.min = fixedMin;
                result.max = fixedMax;
            } else if (result.hasFixedMin) {
                result.min = fixedMin;
                result.max = dataMax > fixedMin ? dataMax : fixedMin;
            } else if (result.hasFixedMax) {
                result.min = dataMin < fixedMax ? dataMin : fixedMax;
                result.max = fixedMax;
            } else if (result.hasDataRange) {
                result.min = dataMin;
                result.max = dataMax;
            } else {
                result.min = 0;
                result.max = 0;
            }
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            if (result.min === 0) {
                result.hasFixedMin = true;
            } else if (result.max === 0) {
                result.hasFixedMax = true;
            }
            return result;
        };
        NumericSequenceRange.calculateDataRange = function(dataMin, dataMax, includeZero) {
            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {
                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
            } else {
                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);
            }
        };
        NumericSequenceRange.calculateFixedRange = function(fixedMin, fixedMax, includeZero) {
            debug.assertValue(fixedMin, "fixedMin");
            debug.assertValue(fixedMax, "fixedMax");
            var result = new NumericSequenceRange();
            result.hasDataRange = false;
            result.includeZero = includeZero;
            result.min = fixedMin;
            result.max = fixedMax;
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            result.hasFixedMin = true;
            result.hasFixedMax = true;
            return result;
        };
        NumericSequenceRange.DEFAULT_MAX = 10;
        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1e307;
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1e307;
        return NumericSequenceRange;
    }();
    powerbi.NumericSequenceRange = NumericSequenceRange;
    var ValueUtil;
    (function(ValueUtil) {
        function hasValue(value) {
            return value !== undefined && value !== null;
        }
        ValueUtil.hasValue = hasValue;
    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var valueFormatter;
        (function(valueFormatter) {
            var StringExtensions = jsCommon.StringExtensions;
            var BeautifiedFormat = {
                "0.00 %;-0.00 %;0.00 %": "Percentage",
                "0.0 %;-0.0 %;0.0 %": "Percentage1"
            };
            var defaultLocalizedStrings = {
                NullValue: "(Blank)",
                BooleanTrue: "True",
                BooleanFalse: "False",
                NaNValue: "NaN",
                InfinityValue: "+Infinity",
                NegativeInfinityValue: "-Infinity",
                RestatementComma: "{0}, {1}",
                RestatementCompoundAnd: "{0} and {1}",
                RestatementCompoundOr: "{0} or {1}",
                DisplayUnitSystem_E3_LabelFormat: "{0}K",
                DisplayUnitSystem_E3_Title: "Thousands",
                DisplayUnitSystem_E6_LabelFormat: "{0}M",
                DisplayUnitSystem_E6_Title: "Millions",
                DisplayUnitSystem_E9_LabelFormat: "{0}bn",
                DisplayUnitSystem_E9_Title: "Billions",
                DisplayUnitSystem_E12_LabelFormat: "{0}T",
                DisplayUnitSystem_E12_Title: "Trillions",
                Percentage: "#,0.##%",
                Percentage1: "#,0.#%",
                TableTotalLabel: "Total",
                Tooltip_HighlightedValueDisplayName: "Highlighted",
                GeotaggingString_Continent: "continent",
                GeotaggingString_Continents: "continents",
                GeotaggingString_Country: "country",
                GeotaggingString_Countries: "countries",
                GeotaggingString_State: "state",
                GeotaggingString_States: "states",
                GeotaggingString_City: "city",
                GeotaggingString_Cities: "cities",
                GeotaggingString_Town: "town",
                GeotaggingString_Towns: "towns",
                GeotaggingString_Province: "province",
                GeotaggingString_Provinces: "provinces",
                GeotaggingString_County: "county",
                GeotaggingString_Counties: "counties",
                GeotaggingString_Village: "village",
                GeotaggingString_Villages: "villages",
                GeotaggingString_Post: "post",
                GeotaggingString_Zip: "zip",
                GeotaggingString_Code: "code",
                GeotaggingString_Place: "place",
                GeotaggingString_Places: "places",
                GeotaggingString_Address: "address",
                GeotaggingString_Addresses: "addresses",
                GeotaggingString_Street: "street",
                GeotaggingString_Streets: "streets",
                GeotaggingString_Longitude: "longitude",
                GeotaggingString_Longitude_Short: "lon",
                GeotaggingString_Latitude: "latitude",
                GeotaggingString_Latitude_Short: "lat",
                GeotaggingString_PostalCode: "postal code",
                GeotaggingString_PostalCodes: "postal codes",
                GeotaggingString_ZipCode: "zip code",
                GeotaggingString_ZipCodes: "zip codes",
                GeotaggingString_Territory: "territory",
                GeotaggingString_Territories: "territories"
            };
            function beautify(format) {
                var key = BeautifiedFormat[format];
                if (key) return defaultLocalizedStrings[key] || format;
                return format;
            }
            function describeUnit(exponent) {
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_Title"];
                var format = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_LabelFormat"];
                if (title || format) return {
                    title: title,
                    format: format
                };
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            valueFormatter.getLocalizedString = getLocalizedString;
            var locale = {
                "null": defaultLocalizedStrings["NullValue"],
                "true": defaultLocalizedStrings["BooleanTrue"],
                "false": defaultLocalizedStrings["BooleanFalse"],
                NaN: defaultLocalizedStrings["NaNValue"],
                infinity: defaultLocalizedStrings["InfinityValue"],
                negativeInfinity: defaultLocalizedStrings["NegativeInfinityValue"],
                beautify: function(format) {
                    return beautify(format);
                },
                describe: function(exponent) {
                    return describeUnit(exponent);
                },
                restatementComma: defaultLocalizedStrings["RestatementComma"],
                restatementCompoundAnd: defaultLocalizedStrings["RestatementCompoundAnd"],
                restatementCompoundOr: defaultLocalizedStrings["RestatementCompoundOr"]
            };
            var MaxScaledDecimalPlaces = 2;
            var MaxValueForDisplayUnitRounding = 1e3;
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            valueFormatter.getFormatMetadata = getFormatMetadata;
            function setLocaleOptions(options) {
                debug.assertValue(options, "options");
                locale = options;
                powerbi.DefaultDisplayUnitSystem.reset();
                powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            valueFormatter.setLocaleOptions = setLocaleOptions;
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                if (allowFormatBeautification === void 0) {
                    allowFormatBeautification = false;
                }
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function(value) {
                        if (value == null) return locale.null;
                        return formatCore(value, formatBeaut);
                    }
                };
            }
            valueFormatter.createDefaultFormatter = createDefaultFormatter;
            function create(options) {
                debug.assertValue(options, "options");
                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);
                    var singleValueFormattingMode = !!options.formatSingleValues;
                    displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var forcePrecision = options.precision != null;
                    var decimals;
                    if (forcePrecision) {
                        decimals = -options.precision;
                    } else if (displayUnitSystem.displayUnit) decimals = -MaxScaledDecimalPlaces;
                    return {
                        format: function(value) {
                            var formattedValue = getStringFormat(value, true);
                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue)) return formattedValue;
                            if (value && !displayUnitSystem.displayUnit && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision) value = powerbi.Double.roundToPrecision(value, powerbi.Double.pow10(powerbi.Double.getPrecision(value)));
                            return singleValueFormattingMode ? displayUnitSystem.formatSingleValue(value, format, decimals) : displayUnitSystem.format(value, format, decimals, forcePrecision);
                        },
                        displayUnit: displayUnitSystem.displayUnit
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit = powerbi.DateTimeSequence.getIntervalUnit(options.value, options.value2, options.tickCount);
                    return {
                        format: function(value) {
                            if (value == null) return locale.null;
                            var formatString = powerbi.formattingService.dateFormatString(unit);
                            return formatCore(value, formatString);
                        }
                    };
                }
                return createDefaultFormatter(format);
            }
            valueFormatter.create = create;
            function format(value, format, allowFormatBeautification) {
                if (value == null) return locale.null;
                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);
            }
            valueFormatter.format = format;
            function formatRaw(value, format) {
                return formatCore(value, format);
            }
            valueFormatter.formatRaw = formatRaw;
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (displayUnitSystemType == null) return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                  case 0:
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);

                  case 2:
                    return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);

                  case 1:
                    return new powerbi.NoDisplayUnitSystem();

                  default:
                    debug.assertFail("Unknown display unit system type");
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value;
                var value2 = options.value2;
                if (typeof value === "number" || typeof value2 === "number") {
                    return true;
                }
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                return value instanceof Date && value2 instanceof Date && (tickCount !== undefined && tickCount !== null);
            }
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue) return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime) return "d";
                            if (columnType.integer) return "g";
                            if (columnType.numeric) return "#,0.00";
                        }
                    }
                }
            }
            valueFormatter.getFormatString = getFormatString;
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) {
                    return null;
                }
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    var lastIndex = length - 1;
                    for (var i = 1, len = lastIndex; i < len; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                } else {
                    result = null;
                }
                return result;
            }
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            valueFormatter.formatListAnd = formatListAnd;
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            valueFormatter.formatListOr = formatListOr;
            function formatCore(value, format) {
                var formattedValue = getStringFormat(value, false);
                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue)) return formattedValue;
                return powerbi.formattingService.formatValue(value, format);
            }
            function getStringFormat(value, nullsAreBlank) {
                if (value == null && nullsAreBlank) return locale.null;
                if (value === true) return locale.true;
                if (value === false) return locale.false;
                if (typeof value === "number" && isNaN(value)) return locale.NaN;
                if (value === Number.NEGATIVE_INFINITY) return locale.negativeInfinity;
                if (value === Number.POSITIVE_INFINITY) return locale.infinity;
                return "";
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            valueFormatter.getDisplayUnits = getDisplayUnits;
        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = function() {
            function ColorAllocatorFactory() {}
            ColorAllocatorFactory.prototype.linearGradient2 = function(options) {
                return new LinearGradient2Allocator(options);
            };
            ColorAllocatorFactory.prototype.linearGradient3 = function(options) {
                return new LinearGradient3Allocator(options);
            };
            return ColorAllocatorFactory;
        }();
        var LinearGradient2Allocator = function() {
            function LinearGradient2Allocator(options) {
                debug.assertValue(options, "options");
                var min = options.min, max = options.max;
                this.scale = d3.scale.linear().domain([ min.value, max.value ]).range([ min.color, max.color ]).clamp(true);
            }
            LinearGradient2Allocator.prototype.color = function(value) {
                return this.scale(value);
            };
            return LinearGradient2Allocator;
        }();
        var LinearGradient3Allocator = function() {
            function LinearGradient3Allocator(options) {
                debug.assertValue(options, "options");
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = d3.scale.linear().domain([ min.value, mid.value, max.value ]).range([ min.color, mid.color, max.color ]).clamp(true);
            }
            LinearGradient3Allocator.prototype.color = function(value) {
                return this.scale(value);
            };
            return LinearGradient3Allocator;
        }();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var BeautifiedFormat = {
            "0.00 %;-0.00 %;0.00 %": "Percentage",
            "0.0 %;-0.0 %;0.0 %": "Percentage1"
        };
        var defaultLocalizedStrings = {
            NullValue: "(Blank)",
            BooleanTrue: "True",
            BooleanFalse: "False",
            NaNValue: "NaN",
            InfinityValue: "+Infinity",
            NegativeInfinityValue: "-Infinity",
            Restatement_Comma: "{0}, {1}",
            Restatement_CompoundAnd: "{0} and {1}",
            DisplayUnitSystem_E3_LabelFormat: "{0}K",
            DisplayUnitSystem_E3_Title: "Thousands",
            DisplayUnitSystem_E6_LabelFormat: "{0}M",
            DisplayUnitSystem_E6_Title: "Millions",
            DisplayUnitSystem_E9_LabelFormat: "{0}bn",
            DisplayUnitSystem_E9_Title: "Billions",
            DisplayUnitSystem_E12_LabelFormat: "{0}T",
            DisplayUnitSystem_E12_Title: "Trillions",
            Percentage: "#,0.##%",
            Percentage1: "#,0.#%",
            TableTotalLabel: "Total",
            Tooltip_HighlightedValueDisplayName: "Highlighted",
            GeotaggingString_Continent: "continent",
            GeotaggingString_Continents: "continents",
            GeotaggingString_Country: "country",
            GeotaggingString_Countries: "countries",
            GeotaggingString_State: "state",
            GeotaggingString_States: "states",
            GeotaggingString_City: "city",
            GeotaggingString_Cities: "cities",
            GeotaggingString_Town: "town",
            GeotaggingString_Towns: "towns",
            GeotaggingString_Province: "province",
            GeotaggingString_Provinces: "provinces",
            GeotaggingString_County: "county",
            GeotaggingString_Counties: "counties",
            GeotaggingString_Village: "village",
            GeotaggingString_Villages: "villages",
            GeotaggingString_Post: "post",
            GeotaggingString_Zip: "zip",
            GeotaggingString_Code: "code",
            GeotaggingString_Place: "place",
            GeotaggingString_Places: "places",
            GeotaggingString_Address: "address",
            GeotaggingString_Addresses: "addresses",
            GeotaggingString_Street: "street",
            GeotaggingString_Streets: "streets",
            GeotaggingString_Longitude: "longitude",
            GeotaggingString_Longitude_Short: "lon",
            GeotaggingString_Latitude: "latitude",
            GeotaggingString_Latitude_Short: "lat",
            GeotaggingString_PostalCode: "postal code",
            GeotaggingString_PostalCodes: "postal codes",
            GeotaggingString_ZipCode: "zip code",
            GeotaggingString_ZipCodes: "zip codes",
            GeotaggingString_Territory: "territory",
            GeotaggingString_Territories: "territories"
        };
        var DefaultVisualHostServices = function() {
            function DefaultVisualHostServices() {}
            DefaultVisualHostServices.initialize = function() {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
            };
            DefaultVisualHostServices.createLocaleOptions = function() {
                return {
                    "null": defaultLocalizedStrings["NullValue"],
                    "true": defaultLocalizedStrings["BooleanTrue"],
                    "false": defaultLocalizedStrings["BooleanFalse"],
                    NaN: defaultLocalizedStrings["NaNValue"],
                    infinity: defaultLocalizedStrings["InfinityValue"],
                    negativeInfinity: defaultLocalizedStrings["NegativeInfinityValue"],
                    beautify: function(format) {
                        return DefaultVisualHostServices.beautify(format);
                    },
                    describe: function(exponent) {
                        return DefaultVisualHostServices.describeUnit(exponent);
                    },
                    restatementComma: defaultLocalizedStrings["Restatement_Comma"],
                    restatementCompoundAnd: defaultLocalizedStrings["Restatement_CompoundAnd"],
                    restatementCompoundOr: defaultLocalizedStrings["Restatement_CompoundOr"]
                };
            };
            DefaultVisualHostServices.createTooltipLocaleOptions = function() {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings["Tooltip_HighlightedValueDisplayName"]
                };
            };
            DefaultVisualHostServices.prototype.getLocalizedString = function(stringId) {
                return defaultLocalizedStrings[stringId];
            };
            DefaultVisualHostServices.prototype.onDragStart = function() {};
            DefaultVisualHostServices.prototype.canSelect = function() {
                return false;
            };
            DefaultVisualHostServices.prototype.onSelect = function() {};
            DefaultVisualHostServices.prototype.loadMoreData = function() {};
            DefaultVisualHostServices.prototype.persistProperties = function(changes) {};
            DefaultVisualHostServices.prototype.onCustomSort = function(args) {};
            DefaultVisualHostServices.prototype.getViewMode = function() {
                return 0;
            };
            DefaultVisualHostServices.prototype.setWarnings = function(warnings) {};
            DefaultVisualHostServices.prototype.setToolbar = function($toolbar) {};
            DefaultVisualHostServices.beautify = function(format) {
                var key = BeautifiedFormat[format];
                if (key) return defaultLocalizedStrings[key] || format;
                return format;
            };
            DefaultVisualHostServices.describeUnit = function(exponent) {
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_Title"];
                var format = defaultLocalizedStrings["DisplayUnitSystem_E" + exponent + "_LabelFormat"];
                if (title || format) return {
                    title: title,
                    format: format
                };
            };
            return DefaultVisualHostServices;
        }();
        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        function createInteractivityService(hostServices) {
            return new WebInteractivityService(hostServices);
        }
        visuals.createInteractivityService = createInteractivityService;
        function appendClearCatcher(selection) {
            return selection.append("rect").classed("clearCatcher", true).attr({
                width: "100%",
                height: "100%"
            });
        }
        visuals.appendClearCatcher = appendClearCatcher;
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; i < ilen; i++) {
                if (data[i].selected) return true;
            }
            return false;
        }
        visuals.dataHasSelection = dataHasSelection;
        var WebInteractivityService = function() {
            function WebInteractivityService(hostServices) {
                this.sendSelectionToVisual = function() {};
                this.sendSelectionToLegend = function() {};
                this.sendSelectionToSecondVisual = function() {};
                this.selectedIds = [];
                this.hasColumnChart = false;
                debug.assertValue(hostServices, "hostServices");
                this.hostService = hostServices;
            }
            WebInteractivityService.prototype.clearSelection = function() {
                this.clearSelectionInternal();
                this.sendSelectionToVisual();
                this.sendSelectionToLegend();
                this.sendSelectionToSecondVisual();
            };
            WebInteractivityService.prototype.hasSelection = function() {
                return this.selectedIds.length > 0;
            };
            WebInteractivityService.prototype.legendHasSelection = function() {
                return dataHasSelection(this.selectableLegendDataPoints);
            };
            WebInteractivityService.prototype.select = function(d, multiselect) {
                if (multiselect === undefined) multiselect = d3.event.ctrlKey;
                if (d.identity.highlight) {
                    d = _.find(this.selectableDataPoints, function(dp) {
                        return !dp.identity.highlight && d.identity.includes(dp.identity, true);
                    });
                    debug.assertValue(d, "Expected to find a non-highlight data point");
                }
                var id = d.identity;
                if (!id) return;
                var selected = !d.selected || !multiselect && this.selectedIds.length > 1;
                if (multiselect) {
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    } else {
                        d.selected = false;
                        this.removeId(id);
                    }
                }
                if (!multiselect || !this.hostService.canSelect({
                    data: this.selectedIds.map(function(value) {
                        return value.getSelector();
                    })
                })) {
                    this.clearSelectionInternal();
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                }
                this.syncSelectionState();
            };
            WebInteractivityService.prototype.removeId = function(toRemove) {
                var selectedIds = this.selectedIds;
                for (var i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    if (toRemove.includes(currentId)) selectedIds.splice(i, 1);
                }
            };
            WebInteractivityService.isSelected = function(propertyId, categories, idx) {
                return categories.objects != null && categories.objects[idx] && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
            };
            WebInteractivityService.prototype.createPropertiesToHost = function(filterPropertyIdentifier) {
                var properties = {};
                if (this.selectedIds.length > 0) {
                    var filter = powerbi.data.Selector.filterFromSelector(this.selectedIds.map(function(value) {
                        return value.getSelector();
                    }), false);
                    properties[filterPropertyIdentifier.propertyName] = filter;
                }
                return [ {
                    objectName: filterPropertyIdentifier.objectName,
                    selector: undefined,
                    properties: properties
                } ];
            };
            WebInteractivityService.prototype.sendPersistPropertiesToHost = function(filterPropertyIdentifier) {
                this.hostService.persistProperties(this.createPropertiesToHost(filterPropertyIdentifier));
            };
            WebInteractivityService.prototype.sendSelectToHost = function() {
                var host = this.hostService;
                if (host.onSelect) {
                    host.onSelect({
                        data: this.selectedIds.filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        })
                    });
                }
            };
            WebInteractivityService.prototype.sendSelectionToHost = function(filterPropertyIdentifier) {
                if (filterPropertyIdentifier) this.sendPersistPropertiesToHost(filterPropertyIdentifier);
                this.sendSelectToHost();
            };
            WebInteractivityService.prototype.clearSelectionInternal = function() {
                ArrayExtensions.clear(this.selectedIds);
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                if (selectableDataPoints) {
                    for (var i = selectableDataPoints.length - 1; i > -1; i--) {
                        selectableDataPoints[i].selected = false;
                    }
                }
                if (secondSelectableDataPoints) {
                    for (var i = secondSelectableDataPoints.length - 1; i > -1; i--) {
                        secondSelectableDataPoints[i].selected = false;
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var i = selectableLegendDataPoints.length - 1; i > -1; i--) {
                        selectableLegendDataPoints[i].selected = false;
                    }
                }
            };
            WebInteractivityService.prototype.applySelectionStateToData = function(dataPoints) {
                var hasSelection = false;
                for (var i = 0, len = dataPoints.length; i < len; i++) {
                    var dataPoint = dataPoints[i];
                    dataPoint.selected = this.selectedIds.some(function(selectedId) {
                        return selectedId.includes(dataPoint.identity);
                    });
                    if (dataPoint.selected) hasSelection = true;
                }
                return hasSelection;
            };
            WebInteractivityService.prototype.initAndSyncSelectionState = function(filterPropertyId) {
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                var selectedIds = this.selectedIds;
                if (selectableDataPoints && selectedIds.length === 0) {
                    if (selectableDataPoints) {
                        for (var i = 0, len = selectableDataPoints.length; i < len; i++) {
                            if (selectableDataPoints[i].selected) {
                                selectedIds.push(selectableDataPoints[i].identity);
                            }
                        }
                    }
                    if (secondSelectableDataPoints) {
                        for (var i = 0, len = secondSelectableDataPoints.length; i < len; i++) {
                            if (secondSelectableDataPoints[i].selected) {
                                selectedIds.push(secondSelectableDataPoints[i].identity);
                            }
                        }
                    }
                    if (selectableLegendDataPoints) {
                        for (var i = 0, len = selectableLegendDataPoints.length; i < len; i++) {
                            if (selectableLegendDataPoints[i].selected) {
                                selectedIds.push(selectableLegendDataPoints[i].identity);
                            }
                        }
                    }
                }
                this.syncSelectionState(filterPropertyId);
            };
            WebInteractivityService.prototype.syncSelectionState = function(filterPropertyId) {
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var secondSelectableDataPoints = this.secondSelectableDataPoints;
                var foundMatchingId = false;
                if (!selectableDataPoints) return;
                for (var i = 0, ilen = selectableDataPoints.length; i < ilen; i++) {
                    var dataPoint = selectableDataPoints[i];
                    if (selectedIds.some(function(value) {
                        return value.includes(dataPoint.identity);
                    })) {
                        if (!dataPoint.selected) {
                            dataPoint.selected = true;
                        }
                        foundMatchingId = true;
                    } else if (dataPoint.selected) {
                        dataPoint.selected = false;
                    }
                }
                if (secondSelectableDataPoints) {
                    for (var i = 0, ilen = secondSelectableDataPoints.length; i < ilen; i++) {
                        var dataPoint = secondSelectableDataPoints[i];
                        if (selectedIds.some(function(value) {
                            return value.includes(dataPoint.identity);
                        })) {
                            if (!dataPoint.selected) {
                                dataPoint.selected = true;
                            }
                            foundMatchingId = true;
                        } else if (dataPoint.selected) {
                            dataPoint.selected = false;
                        }
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var i = 0, ilen = selectableLegendDataPoints.length; i < ilen; i++) {
                        var legendDataPoint = selectableLegendDataPoints[i];
                        if (selectedIds.some(function(value) {
                            return value.includes(legendDataPoint.identity);
                        })) {
                            legendDataPoint.selected = true;
                        } else if (legendDataPoint.selected) {
                            legendDataPoint.selected = false;
                        }
                    }
                }
                if (!foundMatchingId && selectedIds.length > 0) {
                    this.clearSelectionInternal();
                    this.sendSelectionToHost(filterPropertyId);
                }
            };
            WebInteractivityService.prototype.apply = function(visual, options) {
                visual.accept(this, options);
            };
            WebInteractivityService.prototype.visitColumnChart = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.ColumnChartWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                var graphicsContext = options.mainGraphicsContext;
                bars.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars, graphicsContext, hasHighlights);
                    _this.sendSelectionToHost();
                    if (_this.sendSelectionToLegend) _this.sendSelectionToLegend();
                    _this.sendSelectionToSecondVisual();
                });
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), bars, graphicsContext, hasHighlights);
                };
                this.hasColumnChart = true;
            };
            WebInteractivityService.prototype.visitLineChart = function(options) {
                if (this.hasColumnChart) {
                    this.visitLineChartCombo(options);
                } else {
                    this.visitLineChartNoCombo(options);
                }
            };
            WebInteractivityService.prototype.visitLineChartNoCombo = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.LineChartWebBehavior();
                }
                this.selectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = options.dots;
                var clearCatcher = options.clearCatcher;
                var areas = options.areas;
                var clickHandler = function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                interactivityLines.on("click", clickHandler);
                dots.on("click", clickHandler);
                if (areas) areas.on("click", clickHandler);
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    behavior.select(false, lines, dots, areas);
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                };
            };
            WebInteractivityService.prototype.visitLineChartCombo = function(options) {
                var _this = this;
                var behavior = this.secondBehavior;
                if (!behavior) {
                    behavior = this.secondBehavior = new visuals.LineChartWebBehavior();
                }
                this.secondSelectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = options.dots;
                var areas = options.areas;
                var clickHandler = function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                    _this.sendSelectionToHost();
                    if (_this.sendSelectionToLegend) _this.sendSelectionToLegend();
                    if (_this.sendSelectionToVisual) _this.sendSelectionToVisual();
                };
                interactivityLines.on("click", clickHandler);
                dots.on("click", clickHandler);
                if (areas) areas.on("click", clickHandler);
                this.sendSelectionToSecondVisual = function() {
                    behavior.select(_this.hasSelection(), lines, dots, areas);
                };
            };
            WebInteractivityService.prototype.visitDataDotChart = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.DataDotChartWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var dots = options.dots;
                var clearCatcher = options.clearCatcher;
                dots.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), dots);
                    _this.sendSelectionToHost();
                });
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    behavior.select(false, dots);
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), dots);
                };
            };
            WebInteractivityService.prototype.visitDonutChart = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.DonutChartWebBehavior(options);
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var slices = options.slices;
                var highlightSlices = options.highlightSlices;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                var clickHandler = function(d) {
                    _this.select(d.data);
                    behavior.select(_this.hasSelection(), slices, false, hasHighlights, d.data);
                    behavior.select(_this.hasSelection(), highlightSlices, true, hasHighlights, d.data);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                slices.on("click", clickHandler);
                highlightSlices.on("click", clickHandler);
                slices.on("mouseover", function(d) {
                    return behavior.mouseOver(d.data);
                });
                highlightSlices.on("mouseover", function(d) {
                    return behavior.mouseOver(d.data);
                });
                slices.on("mouseout", function(d) {
                    return behavior.mouseOut(d.data);
                });
                highlightSlices.on("mouseout", function(d) {
                    return behavior.mouseOut(d.data);
                });
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), slices, false, hasHighlights);
                    behavior.select(_this.hasSelection(), highlightSlices, true, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitFunnel = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.FunnelWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var labels = options.labels;
                var clearCatcher = options.clearCatcher;
                var hasHighlights = options.hasHighlights;
                bars.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars, hasHighlights);
                    _this.sendSelectionToHost();
                });
                if (labels) {
                    labels.on("click", function(d, i) {
                        _this.select(d);
                        behavior.select(_this.hasSelection(), bars, hasHighlights);
                        _this.sendSelectionToHost();
                    });
                }
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), bars, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitScatterChart = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.ScatterChartWebBehavior();
                }
                this.selectableDataPoints = options.data.dataPoints;
                this.initAndSyncSelectionState();
                var selection = options.dataPointsSelection;
                var clearCatcher = options.clearCatcher;
                selection.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), selection);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), options.dataPointsSelection);
                };
            };
            WebInteractivityService.prototype.visitTreemap = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.TreemapWebBehavior();
                }
                this.selectableDataPoints = options.nodes;
                this.initAndSyncSelectionState();
                var shapes = options.shapes;
                var highlightShapes = options.highlightShapes;
                var labels = options.labels;
                var hasHighlights = options.hasHighlights;
                var clickHandler = function(d) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), shapes, false);
                    behavior.select(_this.hasSelection(), highlightShapes, true);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                };
                shapes.on("click", clickHandler);
                highlightShapes.on("click", clickHandler);
                labels.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), shapes, hasHighlights);
                    _this.sendSelectionToHost();
                    _this.sendSelectionToLegend();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), shapes, hasHighlights);
                };
            };
            WebInteractivityService.prototype.visitSlicer = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.SlicerWebBehavior();
                }
                var filterPropertyId = visuals.slicerProps.filterPropertyIdentifier;
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState(filterPropertyId);
                var slicers = options.slicerItemContainers;
                var slicerItemLabels = options.slicerItemLabels;
                var slicerItemInputs = options.slicerItemInputs;
                var slicerClear = options.slicerClear;
                slicers.on("mouseover", function(d) {
                    d.mouseOver = true;
                    d.mouseOut = false;
                    behavior.mouseInteractions(slicerItemLabels);
                });
                slicers.on("mouseout", function(d) {
                    d.mouseOver = false;
                    d.mouseOut = true;
                    behavior.mouseInteractions(slicerItemLabels);
                });
                slicerItemLabels.on("click", function(d) {
                    _this.select(d, _this.hasSelection());
                    behavior.select(slicerItemLabels);
                    _this.sendSelectionToHost(filterPropertyId);
                });
                slicerClear.on("click", function(d) {
                    _this.clearSelection();
                    behavior.clearSlicers(slicerItemLabels, slicerItemInputs);
                    _this.sendSelectionToHost(filterPropertyId);
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(slicerItemLabels);
                };
                this.sendSelectionToVisual();
            };
            WebInteractivityService.prototype.visitWaterfallChart = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.WaterfallChartWebBehavior();
                }
                this.selectableDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var bars = options.bars;
                var clearCatcher = options.clearCatcher;
                bars.on("click", function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bars);
                    _this.sendSelectionToHost();
                });
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), bars);
                };
            };
            WebInteractivityService.prototype.visitMap = function(options) {
                var _this = this;
                var behavior = this.behavior;
                if (!behavior) {
                    behavior = this.behavior = new visuals.MapBehavior();
                }
                this.selectableDataPoints = options.dataPoints;
                this.initAndSyncSelectionState();
                var bubbles = options.bubbles;
                var slices = options.slices;
                var shapes = options.shapes;
                var clearCatcher = options.clearCatcher;
                var clickHandler = function(d, i) {
                    _this.select(d);
                    behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                    _this.sendSelectionToHost();
                };
                if (bubbles) {
                    bubbles.on("click", clickHandler);
                }
                if (slices) {
                    slices.on("click", function(d, i) {
                        _this.select(d.data);
                        behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                        _this.sendSelectionToHost();
                    });
                }
                if (shapes) {
                    shapes.on("click", clickHandler);
                }
                clearCatcher.on("click", function() {
                    _this.clearSelection();
                    _this.sendSelectionToHost();
                });
                this.sendSelectionToVisual = function() {
                    behavior.select(_this.hasSelection(), bubbles, slices, shapes);
                };
            };
            WebInteractivityService.prototype.visitLegend = function(options) {
                var _this = this;
                var behavior = new visuals.LegendWebBehavior();
                this.selectableLegendDataPoints = options.datapoints;
                this.initAndSyncSelectionState();
                var legendItems = options.legendItems;
                var legendIcons = options.legendIcons;
                var clearCatcher = options.clearCatcher;
                legendItems.on("click", function(d) {
                    _this.select(d);
                    behavior.select(_this.legendHasSelection(), legendIcons);
                    _this.sendSelectionToVisual();
                    _this.sendSelectionToSecondVisual();
                    _this.sendSelectionToHost();
                });
                clearCatcher.on("click", function() {
                    clearLegendSelection(true);
                    _this.sendSelectionToVisual();
                    _this.sendSelectionToSecondVisual();
                });
                this.sendSelectionToLegend = function() {
                    behavior.select(_this.legendHasSelection(), legendIcons);
                };
                this.sendSelectionToLegend();
                var clearLegendSelection = function(sendToHost) {
                    _this.clearSelection();
                    behavior.select(_this.legendHasSelection(), legendIcons);
                    if (sendToHost) _this.sendSelectionToHost();
                };
            };
            return WebInteractivityService;
        }();
        visuals.WebInteractivityService = WebInteractivityService;
        var MobileInteractivityService = function() {
            function MobileInteractivityService() {}
            MobileInteractivityService.prototype.apply = function(visual, options) {
                visual.accept(this, options);
            };
            MobileInteractivityService.prototype.makeDataPointsSelectable = function() {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    sel.on("click", function(d, i) {
                        _this.behavior.select(true, sel, d, i);
                    });
                }
                return this;
            };
            MobileInteractivityService.prototype.makeRootSelectable = function(selection) {
                var _this = this;
                selection.on("click", function(d, i) {
                    _this.behavior.selectRoot();
                });
                return this;
            };
            MobileInteractivityService.prototype.makeDragable = function() {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    var drag = d3.behavior.drag().on("drag", function(d) {
                        _this.behavior.drag(0);
                    }).on("dragend", function(d) {
                        _this.behavior.drag(1);
                    });
                    sel.call(drag);
                }
                return this;
            };
            MobileInteractivityService.prototype.clearSelection = function() {};
            MobileInteractivityService.prototype.applySelectionStateToData = function(dataPoints) {
                return false;
            };
            MobileInteractivityService.prototype.visitColumnChart = function(options) {};
            MobileInteractivityService.prototype.visitLineChart = function(options) {};
            MobileInteractivityService.prototype.visitDataDotChart = function(options) {};
            MobileInteractivityService.prototype.visitDonutChart = function(options) {};
            MobileInteractivityService.prototype.visitFunnel = function(options) {};
            MobileInteractivityService.prototype.visitScatterChart = function(options) {
                var behavior = this.behavior;
                if (options.data.dataPoints.length > 0) {
                    if (!behavior) {
                        behavior = this.behavior = new visuals.ScatterChartMobileBehavior();
                    }
                    behavior.setOptions(options);
                    this.makeDataPointsSelectable(options.dataPointsSelection).makeRootSelectable(options.root).makeDragable(options.root).makeDragable(options.background);
                    behavior.selectRoot();
                }
            };
            MobileInteractivityService.prototype.visitTreemap = function(options) {};
            MobileInteractivityService.prototype.visitSlicer = function(options) {};
            MobileInteractivityService.prototype.visitWaterfallChart = function(options) {};
            MobileInteractivityService.prototype.visitMap = function(options) {};
            MobileInteractivityService.prototype.visitLegend = function(options) {};
            return MobileInteractivityService;
        }();
        visuals.MobileInteractivityService = MobileInteractivityService;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var BI;
        (function(BI) {
            var Services;
            (function(Services) {
                function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                    return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow);
                }
                Services.createGeocodingCache = createGeocodingCache;
                var GeocodingCache = function() {
                    function GeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                        this.geocodeCache = {};
                        this.maxCacheSize = maxCacheSize;
                        this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                    }
                    GeocodingCache.prototype.getCoordinates = function(query) {
                        var pair = this.geocodeCache[query.key];
                        if (pair) {
                            pair.query.incrementCacheHit();
                            return pair.coordinate;
                        }
                        pair = powerbi.localStorageService.getData(query.key);
                        if (pair) {
                            this.registerInMemory(query, pair.coordinate);
                            return pair.coordinate;
                        }
                        return undefined;
                    };
                    GeocodingCache.prototype.registerCoordinates = function(query, coordinate) {
                        this.registerInMemory(query, coordinate);
                        this.registerInStorage(query, coordinate);
                    };
                    GeocodingCache.prototype.registerInMemory = function(query, coordinate) {
                        var geocodeCache = this.geocodeCache;
                        var keys = Object.keys(geocodeCache);
                        var cacheSize = keys.length;
                        var maxCacheSize = this.maxCacheSize;
                        if (keys.length > maxCacheSize + this.maxCacheSizeOverflow) {
                            var sortedKeys = keys.sort(function(a, b) {
                                var ca = geocodeCache[a].query.getCacheHits();
                                var cb = geocodeCache[b].query.getCacheHits();
                                return ca < cb ? -1 : ca > cb ? 1 : 0;
                            });
                            for (var i = 0; i < cacheSize - maxCacheSize; i++) {
                                geocodeCache[sortedKeys[i]] = undefined;
                            }
                        }
                        geocodeCache[query.key] = {
                            query: query,
                            coordinate: coordinate
                        };
                    };
                    GeocodingCache.prototype.registerInStorage = function(query, coordinate) {
                        powerbi.localStorageService.setData(query.key, {
                            query: query,
                            coordinate: coordinate
                        });
                    };
                    return GeocodingCache;
                }();
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var visualPluginFactory;
        (function(visualPluginFactory) {
            var VisualPluginService = function() {
                function VisualPluginService() {
                    this._plugins = powerbi.visuals.plugins;
                }
                VisualPluginService.prototype.getVisuals = function() {
                    var registry = this._plugins, names = Object.keys(registry);
                    return names.map(function(name) {
                        return registry[name];
                    });
                };
                VisualPluginService.prototype.getPlugin = function(type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this._plugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                VisualPluginService.prototype.capabilities = function(type) {
                    var plugin = this.getPlugin(type);
                    if (plugin) return plugin.capabilities;
                };
                return VisualPluginService;
            }();
            visualPluginFactory.VisualPluginService = VisualPluginService;
            function createPlugin(visualPlugins, base, create) {
                var visualPlugin = powerbi.Prototype.inherit(base);
                visualPlugin.create = create;
                visualPlugins[base.name] = visualPlugin;
            }
            var MinervaVisualPluginService = function(_super) {
                __extends(MinervaVisualPluginService, _super);
                function MinervaVisualPluginService(featureSwitches) {
                    _super.call(this);
                    debug.assertValue(featureSwitches, "featureSwitches");
                    this.featureSwitches = featureSwitches;
                    this.visualPlugins = {};
                    if (this.featureSwitches.devToolsEnabled) {
                        this.addCustomVisualizations([]);
                    }
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.barChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 5,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.card, function() {
                        return new visuals.Card({
                            isScrollable: true
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 4,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredColumnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 2,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 3,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 14,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 15,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function() {
                        return new visuals.DonutChart({
                            animator: new visuals.WebDonutChartAnimator(),
                            isScrollable: true
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.funnel, function() {
                        return new visuals.FunnelChart({
                            animator: new visuals.WebFunnelAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 6,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 7,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 0,
                            isScrollable: true,
                            animator: new visuals.NullAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 1,
                            isScrollable: true,
                            animator: new visuals.NullAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 12,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 13,
                            isScrollable: true,
                            animator: new visuals.WebColumnChartAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function() {
                        return new visuals.DonutChart({
                            sliceWidthRatio: 0,
                            animator: new visuals.WebDonutChartAnimator(),
                            isScrollable: true
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 8,
                            isScrollable: true,
                            animator: new visuals.NullAnimator()
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.treemap, function() {
                        return new visuals.Treemap({
                            animator: new visuals.WebTreemapAnimator(),
                            isScrollable: true
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.waterfallChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 11,
                            isScrollable: true
                        });
                    });
                }
                MinervaVisualPluginService.prototype.getVisuals = function() {
                    var convertibleVisualTypes = [ powerbi.visuals.plugins.barChart, powerbi.visuals.plugins.columnChart, powerbi.visuals.plugins.clusteredBarChart, powerbi.visuals.plugins.clusteredColumnChart, powerbi.visuals.plugins.hundredPercentStackedBarChart, powerbi.visuals.plugins.hundredPercentStackedColumnChart, powerbi.visuals.plugins.lineChart, powerbi.visuals.plugins.areaChart, powerbi.visuals.plugins.lineStackedColumnComboChart, powerbi.visuals.plugins.lineClusteredColumnComboChart, powerbi.visuals.plugins.waterfallChart, powerbi.visuals.plugins.scatterChart, powerbi.visuals.plugins.pieChart, powerbi.visuals.plugins.treemap, powerbi.visuals.plugins.map, powerbi.visuals.plugins.table, powerbi.visuals.plugins.matrix, powerbi.visuals.plugins.filledMap, powerbi.visuals.plugins.funnel, powerbi.visuals.plugins.gauge, powerbi.visuals.plugins.multiRowCard, powerbi.visuals.plugins.card, powerbi.visuals.plugins.slicer, powerbi.visuals.plugins.donutChart ];
                    if (this.featureSwitches.devToolsEnabled) {
                        this.addCustomVisualizations(convertibleVisualTypes);
                    }
                    if (this.featureSwitches.dataDotChartEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotClusteredColumnComboChart);
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotStackedColumnComboChart);
                    }
                    return convertibleVisualTypes;
                };
                MinervaVisualPluginService.prototype.addCustomVisualizations = function(convertibleVisualTypes) {
                    var customVisualizationList = powerbi.localStorageService.getData("customVisualizations");
                    if (customVisualizationList) {
                        var len = customVisualizationList.length;
                        for (var i = 0; i < len; i++) {
                            var pluginName = customVisualizationList[i].pluginName;
                            var plugin = this.getPlugin(pluginName);
                            if (!plugin) {
                                var jsCode = customVisualizationList[i].javaScriptCode;
                                var script = $("<script/>", {
                                    html: jsCode + "//# sourceURL=" + pluginName + ".js\n" + "//# sourceMappingURL=" + pluginName + ".js.map"
                                });
                                script.attr("pluginName", pluginName);
                                $("body").append(script);
                                var style = $("<style/>", {
                                    html: customVisualizationList[i].cssCode
                                });
                                style.attr("pluginName", pluginName);
                                $("head").append(style);
                                plugin = this.getPlugin(pluginName);
                            }
                            convertibleVisualTypes.push(plugin);
                        }
                    }
                };
                MinervaVisualPluginService.prototype.getPlugin = function(type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                return MinervaVisualPluginService;
            }(VisualPluginService);
            visualPluginFactory.MinervaVisualPluginService = MinervaVisualPluginService;
            var DashboardPluginService = function(_super) {
                __extends(DashboardPluginService, _super);
                function DashboardPluginService(featureSwitches) {
                    _super.call(this);
                    debug.assertValue(featureSwitches, "featureSwitches");
                    this.featureSwitches = featureSwitches;
                    this.visualPlugins = {};
                }
                DashboardPluginService.prototype.getPlugin = function(type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                return DashboardPluginService;
            }(VisualPluginService);
            visualPluginFactory.DashboardPluginService = DashboardPluginService;
            var MobileVisualPluginService = function(_super) {
                __extends(MobileVisualPluginService, _super);
                function MobileVisualPluginService(smallViewPortProperties) {
                    var _this = this;
                    _super.call(this);
                    this.smallViewPortProperties = smallViewPortProperties || {
                        CartesianSmallViewPortProperties: {
                            hideAxesOnSmallViewPort: true,
                            hideLegendOnSmallViewPort: true,
                            MinHeightLegendVisible: MobileVisualPluginService.MinHeightLegendVisible,
                            MinHeightAxesVisible: MobileVisualPluginService.MinHeightAxesVisible
                        },
                        GaugeSmallViewPortProperties: {
                            hideGaugeSideNumbersOnSmallViewPort: true,
                            smallGaugeMarginsOnSmallViewPort: true,
                            MinHeightGaugeSideNumbersVisible: MobileVisualPluginService.MinHeightGaugeSideNumbersVisible,
                            GaugeMarginsOnSmallViewPort: MobileVisualPluginService.GaugeMarginsOnSmallViewPort
                        }
                    };
                    visuals.TooltipManager.ShowTooltips = false;
                    this.visualPlugins = {};
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 0,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 12,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 13,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function() {
                        return new visuals.CartesianChart({
                            chartType: 8,
                            cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties
                        });
                    });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.gauge, function() {
                        return new visuals.Gauge({
                            chartType: visuals.Gauge,
                            gaugeSmallViewPortProperties: _this.smallViewPortProperties.GaugeSmallViewPortProperties
                        });
                    });
                }
                MobileVisualPluginService.prototype.getPlugin = function(type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                MobileVisualPluginService.MinHeightLegendVisible = 80;
                MobileVisualPluginService.MinHeightAxesVisible = 80;
                MobileVisualPluginService.MinHeightGaugeSideNumbersVisible = 80;
                MobileVisualPluginService.GaugeMarginsOnSmallViewPort = 10;
                return MobileVisualPluginService;
            }(VisualPluginService);
            visualPluginFactory.MobileVisualPluginService = MobileVisualPluginService;
            function create() {
                return new VisualPluginService();
            }
            visualPluginFactory.create = create;
            function createMinerva(featureSwitches) {
                return new MinervaVisualPluginService(featureSwitches);
            }
            visualPluginFactory.createMinerva = createMinerva;
            function createDashboard(featureSwitches) {
                return new DashboardPluginService(featureSwitches);
            }
            visualPluginFactory.createDashboard = createDashboard;
            function createMobile(smallViewPortProperties) {
                return new MobileVisualPluginService(smallViewPortProperties);
            }
            visualPluginFactory.createMobile = createMobile;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) {
                    for (var i = 0; i < eventHandlers.length; i++) {
                        var h = eventHandlers[i];
                        h(eventArgs);
                    }
                }
            }
            controls.fire = fire;
            var ScrollbarButton = function() {
                function ScrollbarButton(owner, direction) {
                    this._owner = owner;
                    this._direction = direction;
                    this._timerHandle = undefined;
                    this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", function(e) {
                        that.onMouseDown(e);
                    });
                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Object.defineProperty(ScrollbarButton.prototype, "element", {
                    get: function() {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                ScrollbarButton.prototype.createView = function() {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon");
                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
                    this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute";
                    svgStyle.left = "0px";
                    svgStyle.top = "0px";
                    this._svg.appendChild(this._polygon);
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.arrowClassName;
                    this._element.appendChild(this._svg);
                    this._owner.element.appendChild(this._element);
                };
                ScrollbarButton.prototype.onMouseDown = function(event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._mouseUpWrapper) {
                        event.cancelBubble = true;
                        var that = this;
                        this._mouseUpWrapper = function(event) {
                            that.onMouseUp(event);
                        };
                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction);
                    this._owner.refresh();
                    this._timerHandle = setTimeout(function() {
                        that.onMouseDown(event);
                    }, 100);
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                };
                ScrollbarButton.prototype.onMouseUp = function(event) {
                    clearTimeout(this._timerHandle);
                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
                    this._mouseUpWrapper = undefined;
                };
                ScrollbarButton.prototype.arrange = function(width, height, angle) {
                    var size = Math.min(width, height);
                    var scale = size / 16;
                    var x = (width - size) / 2;
                    var y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
                    this._svg.setAttributeNS(null, "width", width + "px");
                    this._svg.setAttributeNS(null, "height", height + "px");
                    controls.HTMLElementUtils.setElementWidth(this._element, width);
                    controls.HTMLElementUtils.setElementHeight(this._element, height);
                };
                ScrollbarButton.MIN_WIDTH = 26;
                ScrollbarButton.ARROW_COLOR = "#404040";
                return ScrollbarButton;
            }();
            controls.ScrollbarButton = ScrollbarButton;
            var Scrollbar = function() {
                function Scrollbar(parentElement) {
                    this.MIN_BAR_SIZE = 10;
                    this.min = 0;
                    this.max = 10;
                    this.viewMin = 0;
                    this.viewSize = 2;
                    this.smallIncrement = 1;
                    this._onscroll = [];
                    this._screenToOffsetScale = 1;
                    this.createView(parentElement);
                    var that = this;
                    this._element.addEventListener("mousedown", function(e) {
                        that.onBackgroundMouseDown(e);
                    });
                    this._middleBar.addEventListener("mousedown", function(e) {
                        that.onMiddleBarMouseDown(e);
                    });
                    this._timerHandle = undefined;
                    this._visible = true;
                    this.element["winControl"] = this;
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Scrollbar.prototype.scrollBy = function(delta) {
                    this.scrollTo(this.viewMin + delta);
                };
                Scrollbar.prototype.scrollUp = function() {
                    this.scrollBy(-this.smallIncrement);
                };
                Scrollbar.prototype.scrollDown = function() {
                    this.scrollBy(this.smallIncrement);
                };
                Scrollbar.prototype.scrollPageUp = function() {
                    this.scrollBy(-this.viewSize);
                };
                Scrollbar.prototype.scrollPageDown = function() {
                    this.scrollBy(this.viewSize);
                };
                Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function() {
                        return this._width;
                    },
                    set: function(value) {
                        this._width = value;
                        this._element.style.width = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function() {
                        return this._height;
                    },
                    set: function(value) {
                        this._height = value;
                        this._element.style.height = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.refresh = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
                };
                Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function() {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function() {
                        return this._maxButton;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function() {
                        return this._middleBar;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype._scrollSmallIncrement = function(direction) {
                    this.scrollBy(this.smallIncrement * direction);
                };
                Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function() {
                        return this._visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function() {
                        return this._timerHandle !== undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.show = function(value) {
                    this._visible = value;
                    this.element.style.visibility = value ? "visible" : "hidden";
                    this.invalidateArrange();
                };
                Scrollbar.prototype._getMouseOffset = function(event) {
                    if (event.offsetX !== undefined) return {
                        x: event.offsetX,
                        y: event.offsetY
                    };
                    if (event.layerX !== undefined) return {
                        x: event.layerX,
                        y: event.layerY
                    };
                    return {
                        x: event.screenX,
                        y: event.screenY
                    };
                };
                Scrollbar.prototype._getOffsetXDelta = function(event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetYDelta = function(event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetXTouchDelta = function(event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                };
                Scrollbar.prototype._getOffsetYTouchDelta = function(event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                };
                Scrollbar.prototype.initTouch = function(panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel;
                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                    if ("ontouchmove" in panel) {
                        panel.addEventListener("touchstart", function(e) {
                            return _this.onTouchStart(e);
                        });
                        panel.addEventListener("touchmove", function(e) {
                            return _this.onTouchMove(e);
                        });
                        panel.addEventListener("touchend", function(e) {
                            return _this.onTouchEnd(e);
                        });
                    } else {
                        panel.addEventListener("mousedown", function(e) {
                            return _this.onTouchMouseDown(e);
                        });
                        panel.addEventListener("mousemove", function(e) {
                            return _this.onTouchMouseMove(e);
                        });
                        panel.addEventListener("mouseup", function(e) {
                            return _this.onTouchMouseUp(e);
                        });
                    }
                };
                Scrollbar.prototype.onTouchStart = function(e) {
                    if (e.touches.length === 1) {
                        this.onTouchMouseDown(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchMove = function(e) {
                    if (e.touches.length === 1) {
                        if (e.preventDefault) e.preventDefault();
                        this.onTouchMouseMove(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchEnd = function(e) {
                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                };
                Scrollbar.prototype.onTouchMouseDown = function(e) {
                    if (!this._allowMouseDrag && e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
                        return;
                    }
                    if ("setCapture" in this._touchPanel) {
                        this._touchPanel.setCapture(true);
                    }
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
                    this._touchStarted = true;
                };
                Scrollbar.prototype._getOffsetTouchDelta = function(e) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
                    return null;
                };
                Scrollbar.prototype.onTouchMouseMove = function(e) {
                    if (this._touchStarted) {
                        if (!this._offsetTouchStartPos) {
                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
                        }
                        var delta = this._getOffsetTouchDelta(e);
                        if (delta !== 0) {
                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
                            this._offsetTouchPrevPos = this._getMouseOffset(e);
                        }
                        if (e.preventDefault) e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                Scrollbar.prototype.onTouchMouseUp = function(e, bubble) {
                    if (this._touchStarted) {
                        if (this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
                                if (e.preventDefault) e.preventDefault();
                                e.cancelBubble = true;
                            }
                        }
                    }
                    if ("releaseCapture" in this._touchPanel) {
                        this._touchPanel.releaseCapture();
                    }
                    this._touchStarted = false;
                };
                Scrollbar.prototype.registerElementForMouseWheelScrolling = function(element) {
                    var _this = this;
                    element.addEventListener("mousewheel", function(e) {
                        _this.onMouseWheel(e);
                    });
                    element.addEventListener("DOMMouseScroll", function(e) {
                        _this.onFireFoxMouseWheel(e);
                    });
                };
                Scrollbar.prototype.createView = function(parentElement) {
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.className;
                    this._element.setAttribute("drag-resize-disabled", "true");
                    parentElement.appendChild(this._element);
                    this._minButton = new ScrollbarButton(this, -1);
                    this._maxButton = new ScrollbarButton(this, 1);
                    this._middleBar = document.createElement("div");
                    this._middleBar.className = Scrollbar.barClassName;
                    this._element.appendChild(this._middleBar);
                };
                Scrollbar.prototype.scrollTo = function(pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    if (viewMin !== this.viewMin) {
                        this.viewMin = viewMin;
                        fire(this._onscroll, null);
                    }
                };
                Scrollbar.prototype._scrollByPage = function(event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
                };
                Scrollbar.prototype._getRunningSize = function(net) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
                    return null;
                };
                Scrollbar.prototype._getOffsetDelta = function(event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
                    return null;
                };
                Scrollbar.prototype.scroll = function(event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
                    if (delta < 0) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
                            return;
                        }
                    } else if (delta > 0) {
                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
                            return;
                        }
                    }
                    this.scrollBy(delta);
                };
                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function() {
                        if (this._actualWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function() {
                        if (!this._actualHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function() {
                        if (!this._actualButtonWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function() {
                        if (!this._actualButtonHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.arrange = function() {
                    if (!this._actualWidth) {
                        this._actualWidth = this._element.offsetWidth;
                        this._actualHeight = this._element.offsetHeight;
                        this._actualButtonWidth = this._calculateButtonWidth();
                        this._actualButtonHeight = this._calculateButtonHeight();
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
                        this._setMaxButtonPosition();
                    }
                };
                Scrollbar.prototype._calculateButtonWidth = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
                    return null;
                };
                Scrollbar.prototype._calculateButtonHeight = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
                    return null;
                };
                Scrollbar.prototype._getMinButtonAngle = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._getMaxButtonAngle = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._setMaxButtonPosition = function() {
                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
                };
                Scrollbar.prototype.invalidateArrange = function() {
                    this._actualWidth = undefined;
                    this._actualHeight = undefined;
                    this._actualButtonWidth = undefined;
                    this._actualButtonHeight = undefined;
                };
                Scrollbar.prototype.onHoldBackgroundMouseDown = function(event) {
                    var _this = this;
                    var holdDelay = this._timerHandle ? Scrollbar.ScrollbarBackgroundMousedownHoldDelay : Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout(function() {
                        _this.onBackgroundMouseDown(event);
                    }, holdDelay);
                };
                Scrollbar.prototype.onBackgroundMouseDown = function(event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._backgroundMouseUpWrapper) {
                        event.cancelBubble = true;
                        this._backgroundMouseUpWrapper = function(event) {
                            that.onBackgroundMouseUp(event);
                        };
                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    }
                    this._scrollByPage(event);
                    this.refresh();
                    this.onHoldBackgroundMouseDown(event);
                    if (event.preventDefault) event.preventDefault();
                };
                Scrollbar.prototype.onBackgroundMouseUp = function(event) {
                    clearTimeout(this._timerHandle);
                    this._timerHandle = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    this._backgroundMouseUpWrapper = undefined;
                };
                Scrollbar.prototype.getPinchZoomY = function() {
                    return document.documentElement.clientHeight / window.innerHeight;
                };
                Scrollbar.prototype.onMiddleBarMouseDown = function(event) {
                    event.cancelBubble = true;
                    this._screenPrevMousePos = {
                        x: event.screenX,
                        y: event.screenY
                    };
                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function(e) {
                        that.onMiddleBarMouseMove(e);
                    };
                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseUpWrapper = function(e) {
                        that.onMiddleBarMouseUp(e);
                    };
                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    if (event.preventDefault) event.preventDefault();
                };
                Scrollbar.prototype.onMiddleBarMouseMove = function(event) {
                    if (!this._screenPrevMousePos) {
                        return;
                    }
                    this.scroll(event);
                    this.refresh();
                    this._screenPrevMousePos = {
                        x: event.screenX,
                        y: event.screenY
                    };
                };
                Scrollbar.prototype.onMiddleBarMouseUp = function(event) {
                    this._screenPrevMousePos = undefined;
                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseMoveWrapper = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    this._middleBarMouseUpWrapper = undefined;
                    if (event.preventDefault) event.preventDefault();
                };
                Scrollbar.prototype._getScreenContextualLeft = function(element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
                    return null;
                };
                Scrollbar.prototype._getScreenContextualRight = function(element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
                    return null;
                };
                Scrollbar.prototype.onMouseWheel = function(e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                };
                Scrollbar.prototype.onFireFoxMouseWheel = function(e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                };
                Scrollbar.prototype.mouseWheel = function(delta) {
                    if (this.visible) {
                        this.scrollBy(-delta / 120 * this.smallIncrement);
                    }
                };
                Scrollbar.prototype._getScreenMousePos = function(event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
                    return null;
                };
                Scrollbar.addDocumentMouseUpEvent = function(func) {
                    document.addEventListener("mouseup", func);
                };
                Scrollbar.removeDocumentMouseUpEvent = function(func) {
                    document.removeEventListener("mouseup", func);
                };
                Scrollbar.addDocumentMouseMoveEvent = function(func) {
                    document.addEventListener("mousemove", func);
                };
                Scrollbar.removeDocumentMouseMoveEvent = function(func) {
                    document.removeEventListener("mousemove", func);
                };
                Scrollbar.DefaultScrollbarWidth = "15px";
                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
                Scrollbar.className = "scroll-bar-div";
                Scrollbar.barClassName = "scroll-bar-part-bar";
                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
                return Scrollbar;
            }();
            controls.Scrollbar = Scrollbar;
            var HorizontalScrollbar = function(_super) {
                __extends(HorizontalScrollbar, _super);
                function HorizontalScrollbar(parentElement) {
                    _super.call(this, parentElement);
                    this.height = Scrollbar.DefaultScrollbarWidth;
                }
                HorizontalScrollbar.prototype._calculateButtonWidth = function() {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                };
                HorizontalScrollbar.prototype._calculateButtonHeight = function() {
                    return this.actualHeight;
                };
                HorizontalScrollbar.prototype._getMinButtonAngle = function() {
                    return -180;
                };
                HorizontalScrollbar.prototype._getMaxButtonAngle = function() {
                    return 0;
                };
                HorizontalScrollbar.prototype._setMaxButtonPosition = function() {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                };
                HorizontalScrollbar.prototype.refresh = function() {
                    this.arrange();
                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                };
                HorizontalScrollbar.prototype.show = function(visible) {
                    if (visible === this.visible) return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.height = this.height;
                    } else {
                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
                    }
                };
                HorizontalScrollbar.prototype._scrollByPage = function(event) {
                    var left = this.middleBar.offsetLeft;
                    var right = left + this.middleBar.offsetWidth;
                    var x = event.offsetX === undefined ? event.layerX : event.offsetX;
                    if (x > right) {
                        this.scrollPageDown();
                    } else if (x < left) {
                        this.scrollPageUp();
                    }
                };
                HorizontalScrollbar.prototype._getRunningSize = function(net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE) result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                HorizontalScrollbar.prototype._getOffsetDelta = function(event) {
                    return this._getOffsetXDelta(event);
                };
                HorizontalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                    return this._getOffsetXTouchDelta(e);
                };
                HorizontalScrollbar.prototype._getScreenContextualLeft = function(element) {
                    return element.getBoundingClientRect().left;
                };
                HorizontalScrollbar.prototype._getScreenContextualRight = function(element) {
                    return element.getBoundingClientRect().right;
                };
                HorizontalScrollbar.prototype._getScreenMousePos = function(event) {
                    return event.screenX;
                };
                return HorizontalScrollbar;
            }(Scrollbar);
            controls.HorizontalScrollbar = HorizontalScrollbar;
            var VerticalScrollbar = function(_super) {
                __extends(VerticalScrollbar, _super);
                function VerticalScrollbar(parentElement) {
                    _super.call(this, parentElement);
                    this.width = Scrollbar.DefaultScrollbarWidth;
                }
                VerticalScrollbar.prototype._calculateButtonWidth = function() {
                    return this.actualWidth;
                };
                VerticalScrollbar.prototype._calculateButtonHeight = function() {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                };
                VerticalScrollbar.prototype._getMinButtonAngle = function() {
                    return -90;
                };
                VerticalScrollbar.prototype._getMaxButtonAngle = function() {
                    return 90;
                };
                VerticalScrollbar.prototype._setMaxButtonPosition = function() {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                };
                VerticalScrollbar.prototype.refresh = function() {
                    this.arrange();
                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                };
                VerticalScrollbar.prototype.show = function(visible) {
                    if (visible === this.visible) return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.width = this.width;
                    } else {
                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
                    }
                };
                VerticalScrollbar.prototype._scrollByPage = function(event) {
                    var top = this.middleBar.offsetTop;
                    var bottom = top + this.middleBar.offsetHeight;
                    var y = event.offsetY === undefined ? event.layerY : event.offsetY;
                    if (y > bottom) {
                        this.scrollPageDown();
                    } else if (y < top) {
                        this.scrollPageUp();
                    }
                };
                VerticalScrollbar.prototype._getRunningSize = function(net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE) result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                VerticalScrollbar.prototype._getOffsetDelta = function(event) {
                    return this._getOffsetYDelta(event);
                };
                VerticalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                    return this._getOffsetYTouchDelta(e);
                };
                VerticalScrollbar.prototype._getScreenContextualLeft = function(element) {
                    return element.getBoundingClientRect().top;
                };
                VerticalScrollbar.prototype._getScreenContextualRight = function(element) {
                    return element.getBoundingClientRect().bottom;
                };
                VerticalScrollbar.prototype._getScreenMousePos = function(event) {
                    return event.screenY;
                };
                return VerticalScrollbar;
            }(Scrollbar);
            controls.VerticalScrollbar = VerticalScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var internal;
            (function(internal) {
                var TablixResizer = function() {
                    function TablixResizer(element, handler) {
                        this._element = element;
                        this._handler = handler;
                        this._elementMouseDownWrapper = null;
                        this._elementMouseMoveWrapper = null;
                        this._elementMouseOutWrapper = null;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                        this._startMousePosition = null;
                        this._originalCursor = null;
                    }
                    TablixResizer.addDocumentMouseUpEvent = function(listener) {
                        document.addEventListener("mouseup", listener);
                    };
                    TablixResizer.removeDocumentMouseUpEvent = function(listener) {
                        document.removeEventListener("mouseup", listener);
                    };
                    TablixResizer.addDocumentMouseMoveEvent = function(listener) {
                        document.addEventListener("mousemove", listener);
                    };
                    TablixResizer.removeDocumentMouseMoveEvent = function(listener) {
                        document.removeEventListener("mousemove", listener);
                    };
                    TablixResizer.getMouseCoordinates = function(event) {
                        return {
                            x: event.pageX,
                            y: event.pageY
                        };
                    };
                    TablixResizer.getMouseCoordinateDelta = function(previous, current) {
                        return {
                            x: current.x - previous.x,
                            y: current.y - previous.y
                        };
                    };
                    TablixResizer.prototype.initialize = function() {
                        var _this = this;
                        this._elementMouseDownWrapper = function(e) {
                            return _this.onElementMouseDown(e);
                        };
                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseMoveWrapper = function(e) {
                            return _this.onElementMouseMove(e);
                        };
                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseOutWrapper = function(e) {
                            return _this.onElementMouseOut(e);
                        };
                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = function(e) {
                            return _this.onElementMouseDoubleClick(e);
                        };
                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    };
                    TablixResizer.prototype.uninitialize = function() {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseDownWrapper = null;
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseMoveWrapper = null;
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseOutWrapper = null;
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = null;
                    };
                    Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function() {
                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function() {
                            return this._element;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixResizer.prototype._hotSpot = function(position) {
                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
                        return false;
                    };
                    TablixResizer.prototype.onElementMouseDown = function(event) {
                        var _this = this;
                        var position = TablixResizer.getMouseCoordinates(event);
                        if (!this._hotSpot(position)) return;
                        if ("setCapture" in this._element) {
                            this._element.setCapture();
                        }
                        event.cancelBubble = true;
                        this._startMousePosition = position;
                        this._documentMouseMoveWrapper = function(e) {
                            return _this.onDocumentMouseMove(e);
                        };
                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseUpWrapper = function(e) {
                            return _this.onDocumentMouseUp(e);
                        };
                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        if (document.documentElement) {
                            this._originalCursor = document.documentElement.style.cursor;
                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
                        }
                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
                    };
                    TablixResizer.prototype.onElementMouseMove = function(event) {
                        if (!this._startMousePosition) {
                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
                                if (this._originalCursor === null) {
                                    this._originalCursor = this._element.style.cursor;
                                    this._element.style.cursor = TablixResizer.resizeCursor;
                                }
                            } else {
                                if (this._originalCursor !== null) {
                                    this._element.style.cursor = this._originalCursor;
                                    this._originalCursor = null;
                                }
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseOut = function(event) {
                        if (!this._startMousePosition) {
                            if (this._originalCursor !== null) {
                                this._element.style.cursor = this._originalCursor;
                                this._originalCursor = null;
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseDoubleClick = function(event) {
                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event))) return;
                        this._handler.onReset(this.cell);
                    };
                    TablixResizer.prototype.onDocumentMouseMove = function(event) {
                        if (!this._startMousePosition) return;
                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                        this._handler.onResize(this.cell, delta.x, delta.y);
                    };
                    TablixResizer.prototype.onDocumentMouseUp = function(event) {
                        this._startMousePosition = null;
                        if ("releaseCapture" in this._element) {
                            this._element.releaseCapture();
                        }
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseMoveWrapper = null;
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        this._documentMouseUpWrapper = null;
                        if (document.documentElement) document.documentElement.style.cursor = this._originalCursor;
                        if (event.preventDefault) event.preventDefault();
                        this._handler.onEndResize(this.cell);
                    };
                    TablixResizer.resizeHandleSize = 4;
                    TablixResizer.resizeCursor = "e-resize";
                    return TablixResizer;
                }();
                internal.TablixResizer = TablixResizer;
                var TablixCell = function() {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = false;
                        this._presenter = presenter;
                        this.extension = extension;
                        this._presenter.initialize(this);
                        this._row = row;
                        this.item = null;
                        this.type = null;
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this._colSpan = 1;
                        this._rowSpan = 1;
                        this._contentWidth = -1;
                        this._contentHeight = -1;
                    }
                    Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function() {
                            return this._colSpan;
                        },
                        set: function(value) {
                            if (this._colSpan !== value) {
                                this._presenter.onColumnSpanChanged(value);
                                this._colSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function() {
                            return this._rowSpan;
                        },
                        set: function(value) {
                            if (this._rowSpan !== value) {
                                this._presenter.onRowSpanChanged(value);
                                this._rowSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function() {
                            return this._textAlign;
                        },
                        set: function(value) {
                            if (value !== this._textAlign) {
                                this._presenter.onTextAlignChanged(value);
                                this._textAlign = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function() {
                            return this._horizontalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function() {
                            return this._verticalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.isScrollable = function() {
                        return this._scrollable;
                    };
                    TablixCell.prototype.clear = function() {
                        if (this.isScrollable()) {
                            this.initializeScrolling();
                        }
                        this._presenter.onClear();
                        this.setContentWidth(-1);
                        this.setContentHeight(-1);
                    };
                    TablixCell.prototype.initializeScrolling = function() {
                        this._presenter.onInitializeScrolling();
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this.setContentWidth(-1);
                        this.setContentHeight(-1);
                    };
                    TablixCell.prototype.prepare = function(scrollable) {
                        if (this.isScrollable()) this.initializeScrolling();
                        this._scrollable = scrollable;
                    };
                    TablixCell.prototype.scrollVertically = function(height, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        var offsetInPixels = -height * offset;
                        this._verticalOffset = offsetInPixels;
                        this._presenter.onVerticalScroll(height, offsetInPixels);
                        this.setContentHeight(height + offsetInPixels);
                    };
                    TablixCell.prototype.scrollHorizontally = function(width, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        var offsetInPixels = -width * offset;
                        this._horizontalOffset = offsetInPixels;
                        this._presenter.onHorizontalScroll(width, offsetInPixels);
                        this.setContentWidth(width + offsetInPixels);
                    };
                    TablixCell.prototype.setContentWidth = function(value) {
                        if (value === this._contentWidth) return;
                        this._contentWidth = value;
                        this._presenter.onContentWidthChanged(value);
                    };
                    TablixCell.prototype.setContentHeight = function(value) {
                        if (value === this._contentHeight) return;
                        this._contentHeight = value;
                        this._presenter.onContentHeightChanged(value);
                    };
                    TablixCell.prototype.enableHorizontalResize = function(enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    };
                    return TablixCell;
                }();
                internal.TablixCell = TablixCell;
                var TablixColumn = function() {
                    function TablixColumn(presenter) {
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._contentWidth = -1;
                        this._width = -1;
                        this._sizeFixed = false;
                        this._aligningWidth = -1;
                        this._fixedToAligningWidth = false;
                        this._items = [];
                        this._itemType = null;
                        this._footerCell = null;
                    }
                    TablixColumn.prototype.initialize = function(owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCornerCells = [];
                        this._realizedBodyCells = [];
                    };
                    Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getType = function() {
                        if (this._realizedCornerCells.length > 0) return 0;
                        return 2;
                    };
                    TablixColumn.prototype.getColumnHeadersOrCorners = function() {
                        if (this._realizedCornerCells.length > 0) return this._realizedCornerCells;
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.columnHeadersOrCornersEqual = function(newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length) return false;
                        var count = this._items.length;
                        for (var i = 0; i < count; i++) {
                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator)) return false;
                        }
                        return true;
                    };
                    Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function() {
                            return this._itemType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getLeafItem = function() {
                        if (this._items.length === 0) return null;
                        return this._items[this._items.length - 1];
                    };
                    TablixColumn.prototype.columnHeaderOrCornerEquals = function(type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2) return false;
                        if (type1 === 0) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2)) return false;
                        } else {
                            if (!hierarchyNavigator.headerItemEquals(item1, item2)) return false;
                        }
                        return true;
                    };
                    TablixColumn.prototype.OnLeafRealized = function(hierarchyNavigator) {
                        var type = this.getType();
                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
                        } else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; i < count; i++) {
                                this._items.push(columnHeadersOrCorners[i].item);
                            }
                            this._itemType = type;
                            this.clearSize();
                        }
                    };
                    TablixColumn.prototype.clearSpanningCellsWidth = function(cells) {
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (cell.colSpan > 1) {
                                cell.setContentWidth(-1);
                            }
                        }
                    };
                    TablixColumn.prototype.addCornerCell = function(cell) {
                        cell._column = this;
                        this._realizedCornerCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addRowHeader = function(cell) {
                        cell._column = this;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    TablixColumn.prototype.addColumnHeader = function(cell, isLeaf) {
                        cell._column = this;
                        this._realizedColumnHeaders.push(cell);
                        if (isLeaf) {
                            cell.setContentWidth(this._contentWidth);
                        }
                    };
                    TablixColumn.prototype.addBodyCell = function(cell) {
                        cell._column = this;
                        this._realizedBodyCells.push(cell);
                        cell.setContentWidth(this._contentWidth);
                    };
                    Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function() {
                            return this._footerCell;
                        },
                        set: function(footerCell) {
                            this._footerCell = footerCell;
                            footerCell._column = this;
                            footerCell.setContentWidth(this._contentWidth);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.resize = function(width) {
                        if (width === this.getContentContextualWidth()) return;
                        this._contentWidth = width;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = false;
                        this._aligningWidth = -1;
                    };
                    TablixColumn.prototype.fixSize = function() {
                        var shouldAlign = this._aligningWidth !== -1;
                        var switched = shouldAlign !== this._fixedToAligningWidth;
                        if (this._sizeFixed && !switched && !shouldAlign) return;
                        if (this._aligningWidth === -1) {
                            this._contentWidth += 1;
                            this.setContentWidth(this._contentWidth);
                        } else {
                            this.setContentWidth(this._aligningWidth);
                        }
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = this._aligningWidth !== -1;
                    };
                    TablixColumn.prototype.clearSize = function() {
                        this._contentWidth = -1;
                        this.setContentWidth(this._contentWidth);
                        this._sizeFixed = false;
                    };
                    TablixColumn.prototype.getContentContextualWidth = function() {
                        return this._contentWidth;
                    };
                    TablixColumn.prototype.getCellIContentContextualWidth = function(cell) {
                        return this._presenter.getCellContentWidth(cell);
                    };
                    TablixColumn.prototype.getCellSpanningWidthWithScrolling = function(cell, tablixGrid) {
                        var width = this.getContextualWidth() + this.getScrollingOffset();
                        if (cell.colSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var columns = tablixGrid.realizedColumns;
                            for (var i = 1; i < cell.colSpan; i++) width += columns[i + index].getContextualWidth();
                        }
                        return width;
                    };
                    TablixColumn.prototype.getScrollingOffset = function() {
                        var offset = 0;
                        if (this._realizedColumnHeaders.length > 0) offset = this._realizedColumnHeaders[this._realizedColumnHeaders.length - 1].horizontalOffset;
                        return offset;
                    };
                    TablixColumn.prototype.getContextualWidth = function() {
                        if (this._width === -1 || this._contentWidth === -1) this._width = this._presenter.getWidth();
                        return this._width;
                    };
                    TablixColumn.prototype.calculateSize = function() {
                        if (this._sizeFixed) return;
                        var contentWidth = 0;
                        var count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.colSpan === 1) contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.colSpan === 1) contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._realizedCornerCells[i]));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._realizedBodyCells[i]));
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1) contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._footerCell));
                        }
                        this._contentWidth = contentWidth;
                    };
                    TablixColumn.prototype.setAligningContextualWidth = function(size) {
                        this._aligningWidth = size;
                    };
                    TablixColumn.prototype.getAligningContextualWidth = function() {
                        return this._aligningWidth;
                    };
                    TablixColumn.prototype.setContentWidth = function(value) {
                        var count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.colSpan === 1) cell.setContentWidth(value);
                        }
                        count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.colSpan === 1) cell.setContentWidth(value);
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContentWidth(value);
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContentWidth(value);
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1) this._footerCell.setContentWidth(value);
                        }
                        this._width = -1;
                    };
                    TablixColumn.prototype.getTablixCell = function() {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixColumn.prototype.getIndex = function(grid) {
                        return grid.realizedColumns.indexOf(this);
                    };
                    TablixColumn.prototype.getHeaders = function() {
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.getOtherDimensionHeaders = function() {
                        return this._realizedRowHeaders;
                    };
                    TablixColumn.prototype.getCellContextualSpan = function(cell) {
                        return cell.colSpan;
                    };
                    TablixColumn.prototype.getOtherDimensionOwner = function(cell) {
                        return cell._row;
                    };
                    return TablixColumn;
                }();
                internal.TablixColumn = TablixColumn;
                var TablixRow = function() {
                    function TablixRow(presenter) {
                        this._contentHeight = -1;
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._allocatedCells = [];
                        this._heightFixed = false;
                        this._contentHeight = -1;
                        this._height = -1;
                    }
                    TablixRow.prototype.initialize = function(owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedBodyCells = [];
                        this._realizedCornerCells = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCellsCount = 0;
                    };
                    Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function() {
                            return this._presenter;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixRow.prototype.releaseUnusedCells = function(owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    };
                    TablixRow.prototype.releaseAllCells = function(owner) {
                        this.releaseCells(owner, 0);
                    };
                    TablixRow.prototype.releaseCells = function(owner, startIndex) {
                        var cells = this._allocatedCells;
                        var length = cells.length;
                        for (var i = startIndex; i < length; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell);
                            cell.clear();
                        }
                    };
                    TablixRow.prototype.moveScrollableCellsToEnd = function(count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onAppendCell(cell);
                            this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    };
                    TablixRow.prototype.moveScrollableCellsToStart = function(count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    };
                    TablixRow.prototype.getOrCreateCornerCell = function(column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.addCornerCell(cell);
                        this._realizedCornerCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateRowHeader = function(column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addRowHeader(cell);
                        this._realizedRowHeaders.push(cell);
                        if (leaf) cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateColumnHeader = function(column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addColumnHeader(cell, leaf);
                        this._realizedColumnHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateBodyCell = function(column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addBodyCell(cell);
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterRowHeader = function(column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.footer = cell;
                        this._realizedRowHeaders.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterBodyCell = function(column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.footer = cell;
                        this._realizedBodyCells.push(cell);
                        cell.setContentHeight(this._contentHeight);
                        return cell;
                    };
                    TablixRow.prototype.getRowHeaderLeafIndex = function() {
                        var index = -1;
                        var count = this._allocatedCells.length;
                        for (var i = 0; i < count; i++) {
                            if (this._allocatedCells[i].type !== 1) break;
                            index++;
                        }
                        return index;
                    };
                    TablixRow.prototype.getAllocatedCellAt = function(index) {
                        return this._allocatedCells[index];
                    };
                    TablixRow.prototype.moveCellsBy = function(delta) {
                        if (this._allocatedCells.length === 0) return;
                        if (delta > 0) {
                            var refCell = this._allocatedCells[0];
                            for (var i = 0; i < delta; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell);
                                this._allocatedCells.unshift(cell);
                                refCell = cell;
                            }
                        } else {
                            delta = -delta;
                            for (var i = 0; i < delta; i++) {
                                this._presenter.onRemoveCell(this._allocatedCells[i]);
                            }
                            this._allocatedCells.splice(0, delta);
                        }
                    };
                    TablixRow.prototype.getRealizedCellCount = function() {
                        return this._realizedCellsCount;
                    };
                    TablixRow.prototype.getRealizedHeadersCount = function() {
                        return this._realizedRowHeaders.length;
                    };
                    TablixRow.prototype.getRealizedHeaderAt = function(index) {
                        return this._realizedRowHeaders[index];
                    };
                    TablixRow.prototype.getTablixCell = function() {
                        var realizedCells;
                        if (this._realizedRowHeaders.length > 0) {
                            realizedCells = this._realizedRowHeaders;
                        } else if (this._realizedCornerCells.length > 0) {
                            realizedCells = this._realizedCornerCells;
                        } else {
                            realizedCells = this._realizedColumnHeaders;
                        }
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixRow.prototype.getOrCreateEmptySpaceCell = function() {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        return cell;
                    };
                    TablixRow.prototype.createCell = function(row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    };
                    TablixRow.prototype.getOrCreateCell = function() {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        } else {
                            cell.colSpan = 1;
                            cell.rowSpan = 1;
                        }
                        this._realizedCellsCount = this._realizedCellsCount + 1;
                        return cell;
                    };
                    TablixRow.prototype.resize = function(height) {
                        if (height === this.getContentContextualWidth()) return;
                        this._contentHeight = height;
                        this.setContentHeight();
                        this._heightFixed = true;
                        this.setAligningContextualWidth(-1);
                    };
                    TablixRow.prototype.fixSize = function() {
                        if (this.sizeFixed()) return;
                        this.setContentHeight();
                        this._heightFixed = true;
                    };
                    TablixRow.prototype.getContentContextualWidth = function() {
                        return this._contentHeight;
                    };
                    TablixRow.prototype.getCellIContentContextualWidth = function(cell) {
                        return this.presenter.getCellContentHeight(cell);
                    };
                    TablixRow.prototype.getCellSpanningHeight = function(cell, tablixGrid) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var rows = tablixGrid.realizedRows;
                            for (var i = 1; i < cell.rowSpan; i++) height += rows[i + index].getContextualWidth();
                        }
                        return height;
                    };
                    TablixRow.prototype.getContextualWidth = function() {
                        if (this._height === -1 || this._contentHeight === -1) this._height = this._presenter.getHeight();
                        return this._height;
                    };
                    TablixRow.prototype.sizeFixed = function() {
                        return this._heightFixed;
                    };
                    TablixRow.prototype.calculateSize = function() {
                        if (this._heightFixed) return;
                        var contentHeight = 0;
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        }
                        this._contentHeight = contentHeight;
                    };
                    TablixRow.prototype.setAligningContextualWidth = function(size) {};
                    TablixRow.prototype.getAligningContextualWidth = function() {
                        return -1;
                    };
                    TablixRow.prototype.setContentHeight = function() {
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan) cell.setContentHeight(this._contentHeight);
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContentHeight(this._contentHeight);
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1) cell.setContentHeight(this._contentHeight);
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContentHeight(this._contentHeight);
                        }
                        this._height = -1;
                    };
                    TablixRow.prototype.getIndex = function(grid) {
                        return grid.realizedRows.indexOf(this);
                    };
                    TablixRow.prototype.getHeaders = function() {
                        return this._realizedRowHeaders;
                    };
                    TablixRow.prototype.getOtherDimensionHeaders = function() {
                        return this._realizedColumnHeaders;
                    };
                    TablixRow.prototype.getCellContextualSpan = function(cell) {
                        return cell.rowSpan;
                    };
                    TablixRow.prototype.getOtherDimensionOwner = function(cell) {
                        return cell._column;
                    };
                    return TablixRow;
                }();
                internal.TablixRow = TablixRow;
                var TablixGrid = function() {
                    function TablixGrid(presenter) {
                        this._presenter = presenter;
                        this._footerRow = null;
                    }
                    TablixGrid.prototype.initialize = function(owner, gridHost, footerHost) {
                        this._owner = owner;
                        this._presenter.initialize(this, gridHost, footerHost, owner);
                        this.fillColumnsProportionally = false;
                        this._realizedRows = [];
                        this._realizedColumns = [];
                        this._emptySpaceHeaderCell = null;
                        this._emptyFooterSpaceCell = null;
                    };
                    Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function() {
                            return this._fillColumnsProportionally;
                        },
                        set: function(value) {
                            if (this._fillColumnsProportionally === value) return;
                            this._fillColumnsProportionally = value;
                            this._presenter.onFillColumnsProportionallyChanged(value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function() {
                            return this._realizedColumns;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function() {
                            return this._realizedRows;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function() {
                            return this._footerRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function() {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function() {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixGrid.prototype.ShowEmptySpaceCells = function(rowSpan, width) {
                        if (this._realizedRows.length === 0) return;
                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
                            this._emptySpaceHeaderCell.colSpan = 1;
                            this._emptySpaceHeaderCell.setContentWidth(width);
                        }
                        if (this._footerRow && this._emptyFooterSpaceCell === null) {
                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
                            this._emptyFooterSpaceCell.rowSpan = 1;
                            this._emptyFooterSpaceCell.colSpan = 1;
                            this._emptyFooterSpaceCell.setContentWidth(width);
                        }
                    };
                    TablixGrid.prototype.HideEmptySpaceCells = function() {
                        if (this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell.clear();
                            this._emptySpaceHeaderCell = null;
                        }
                        if (this._emptyFooterSpaceCell) {
                            this._emptyFooterSpaceCell.clear();
                            this._emptyFooterSpaceCell = null;
                        }
                    };
                    TablixGrid.prototype.onStartRenderingIteration = function(clear) {
                        this.initializeRows(clear);
                        this.initializeColumns(clear);
                    };
                    TablixGrid.prototype.onEndRenderingIteration = function() {
                        var rows = this._rows;
                        if (rows !== undefined) {
                            var rowCount = rows.length;
                            for (var i = 0; i < rowCount; i++) {
                                rows[i].releaseUnusedCells(this._owner);
                            }
                        }
                        if (this._footerRow) {
                            this._footerRow.releaseUnusedCells(this._owner);
                        }
                    };
                    TablixGrid.prototype.onStartRenderingSession = function() {};
                    TablixGrid.prototype.onEndRenderingSession = function() {};
                    TablixGrid.prototype.getOrCreateRow = function(rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        if (currentRow === undefined) {
                            currentRow = new TablixRow(this._presenter.createRowPresenter());
                            currentRow.initialize(this);
                            this._presenter.onAppendRow(currentRow);
                            this._rows[rowIndex] = currentRow;
                        }
                        if (this._realizedRows[rowIndex] === undefined) {
                            this._realizedRows[rowIndex] = currentRow;
                        }
                        return currentRow;
                    };
                    TablixGrid.prototype.getOrCreateFootersRow = function() {
                        if (this._footerRow === null) {
                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
                            this._footerRow.initialize(this);
                            this._presenter.onAddFooterRow(this._footerRow);
                        }
                        return this._footerRow;
                    };
                    TablixGrid.prototype.moveRowsToEnd = function(moveFromIndex, count) {
                        for (var i = 0; i < count; i++) {
                            var row = this._rows[i + moveFromIndex];
                            debug.assertValue(row, "Invalid Row Index");
                            this._presenter.onRemoveRow(row);
                            this._presenter.onAppendRow(row);
                            this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveRowsToStart = function(moveToIndex, count) {
                        var refRow = this._rows[moveToIndex];
                        debug.assertValue(refRow, "Invalid Row Index");
                        for (var i = 0; i < count; i++) {
                            var row = this._rows.pop();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onInsertRowBefore(row, refRow);
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    };
                    TablixGrid.prototype.moveColumnsToEnd = function(moveFromIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToEnd(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns[i + moveFromIndex];
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveColumnsToStart = function(moveToIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToStart(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    };
                    TablixGrid.prototype.getOrCreateColumn = function(columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        if (currentColumn === undefined) {
                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter());
                            currentColumn.initialize(this);
                            this._columns[columnIndex] = currentColumn;
                        }
                        if (this._realizedColumns[columnIndex] === undefined) {
                            this._realizedColumns[columnIndex] = currentColumn;
                        }
                        return currentColumn;
                    };
                    TablixGrid.prototype.initializeColumns = function(clear) {
                        if (this._columns === undefined || clear) {
                            this._columns = [];
                        }
                        var length = this._columns.length;
                        for (var i = 0; i < length; i++) {
                            this._columns[i].initialize(this);
                        }
                        this._realizedColumns = [];
                    };
                    TablixGrid.prototype.initializeRows = function(clear) {
                        var hasFooter = this._owner.rowDimension.hasFooter() && this._footerRow !== null;
                        if (clear) {
                            var rows = this._rows;
                            if (rows) {
                                var length = rows.length;
                                for (var i = 0; i < length; i++) {
                                    rows[i].releaseAllCells(this._owner);
                                }
                                if (hasFooter) this._footerRow.releaseAllCells(this._owner);
                                this._presenter.onClear();
                                this._footerRow = null;
                                this._rows = null;
                            }
                        }
                        this._realizedRows = [];
                        if (!this._rows) {
                            this._rows = [];
                        }
                        var rows = this._rows;
                        var length = rows.length;
                        for (var i = 0; i < length; i++) {
                            rows[i].initialize(this);
                        }
                        if (hasFooter) {
                            if (!this._footerRow) {
                                this.getOrCreateFootersRow();
                            }
                            this._footerRow.initialize(this);
                        }
                    };
                    TablixGrid.prototype.getWidth = function() {
                        return this._presenter.getWidth();
                    };
                    TablixGrid.prototype.getHeight = function() {
                        return this._presenter.getHeight();
                    };
                    return TablixGrid;
                }();
                internal.TablixGrid = TablixGrid;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var internal;
            (function(internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                var TablixDomResizer = function(_super) {
                    __extends(TablixDomResizer, _super);
                    function TablixDomResizer(cell, element, handler) {
                        this._cell = cell;
                        _super.call(this, element, handler);
                    }
                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function() {
                            return this._cell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDomResizer.prototype._hotSpot = function(position) {
                        return position.x >= this.element.getBoundingClientRect().right - internal.TablixResizer.resizeHandleSize;
                    };
                    return TablixDomResizer;
                }(internal.TablixResizer);
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = function() {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        this._tableCell = null;
                        this._contentElement = internal.TablixUtils.createDiv();
                        this._contentElement.style.position = "relative";
                        if (!fitProportionally) this._contentElement.style.setProperty("float", "left");
                        this._contentHost = internal.TablixUtils.createDiv();
                        this._contentHost.style.position = "relative";
                        if (layoutKind === 1) {
                            this._contentHost.style.textOverflow = "ellipsis";
                            this._contentHost.style.paddingRight = "2px";
                        }
                        this._contentElement.appendChild(this._contentHost);
                        this._resizer = null;
                        TablixCellPresenter.addNoMarginStyle();
                    }
                    TablixCellPresenter.prototype.initialize = function(owner) {
                        this._owner = owner;
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerTableCell = function(tableCell) {
                        this._tableCell = tableCell;
                        tableCell.appendChild(this._contentElement);
                        tableCell.className = TablixCellPresenter._noMarginsStyleName;
                        tableCell.style.verticalAlign = "top";
                        tableCell.style.lineHeight = "normal";
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function() {
                            return this._tableCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        get: function() {
                            return this._contentElement;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        get: function() {
                            return this._contentHost;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerClickHandler = function(handler) {
                        this._contentElement.onclick = handler;
                    };
                    TablixCellPresenter.prototype.unregisterClickHandler = function() {
                        this._contentElement.onclick = null;
                    };
                    TablixCellPresenter.prototype.onContentWidthChanged = function(value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    };
                    TablixCellPresenter.prototype.onContentHeightChanged = function(height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    };
                    TablixCellPresenter.prototype.onColumnSpanChanged = function(value) {
                        this._tableCell.colSpan = value;
                    };
                    TablixCellPresenter.prototype.onRowSpanChanged = function(value) {
                        this._tableCell.rowSpan = value;
                    };
                    TablixCellPresenter.prototype.onTextAlignChanged = function(value) {
                        this._tableCell.style.textAlign = value;
                    };
                    TablixCellPresenter.prototype.onClear = function() {
                        this._contentHost.className = "";
                        this._contentHostStyle = "";
                        this._tableCell.className = TablixCellPresenter._noMarginsStyleName;
                        this._containerStyle = "";
                    };
                    TablixCellPresenter.prototype.onHorizontalScroll = function(width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    };
                    TablixCellPresenter.prototype.onVerticalScroll = function(height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    };
                    TablixCellPresenter.prototype.onInitializeScrolling = function() {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    };
                    TablixCellPresenter.prototype.setContentHostStyle = function(style) {
                        if (this._contentHostStyle !== style) {
                            this._contentHostStyle = style;
                            this._contentHost.className = this._contentHostStyle;
                        }
                    };
                    TablixCellPresenter.prototype.setContainerStyle = function(style) {
                        if (this._containerStyle !== style) {
                            this._containerStyle = style;
                            this._tableCell.className = this._containerStyle + " " + TablixCellPresenter._noMarginsStyleName;
                        }
                    };
                    TablixCellPresenter.prototype.clearContainerStyle = function() {
                        this._containerStyle = undefined;
                        if (this._tableCell.className !== TablixCellPresenter._noMarginsStyleName) this._tableCell.className = TablixCellPresenter._noMarginsStyleName;
                    };
                    TablixCellPresenter.prototype.enableHorizontalResize = function(enable, handler) {
                        if (enable === (this._resizer !== null)) return;
                        if (enable) {
                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
                            this._resizer.initialize();
                        } else {
                            this._resizer.uninitialize();
                            this._resizer = null;
                        }
                    };
                    TablixCellPresenter.addNoMarginStyle = function() {
                        if (!TablixCellPresenter._noMarginsStyle) {
                            var style = document.createElement("style");
                            style.appendChild(document.createTextNode("." + TablixCellPresenter._noMarginsStyleName + "{ padding: 0px; margin: 0px}"));
                            document.head.appendChild(style);
                            TablixCellPresenter._noMarginsStyle = style;
                        }
                    };
                    TablixCellPresenter.prototype.disableDragResize = function() {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    };
                    TablixCellPresenter._noMarginsStyleName = "bi-tablix-cellNoMarginStyle";
                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
                    return TablixCellPresenter;
                }();
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = function() {
                    function TablixRowPresenter(fitProportionally) {
                        this._tableRow = null;
                        this._fitProportionally = fitProportionally;
                    }
                    TablixRowPresenter.prototype.initialize = function(row) {
                        this._row = row;
                    };
                    TablixRowPresenter.prototype.createCellPresenter = function(layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    };
                    TablixRowPresenter.prototype.registerRow = function(tableRow) {
                        this._tableRow = tableRow;
                    };
                    TablixRowPresenter.prototype.onAppendCell = function(cell) {
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        } else {
                            this._tableRow.appendChild(presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onInsertCellBefore = function(cell, refCell) {
                        debug.assertValue(refCell._presenter.tableCell, "refTableCell");
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        } else {
                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onRemoveCell = function(cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    };
                    TablixRowPresenter.prototype.getHeight = function() {
                        return this.getCellHeight(this._row.getTablixCell());
                    };
                    TablixRowPresenter.prototype.getCellHeight = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    TablixRowPresenter.prototype.getCellContentHeight = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function() {
                            return this._tableRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TablixRowPresenter;
                }();
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = function(_super) {
                    __extends(DashboardRowPresenter, _super);
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        _super.call(this, fitProportionally);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardRowPresenter.prototype.getCellHeight = function(cell) {
                        return this._gridPresenter.sizeComputationManager.cellHeight;
                    };
                    DashboardRowPresenter.prototype.getCellContentHeight = function(cell) {
                        return this._gridPresenter.sizeComputationManager.contentHeight;
                    };
                    return DashboardRowPresenter;
                }(TablixRowPresenter);
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = function(_super) {
                    __extends(CanvasRowPresenter, _super);
                    function CanvasRowPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowPresenter.prototype.getCellHeight = function(cell) {
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.tableCell);
                    };
                    CanvasRowPresenter.prototype.getCellContentHeight = function(cell) {
                        return controls.HTMLElementUtils.getElementHeight(cell._presenter.contentElement);
                    };
                    return CanvasRowPresenter;
                }(TablixRowPresenter);
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = function() {
                    function TablixColumnPresenter() {}
                    TablixColumnPresenter.prototype.initialize = function(column) {
                        this._column = column;
                    };
                    TablixColumnPresenter.prototype.getWidth = function() {
                        return this.getCellWidth(this._column.getTablixCell());
                    };
                    TablixColumnPresenter.prototype.getCellWidth = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
                        return -1;
                    };
                    TablixColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellContentWidth");
                        return -1;
                    };
                    return TablixColumnPresenter;
                }();
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = function(_super) {
                    __extends(DashboardColumnPresenter, _super);
                    function DashboardColumnPresenter(gridPresenter) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardColumnPresenter.prototype.getCellWidth = function(cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    DashboardColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        return this._gridPresenter.sizeComputationManager.contentWidth;
                    };
                    return DashboardColumnPresenter;
                }(TablixColumnPresenter);
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = function(_super) {
                    __extends(CanvasColumnPresenter, _super);
                    function CanvasColumnPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnPresenter.prototype.getCellWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasColumnPresenter.prototype.getCellContentWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    return CanvasColumnPresenter;
                }(TablixColumnPresenter);
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = function() {
                    function TablixGridPresenter() {
                        this._table = internal.TablixUtils.createTable();
                        this._table.className = UNSELECTABLE_CLASS_NAME;
                        this._footerTable = internal.TablixUtils.createTable();
                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
                    }
                    TablixGridPresenter.prototype.initialize = function(owner, gridHost, footerHost, control) {
                        this._owner = owner;
                        gridHost.appendChild(this._table);
                        footerHost.appendChild(this._footerTable);
                    };
                    TablixGridPresenter.prototype.getWidth = function() {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getHeight = function() {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioX = function() {
                        return 1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioY = function() {
                        return 1;
                    };
                    TablixGridPresenter.prototype.createRowPresenter = function() {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.createColumnPresenter = function() {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.onAppendRow = function(row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        } else {
                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onInsertRowBefore = function(row, refRow) {
                        debug.assertValue(refRow.presenter.tableRow, "refTableRow");
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        } else {
                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onRemoveRow = function(row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    };
                    TablixGridPresenter.prototype.onAddFooterRow = function(row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        } else {
                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onClear = function() {
                        controls.HTMLElementUtils.clearChildren(this._table);
                        controls.HTMLElementUtils.clearChildren(this._footerTable);
                    };
                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function(value) {
                        if (value) {
                            this._table.style.width = "100%";
                            this._footerTable.style.width = "100%";
                        } else {
                            this._table.style.width = "auto";
                            this._footerTable.style.width = "auto";
                        }
                    };
                    return TablixGridPresenter;
                }();
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = function(_super) {
                    __extends(DashboardTablixGridPresenter, _super);
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        _super.call(this);
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixGridPresenter.prototype.createRowPresenter = function() {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    };
                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function() {
                        return new DashboardColumnPresenter(this);
                    };
                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function() {
                            return this._sizeComputationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DashboardTablixGridPresenter.prototype.getWidth = function() {
                        return this._sizeComputationManager.gridWidth;
                    };
                    DashboardTablixGridPresenter.prototype.getHeight = function() {
                        return this._sizeComputationManager.gridHeight;
                    };
                    return DashboardTablixGridPresenter;
                }(TablixGridPresenter);
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = function(_super) {
                    __extends(CanvasTablixGridPresenter, _super);
                    function CanvasTablixGridPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasTablixGridPresenter.prototype.createRowPresenter = function() {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    };
                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function() {
                        return new CanvasColumnPresenter();
                    };
                    CanvasTablixGridPresenter.prototype.getWidth = function() {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    };
                    CanvasTablixGridPresenter.prototype.getHeight = function() {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    };
                    return CanvasTablixGridPresenter;
                }(TablixGridPresenter);
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var internal;
            (function(internal) {
                var TablixDimensionRealizationManager = function() {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder;
                        this._adjustmentFactor = 1;
                    }
                    TablixDimensionRealizationManager.prototype._getOwner = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
                        return null;
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function() {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function() {
                            return this._adjustmentFactor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function() {
                            return this._itemsToRealizeCount;
                        },
                        set: function(count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function() {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function(contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function() {
                        var owner = this._getOwner();
                        if (owner.measureEnabled && !owner.done) {
                            this._getEstimatedItemsToRealizeCount();
                        }
                        this._realizedLeavesCount = 0;
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function(gridContextualWidth, filled) {
                        if (!filled && !this._getOwner().allItemsRealized) this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function() {
                        this._adjustmentFactor = 1;
                    };
                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function(item, cell) {};
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                        if (leaf) {
                            this._realizedLeavesCount++;
                        }
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function() {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
                    };
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
                        return 1;
                    };
                    return TablixDimensionRealizationManager;
                }();
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                var RowRealizationManager = function(_super) {
                    __extends(RowRealizationManager, _super);
                    function RowRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function(owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowRealizationManager.prototype._getOwner = function() {
                        return this._owner;
                    };
                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                        this.estimateRowsToRealizeCount();
                    };
                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function() {
                        debug.assertValue(this._owner, "_owner");
                        if (!this._owner.dimension.model) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        if (this._owner.alignToEnd) this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1; else this.itemsToRealizeCount = Math.ceil(this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
                    };
                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0) return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        var levelsArray = levels.items;
                        var levelCount = levelsArray.length;
                        var width = 0;
                        for (var i = 0; i < levelCount; i++) {
                            var level = levelsArray[i];
                            if (level.maxNonLeafWidth !== 0) width += level.maxNonLeafWidth; else width += level.maxLeafWidth;
                        }
                        return width;
                    };
                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function(items, firstVisibleIndex, levels) {
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var binder = this.binder;
                        var length = hierarchyNavigator.getCount(items);
                        for (var i = firstVisibleIndex; i < length; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount) return;
                            var item = hierarchyNavigator.getAt(items, i);
                            var label = binder.getHeaderLabel(item);
                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
                            var isLeaf = hierarchyNavigator.isLeaf(item);
                            var l = hierarchyNavigator.getLevel(item);
                            var level = levels.items[l];
                            if (!level) {
                                level = new RowWidth();
                                levels.items[l] = level;
                            }
                            if (isLeaf) {
                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
                                levels.leafCount = levels.leafCount + 1;
                            } else {
                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
                            }
                        }
                    };
                    RowRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    };
                    return RowRealizationManager;
                }(TablixDimensionRealizationManager);
                internal.RowRealizationManager = RowRealizationManager;
                var ColumnRealizationManager = function(_super) {
                    __extends(ColumnRealizationManager, _super);
                    function ColumnRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function(owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype._getOwner = function() {
                        return this._owner;
                    };
                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    };
                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function() {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                        if (this._owner.otherLayoutManager.done) return this._owner.getOtherHierarchyContextualHeight();
                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    };
                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function(rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        var binder = this.binder;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
                        var endColumnIndex = this._owner.dimension.getItemsCount();
                        this.itemsEstimatedContextualWidth = 0;
                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
                        var endRowIndex = Math.min(startRowIndex + this.rowRealizationManager.itemsToRealizeCount, this._owner.otherLayoutManager.dimension.getItemsCount() - 1);
                        var columnCount = endColumnIndex - startColumnIndex;
                        if (this._owner.alignToEnd) {
                            this.itemsToRealizeCount = columnCount;
                            return;
                        }
                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
                                this.itemsToRealizeCount = i - startColumnIndex;
                                return;
                            }
                            var maxWidth = 0;
                            var visibleSizeRatio;
                            if (i === startColumnIndex) {
                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
                            } else {
                                visibleSizeRatio = 1;
                            }
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
                            var label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; j < endRowIndex; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    };
                    ColumnRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    };
                    return ColumnRealizationManager;
                }(TablixDimensionRealizationManager);
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = function() {
                    function RowWidths() {
                        this.items = [];
                        this.leafCount = 0;
                    }
                    return RowWidths;
                }();
                internal.RowWidths = RowWidths;
                var RowWidth = function() {
                    function RowWidth() {
                        this.maxLeafWidth = 0;
                        this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                }();
                internal.RowWidth = RowWidth;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var internal;
            (function(internal) {
                var SizeComputationManager = function() {
                    function SizeComputationManager() {}
                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function() {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function() {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function() {
                            return this.visibleWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function() {
                            return this.visibleHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function() {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function() {
                            return this._cellWidth - SizeComputationManager.DashboardCellPaddingLeft - SizeComputationManager.DashboardCellPaddingRight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function() {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SizeComputationManager.prototype.updateColumnCount = function(columnCount) {
                        this._columnCount = columnCount;
                    };
                    SizeComputationManager.prototype.updateViewport = function(viewport) {
                        this._viewport = viewport;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                        this._cellHeight = SizeComputationManager.DashboardRowHeight;
                    };
                    SizeComputationManager.prototype.computeColumnWidth = function(totalColumnCount) {
                        var width = this._viewport.width;
                        if (width <= 250) {
                            return this.fitToColumnCount(3, totalColumnCount);
                        } else if (width <= 510) {
                            return this.fitToColumnCount(4, totalColumnCount);
                        } else if (width <= 770) {
                            return this.fitToColumnCount(7, totalColumnCount);
                        }
                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
                    };
                    SizeComputationManager.prototype.fitToColumnCount = function(desiredColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(desiredColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    };
                    SizeComputationManager.DashboardCellPaddingLeft = 10;
                    SizeComputationManager.DashboardCellPaddingRight = 5;
                    SizeComputationManager.DashboardRowHeight = 19;
                    return SizeComputationManager;
                }();
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = function() {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        this._owner = owner;
                        this._grid = grid;
                        this._lastScrollOffset = null;
                        this._isScrolling = false;
                        this._fixedSizeEnabled = true;
                        this._done = false;
                        this._realizationManager = realizationManager;
                    }
                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function() {
                            return this._realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function() {
                            return this._fixedSizeEnabled;
                        },
                        set: function(enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onCornerCellRealized = function(item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    };
                    DimensionLayoutManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function() {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function() {
                        return 1 - this.dimension.getFractionScrollOffset();
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function() {
                            return this._alignToEnd;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function() {
                            return this._done;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype._requiresMeasure = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
                        return true;
                    };
                    DimensionLayoutManager.prototype.startScrollingSession = function() {
                        this._isScrolling = true;
                    };
                    DimensionLayoutManager.prototype.endScrollingSession = function() {
                        this._isScrolling = false;
                    };
                    DimensionLayoutManager.prototype.isScrolling = function() {
                        return this._isScrolling;
                    };
                    DimensionLayoutManager.prototype.isResizing = function() {
                        return false;
                    };
                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function() {
                        var otherDimension = this.dimension.otherDimension;
                        var count = otherDimension.getDepth();
                        var contextualHeight = 0;
                        var items = this._getRealizedItems();
                        if (items.length > 0) {
                            for (var i = 0; i < count; i++) {
                                contextualHeight += items[i].getContextualWidth();
                            }
                        }
                        return contextualHeight;
                    };
                    DimensionLayoutManager.prototype._isAutoSized = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
                        return false;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingSession = function() {
                        this._measureEnabled = this._requiresMeasure();
                        this._gridOffset = this.dimension.otherDimension.getDepth();
                    };
                    DimensionLayoutManager.prototype.onEndRenderingSession = function() {
                        this._realizationManager.onEndRenderingSession();
                        this._alignToEnd = false;
                        this._done = false;
                        this._measureEnabled = true;
                        this._sendDimensionsToControl();
                    };
                    DimensionLayoutManager.prototype._sendDimensionsToControl = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function() {
                            return this._measureEnabled;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getFooterContextualWidth = function() {
                        return 0;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingIteration = function(clear, contextualWidth) {
                        if (this._measureEnabled && !this._done) {
                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
                        }
                        this._realizationManager.onStartRenderingIteration();
                        if (clear) {
                            this._lastScrollOffset = null;
                        } else if (this._lastScrollOffset !== null) {
                            this.swapElements();
                        }
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function() {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onEndRenderingIteration = function() {
                        if (this._done) {
                            return;
                        }
                        if (!this._measureEnabled) {
                            this._lastScrollOffset = this.dimension.scrollOffset;
                            this._done = true;
                            return;
                        }
                        var gridContextualWidth = this.getGridContextualWidth();
                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        var allRealized = this.allItemsRealized;
                        var newScrollOffset;
                        if (filled) {
                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
                        } else {
                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
                        }
                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
                        this.updateScrollbar(gridContextualWidth);
                        this._done = (filled || allRealized) && this.dimension.scrollbar.visible === originalScrollbarVisible && powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        this.dimension.scrollOffset = newScrollOffset;
                        this._lastScrollOffset = this.dimension.scrollOffset;
                    };
                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function() {
                        if (this._lastScrollOffset !== null) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
                                return delta;
                            }
                        }
                        return null;
                    };
                    DimensionLayoutManager.prototype.swapElements = function() {
                        var delta = this.getScrollDeltaWithinPage();
                        if (delta !== null) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
                                if (delta > 0) {
                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
                                } else if (delta < 0) {
                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype._getRealizedItems = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
                        return null;
                    };
                    DimensionLayoutManager.prototype.getRealizedItemsCount = function() {
                        return this._getRealizedItems().length;
                    };
                    DimensionLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
                    };
                    DimensionLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
                    };
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function() {
                        return this.getScrollDeltaWithinPage() !== null;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidth = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
                        return 0;
                    };
                    DimensionLayoutManager.prototype.updateScrollbar = function(gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset;
                        scrollbar.min = 0;
                        scrollbar.max = this.dimension.getItemsCount();
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    };
                    DimensionLayoutManager.prototype.getViewSize = function(gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (count === 0) return 0;
                        var startIndex = this._gridOffset;
                        var sizeInItems = 0;
                        var sizeInPixels = 0;
                        var widthToFill = this._contextualWidthToFill;
                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
                        var error = this.getMeaurementError(gridContextualWidth);
                        for (var i = startIndex; i < count; i++) {
                            var visibleRatio;
                            if (i === startIndex) {
                                visibleRatio = this.getVisibleSizeRatio();
                            } else visibleRatio = 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            sizeInPixels += itemContextualWidth;
                            sizeInItems += visibleRatio;
                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= (sizeInPixels - scrollableArea) / itemContextualWidth * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    };
                    DimensionLayoutManager.prototype.isScrollableHeader = function(item, items, index) {
                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
                            return false;
                        }
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) {
                            return true;
                        }
                        var currentItem = item;
                        var currentItems = items;
                        do {
                            currentItems = hierarchyNavigator.getChildren(currentItem);
                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
                            if (currentItem === undefined) {
                                break;
                            }
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
                                return false;
                            }
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return true;
                    };
                    DimensionLayoutManager.prototype.reachedEnd = function() {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    DimensionLayoutManager.prototype.scrollBackwardToFill = function(gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - widthToFill / averageColumnwidth));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        }
                        return newScrollOffset;
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidth = function(index) {
                        return this._getRealizedItems()[index].getContextualWidth();
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function(index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    };
                    DimensionLayoutManager.prototype.getSizeWithScrolling = function(size, index) {
                        var ratio;
                        if (this._gridOffset === index) {
                            ratio = this.getVisibleSizeRatio();
                        } else {
                            ratio = 1;
                        }
                        return size * ratio;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function() {
                        var count = this.getRealizedItemsCount();
                        var contextualWidth = 0;
                        for (var i = 0; i < count; i++) {
                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        }
                        return contextualWidth;
                    };
                    DimensionLayoutManager.prototype.getMeaurementError = function(gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    };
                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function(gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) {
                                var count = this.getRealizedItemsCount();
                                var startIndex = this._gridOffset;
                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
                                var error = this.getMeaurementError(gridContextualWidth);
                                for (var i = startIndex; i < count; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        widthToScroll -= itemContextualWidth;
                                    } else {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + widthToScroll * visibleRatio / itemContextualWidth);
                                        break;
                                    }
                                }
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function() {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function() {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function() {
                            return this._contextualWidthToFill;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getGridScale = function() {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
                        return 0;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getActualContextualWidth = function(gridContextualWidth) {
                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth)) return gridContextualWidth;
                        return this._contextualWidthToFill;
                    };
                    DimensionLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
                        return false;
                    };
                    DimensionLayoutManager.prototype.calculateSizes = function() {
                        if (this.fixedSizeEnabled) {
                            this.calculateContextualWidths();
                            this.calculateSpans();
                        }
                    };
                    DimensionLayoutManager.prototype._calculateSize = function(item) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
                    };
                    DimensionLayoutManager.prototype.calculateContextualWidths = function() {
                        var items = this._getRealizedItems();
                        var count = items.length;
                        for (var i = 0; i < count; i++) {
                            var item = items[i];
                            if (this.measureEnabled) item.setAligningContextualWidth(-1);
                            this._calculateSize(item);
                        }
                    };
                    DimensionLayoutManager.prototype.calculateSpans = function() {
                        if (this.measureEnabled) {
                            this.updateNonScrollableItemsSpans();
                            this.updateScrollableItemsSpans();
                        }
                    };
                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function() {
                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
                        var otherDimensionItemsCount = otherDimensionItems.length;
                        var startIndex = this.dimension.getDepth();
                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function() {
                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
                        for (var i = 0; i < otherRealizedItemsCount; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.fixSizes = function() {
                        if (this.fixedSizeEnabled) {
                            var items = this._getRealizedItems();
                            var count = items.length;
                            for (var i = 0; i < count; i++) {
                                items[i].fixSize();
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateSpans = function(otherRealizedItem, cells) {
                        var realizedItems = this._getRealizedItems();
                        var cellCount = cells.length;
                        for (var j = 0; j < cellCount; j++) {
                            var cell = cells[j];
                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
                            var span = owner.getCellContextualSpan(cell);
                            if (span > 1) {
                                var totalSizeInSpan = 0;
                                var startIndex = owner.getIndex(this._grid);
                                for (var k = 0; k < span; k++) {
                                    var item = realizedItems[k + startIndex];
                                    totalSizeInSpan += this.getSizeWithScrolling(item.getContentContextualWidth(), k + startIndex);
                                    if (k === span - 1) this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateLastChildSize = function(spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        if (delta > 0) item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    };
                    DimensionLayoutManager._pixelPrecision = 1.0001;
                    DimensionLayoutManager._scrollOffsetPrecision = .01;
                    return DimensionLayoutManager;
                }();
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = function() {
                    function ResizeState(column, width, scale) {
                        this.column = column;
                        this.item = column.getLeafItem();
                        this.itemType = column.itemType;
                        this.startColumnWidth = width;
                        this.resizingDelta = 0;
                        this.animationFrame = null;
                        this.scale = scale;
                    }
                    return ResizeState;
                }();
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = function(_super) {
                    __extends(ColumnLayoutManager, _super);
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                        this.fillProportionally = false;
                        this._resizeState = null;
                    }
                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function() {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.isResizing = function() {
                        return this._resizeState !== null;
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function() {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function(value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.getGridScale = function() {
                        return this._grid._presenter.getScreenToCssRatioX();
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype._getRealizedItems = function() {
                        return this._grid.realizedColumns;
                    };
                    ColumnLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    };
                    ColumnLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    };
                    ColumnLayoutManager.prototype._requiresMeasure = function() {
                        return !this.isScrolling() && !this.otherLayoutManager.isScrolling() || this.isScrolling() || this.isResizing();
                    };
                    ColumnLayoutManager.prototype.getGridContextualWidth = function() {
                        return this._grid.getWidth();
                    };
                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function() {
                        return this._grid.realizedColumns[this._gridOffset];
                    };
                    ColumnLayoutManager.prototype._isAutoSized = function() {
                        return this.owner.owner.autoSizeWidth;
                    };
                    ColumnLayoutManager.prototype.applyScrolling = function() {
                        var columnOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleColumnWidth = 0;
                        if (columnOffset !== 0) {
                            var firstVisibleColumn = this.getFirstVisibleColumn();
                            if (firstVisibleColumn !== undefined) {
                                firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                                this.scroll(firstVisibleColumn, firstVisibleColumnWidth, columnOffset);
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.scroll = function(firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
                        if (firstVisibleColumn.footer !== null) {
                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollCells = function(cells, width, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollBodyCells = function(rows, width, offset) {
                        var length = rows.length;
                        var cells;
                        var cell;
                        for (var i = 0; i < length; i++) {
                            cells = rows[i]._realizedBodyCells;
                            if (cells !== undefined) {
                                cell = cells[0];
                                if (cell !== undefined) {
                                    cell.scrollHorizontally(width, offset);
                                }
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.onStartResize = function(cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    };
                    ColumnLayoutManager.prototype.onResize = function(cell, deltaX, deltaY) {
                        var _this = this;
                        this._resizeState.resizingDelta = Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth);
                        if (this._resizeState.animationFrame === null) this._resizeState.animationFrame = requestAnimationFrame(function() {
                            return _this.performResizing();
                        });
                    };
                    ColumnLayoutManager.prototype.onEndResize = function(cell) {
                        if (this._resizeState.animationFrame !== null) {
                            this.performResizing();
                        }
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.onReset = function(cell) {
                        this._resizeState = new ResizeState(cell._column, -1, 1);
                        cell._column.clearSize();
                        this.owner.owner.refresh(false);
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.updateItemToResizeState = function(realizedColumns) {
                        if (this._resizeState === null) return;
                        var columnCount = realizedColumns.length;
                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
                        var startIndex = this.otherLayoutManager.dimension.getDepth();
                        for (var i = startIndex; i < columnCount; i++) {
                            var column = realizedColumns[i];
                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator)) continue;
                            if (column !== this._resizeState.column) {
                                this._resizeState.column = column;
                                column.resize(this._resizeState.startColumnWidth + this._resizeState.resizingDelta);
                                break;
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.performResizing = function() {
                        if (this._resizeState === null) return;
                        this._resizeState.animationFrame = null;
                        var newSize = this._resizeState.startColumnWidth + this._resizeState.resizingDelta;
                        this._resizeState.column.resize(newSize);
                        this.owner.owner.refresh(false);
                    };
                    ColumnLayoutManager.prototype._sendDimensionsToControl = function() {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    };
                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
                        return -1;
                    };
                    ColumnLayoutManager.minColumnWidth = 10;
                    return ColumnLayoutManager;
                }(DimensionLayoutManager);
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = function(_super) {
                    __extends(DashboardColumnLayoutManager, _super);
                    function DashboardColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        if (this.ignoreColumn(headerIndex)) return 0;
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return false;
                    };
                    DashboardColumnLayoutManager.prototype._calculateSize = function(item) {
                        var headerIndex = item.getIndex(this._grid);
                        var computedSize = 0;
                        if (!this.ignoreColumn(headerIndex)) {
                            computedSize = this.owner.getContentWidth(undefined);
                        }
                        item.resize(computedSize);
                    };
                    DashboardColumnLayoutManager.prototype.ignoreColumn = function(headerIndex) {
                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
                    };
                    return DashboardColumnLayoutManager;
                }(ColumnLayoutManager);
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = function(_super) {
                    __extends(CanvasColumnLayoutManager, _super);
                    function CanvasColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                        return this.owner.getEstimatedTextWidth(content);
                    };
                    CanvasColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasColumnLayoutManager.prototype._calculateSize = function(item) {
                        item.calculateSize();
                    };
                    return CanvasColumnLayoutManager;
                }(ColumnLayoutManager);
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = function(_super) {
                    __extends(RowLayoutManager, _super);
                    function RowLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                    }
                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function() {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.getGridScale = function() {
                        return this._grid._presenter.getScreenToCssRatioY();
                    };
                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function() {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.startScrollingSession = function() {
                        _super.prototype.startScrollingSession.call(this);
                    };
                    RowLayoutManager.prototype._getRealizedItems = function() {
                        return this._grid.realizedRows;
                    };
                    RowLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    };
                    RowLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    };
                    RowLayoutManager.prototype._requiresMeasure = function() {
                        return !this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing() || this.isScrolling() && this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    RowLayoutManager.prototype.getGridContextualWidth = function() {
                        return this._grid.getHeight();
                    };
                    RowLayoutManager.prototype.getFirstVisibleRow = function() {
                        return this._grid.realizedRows[this._gridOffset];
                    };
                    RowLayoutManager.prototype._isAutoSized = function() {
                        return this.owner.owner.autoSizeHeight;
                    };
                    RowLayoutManager.prototype.applyScrolling = function() {
                        var rowOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleRowHeight = 0;
                        if (rowOffset !== 0) {
                            var firstVisibleRow = this.getFirstVisibleRow();
                            if (firstVisibleRow) {
                                firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
                            }
                        }
                    };
                    RowLayoutManager.prototype.scroll = function(firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    };
                    RowLayoutManager.prototype.scrollCells = function(cells, height, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollVertically(height, offset);
                        }
                    };
                    RowLayoutManager.prototype.getFooterContextualWidth = function() {
                        if (this.owner.owner.rowDimension.hasFooter()) {
                            if (this.owner.grid.footerRow) {
                                return this.owner.grid.footerRow.getContextualWidth();
                            }
                        }
                        return 0;
                    };
                    RowLayoutManager.prototype.calculateContextualWidths = function() {
                        _super.prototype.calculateContextualWidths.call(this);
                        if (this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            if (footerRow) {
                                this._calculateSize(footerRow);
                            }
                        }
                    };
                    RowLayoutManager.prototype.fixSizes = function() {
                        _super.prototype.fixSizes.call(this);
                        if (this.fixedSizeEnabled) {
                            if (this._grid.footerRow) {
                                this._grid.footerRow.fixSize();
                            }
                        }
                    };
                    RowLayoutManager.prototype._sendDimensionsToControl = function() {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0);
                    };
                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    return RowLayoutManager;
                }(DimensionLayoutManager);
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = function(_super) {
                    __extends(DashboardRowLayoutManager, _super);
                    function DashboardRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    };
                    DashboardRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return false;
                    };
                    DashboardRowLayoutManager.prototype._calculateSize = function(item) {
                        var computedSize = this.owner.getEstimatedRowHeight();
                        item.resize(computedSize);
                    };
                    DashboardRowLayoutManager.prototype.getHeaderWidth = function(headerIndex) {
                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups()) return 0;
                        return this.owner.getEstimatedTextWidth(undefined);
                    };
                    return DashboardRowLayoutManager;
                }(RowLayoutManager);
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = function(_super) {
                    __extends(CanvasRowLayoutManager, _super);
                    function CanvasRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasRowLayoutManager.prototype._calculateSize = function(item) {
                        item.calculateSize();
                    };
                    return CanvasRowLayoutManager;
                }(RowLayoutManager);
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = function() {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = true;
                        this._binder = binder;
                        this._grid = grid;
                        this._columnLayoutManager = columnLayoutManager;
                        this._rowLayoutManager = rowLayoutManager;
                    }
                    TablixLayoutManager.prototype.initialize = function(owner) {
                        this._owner = owner;
                        this._container = owner.container;
                        this._gridHost = owner.contentHost;
                        this._footersHost = owner.footerHost;
                        this._grid.initialize(owner, this._gridHost, this._footersHost);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function() {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function() {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.getTablixClassName = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
                        return null;
                    };
                    TablixLayoutManager.prototype.getLayoutKind = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
                        return null;
                    };
                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function(item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        var isLeaf = this.owner.hierarchyNavigator.isLeaf(item);
                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateRowHeader = function(item, items, rowIndex, columnIndex) {
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex);
                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        if (row.getRealizedCellCount() === 0) {
                            this.alignRowHeaderCells(item, row);
                        }
                        var cell = row.getOrCreateRowHeader(column, scrollable, this.owner.hierarchyNavigator.isLeaf(item));
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateCornerCell = function(item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel);
                        var column = this._grid.getOrCreateColumn(rowLevel);
                        var cell = row.getOrCreateCornerCell(column);
                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
                        var isLeaf = columnLevel === columnDepth - 1;
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateBodyCell = function(cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
                            scrollable = true;
                        } else {
                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        }
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function(cellItem, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0;
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function(item, items) {
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(0);
                        var cell = row.getOrCreateFooterRowHeader(column);
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getVisibleWidth = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getVisibleHeight = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
                    };
                    TablixLayoutManager.prototype.updateViewport = function(viewport) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
                    };
                    TablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getCellWidth = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getContentWidth = function(cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.alignRowHeaderCells = function(item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (index === -1) {
                            return;
                        }
                        var rowDimension = this._owner.rowDimension;
                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
                            return;
                        }
                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function() {
                            return this._grid;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function() {
                            return this._rowLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function() {
                            return this._columnLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
                        return false;
                    };
                    TablixLayoutManager.prototype.onStartRenderingSession = function(scrollingDimension, parentElement) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceHeaderCell(cell);
                            }
                            cell = this._grid.emptySpaceFooterCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceFooterCell(cell);
                            }
                            this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension;
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.startScrollingSession();
                        }
                        this._grid.onStartRenderingSession();
                        this._rowLayoutManager.onStartRenderingSession();
                        this._columnLayoutManager.onStartRenderingSession();
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        if (measureEnabled) this.measureSampleText(parentElement);
                    };
                    TablixLayoutManager.prototype.onEndRenderingSession = function() {
                        this._rowLayoutManager.onEndRenderingSession();
                        this._columnLayoutManager.onEndRenderingSession();
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.endScrollingSession();
                        }
                        this._scrollingDimension = null;
                        if (this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceHeaderCell(cell);
                                }
                                cell = this._grid.emptySpaceFooterCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }
                        this._grid.onEndRenderingSession();
                    };
                    TablixLayoutManager.prototype.onStartRenderingIteration = function(clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
                        this._grid.onStartRenderingIteration(clear);
                    };
                    TablixLayoutManager.prototype.onEndRenderingIteration = function() {
                        this._grid.onEndRenderingIteration();
                        this._columnLayoutManager.calculateSizes();
                        this._rowLayoutManager.calculateSizes();
                        this._columnLayoutManager.fixSizes();
                        this._rowLayoutManager.fixSizes();
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns);
                        this._columnLayoutManager.applyScrolling();
                        this._rowLayoutManager.applyScrolling();
                        this._columnLayoutManager.onEndRenderingIteration();
                        this._rowLayoutManager.onEndRenderingIteration();
                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
                    };
                    TablixLayoutManager.prototype.onCornerCellRealized = function(item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        if (columnLeaf) cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderRealized = function(item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function(item, cell) {};
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function(item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        if (leaf) cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onBodyCellRealized = function(item, cell) {};
                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function(item, cell) {};
                    TablixLayoutManager.prototype.setAllowHeaderResize = function(value) {
                        this._allowHeaderResize = value;
                    };
                    TablixLayoutManager.prototype.enableCellHorizontalResize = function(isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    };
                    TablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
                    };
                    return TablixLayoutManager;
                }();
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = function(_super) {
                    __extends(DashboardTablixLayoutManager, _super);
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        _super.call(this, binder, grid, new DashboardColumnLayoutManager(this, grid, columnRealizationManager), new DashboardRowLayoutManager(this, grid, rowRealizationManager));
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixLayoutManager.createLayoutManager = function(binder) {
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    DashboardTablixLayoutManager.prototype.getTablixClassName = function() {
                        return "bi-dashboard-tablix";
                    };
                    DashboardTablixLayoutManager.prototype.getLayoutKind = function() {
                        return 1;
                    };
                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        return false;
                    };
                    DashboardTablixLayoutManager.prototype.measureSampleText = function(parentElement) {};
                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function() {
                        return this._sizeComputationManager.visibleWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function() {
                        return this._sizeComputationManager.visibleHeight;
                    };
                    DashboardTablixLayoutManager.prototype.getCellWidth = function(cell) {
                        return this._sizeComputationManager.cellWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getContentWidth = function(cell) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
                        var totalColumnCount = rowDimensionDepth + columnInstances;
                        if (!this.binder.hasRowGroups()) totalColumnCount--;
                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    };
                    DashboardTablixLayoutManager.prototype.updateViewport = function(viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        return this._sizeComputationManager.cellHeight;
                    };
                    return DashboardTablixLayoutManager;
                }(TablixLayoutManager);
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = function(_super) {
                    __extends(CanvasTablixLayoutManager, _super);
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        _super.call(this, binder, grid, new CanvasColumnLayoutManager(this, grid, columnRealizationManager), new CanvasRowLayoutManager(this, grid, rowRealizationManager));
                    }
                    CanvasTablixLayoutManager.createLayoutManager = function(binder) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter()), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    CanvasTablixLayoutManager.prototype.getTablixClassName = function() {
                        return "bi-tablix";
                    };
                    CanvasTablixLayoutManager.prototype.getLayoutKind = function() {
                        return 0;
                    };
                    CanvasTablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = "left";
                        parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode);
                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
                        textDiv.removeChild(textNode);
                        parentElement.removeChild(textDiv);
                    };
                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                        return !this._columnLayoutManager.fillProportionally;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function() {
                        if (this._columnLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
                                return this._owner.maxWidth;
                            } else {
                                return controls.HTMLElementUtils.getElementWidth(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function() {
                        if (this._rowLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
                                return this._owner.maxHeight;
                            } else {
                                return controls.HTMLElementUtils.getElementHeight(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getCellWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasTablixLayoutManager.prototype.getContentWidth = function(cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function(text) {
                        return text ? text.length * this.characterWidth : 0;
                    };
                    CanvasTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {};
                    CanvasTablixLayoutManager.prototype.updateViewport = function(viewport) {};
                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                        return this.characterHeight;
                    };
                    return CanvasTablixLayoutManager;
                }(TablixLayoutManager);
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var HTMLElementUtils;
            (function(HTMLElementUtils) {
                function clearChildren(element) {
                    if (!element) {
                        return;
                    }
                    while (element.hasChildNodes()) {
                        element.removeChild(element.firstChild);
                    }
                }
                HTMLElementUtils.clearChildren = clearChildren;
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                HTMLElementUtils.setElementTop = setElementTop;
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                HTMLElementUtils.setElementLeft = setElementLeft;
                function setElementHeight(element, height) {
                    if (HTMLElementUtils.isAutoSize(height)) element.style.height = "auto"; else element.style.height = height + "px";
                }
                HTMLElementUtils.setElementHeight = setElementHeight;
                function setElementWidth(element, width) {
                    if (HTMLElementUtils.isAutoSize(width)) element.style.width = "auto"; else element.style.width = width + "px";
                }
                HTMLElementUtils.setElementWidth = setElementWidth;
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                HTMLElementUtils.getElementWidth = getElementWidth;
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                HTMLElementUtils.getElementHeight = getElementHeight;
                function isAutoSize(size) {
                    return size === -1;
                }
                HTMLElementUtils.isAutoSize = isAutoSize;
                function getAccumulatedScale(element) {
                    var scale = 1;
                    while (element) {
                        scale *= HTMLElementUtils.getScale(element);
                        element = element.parentElement;
                    }
                    return scale;
                }
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
                function getScale(element) {
                    element = $(element);
                    var str = element.css("-webkit-transform") || element.css("-moz-transform") || element.css("-ms-transform") || element.css("-o-transform") || element.css("transform");
                    return str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) || str.match(/\d+/) && Number(str.match(/\d+/)[0])) || 1;
                }
                HTMLElementUtils.getScale = getScale;
            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var internal;
            (function(internal) {
                var TablixUtils;
                (function(TablixUtils) {
                    function createTable() {
                        return document.createElement("table");
                    }
                    TablixUtils.createTable = createTable;
                    function createDiv() {
                        var div = document.createElement("div");
                        var divStyle = div.style;
                        divStyle.whiteSpace = "nowrap";
                        divStyle.overflow = "hidden";
                        divStyle.lineHeight = "normal";
                        return div;
                    }
                    TablixUtils.createDiv = createDiv;
                    function appendATagToBodyCell(value, cell) {
                        var element = cell.extension.contentHost;
                        var atag = null;
                        if (element.childElementCount === 0) {
                            atag = document.createElement("a");
                            element.appendChild(atag);
                        } else {
                            atag = element.children[0];
                        }
                        atag.href = value;
                        atag.target = "_blank";
                        atag.title = value;
                        atag.innerText = value;
                    }
                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            (function(TablixCellType) {
                TablixCellType[TablixCellType["CornerCell"] = 0] = "CornerCell";
                TablixCellType[TablixCellType["RowHeader"] = 1] = "RowHeader";
                TablixCellType[TablixCellType["ColumnHeader"] = 2] = "ColumnHeader";
                TablixCellType[TablixCellType["BodyCell"] = 3] = "BodyCell";
            })(controls.TablixCellType || (controls.TablixCellType = {}));
            var TablixCellType = controls.TablixCellType;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            (function(TablixLayoutKind) {
                TablixLayoutKind[TablixLayoutKind["Canvas"] = 0] = "Canvas";
                TablixLayoutKind[TablixLayoutKind["DashboardTile"] = 1] = "DashboardTile";
            })(controls.TablixLayoutKind || (controls.TablixLayoutKind = {}));
            var TablixLayoutKind = controls.TablixLayoutKind;
            var TablixControl = function() {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this._scrollbarWidth = 9;
                    this._fixSizedClassName = "bi-tablix-fixed-size";
                    this._options = options;
                    var isInteractive = options.interactive;
                    this._isTouchEnabled = isInteractive && options.enableTouchSupport;
                    this._mainDiv = controls.internal.TablixUtils.createDiv();
                    var mainDivStyle = this._mainDiv.style;
                    mainDivStyle.position = "absolute";
                    mainDivStyle.left = "0px";
                    mainDivStyle.top = "0px";
                    this._footerDiv = controls.internal.TablixUtils.createDiv();
                    var footerDivStyle = this._footerDiv.style;
                    footerDivStyle.position = "absolute";
                    footerDivStyle.left = "0px";
                    if (this._isTouchEnabled) this.InitializeTouchSupport();
                    this._gridDimensions = {};
                    this._container = controls.internal.TablixUtils.createDiv();
                    this.className = layoutManager.getTablixClassName();
                    this.autoSizeWidth = false;
                    this.autoSizeHeight = false;
                    parentDomElement.appendChild(this._container);
                    this._container.addEventListener("mousewheel", function(e) {
                        _this.onMouseWheel(e);
                    });
                    this._container.addEventListener("DOMMouseScroll", function(e) {
                        _this.onFireFoxMouseWheel(e);
                    });
                    this._container.appendChild(this._mainDiv);
                    this._container.appendChild(this._footerDiv);
                    if (this._isTouchEnabled) {
                        this._touchInterpreter.initTouch(this._mainDiv, null, false);
                        this._footerTouchInterpreter.initTouch(this._footerDiv, this._mainDiv, false);
                    }
                    this._layoutManager = layoutManager;
                    this._layoutManager.initialize(this);
                    this._hierarchyNavigator = hierarchyNavigator;
                    this._binder = binder;
                    this._columnDimension = new controls.TablixColumnDimension(this);
                    this._rowDimension = new controls.TablixRowDimension(this);
                    this._columnDimension._otherDimension = this.rowDimension;
                    this._rowDimension._otherDimension = this.columnDimension;
                    this.InitializeScrollbars();
                    if (!isInteractive) {
                        this.scrollbarWidth = 0;
                    }
                    this.updateHorizontalPosition();
                    this.updateVerticalPosition();
                    this.updateFooterVisibility();
                    this._lastRenderingArgs = {};
                }
                TablixControl.prototype.InitializeTouchSupport = function() {
                    this._touchManager = new controls.TouchUtils.TouchManager();
                    this._touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this._touchManager);
                    this._footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this._touchManager);
                    this._columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this._columnTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._rowTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._bodyTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._footerTouchDelegate.setHandler(this, this.onTouchEvent);
                    this._touchManager.addTouchRegion(this._columnTouchDelegate.dimension, this._columnTouchDelegate, this._columnTouchDelegate);
                    this._touchManager.addTouchRegion(this._rowTouchDelegate.dimension, this._rowTouchDelegate, this._rowTouchDelegate);
                    this._touchManager.addTouchRegion(this._bodyTouchDelegate.dimension, this._bodyTouchDelegate, this._bodyTouchDelegate);
                    this._touchManager.addTouchRegion(this._footerTouchDelegate.dimension, this._footerTouchDelegate, this._footerTouchDelegate);
                };
                TablixControl.prototype.InitializeScrollbars = function() {
                    this._rowDimension._initializeScrollbar(this._container, null);
                    var rowDimensionScrollbarStyle = this._rowDimension.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute";
                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
                    this._rowDimension.scrollbar.width = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    this._rowDimension.scrollbar.show(false);
                    this._columnDimension._initializeScrollbar(this._container, null);
                    var columnDimensionScrollbarStyle = this._columnDimension.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute";
                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
                    this._columnDimension.scrollbar.height = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    this._columnDimension.scrollbar.show(false);
                };
                Object.defineProperty(TablixControl.prototype, "container", {
                    get: function() {
                        return this._container;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function() {
                        return this._mainDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function() {
                        return this._footerDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "className", {
                    set: function(value) {
                        this._container.className = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function() {
                        return this._hierarchyNavigator;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "binder", {
                    get: function() {
                        return this._binder;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function() {
                        return this._autoSizeWidth;
                    },
                    set: function(value) {
                        this._autoSizeWidth = value;
                        if (this._autoSizeWidth) {
                            this.removeFixSizedClassName();
                        } else {
                            this.addFixedSizeClassNameIfNeeded();
                            this._container.style.minWidth = this._container.style.maxWidth = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function() {
                        return this._autoSizeHeight;
                    },
                    set: function(value) {
                        this._autoSizeHeight = value;
                        if (this._autoSizeHeight) {
                            this.removeFixSizedClassName();
                        } else {
                            this.addFixedSizeClassNameIfNeeded();
                            this._container.style.minHeight = this._container.style.maxHeight = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function() {
                        return this._maxWidth;
                    },
                    set: function(value) {
                        this._maxWidth = value;
                        this._container.style.maxWidth = this._maxWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function() {
                        return this._viewport;
                    },
                    set: function(value) {
                        this._viewport = value;
                        this._container.style.width = this._viewport.width + TablixControl.UnitOfMeasurement;
                        this._container.style.height = this._viewport.height + TablixControl.UnitOfMeasurement;
                        this._rowDimension.scrollbar.invalidateArrange();
                        this._columnDimension.scrollbar.invalidateArrange();
                        this._layoutManager.updateViewport(this._viewport);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function() {
                        return this._maxHeight;
                    },
                    set: function(value) {
                        this._maxHeight = value;
                        this._container.style.maxHeight = this._maxHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function() {
                        return this._minWidth;
                    },
                    set: function(value) {
                        this._minWidth = value;
                        this._container.style.minWidth = this._minWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function() {
                        return this._minHeight;
                    },
                    set: function(value) {
                        this._minHeight = value;
                        this._container.style.minHeight = this._minHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function(value) {
                        this._scrollbarWidth = value;
                        this._rowDimension.scrollbar.width = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._columnDimension.scrollbar.height = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.updateModels = function(resetScrollOffsets, rowModel, columnModel) {
                    if (rowModel) {
                        this._rowDimension.model = rowModel;
                        if (resetScrollOffsets) this._rowDimension.scrollOffset = 0;
                    }
                    if (columnModel) {
                        this._columnDimension.model = columnModel;
                        if (resetScrollOffsets) this._columnDimension.scrollOffset = 0;
                    }
                    this.layoutManager.updateColumnCount(this._rowDimension, this._columnDimension);
                };
                TablixControl.prototype.updateColumnDimensions = function(rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this._gridDimensions;
                    gridDimensions.columnCount = count;
                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                };
                TablixControl.prototype.updateRowDimensions = function(columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this._gridDimensions;
                    gridDimensions.rowCount = count;
                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
                    gridDimensions.footerHeight = footerHeight;
                };
                TablixControl.prototype.updateTouchDimensions = function() {
                    var gridDimensions = this._gridDimensions;
                    this._columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
                    this._columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    this._rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this._rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this._bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this._bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this._footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
                    this._footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                };
                TablixControl.prototype.onMouseWheel = function(e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                };
                TablixControl.prototype.onFireFoxMouseWheel = function(e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                };
                TablixControl.prototype.mouseWheel = function(delta) {
                    if (delta < 0) {
                        delta = Math.min(-TablixControl.MouseWheelRange, delta);
                    } else if (delta > 0) {
                        delta = Math.max(TablixControl.MouseWheelRange, delta);
                    }
                    var dimension = null;
                    if (this._rowDimension.scrollbar.visible) {
                        dimension = this._rowDimension;
                    } else if (this._columnDimension.scrollbar.visible) {
                        dimension = this._columnDimension;
                    }
                    if (dimension) {
                        dimension.scrollOffset -= delta / TablixControl.MouseWheelRange * dimension.scrollbar.smallIncrement;
                        dimension.scrollOffset = Math.max(dimension.scrollOffset, 0);
                        dimension.scrollbar.viewMin = dimension.scrollOffset;
                        this._onScrollAsync(dimension);
                    }
                };
                Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function() {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function() {
                        return this._columnDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function() {
                        return this._rowDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.refresh = function(clear) {
                    this.render(clear, null);
                };
                TablixControl.prototype._onScrollAsync = function(dimension) {
                    var _this = this;
                    requestAnimationFrame(function() {
                        _this.performPendingScroll(dimension);
                    });
                };
                TablixControl.prototype.performPendingScroll = function(dimension) {
                    this.render(false, dimension);
                };
                TablixControl.prototype.updateHorizontalPosition = function() {
                    if (this._rowDimension.scrollbar.visible) {
                        this._columnDimension.scrollbar.element.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                        this._mainDiv.style.right = this._scrollbarWidth + TablixControl.UnitOfMeasurement;
                    } else {
                        this._columnDimension.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this._mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.updateFooterVisibility = function() {
                    if (this._rowDimension.hasFooter() ? this._footerDiv.style.display !== "block" : this._footerDiv.style.display !== "none") {
                        if (this._rowDimension.hasFooter()) {
                            this._footerDiv.style.display = "block";
                        } else {
                            this._footerDiv.style.display = "none";
                        }
                    }
                };
                TablixControl.prototype.updateVerticalPosition = function() {
                    var footerHeight = 0;
                    if (this._rowDimension.hasFooter()) {
                        footerHeight = this._gridDimensions.footerHeight;
                    }
                    this._footerDiv.style.height = footerHeight + TablixControl.UnitOfMeasurement;
                    var hasVerticalScrollbar = this._rowDimension.scrollbar.visible;
                    var isDashboardTile = this._layoutManager.getLayoutKind() === 1;
                    var showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = footerHeight;
                        var footerBottom = 0;
                        var verticalScrollbarBottom = 0;
                        var hasHorizontalScrollbar = this._columnDimension.scrollbar.visible;
                        if (hasHorizontalScrollbar) {
                            mainBottom += this._scrollbarWidth;
                            footerBottom += this._scrollbarWidth;
                            verticalScrollbarBottom = this._scrollbarWidth;
                        }
                        this._mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
                        this._rowDimension.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.removeProperty("top");
                    } else {
                        this._footerDiv.style.top = this._gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
                        this._footerDiv.style.removeProperty("bottom");
                        this._mainDiv.style.removeProperty("bottom");
                    }
                };
                TablixControl.prototype.alreadyRendered = function(scrollingDimension) {
                    if (scrollingDimension !== this._lastRenderingArgs.scrollingDimension || this.rowDimension.scrollOffset !== this._lastRenderingArgs.rowScrollOffset || this.columnDimension.scrollOffset !== this._lastRenderingArgs.columnScrollOffset) {
                        return false;
                    }
                    return true;
                };
                TablixControl.prototype.render = function(clear, scrollingDimension) {
                    this._columnDimension.makeScrollOffsetValid();
                    this._rowDimension.makeScrollOffsetValid();
                    if (clear || scrollingDimension === null) {
                        this._lastRenderingArgs = {};
                    } else if (this.alreadyRendered(scrollingDimension)) {
                        return;
                    }
                    var done = false;
                    this._renderIterationCount = 0;
                    this._layoutManager.onStartRenderingSession(scrollingDimension, this._mainDiv);
                    var binder = this._binder;
                    binder.onStartRenderingSession();
                    var priorFooterHeight = this._gridDimensions.footerHeight;
                    var priorRowHierarchyHeight = this._gridDimensions.rowHierarchyHeight;
                    var priorRowHierarchyContentHeight = this._gridDimensions.rowHierarchyContentHeight;
                    while (!done) {
                        var hScrollbarVisibility = this._columnDimension.scrollbar.visible;
                        var vScrollbarVisibility = this._rowDimension.scrollbar.visible;
                        this._columnDimension._onStartRenderingIteration(clear);
                        this._rowDimension._onStartRenderingIteration(clear);
                        this._layoutManager.onStartRenderingIteration(clear);
                        this.renderCorner();
                        this._columnDimension._render();
                        this._rowDimension._render();
                        done = this._layoutManager.onEndRenderingIteration();
                        this._columnDimension._onEndRenderingIteration();
                        this._rowDimension._onEndRenderingIteration();
                        if (hScrollbarVisibility !== this._columnDimension.scrollbar.visible) {
                            this.updateVerticalPosition();
                        }
                        if (vScrollbarVisibility !== this._rowDimension.scrollbar.visible) {
                            this.updateHorizontalPosition();
                        }
                        this._renderIterationCount++;
                    }
                    this._layoutManager.onEndRenderingSession();
                    binder.onEndRenderingSession();
                    if (this._isTouchEnabled) this.updateTouchDimensions();
                    this._lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    this._lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    this.updateContainerDimensions();
                    if (this._options.interactive) {
                        this._columnDimension.scrollbar.refresh();
                        this._rowDimension.scrollbar.refresh();
                    }
                    var lastRenderingArgs = this._lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    lastRenderingArgs.scrollingDimension = scrollingDimension;
                    if (priorFooterHeight !== this._gridDimensions.footerHeight || priorRowHierarchyHeight !== this._gridDimensions.rowHierarchyHeight || priorRowHierarchyContentHeight !== this._gridDimensions.rowHierarchyContentHeight) {
                        this.updateVerticalPosition();
                    }
                };
                TablixControl.prototype.updateContainerDimensions = function() {
                    var gridDimensions = this._gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this._rowDimension.scrollbar.visible ? this._scrollbarWidth : 0;
                        this._container.style.width = gridDimensions.rowHierarchyWidth + gridDimensions.columnHierarchyWidth + vScrollBarWidth + TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this._columnDimension.scrollbar.visible ? this._scrollbarWidth : 0;
                        this._container.style.height = gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight + gridDimensions.footerHeight + hScrollBarHeight + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.cornerCellMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 0 && previousItem && this._hierarchyNavigator.cornerCellItemEquals(item, previousItem);
                };
                TablixControl.prototype.renderCorner = function() {
                    var columnDepth = this._columnDimension.getDepth();
                    var rowDepth = this._rowDimension.getDepth();
                    for (var i = 0; i < columnDepth; i++) {
                        for (var j = 0; j < rowDepth; j++) {
                            var item = this._hierarchyNavigator.getCorner(j, i);
                            var cell = this._layoutManager.getOrCreateCornerCell(item, j, i);
                            var match = this.cornerCellMatch(item, cell);
                            if (!match) {
                                this._unbindCell(cell);
                                cell.type = 0;
                                cell.item = item;
                                this._binder.bindCornerCell(item, cell);
                            }
                            this._layoutManager.onCornerCellRealized(item, cell);
                        }
                    }
                };
                TablixControl.prototype._unbindCell = function(cell) {
                    switch (cell.type) {
                      case 3:
                        this._binder.unbindBodyCell(cell.item, cell);
                        break;

                      case 2:
                        this._binder.unbindColumnHeader(cell.item, cell);
                        break;

                      case 1:
                        this._binder.unbindRowHeader(cell.item, cell);
                        break;

                      case 0:
                        this._binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null;
                    cell.type = null;
                };
                TablixControl.prototype.onTouchEvent = function(args) {
                    var colShift;
                    var rowShift;
                    var that;
                    if (args && args.length > 0) {
                        if ("_columnDimension" in args[0] && "_rowDimension" in args[0]) {
                            that = args[0];
                            colShift = that._columnDimension.scrollbar.visible ? args[1] : 0;
                            rowShift = that._rowDimension.scrollbar.visible ? args[2] : 0;
                            that._columnDimension.scrollbar.viewMin = Math.max(0, that._columnDimension.scrollbar.viewMin + colShift);
                            that._columnDimension.scrollOffset = Math.max(0, that._columnDimension.scrollOffset + colShift);
                            that._rowDimension.scrollbar.viewMin = Math.max(0, that._rowDimension.scrollbar.viewMin + rowShift);
                            that._rowDimension.scrollOffset = Math.max(0, that._rowDimension.scrollOffset + rowShift);
                            if (colShift === 0) {
                                that._onScrollAsync(that._rowDimension);
                            } else if (rowShift === 0) {
                                that._onScrollAsync(that._columnDimension);
                            } else {
                                that._onScrollAsync(null);
                            }
                        }
                    }
                };
                TablixControl.prototype.addFixedSizeClassNameIfNeeded = function() {
                    if (!this._autoSizeHeight && !this._autoSizeWidth && this._container.className.indexOf(this._fixSizedClassName) === -1) {
                        this._container.className += " " + this._fixSizedClassName;
                    }
                };
                TablixControl.prototype.removeFixSizedClassName = function() {
                    this._container.className = this._container.className.replace(this._fixSizedClassName, "");
                };
                TablixControl.UnitOfMeasurement = "px";
                TablixControl.MouseWheelRange = 120;
                return TablixControl;
            }();
            controls.TablixControl = TablixControl;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var TablixDimension = function() {
                function TablixDimension(tablixControl) {
                    this._scrollStep = .1;
                    this._owner = tablixControl;
                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
                    this._binder = tablixControl.binder;
                    this._tablixLayoutManager = tablixControl.layoutManager;
                    this.scrollOffset = 0;
                }
                TablixDimension.prototype._onStartRenderingIteration = function(clear) {
                    this.updateScrollPosition();
                };
                TablixDimension.prototype._onEndRenderingIteration = function() {};
                TablixDimension.prototype.getValidScrollOffset = function(scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                };
                TablixDimension.prototype.makeScrollOffsetValid = function() {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                };
                TablixDimension.prototype.getIntegerScrollOffset = function() {
                    return Math.floor(this.scrollOffset);
                };
                TablixDimension.prototype.getFractionScrollOffset = function() {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                };
                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function() {
                        return this._scrollbar;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype.getFirstVisibleItem = function(level) {
                    return this._scrollItems[level];
                };
                TablixDimension.prototype.getFirstVisibleChild = function(item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                };
                TablixDimension.prototype.getFirstVisibleChildIndex = function(item) {
                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    var firstVisibleIndex;
                    if (startItem === undefined || startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item) {
                        firstVisibleIndex = 0;
                    } else {
                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
                    }
                    return firstVisibleIndex;
                };
                TablixDimension.prototype._initializeScrollbar = function(parentElement, touchDiv) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement);
                    this._scrollbar._onscroll.push(function(e) {
                        return _this.onScroll();
                    });
                    if (touchDiv) {
                        this.scrollbar.initTouch(touchDiv, true);
                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
                    }
                };
                TablixDimension.prototype.getItemsCount = function() {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                };
                TablixDimension.prototype.getDepth = function() {
                    return this.model ? this._hierarchyNavigator.getDepth(this.model) : 0;
                };
                TablixDimension.prototype.onScroll = function() {
                    this.scrollOffset = this._scrollbar.viewMin;
                    this._owner._onScrollAsync(this);
                };
                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function() {
                        return this._otherDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function() {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype._createScrollbar = function(parentElement) {
                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
                    return null;
                };
                TablixDimension.prototype.updateScrollPosition = function() {
                    this._scrollItems = [];
                    if (!this.model) {
                        return;
                    }
                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                    if (!firstVisible) {
                        return;
                    }
                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                    do {
                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
                    } while (firstVisible !== null);
                };
                return TablixDimension;
            }();
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = function(_super) {
                __extends(TablixRowDimension, _super);
                function TablixRowDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.rowLayoutManager;
                    this._footer = null;
                }
                TablixRowDimension.prototype.setFooter = function(footerHeader) {
                    this._footer = footerHeader;
                    this._owner.updateFooterVisibility();
                };
                TablixRowDimension.prototype.hasFooter = function() {
                    return this._footer !== null;
                };
                TablixRowDimension.prototype._render = function() {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    if (this.hasFooter()) {
                        this.addFooterRowHeader(this._footer);
                        this.addFooterBodyCells(this._footer);
                    }
                    if (firstVisibleRowItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }
                };
                TablixRowDimension.prototype._createScrollbar = function(parentElement) {
                    return new controls.VerticalScrollbar(parentElement);
                };
                TablixRowDimension.prototype.addNodes = function(items, rowIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var item = this._hierarchyNavigator.getAt(items, i);
                        var cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan;
                    }
                };
                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function(item) {
                    var leaf = item;
                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
                        leaf = this.getFirstVisibleChild(leaf);
                    }
                    return leaf;
                };
                TablixRowDimension.prototype.bindRowHeader = function(item, cell) {
                    this._binder.bindRowHeader(item, cell);
                };
                TablixRowDimension.prototype.addNode = function(item, items, rowIndex, depth) {
                    var previousCount;
                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
                    var match = this.rowHeaderMatch(item, rowHeaderCell);
                    if (!match) {
                        this._owner._unbindCell(rowHeaderCell);
                        rowHeaderCell.type = 1;
                        rowHeaderCell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
                        rowHeaderCell.rowSpan = 1;
                        if (!match) this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                        this.addBodyCells(item, items, rowIndex);
                    } else {
                        previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
                        rowHeaderCell.colSpan = 1;
                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        if (!match) this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                    }
                    return rowHeaderCell;
                };
                TablixRowDimension.prototype.rowHeaderMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 1 && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                TablixRowDimension.prototype.addBodyCells = function(item, items, rowIndex) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
                    var hierarchyNavigator = this._hierarchyNavigator;
                    var otherModel = this._otherDimension.model;
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell);
                        layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                };
                TablixRowDimension.prototype.bindBodyCell = function(item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 3;
                        cell.item = item;
                        this._binder.bindBodyCell(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterRowHeader = function(item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 1;
                        cell.item = item;
                        this.bindRowHeader(item, cell);
                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterBodyCells = function(rowItem) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell);
                        layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.bodyCelMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 3 && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                };
                return TablixRowDimension;
            }(TablixDimension);
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = function(_super) {
                __extends(TablixColumnDimension, _super);
                function TablixColumnDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                }
                TablixColumnDimension.prototype._render = function() {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    if (firstVisibleColumnItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }
                };
                TablixColumnDimension.prototype._createScrollbar = function(parentElement) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement);
                    scrollbar.smallIncrement = .2;
                    return scrollbar;
                };
                TablixColumnDimension.prototype.addNodes = function(items, columnIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                };
                TablixColumnDimension.prototype.addNode = function(item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
                    var match = this.columnHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 2;
                        cell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
                    } else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        cell.rowSpan = 1;
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    if (!match) this._binder.bindColumnHeader(item, cell);
                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
                    return cell;
                };
                TablixColumnDimension.prototype.columnHeaderMatch = function(item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 2 && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                return TablixColumnDimension;
            }(TablixDimension);
            controls.TablixColumnDimension = TablixColumnDimension;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var ColumnTouchDelegate = function() {
                function ColumnTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSize = 1;
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                ColumnTouchDelegate.prototype.setScrollDensity = function(xRatio) {
                    this._averageSize = xRatio;
                };
                ColumnTouchDelegate.prototype.resize = function(x, y, width, height) {
                    this._dimension.x = x;
                    this._dimension.y = y;
                    this._dimension.width = width;
                    this._dimension.height = height;
                };
                ColumnTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this._averageSize, 0, down, -dx * this._averageSize, 0);
                };
                ColumnTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [];
                    args[0] = this._tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this._handlers) {
                        controls.fire([ this._handlers ], args);
                    }
                };
                ColumnTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                return ColumnTouchDelegate;
            }();
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            var RowTouchDelegate = function() {
                function RowTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSize = 30;
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                RowTouchDelegate.prototype.setScrollDensity = function(yRatio) {
                    this._averageSize = yRatio;
                };
                RowTouchDelegate.prototype.resize = function(x, y, width, height) {
                    this._dimension.x = x;
                    this._dimension.y = y;
                    this._dimension.width = width;
                    this._dimension.height = height;
                };
                RowTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this._averageSize, down, 0, -dy * this._averageSize);
                    return event;
                };
                RowTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [];
                    args[0] = this._tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this._handlers) {
                        controls.fire([ this._handlers ], args);
                    }
                };
                RowTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                return RowTouchDelegate;
            }();
            controls.RowTouchDelegate = RowTouchDelegate;
            var BodyTouchDelegate = function() {
                function BodyTouchDelegate(region) {
                    this._dimension = region;
                    this._averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
                    this._averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
                    this._handlers = null;
                    this._tablixControl = null;
                }
                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    get: function() {
                        return this._dimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                BodyTouchDelegate.prototype.setScrollDensity = function(xRatio, yRatio) {
                    this._averageSizeX = xRatio;
                    this._averageSizeY = yRatio;
                };
                BodyTouchDelegate.prototype.resize = function(x, y, width, height) {
                    var dimension = this._dimension;
                    dimension.x = x;
                    dimension.y = y;
                    dimension.width = width;
                    dimension.height = height;
                };
                BodyTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this._averageSizeX, y * this._averageSizeY, down, -dx * this._averageSizeX, -dy * this._averageSizeY);
                };
                BodyTouchDelegate.prototype.touchEvent = function(e) {
                    var args = [ this._tablixControl, e.dx, e.dy ];
                    if (this._handlers) {
                        controls.fire([ this._handlers ], args);
                    }
                };
                BodyTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                    this._handlers = handlerCall;
                    this._tablixControl = tablixObj;
                };
                BodyTouchDelegate.DefaultAverageSizeX = 30;
                BodyTouchDelegate.DefaultAverageSizeY = 30;
                return BodyTouchDelegate;
            }();
            controls.BodyTouchDelegate = BodyTouchDelegate;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var controls;
        (function(controls) {
            var TouchUtils;
            (function(TouchUtils) {
                var Point = function() {
                    function Point(x, y) {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                    Point.prototype.offset = function(offsetX, offsetY) {
                        this.x += offsetX;
                        this.y += offsetY;
                    };
                    return Point;
                }();
                TouchUtils.Point = Point;
                var Rectangle = function(_super) {
                    __extends(Rectangle, _super);
                    function Rectangle(x, y, width, height) {
                        _super.call(this, x, y);
                        this.width = width || 0;
                        this.height = height || 0;
                    }
                    Object.defineProperty(Rectangle.prototype, "point", {
                        get: function() {
                            return new Point(this.x, this.y);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Rectangle.prototype.contains = function(p) {
                        return Rectangle.contains(this, p);
                    };
                    Rectangle.contains = function(rect, p) {
                        if (p && !Rectangle.isEmpty(rect)) {
                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
                        }
                        return false;
                    };
                    Rectangle.isEmpty = function(rect) {
                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
                    };
                    return Rectangle;
                }(Point);
                TouchUtils.Rectangle = Rectangle;
                (function(SwipeDirection) {
                    SwipeDirection[SwipeDirection["Vertical"] = 0] = "Vertical";
                    SwipeDirection[SwipeDirection["Horizontal"] = 1] = "Horizontal";
                    SwipeDirection[SwipeDirection["FreeForm"] = 2] = "FreeForm";
                })(TouchUtils.SwipeDirection || (TouchUtils.SwipeDirection = {}));
                var SwipeDirection = TouchUtils.SwipeDirection;
                (function(MouseButton) {
                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
                })(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                var MouseButton = TouchUtils.MouseButton;
                var TouchEvent = function() {
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x;
                        this._y = y;
                        this._isMouseDown = isMouseDown;
                        this._dx = dx || 0;
                        this._dy = dy || 0;
                    }
                    Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function() {
                            return this._x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function() {
                            return this._y;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function() {
                            return this._dx;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function() {
                            return this._dy;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        get: function() {
                            return this._isMouseDown;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TouchEvent;
                }();
                TouchUtils.TouchEvent = TouchEvent;
                var TouchManager = function() {
                    function TouchManager() {
                        this._touchList = [];
                        this._swipeDirection = 2;
                        this._matchingDirectionCount = 0;
                        this._lockThreshold = true;
                        this._scrollThreshold = true;
                        this._lastEvent = new TouchEvent(0, 0, false);
                    }
                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function() {
                            return this._lastEvent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TouchManager.prototype.addTouchRegion = function(region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, false),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this._touchList = this._touchList.concat([ item ]);
                    };
                    TouchManager.prototype.upAllTouches = function() {
                        var eventPoint;
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].lastPoint.isMouseDown) {
                                eventPoint = this._touchList[i].converter.getPixelToItem(this._touchList[i].lastPoint.x, this._touchList[i].lastPoint.y, 0, 0, false);
                                this._touchList[i].handler.touchEvent(eventPoint);
                            }
                            this._touchList[i].lastPoint = new TouchEvent(this._touchList[i].lastPoint.x, this._touchList[i].lastPoint.y, false);
                        }
                        this._lastEvent = new TouchEvent(0, 0, false);
                    };
                    TouchManager.prototype.touchEvent = function(e) {
                        var list;
                        var length;
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = 0;
                        var angle = 0;
                        var eventPoint = null;
                        list = this._getActive();
                        if (!this._lastEvent.isMouseDown && e.isMouseDown) {
                            list = this._findRegions(e);
                        }
                        dx = this._lastEvent.x - e.x;
                        dy = this._lastEvent.y - e.y;
                        this._lastEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
                        length = list.length;
                        for (var i = 0; i < length; i++) {
                            x = e.x - list[i].region.point.x;
                            y = e.y - list[i].region.point.y;
                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
                                dx = x - list[i].lastPoint.x;
                                dy = y - list[i].lastPoint.y;
                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
                                if (this._scrollThreshold) {
                                    if (this._lockThreshold && this._matchingDirectionCount > 5) {
                                        if (this._swipeDirection === 1) {
                                            dy = 0;
                                        } else if (this._swipeDirection === 0) {
                                            dx = 0;
                                        }
                                    } else {
                                        if (angle < 20) {
                                            dy = 0;
                                            if (this._swipeDirection === 1) {
                                                this._matchingDirectionCount++;
                                            } else {
                                                this._matchingDirectionCount = 1;
                                                this._swipeDirection = 1;
                                            }
                                        } else {
                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
                                            if (angle < 20) {
                                                dx = 0;
                                                if (this._swipeDirection === 0) {
                                                    this._matchingDirectionCount++;
                                                } else {
                                                    this._matchingDirectionCount = 1;
                                                    this._swipeDirection = 0;
                                                }
                                            } else {
                                                if (this._swipeDirection === 2) {
                                                    this._matchingDirectionCount++;
                                                } else {
                                                    this._swipeDirection = 2;
                                                    this._matchingDirectionCount = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                dx = 0;
                                dy = 0;
                                this._swipeDirection = 2;
                                this._matchingDirectionCount = 0;
                            }
                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
                            list[i].handler.touchEvent(eventPoint);
                        }
                    };
                    TouchManager.prototype._findRegions = function(e) {
                        var list = [];
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].region.contains(new Point(e.x, e.y))) {
                                list = list.concat([ this._touchList[i] ]);
                            }
                        }
                        return list;
                    };
                    TouchManager.prototype._getActive = function() {
                        var list = [];
                        var length;
                        length = this._touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this._touchList[i].lastPoint.isMouseDown) {
                                list = list.concat([ this._touchList[i] ]);
                            }
                        }
                        return list;
                    };
                    return TouchManager;
                }();
                TouchUtils.TouchManager = TouchManager;
                var TouchEventInterpreter = function() {
                    function TouchEventInterpreter(manager) {
                        this._manager = manager;
                        this._allowMouseDrag = true;
                        this._touchPanel = null;
                        this._scale = 1;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                    }
                    TouchEventInterpreter.prototype.initTouch = function(panel, touchReferencePoint, allowMouseDrag) {
                        var _this = this;
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
                        this._touchReferencePoint = touchReferencePoint;
                        this._touchPanel = panel;
                        this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                        if ("ontouchmove" in panel) {
                            panel.addEventListener("touchstart", function(e) {
                                return _this.onTouchStart(e);
                            });
                            panel.addEventListener("touchend", function(e) {
                                return _this.onTouchEnd(e);
                            });
                        } else {
                            panel.addEventListener("mousedown", function(e) {
                                return _this.onTouchMouseDown(e);
                            });
                            panel.addEventListener("mouseup", function(e) {
                                return _this.onTouchMouseUp(e);
                            });
                        }
                    };
                    TouchEventInterpreter.prototype.getXYByClient = function(event) {
                        var rect = this._rect;
                        var x = rect.left;
                        var y = rect.top;
                        if (window["scrollX"] !== undefined) {
                            x += window["scrollX"];
                            y += window["scrollY"];
                        }
                        var point = new Point(0, 0);
                        point.offset(event.pageX - x, event.pageY - y);
                        return point;
                    };
                    TouchEventInterpreter.prototype.onTouchStart = function(e) {
                        if (e.touches.length === 1) {
                            e.cancelBubble = true;
                            this.onTouchMouseDown(e.touches[0]);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMove = function(e) {
                        if (e.touches.length === 1) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            this.onTouchMouseMove(e.touches[0]);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchEnd = function(e) {
                        this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                    };
                    TouchEventInterpreter.prototype.onTouchMouseDown = function(e) {
                        var _this = this;
                        this._scale = controls.HTMLElementUtils.getAccumulatedScale(this._touchPanel);
                        document.getSelection().removeAllRanges();
                        this._rect = (this._touchReferencePoint ? this._touchReferencePoint : this._touchPanel).getBoundingClientRect();
                        if ("ontouchmove" in this._touchPanel) {
                            this._documentMouseMoveWrapper = function(e) {
                                return _this.onTouchMove(e);
                            };
                            document.addEventListener("touchmove", this._documentMouseMoveWrapper);
                            this._documentMouseUpWrapper = function(e) {
                                return _this.onTouchEnd(e);
                            };
                            document.addEventListener("touchend", this._documentMouseUpWrapper);
                        } else {
                            this._documentMouseMoveWrapper = function(e) {
                                return _this.onTouchMouseMove(e);
                            };
                            document.addEventListener("mousemove", this._documentMouseMoveWrapper);
                            this._documentMouseUpWrapper = function(e) {
                                return _this.onTouchMouseUp(e);
                            };
                            document.addEventListener("mouseup", this._documentMouseUpWrapper);
                        }
                        if ("setCapture" in this._touchPanel) {
                            this._touchPanel.setCapture();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseMove = function(e) {
                        var event;
                        var point;
                        var validMouseDragEvent = this._rect !== null && e.which !== 0;
                        if (!validMouseDragEvent) return;
                        point = this.getXYByClient(e);
                        event = new TouchEvent(point.x / this._scale, point.y / this._scale, validMouseDragEvent);
                        this._manager.touchEvent(event);
                        if (e.preventDefault) e.preventDefault(); else if ("returnValue" in e) e["returnValue"] = false;
                    };
                    TouchEventInterpreter.prototype.onTouchMouseUp = function(e, bubble) {
                        this._rect = null;
                        this._manager.upAllTouches();
                        if ("releaseCapture" in this._touchPanel) {
                            this._touchPanel.releaseCapture();
                        }
                        if (this._documentMouseMoveWrapper === null) return;
                        if ("ontouchmove" in this._touchPanel) {
                            document.removeEventListener("touchmove", this._documentMouseMoveWrapper);
                            document.removeEventListener("touchend", this._documentMouseUpWrapper);
                        } else {
                            document.removeEventListener("mousemove", this._documentMouseMoveWrapper);
                            document.removeEventListener("mouseup", this._documentMouseUpWrapper);
                        }
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                    };
                    return TouchEventInterpreter;
                }();
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var AnimatedText = function() {
            function AnimatedText(name) {
                this.mainText = {
                    "class": "mainText",
                    selector: ".mainText"
                };
                this.name = name;
                this.visualConfiguration = {
                    maxFontSize: 60
                };
            }
            AnimatedText.prototype.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            this.metaDataColumn = column;
                            break;
                        }
                    }
                }
            };
            AnimatedText.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                var nodeSelection = this.svg.append("text").text(textToMeasure);
                var fontHeight = this.getAdjustedFontHeightCore(nodeSelection, availableWidth, seedFontHeight, 0);
                nodeSelection.remove();
                return fontHeight;
            };
            AnimatedText.prototype.getAdjustedFontHeightCore = function(nodeToMeasure, availableWidth, seedFontHeight, iteration) {
                if (iteration > 10) return seedFontHeight;
                nodeToMeasure.attr("font-size", seedFontHeight);
                var candidateLength = powerbi.TextMeasurementService.measureSvgTextElementWidth(nodeToMeasure[0][0]);
                if (candidateLength < availableWidth) return seedFontHeight;
                return this.getAdjustedFontHeightCore(nodeToMeasure, availableWidth, seedFontHeight * .9, iteration + 1);
            };
            AnimatedText.prototype.clear = function() {
                this.svg.select(this.mainText.selector).text("");
            };
            AnimatedText.prototype.doValueTransition = function(startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate) {
                if (!forceUpdate && startValue === endValue) return;
                if (!startValue) startValue = 0;
                var svg = this.svg, graphicsContext = this.graphicsContext, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [ endValue ], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(fontHeight), metaDataColumn = this.metaDataColumn, formatter = visuals.valueFormatter.create({
                    format: this.getFormatString(metaDataColumn),
                    value: endValue,
                    displayUnitSystemType: displayUnitSystemType,
                    formatSingleValues: true,
                    allowFormatBeautification: true
                }), startText = formatter.format(startValue), endText = formatter.format(endValue);
                svg.attr("class", this.name);
                var textElement = graphicsContext.selectAll("text").data(endValueArr);
                textElement.enter().append("text").attr("class", this.mainText.class);
                var textElementUpdate = textElement.text(startText).attr("text-anchor", this.getTextAnchor());
                var node = textElementUpdate.node();
                if (node) {
                    var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                    translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                }
                graphicsContext.attr("font-size", fontHeight).attr("transform", "translate(" + translateX + "," + translateY + ")");
                if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) {
                    textElementUpdate.text(endText);
                } else {
                    var interpolatedValue = startValue;
                    textElementUpdate.transition().duration(duration).tween("text", function(d) {
                        var i = d3.interpolate(interpolatedValue, d);
                        return function(t) {
                            var num = i(t);
                            this.textContent = formatter.format(num);
                        };
                    });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
            };
            AnimatedText.prototype.getSeedFontHeight = function(boundingWidth, boundingHeight) {
                var estimatedSize = Math.floor(Math.min(boundingWidth, boundingHeight) * .75);
                var maxFontSize = this.visualConfiguration.maxFontSize;
                if (maxFontSize) return Math.min(maxFontSize, estimatedSize);
                return estimatedSize;
            };
            AnimatedText.prototype.getTranslateX = function(width) {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                      case "left":
                        return 0;

                      case "right":
                        return width;
                    }
                }
                return width / 2;
            };
            AnimatedText.prototype.getTranslateY = function(height) {
                return height;
            };
            AnimatedText.prototype.getTextAnchor = function() {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                      case "left":
                        return "start";

                      case "right":
                        return "end";
                    }
                }
                return "middle";
            };
            AnimatedText.prototype.getFormatString = function(column) {
                debug.assertAnyValue(column, "column");
                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
            };
            AnimatedText.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            AnimatedText.objectDescs = {
                general: {
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                }
            };
            return AnimatedText;
        }();
        visuals.AnimatedText = AnimatedText;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var AnimatedNumber = function(_super) {
            __extends(AnimatedNumber, _super);
            function AnimatedNumber(svg) {
                _super.call(this, "animatedNumber");
                if (svg) this.svg = svg;
            }
            AnimatedNumber.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                if (!this.svg) this.svg = d3.select(element.get(0)).append("svg");
                this.graphicsContext = this.svg.append("g");
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportDependantProperties();
            };
            AnimatedNumber.prototype.updateViewportDependantProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            };
            AnimatedNumber.prototype.update = function(options) {
                debug.assertValue(options, "options");
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                var dataView = dataViews[0];
                this.updateViewportDependantProperties();
                this.getMetaDataColumn(dataView);
                var newValue = dataView && dataView.single ? dataView.single.value : 0;
                if (newValue != null) {
                    this.updateInternal(newValue, options.duration, true);
                }
            };
            AnimatedNumber.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration,
                    viewport: this.currentViewport
                });
            };
            AnimatedNumber.prototype.onResizing = function(viewport, duration) {
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewport: viewport
                });
            };
            AnimatedNumber.prototype.canResizeTo = function(viewport) {
                return true;
            };
            AnimatedNumber.prototype.updateInternal = function(target, duration, forceUpdate) {
                if (duration === void 0) {
                    duration = 0;
                }
                if (forceUpdate === void 0) {
                    forceUpdate = false;
                }
                var start = this.value || 0;
                this.doValueTransition(start, target, null, this.options.animation, duration, forceUpdate);
                this.value = target;
            };
            AnimatedNumber.capabilities = {
                objects: visuals.AnimatedText.objectDescs,
                dataViewMappings: [ {
                    single: {
                        role: "Values"
                    }
                } ]
            };
            return AnimatedNumber;
        }(visuals.AnimatedText);
        visuals.AnimatedNumber = AnimatedNumber;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = .1;
        (function(CartesianChartType) {
            CartesianChartType[CartesianChartType["Line"] = 0] = "Line";
            CartesianChartType[CartesianChartType["Area"] = 1] = "Area";
            CartesianChartType[CartesianChartType["ClusteredColumn"] = 2] = "ClusteredColumn";
            CartesianChartType[CartesianChartType["StackedColumn"] = 3] = "StackedColumn";
            CartesianChartType[CartesianChartType["ClusteredBar"] = 4] = "ClusteredBar";
            CartesianChartType[CartesianChartType["StackedBar"] = 5] = "StackedBar";
            CartesianChartType[CartesianChartType["HundredPercentStackedBar"] = 6] = "HundredPercentStackedBar";
            CartesianChartType[CartesianChartType["HundredPercentStackedColumn"] = 7] = "HundredPercentStackedColumn";
            CartesianChartType[CartesianChartType["Scatter"] = 8] = "Scatter";
            CartesianChartType[CartesianChartType["ComboChart"] = 9] = "ComboChart";
            CartesianChartType[CartesianChartType["DataDot"] = 10] = "DataDot";
            CartesianChartType[CartesianChartType["Waterfall"] = 11] = "Waterfall";
            CartesianChartType[CartesianChartType["LineClusteredColumnCombo"] = 12] = "LineClusteredColumnCombo";
            CartesianChartType[CartesianChartType["LineStackedColumnCombo"] = 13] = "LineStackedColumnCombo";
            CartesianChartType[CartesianChartType["DataDotClusteredColumnCombo"] = 14] = "DataDotClusteredColumnCombo";
            CartesianChartType[CartesianChartType["DataDotStackedColumnCombo"] = 15] = "DataDotStackedColumnCombo";
        })(visuals.CartesianChartType || (visuals.CartesianChartType = {}));
        var CartesianChartType = visuals.CartesianChartType;
        (function(AxisLinesVisibility) {
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnXAxis"] = 1] = "ShowLinesOnXAxis";
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnYAxis"] = 2] = "ShowLinesOnYAxis";
            AxisLinesVisibility[AxisLinesVisibility["ShowLinesOnBothAxis"] = AxisLinesVisibility.ShowLinesOnXAxis | AxisLinesVisibility.ShowLinesOnYAxis] = "ShowLinesOnBothAxis";
        })(visuals.AxisLinesVisibility || (visuals.AxisLinesVisibility = {}));
        var AxisLinesVisibility = visuals.AxisLinesVisibility;
        var CartesianChart = function() {
            function CartesianChart(options) {
                this.isScrollable = false;
                if (options) {
                    this.type = options.chartType;
                    if (options.isScrollable) this.isScrollable = options.isScrollable;
                    this.animator = options.animator;
                    if (options.cartesianSmallViewPortProperties) {
                        this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                    }
                }
            }
            CartesianChart.getAxisVisibility = function(type) {
                switch (type) {
                  case 5:
                  case 4:
                  case 6:
                    return 1;

                  case 8:
                    return AxisLinesVisibility.ShowLinesOnBothAxis;

                  default:
                    return 2;
                }
            };
            CartesianChart.prototype.init = function(options) {
                this.visualInitOptions = options;
                this.layers = [];
                var element = this.element = options.element;
                var viewport = this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.brush = d3.svg.brush();
                element.addClass(CartesianChart.ClassName);
                this.margin = {
                    top: 1,
                    right: 1,
                    bottom: 1,
                    left: 1
                };
                this.yAxisOrientation = powerbi.yAxisPosition.left;
                this.adjustMargins(viewport);
                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                var showLinesOnX = this.scrollY = EnumExtensions.hasFlag(axisLinesVisibility, AxisLinesVisibility.ShowLinesOnBothAxis) || EnumExtensions.hasFlag(axisLinesVisibility, 1);
                var showLinesOnY = this.scrollX = EnumExtensions.hasFlag(axisLinesVisibility, AxisLinesVisibility.ShowLinesOnBothAxis) || EnumExtensions.hasFlag(axisLinesVisibility, 2);
                var svg = this.svg = d3.select(element.get(0)).append("svg");
                svg.style("position", "absolute");
                var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(CartesianChart.AxisGraphicsContextClassName, true);
                this.svgScrollable = svg.append("svg").classed("svgScrollable", true).style("overflow", "hidden");
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(CartesianChart.AxisGraphicsContextClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                this.brushGraphicsContext = svg.append("g").attr("class", "x brush");
                var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis");
                this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis");
                this.y2AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis");
                this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX);
                this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY);
                this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY);
                this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX);
                this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY);
                this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY);
                if (this.type !== 11) {
                    this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
            };
            CartesianChart.prototype.renderAxesLabels = function(axisLabels, legendMargin, viewport, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                this.axisGraphicsContext.selectAll(".xAxisLabel").remove();
                this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height;
                var fontSize = CartesianChart.FontSize;
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                if (!hideXAxisTitle) {
                    var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                transform: visuals.SVGUtil.translate(width / 2, height - fontSize)
                            });
                        });
                    });
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                }
                if (!hideYAxisTitle) {
                    var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                transform: "rotate(-90)",
                                y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                x: -((height - margin.top - legendMargin) / 2),
                                dy: "1em"
                            });
                        });
                    });
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                }
                if (!hideY2AxisTitle && axisLabels.y2) {
                    var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function(text) {
                        text.each(function() {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                transform: "rotate(-90)",
                                y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                x: -((height - margin.top - legendMargin) / 2),
                                dy: "1em"
                            });
                        });
                    });
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                }
            };
            CartesianChart.prototype.adjustMargins = function(viewport) {
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xAxis = this.element.find(".x.axis");
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0 && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                    this.margin = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    };
                    xAxis.hide();
                } else {
                    xAxis.show();
                }
            };
            CartesianChart.prototype.updateAxis = function(duration, viewport) {
                this.adjustMargins(viewport);
                var margin = this.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height));
                this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showOnRight ? 0 : width, 0));
                this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showOnRight ? 0 : width, 0));
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                this.svgScrollable.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                this.svgScrollable.attr({
                    x: 0
                });
                this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top));
                this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top));
                if (this.isXScrollBarVisible) {
                    this.svgScrollable.attr({
                        x: this.margin.left
                    });
                    this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                    this.svgScrollable.attr("width", width);
                    this.svg.attr("width", viewport.width).attr("height", viewport.height + CartesianChart.ScrollBarWidth);
                } else if (this.isYScrollBarVisible) {
                    this.svgScrollable.attr("height", height + margin.top);
                    this.svg.attr("width", viewport.width + CartesianChart.ScrollBarWidth).attr("height", viewport.height);
                }
            };
            CartesianChart.getIsScalar = function(objects, propertyId, type) {
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                if (!objects || axisTypeValue === undefined) {
                    return !visuals.AxisHelper.isOrdinal(type);
                }
                return axisTypeValue === powerbi.axisType.scalar && !visuals.AxisHelper.isOrdinal(type);
            };
            CartesianChart.prototype.populateObjectProperties = function(dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata) {
                        this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {});
                    } else {
                        this.legendObjectProperties = {};
                    }
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    var axisPosition = this.valueAxisProperties["position"];
                    this.yAxisOrientation = axisPosition ? axisPosition.toString() : powerbi.yAxisPosition.left;
                }
            };
            CartesianChart.prototype.update = function(options) {
                debug.assertValue(options, "options");
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (!dataViews) return;
                var layers = this.layers;
                if (layers.length === 0) {
                    this.createAndInitLayers(dataViews);
                    debug.assert(layers.length > 0, "createAndInitLayers should update the layers.");
                }
                if (dataViews && dataViews.length > 0) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0) this.hostServices.setWarnings(warnings);
                    this.populateObjectProperties(dataViews);
                }
                for (var i = 0, len = layers.length; i < len; i++) {
                    layers[i].setData(getLayerData(dataViews, i, len));
                }
                if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                    this.renderLegend();
                }
                var duration = options.duration == null ? this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0 : options.duration;
                this.render(this.hasSetData && duration);
                this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0;
            };
            CartesianChart.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0),
                    viewport: this.currentViewport
                });
            };
            CartesianChart.prototype.onResizing = function(viewport, duration) {
                if (this.currentViewport && (this.currentViewport.height === viewport.height && this.currentViewport.width === viewport.width)) {
                    return;
                }
                this.update({
                    dataViews: this.dataViews,
                    duration: duration || 0,
                    viewport: viewport
                });
            };
            CartesianChart.prototype.enumerateObjectInstances = function(options) {
                var objectInstances = [];
                var layersLength = this.layers ? this.layers.length : 0;
                if (options.objectName === "legend") {
                    if (layersLength > 0 && !this.layers[0].hasLegend()) return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : "");
                    objectInstances.push({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText
                        },
                        objectName: options.objectName
                    });
                } else if (options.objectName === "categoryAxis" && this.hasCategoryAxis) {
                    objectInstances = this.getCategoryAxisValues();
                } else if (options.objectName === "valueAxis") {
                    objectInstances = this.getValueAxisValues();
                }
                for (var i = 0, len = layersLength; i < len; i++) {
                    var layer = this.layers[i];
                    if (layer.enumerateObjectInstances) {
                        var layerInstances = layer.enumerateObjectInstances(options);
                        if (layerInstances) {
                            if (i > 0) {
                                if (options.objectName === "dataPoint") {
                                    var defaultColorObject = this.findObjectWithProperty(layerInstances, "defaultColor");
                                    if (defaultColorObject) {
                                        var index = layerInstances.indexOf(defaultColorObject);
                                        layerInstances.splice(index, 1);
                                    }
                                    var showAllObject = this.findObjectWithProperty(layerInstances, "showAllDataPoints");
                                    if (showAllObject) {
                                        var index = layerInstances.indexOf(showAllObject);
                                        layerInstances.splice(index, 1);
                                    }
                                } else if (options.objectName === "labels" && objectInstances.length > 0) {
                                    layerInstances = [];
                                }
                            }
                            if (options.objectName === "categoryAxis" || options.objectName === "valueAxis") {
                                if (objectInstances.length > 0 && layerInstances.length > 0) {
                                    objectInstances[0].properties["showAxisTitle"] = layerInstances[0].properties["showAxisTitle"];
                                }
                            } else {
                                objectInstances = objectInstances.concat(layerInstances);
                            }
                        }
                    }
                }
                return objectInstances;
            };
            CartesianChart.prototype.getCategoryAxisValues = function() {
                var instances = [];
                var supportedType = powerbi.axisType.both;
                var isScalar = false;
                if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                    supportedType = this.layers[0].getSupportedCategoryAxisType();
                    if (supportedType === powerbi.axisType.scalar) {
                        isScalar = true;
                    } else {
                        isScalar = visuals.CartesianHelper.isScalar(supportedType === powerbi.axisType.both, this.categoryAxisProperties);
                    }
                }
                if (!isScalar) {
                    if (this.categoryAxisProperties) {
                        this.categoryAxisProperties["start"] = null;
                        this.categoryAxisProperties["end"] = null;
                    }
                }
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: "categoryAxis"
                };
                instance.properties["show"] = this.categoryAxisProperties && this.categoryAxisProperties["show"] != null ? this.categoryAxisProperties["show"] : true;
                if (this.yAxisIsCategorical) instance.properties["position"] = this.valueAxisProperties && this.valueAxisProperties["position"] != null ? this.valueAxisProperties["position"] : powerbi.yAxisPosition.left;
                if (supportedType === powerbi.axisType.both) {
                    instance.properties["axisType"] = isScalar ? powerbi.axisType.scalar : powerbi.axisType.categorical;
                }
                if (isScalar) {
                    instance.properties["start"] = this.categoryAxisProperties ? this.categoryAxisProperties["start"] : null;
                    instance.properties["end"] = this.categoryAxisProperties ? this.categoryAxisProperties["end"] : null;
                }
                instance.properties["showAxisTitle"] = this.categoryAxisProperties && this.categoryAxisProperties["showAxisTitle"] != null ? this.categoryAxisProperties["showAxisTitle"] : false;
                instances.push(instance);
                instances.push({
                    selector: null,
                    properties: {
                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties["axisStyle"] ? this.categoryAxisProperties["axisStyle"] : powerbi.axisStyle.showTitleOnly
                    },
                    objectName: "categoryAxis",
                    validValues: this.categoryAxisHasUnitType ? [ powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth ] : [ powerbi.axisStyle.showTitleOnly ]
                });
                return instances;
            };
            CartesianChart.prototype.getValueAxisValues = function() {
                var y2AxesRendered = this.layers.length === 2 && this.y2AxesRendered;
                var instances = [];
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: "valueAxis"
                };
                instance.properties["show"] = this.valueAxisProperties && this.valueAxisProperties["show"] != null ? this.valueAxisProperties["show"] : true;
                if (y2AxesRendered) {
                    instance.properties["secShow"] = this.valueAxisProperties && this.valueAxisProperties["secShow"] != null ? this.valueAxisProperties["secShow"] : true;
                    if (instance.properties["secShow"]) {
                        instance.properties["axisLabel"] = "";
                    }
                }
                if (!this.yAxisIsCategorical) {
                    instance.properties["position"] = this.valueAxisProperties && this.valueAxisProperties["position"] != null ? this.valueAxisProperties["position"] : powerbi.yAxisPosition.left;
                }
                instance.properties["start"] = this.valueAxisProperties ? this.valueAxisProperties["start"] : null;
                instance.properties["end"] = this.valueAxisProperties ? this.valueAxisProperties["end"] : null;
                instance.properties["showAxisTitle"] = this.valueAxisProperties && this.valueAxisProperties["showAxisTitle"] != null ? this.valueAxisProperties["showAxisTitle"] : false;
                instances.push(instance);
                instances.push({
                    selector: null,
                    properties: {
                        axisStyle: this.valueAxisProperties && this.valueAxisProperties["axisStyle"] != null ? this.valueAxisProperties["axisStyle"] : powerbi.axisStyle.showTitleOnly
                    },
                    objectName: "valueAxis",
                    validValues: this.valueAxisHasUnitType ? [ powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth ] : [ powerbi.axisStyle.showTitleOnly ]
                });
                if (y2AxesRendered && instance.properties["secShow"]) {
                    var secInstance = {
                        selector: null,
                        properties: {},
                        objectName: "valueAxis"
                    };
                    secInstance.properties["secAxisLabel"] = "";
                    secInstance.properties["secPosition"] = this.valueAxisProperties && this.valueAxisProperties["secPosition"] != null ? this.valueAxisProperties["secPosition"] : powerbi.yAxisPosition.right;
                    secInstance.properties["secStart"] = this.valueAxisProperties ? this.valueAxisProperties["secStart"] : null;
                    secInstance.properties["secEnd"] = this.valueAxisProperties ? this.valueAxisProperties["secEnd"] : null;
                    secInstance.properties["secShowAxisTitle"] = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null ? this.valueAxisProperties["secShowAxisTitle"] : false;
                    instances.push(secInstance);
                    instances.push({
                        selector: null,
                        properties: {
                            secAxisStyle: this.valueAxisProperties && this.valueAxisProperties["secAxisStyle"] ? this.valueAxisProperties["secAxisStyle"] : powerbi.axisStyle.showTitleOnly
                        },
                        objectName: "valueAxis",
                        validValues: this.secValueAxisHasUnitType ? [ powerbi.axisStyle.showTitleOnly, powerbi.axisStyle.showUnitOnly, powerbi.axisStyle.showBoth ] : [ powerbi.axisStyle.showTitleOnly ]
                    });
                }
                return instances;
            };
            CartesianChart.prototype.findObjectWithProperty = function(objectInstances, propertyName) {
                for (var i = 0, len = objectInstances.length; i < len; i++) {
                    var object = objectInstances[i];
                    if (object.properties[propertyName] !== undefined) {
                        return object;
                    }
                }
            };
            CartesianChart.prototype.onClearSelection = function() {
                if (this.hasSetData) {
                    for (var i = 0, len = this.layers.length; i < len; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection();
                        layer.render(0);
                    }
                }
            };
            CartesianChart.prototype.createAndInitLayers = function(dataViews) {
                var _this = this;
                var objects;
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata) objects = dataViewMetadata.objects;
                }
                var layers = this.layers;
                createLayers(layers, this.type, objects, this.interactivityService, this.animator, this.isScrollable);
                var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                cartesianOptions.svg = this.axisGraphicsContextScrollable;
                cartesianOptions.cartesianHost = {
                    updateLegend: function(data) {
                        return _this.legend.drawLegend(data, _this.currentViewport);
                    }
                };
                for (var i = 0, len = layers.length; i < len; i++) layers[i].init(cartesianOptions);
            };
            CartesianChart.prototype.renderLegend = function() {
                var layers = this.layers;
                var legendData = {
                    title: "",
                    dataPoints: []
                };
                for (var i = 0, len = layers.length; i < len; i++) {
                    this.layerLegendData = layers[i].calculateLegend();
                    if (this.layerLegendData) {
                        legendData.title = i === 0 ? this.layerLegendData.title || "" : legendData.title;
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                }
                var legendProperties = this.legendObjectProperties;
                if (legendProperties) {
                    visuals.LegendData.update(legendData, legendProperties);
                    var position = legendProperties[visuals.legendProps.position];
                    if (position) this.legend.changeOrientation(visuals.LegendPosition[position]);
                } else {
                    this.legend.changeOrientation(0);
                }
                if (legendData.dataPoints.length === 1 && !legendData.grouped || this.hideLegends()) {
                    legendData.dataPoints = [];
                }
                this.legend.drawLegend(legendData, this.currentViewport);
            };
            CartesianChart.prototype.hideLegends = function() {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.addUnitTypeToAxisLabel = function(axes) {
                var unitType = axes.x.formatter && axes.x.formatter.displayUnit ? axes.x.formatter.displayUnit.title : null;
                this.categoryAxisHasUnitType = unitType !== null;
                if (axes.x.axisLabel && unitType) {
                    if (this.categoryAxisProperties && this.categoryAxisProperties["axisStyle"]) {
                        if (this.categoryAxisProperties["axisStyle"] === powerbi.axisStyle.showBoth) {
                            axes.x.axisLabel = axes.x.axisLabel + " (" + unitType + ")";
                        } else if (this.categoryAxisProperties["axisStyle"] === powerbi.axisStyle.showUnitOnly) {
                            axes.x.axisLabel = unitType;
                        }
                    }
                }
                unitType = axes.y1.formatter && axes.y1.formatter.displayUnit ? axes.y1.formatter.displayUnit.title : null;
                this.valueAxisHasUnitType = unitType !== null;
                if (axes.y1.axisLabel && unitType) {
                    if (this.valueAxisProperties && this.valueAxisProperties["axisStyle"]) {
                        if (this.valueAxisProperties["axisStyle"] === powerbi.axisStyle.showBoth) {
                            axes.y1.axisLabel = axes.y1.axisLabel + " (" + unitType + ")";
                        } else if (this.valueAxisProperties["axisStyle"] === powerbi.axisStyle.showUnitOnly) {
                            axes.y1.axisLabel = unitType;
                        }
                    }
                }
                if (axes.y2) {
                    unitType = axes.y2.formatter && axes.y2.formatter.displayUnit ? axes.y2.formatter.displayUnit.title : null;
                    this.secValueAxisHasUnitType = unitType !== null;
                    if (axes.y2.axisLabel && unitType) {
                        if (this.valueAxisProperties && this.valueAxisProperties["secAxisStyle"]) {
                            if (this.valueAxisProperties["secAxisStyle"] === powerbi.axisStyle.showBoth) {
                                axes.y2.axisLabel = axes.y2.axisLabel + " (" + unitType + ")";
                            } else if (this.valueAxisProperties["secAxisStyle"] === powerbi.axisStyle.showUnitOnly) {
                                axes.y2.axisLabel = unitType;
                            }
                        }
                    }
                }
            };
            CartesianChart.prototype.shouldRenderSecondaryAxis = function(axisProperties) {
                if (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"]) {
                    return true;
                }
                return false;
            };
            CartesianChart.prototype.shouldRenderAxis = function(axisProperties) {
                if (!axisProperties) {
                    return false;
                } else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties["show"] == null || this.categoryAxisProperties["show"])) {
                    return true;
                } else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties["show"] == null || this.valueAxisProperties["show"])) {
                    return true;
                }
                return false;
            };
            CartesianChart.prototype.render = function(duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                this.duration = duration;
                var legendMargins = this.legendMargins = this.legend.getMargins();
                var viewport = {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
                var maxMarginFactor = this.getMaxMarginFactor();
                var leftMarginLimit = this.leftMarginLimit = viewport.width * maxMarginFactor;
                var bottomMarginLimit = this.bottomMarginLimit = Math.max(CartesianChart.MinBottomMargin, viewport.height * maxMarginFactor);
                var margin = this.margin;
                margin.top = CartesianChart.TopMargin;
                margin.bottom = bottomMarginLimit;
                margin.right = 0;
                var axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties);
                this.yAxisIsCategorical = axes.y1.isCategoryAxis;
                this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                if (axes.forceValueDomainStartToZero) {
                    if (!this.valueAxisProperties) {
                        this.valueAxisProperties = {};
                    }
                    visuals.CartesianHelper.forceValueDomainToZero(this.valueAxisProperties);
                }
                var renderXAxis = this.shouldRenderAxis(axes.x);
                var renderYAxes = this.shouldRenderAxis(axes.y1);
                var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);
                var width = viewport.width - (margin.left + margin.right);
                var properties = {
                    fontFamily: "wf_segoe-ui_normal",
                    fontSize: CartesianChart.FontSizeString
                };
                var isScalar = false;
                var mainAxisScale;
                var preferredViewport;
                this.isXScrollBarVisible = false;
                this.isYScrollBarVisible = false;
                var yAxisOrientation = this.yAxisOrientation;
                var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                if (this.layers) {
                    if (this.layers[0].getVisualCategoryAxisIsScalar) isScalar = this.layers[0].getVisualCategoryAxisIsScalar();
                    if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {
                        var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;
                        var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                        preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                        if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {
                            this.isXScrollBarVisible = true;
                            viewport.height -= CartesianChart.ScrollBarWidth;
                        }
                        if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {
                            this.isYScrollBarVisible = true;
                            viewport.width -= CartesianChart.ScrollBarWidth;
                            width = viewport.width - (margin.left + margin.right);
                        }
                    }
                }
                var needRotate = this.needRotate = visuals.AxisHelper.LabelLayoutStrategy.willRotate(axes.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, properties);
                var margins = visuals.AxisHelper.getTickLabelMargins({
                    width: width,
                    height: viewport.height
                }, leftMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, axes.x, axes.y1, needRotate, bottomMarginLimit, properties, axes.y2, this.isXScrollBarVisible || this.isYScrollBarVisible, showOnRight, renderXAxis, renderYAxes, renderY2Axis);
                var maxMainYaxisSide = showOnRight ? margins.yRight : margins.yLeft, maxSecondYaxisSide = showOnRight ? margins.yLeft : margins.yRight, xMax = margins.xMax;
                maxMainYaxisSide += CartesianChart.LeftPadding;
                if (hasMultipleYAxes(this.layers)) maxSecondYaxisSide += CartesianChart.RightPadding;
                xMax += CartesianChart.BottomPadding;
                if (this.hideAxisLabels(legendMargins)) {
                    axes.x.axisLabel = null;
                    axes.y1.axisLabel = null;
                    if (axes.y2) {
                        axes.y2.axisLabel = null;
                    }
                }
                this.addUnitTypeToAxisLabel(axes);
                var axisLabels = {
                    x: axes.x.axisLabel,
                    y: axes.y1.axisLabel,
                    y2: axes.y2 ? axes.y2.axisLabel : null
                };
                var chartHasAxisLabels = axisLabels.x != null || (axisLabels.y != null || axisLabels.y2 != null);
                if (axisLabels.x != null) xMax += CartesianChart.XAxisLabelPadding;
                if (axisLabels.y != null) maxMainYaxisSide += CartesianChart.YAxisLabelPadding;
                if (axisLabels.y2 != null) maxSecondYaxisSide += CartesianChart.YAxisLabelPadding;
                if (showOnRight && (maxMainYaxisSide !== margin.right || maxSecondYaxisSide !== margin.left) || !showOnRight && (maxMainYaxisSide !== margin.left || maxSecondYaxisSide !== margin.right) || xMax !== margin.bottom || this.currentViewport.height !== viewport.height || this.isXScrollBarVisible || this.isYScrollBarVisible) {
                    margin.left = showOnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                    margin.right = showOnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                    margin.bottom = xMax;
                    this.margin = margin;
                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties);
                    width = viewport.width - (margin.left + margin.right);
                }
                if (this.isXScrollBarVisible) {
                    mainAxisScale = axes.x.scale;
                    var brushX = this.margin.left;
                    var brushY = viewport.height;
                    this.renderChartWithScrollBar(mainAxisScale, brushX, brushY, preferredViewport.width, viewport, axes, width, margins, chartHasAxisLabels, axisLabels);
                } else if (this.isYScrollBarVisible) {
                    mainAxisScale = axes.y1.scale;
                    var brushX = viewport.width;
                    var brushY = this.margin.top;
                    this.renderChartWithScrollBar(mainAxisScale, brushX, brushY, preferredViewport.height, viewport, axes, width, margins, chartHasAxisLabels, axisLabels);
                } else {
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport);
                }
                this.updateAxis(0, viewport);
                if (!(this.isXScrollBarVisible || this.isYScrollBarVisible)) {
                    this.brushGraphicsContext.selectAll("rect").remove();
                }
            };
            CartesianChart.prototype.hideAxisLabels = function(legendMargins) {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height + legendMargins.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.renderChartWithScrollBar = function(inputMainAxisScale, brushX, brushY, svgLength, viewport, axes, width, margins, chartHasAxisLabels, axisLabels) {
                var _this = this;
                var mainAxisScale = inputMainAxisScale;
                var miniAxisScale = mainAxisScale.copy();
                var brush = this.brush;
                var viewportLength;
                var marginTop = this.margin.top;
                var marginLeft = this.margin.left;
                var marginRight = this.margin.right;
                var marginBottom = this.margin.bottom;
                var minExtent;
                if (this.isXScrollBarVisible) {
                    viewportLength = viewport.width - (marginLeft + marginRight);
                    minExtent = this.getMinExtent(svgLength, viewportLength);
                    miniAxisScale.rangeBands([ 0, viewportLength ]);
                    brush.x(miniAxisScale).extent([ 0, minExtent ]);
                } else {
                    viewportLength = viewport.height - (marginTop + marginBottom);
                    minExtent = this.getMinExtent(svgLength, viewportLength);
                    miniAxisScale.rangeBands([ 0, viewportLength ]);
                    brush.y(miniAxisScale).extent([ 0, minExtent ]);
                }
                this.brushMinExtent = minExtent;
                var viewportToSvgRatio = svgLength / viewportLength;
                brush.on("brush", function() {
                    return window.requestAnimationFrame(function() {
                        return _this.onBrushed(miniAxisScale, mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, viewportLength);
                    });
                }).on("brushend", function() {
                    return _this.onBrushEnd(minExtent);
                });
                var brushContext = this.brushContext = this.brushGraphicsContext.attr({
                    transform: visuals.SVGUtil.translate(brushX, brushY),
                    "drag-resize-disabled": "true"
                }).call(brush);
                brushContext.selectAll(".resize rect").remove();
                var minBrushExtent = this.setMinBrush(viewportLength, minExtent, viewportToSvgRatio);
                brushContext.select(".background").style("cursor", "pointer").on("mousedown.brush", function() {
                    return minBrushExtent;
                }).on("touchstart.brush", function() {
                    return minBrushExtent;
                });
                brushContext.selectAll(".extent").style({
                    "fill-opacity": CartesianChart.fillOpacity,
                    cursor: "hand"
                });
                if (this.isXScrollBarVisible) brushContext.selectAll("rect").attr("height", CartesianChart.ScrollBarWidth); else brushContext.selectAll("rect").attr("width", CartesianChart.ScrollBarWidth);
                if (mainAxisScale && miniAxisScale) {
                    mainAxisScale.domain(miniAxisScale.domain());
                    mainAxisScale.rangeBands([ 0, viewportLength ]);
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, brush.extent());
                }
            };
            CartesianChart.prototype.getMinExtent = function(svgLength, viewportLength) {
                return viewportLength * viewportLength / svgLength;
            };
            CartesianChart.prototype.onBrushEnd = function(minExtent) {
                var brushContext = this.brushContext;
                if (this.isXScrollBarVisible) {
                    brushContext.select(".extent").attr("width", minExtent);
                } else brushContext.select(".extent").attr("height", minExtent);
            };
            CartesianChart.prototype.onBrushed = function(miniAxisScale, mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, viewportLength) {
                var brush = this.brush;
                if (mainAxisScale && miniAxisScale) {
                    mainAxisScale.domain(miniAxisScale.domain());
                    this.setBrushExtent(this.brush, viewportLength, this.brushMinExtent);
                    var extent = brush.extent();
                    this.renderChart(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, extent, 0);
                }
            };
            CartesianChart.prototype.setMinBrush = function(viewportLength, minExtent, viewportToSvgRatio) {
                this.setBrushExtent(this.brush, viewportLength, minExtent);
            };
            CartesianChart.prototype.setBrushExtent = function(brush, viewportWidth, minExtent) {
                var extent = brush.extent();
                var width = extent[1] - extent[0];
                if (width === minExtent && extent[1] <= viewportWidth && extent[0] >= 0) return;
                if (width > minExtent) {
                    var padding = (width - minExtent) / 2;
                    extent[0] += padding;
                    extent[1] -= padding;
                } else if (width < minExtent) {
                    var padding = (minExtent - width) / 2;
                    extent[0] -= padding;
                    extent[1] += padding;
                }
                if (extent[0] < 0) {
                    extent[0] = 0;
                    extent[1] = minExtent;
                } else if (extent[0] > viewportWidth - minExtent) {
                    extent[0] = viewportWidth - minExtent;
                    extent[1] = viewportWidth;
                }
                brush.extent(extent);
            };
            CartesianChart.prototype.getMaxMarginFactor = function() {
                return this.visualInitOptions.style.maxMarginFactor || CartesianChart.MaxMarginFactor;
            };
            CartesianChart.prototype.renderChart = function(mainAxisScale, axes, width, margins, chartHasAxisLabels, axisLabels, viewport, miniAxisScale, extent, duration) {
                if (duration === void 0) {
                    duration = this.duration;
                }
                var bottomMarginLimit = this.bottomMarginLimit;
                var leftMarginLimit = this.leftMarginLimit;
                var needRotate = this.needRotate;
                var layers = this.layers;
                debug.assertValue(layers, "layers");
                if (miniAxisScale) {
                    var selected;
                    var data = [];
                    var startValue = extent[0];
                    var endValue = extent[1];
                    var pixelStepSize = miniAxisScale(1) - miniAxisScale(0);
                    var startIndex = Math.floor(startValue / pixelStepSize);
                    var sliceLength = Math.ceil((endValue - startValue) / pixelStepSize);
                    var endIndex = startIndex + sliceLength;
                    selected = mainAxisScale.domain().slice(startIndex, endIndex);
                    if (selected && selected.length > 0) {
                        for (var i = 0; i < layers.length; i++) {
                            data[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                        }
                        mainAxisScale.domain(selected);
                        var dataType = visuals.AxisHelper.getCategoryValueType(data[0].categoryMetadata);
                        var newTickValues = visuals.AxisHelper.getRecommendedTickValuesForAnOrdinalRange(sliceLength, mainAxisScale.domain());
                        var dw = new visuals.DataWrapper(data[0], false);
                        var getValueFn = function(index, type) {
                            return dw.lookupXValue(index - startIndex, type);
                        };
                        var axisPropsToUpdate;
                        if (this.isXScrollBarVisible) {
                            axisPropsToUpdate = axes.x;
                        } else {
                            axisPropsToUpdate = axes.y1;
                        }
                        axisPropsToUpdate.axis.scale(mainAxisScale);
                        axisPropsToUpdate.scale(mainAxisScale);
                        axisPropsToUpdate.axis.ticks(sliceLength);
                        axisPropsToUpdate.axis.tickValues(selected);
                        axisPropsToUpdate.values = visuals.AxisHelper.formatAxisTickValues(axisPropsToUpdate.axis, newTickValues, axisPropsToUpdate.formatter, dataType, false, getValueFn);
                    }
                }
                if (this.shouldRenderAxis(axes.x)) {
                    axes.x.axis.orient("bottom");
                    if (needRotate) axes.x.axis.tickPadding(CartesianChart.TickPaddingRotatedX);
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    if (duration) {
                        xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis);
                    } else {
                        xAxisGraphicsElement.call(axes.x.axis);
                    }
                    xAxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.rotate, width, bottomMarginLimit, powerbi.TextMeasurementService.svgEllipsis, needRotate, bottomMarginLimit === margins.xMax, axes.x, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                } else {
                    this.xAxisGraphicsContext.selectAll("*").remove();
                }
                if (this.shouldRenderAxis(axes.y1)) {
                    var yAxisOrientation = this.yAxisOrientation;
                    var showOnRight = yAxisOrientation === powerbi.yAxisPosition.right;
                    axes.y1.axis.tickSize(width).tickPadding(CartesianChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                    if (duration) {
                        y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis);
                    } else {
                        y1AxisGraphicsElement.call(axes.y1.axis);
                    }
                    if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"])) {
                        axes.y2.axis.tickPadding(CartesianChart.TickPaddingY).orient(showOnRight ? powerbi.yAxisPosition.left.toLowerCase() : powerbi.yAxisPosition.right.toLowerCase());
                        if (duration) {
                            this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis);
                        } else {
                            this.y2AxisGraphicsContext.call(axes.y2.axis);
                        }
                        this.y2AxesRendered = true;
                    } else {
                        this.y2AxisGraphicsContext.selectAll("*").remove();
                    }
                    if (margins.yLeft >= leftMarginLimit) {
                        y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftMarginLimit - CartesianChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis);
                    }
                } else {
                    this.y1AxisGraphicsContext.selectAll("*").remove();
                    this.y2AxisGraphicsContext.selectAll("*").remove();
                }
                if (chartHasAxisLabels) {
                    var hideXAxisTitle = this.categoryAxisProperties && this.categoryAxisProperties["showAxisTitle"] != null && this.categoryAxisProperties["showAxisTitle"] === false;
                    var hideYAxisTitle = this.valueAxisProperties && this.valueAxisProperties["showAxisTitle"] != null && this.valueAxisProperties["showAxisTitle"] === false;
                    var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                    this.renderAxesLabels(axisLabels, this.legendMargins.height, viewport, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                } else {
                    this.axisGraphicsContext.selectAll(".xAxisLabel").remove();
                    this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                }
                for (var i = 0, len = layers.length; i < len; i++) layers[i].render(duration);
            };
            CartesianChart.getPreferredPlotArea = function(categoryCount, categoryThickness, viewport, isScrollable, isScalar) {
                var preferredViewport = {
                    height: viewport.height,
                    width: viewport.width
                };
                if (!isScalar && isScrollable) {
                    var preferredWidth = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    preferredViewport.width = Math.max(preferredWidth, viewport.width);
                }
                return preferredViewport;
            };
            CartesianChart.getPreferredCategorySpan = function(categoryCount, categoryThickness) {
                return categoryThickness * (categoryCount + CartesianChart.OuterPaddingRatio * 2);
            };
            CartesianChart.getLayout = function(data, options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
                var categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar);
                var totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2;
                var calculatedBarCount = Math.round((availableWidth - totalOuterPadding) / categoryThickness);
                var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
                var outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                if (!isScalar) {
                    var oneOuterPadding = (availableWidth - categoryThickness * visibleCategoryCount) / 2;
                    outerPaddingRatio = oneOuterPadding / categoryThickness;
                }
                if (!isScalar && isScrollable) visibleCategoryCount = categoryCount;
                return {
                    categoryCount: visibleCategoryCount,
                    categoryThickness: categoryThickness,
                    outerPaddingRatio: outerPaddingRatio,
                    isScalar: isScalar
                };
            };
            CartesianChart.getCategoryThickness = function(seriesList, numCategories, plotLength, domain, isScalar) {
                var thickness;
                if (numCategories < 2) thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio); else if (isScalar && domain && domain.length > 1) {
                    var minInterval = CartesianChart.getMinInterval(seriesList);
                    var domainSpan = domain[domain.length - 1] - domain[0];
                    var ratio = minInterval / (domainSpan + minInterval * CartesianChart.OuterPaddingRatio * 2);
                    thickness = plotLength * ratio;
                    thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                } else {
                    thickness = plotLength / (numCategories + CartesianChart.OuterPaddingRatio * 2);
                    thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                }
                var maxRectThickness = plotLength / (3 + CartesianChart.OuterPaddingRatio * 2);
                if (!isScalar && numCategories >= 3) return Math.max(Math.min(thickness, maxRectThickness), CartesianChart.MinOrdinalRectThickness);
                return Math.min(thickness, maxRectThickness);
            };
            CartesianChart.getMinInterval = function(seriesList) {
                var minInterval = Number.MAX_VALUE;
                if (seriesList.length > 0) {
                    var series0data = seriesList[0].data.filter(function(d) {
                        return !d.highlight;
                    });
                    for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
                        minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                    }
                }
                return minInterval;
            };
            CartesianChart.MinOrdinalRectThickness = 20;
            CartesianChart.MinScalarRectThickness = 2;
            CartesianChart.OuterPaddingRatio = .4;
            CartesianChart.InnerPaddingRatio = .2;
            CartesianChart.ClassName = "cartesianChart";
            CartesianChart.AxisGraphicsContextClassName = "axisGraphicsContext";
            CartesianChart.MaxMarginFactor = .18;
            CartesianChart.MinBottomMargin = 25;
            CartesianChart.TopMargin = 8;
            CartesianChart.LeftPadding = 10;
            CartesianChart.RightPadding = 15;
            CartesianChart.BottomPadding = 12;
            CartesianChart.YAxisLabelPadding = 20;
            CartesianChart.XAxisLabelPadding = 18;
            CartesianChart.TickPaddingY = 10;
            CartesianChart.TickPaddingRotatedX = 5;
            CartesianChart.FontSize = 11;
            CartesianChart.FontSizeString = visuals.SVGUtil.convertToPixelString(CartesianChart.FontSize);
            CartesianChart.ScrollBarWidth = 10;
            CartesianChart.fillOpacity = .125;
            return CartesianChart;
        }();
        visuals.CartesianChart = CartesianChart;
        function createLayers(layers, type, objects, interactivityService, animator, isScrollable) {
            if (isScrollable === void 0) {
                isScrollable = false;
            }
            debug.assertValue(layers, "layers");
            debug.assert(layers.length === 0, "layers.length === 0");
            switch (type) {
              case 1:
                layers.push(new visuals.LineChart({
                    chartType: 2,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService,
                    animator: animator
                }));
                return;

              case 0:
                layers.push(new visuals.LineChart({
                    chartType: 1,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService,
                    animator: animator
                }));
                return;

              case 3:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.stackedColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 2:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.clusteredColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 7:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.hundredPercentStackedColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 5:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.stackedBar,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 4:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.clusteredBar,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 6:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.hundredPercentStackedBar,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                return;

              case 8:
                layers.push(new visuals.ScatterChart({
                    interactivityService: interactivityService
                }));
                return;

              case 11:
                layers.push(new visuals.WaterfallChart({
                    isScrollable: isScrollable
                }));
                return;

              case 9:
                var columnType = visuals.ColumnChartType.clusteredColumn;
                if (objects) {
                    var comboChartTypes = objects.general;
                    if (comboChartTypes) {
                        switch (comboChartTypes.visualType1) {
                          case "Column":
                            columnType = visuals.ColumnChartType.clusteredColumn;
                            break;

                          case "ColumnStacked":
                            columnType = visuals.ColumnChartType.stackedColumn;
                            break;

                          default:
                            debug.assertFail("Unsupported cartesian chart type " + comboChartTypes.visualType1);
                        }
                        if (comboChartTypes.visualType2) {
                            debug.assert(comboChartTypes.visualType2 === "Line", "expecting a LineChart for VisualType2");
                        }
                    }
                }
                layers.push(new visuals.ColumnChart({
                    chartType: columnType,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                layers.push(new visuals.LineChart({
                    chartType: 1 | 8,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService,
                    animator: animator
                }));
                return;

              case 10:
                layers.push(new visuals.DataDotChart());
                return;

              case 12:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.clusteredColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                layers.push(new visuals.LineChart({
                    chartType: 1 | 8,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService,
                    animator: animator
                }));
                return;

              case 13:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.stackedColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                layers.push(new visuals.LineChart({
                    chartType: 1 | 8,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService,
                    animator: animator
                }));
                return;

              case 14:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.clusteredColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                layers.push(new visuals.DataDotChart());
                return;

              case 15:
                layers.push(new visuals.ColumnChart({
                    chartType: visuals.ColumnChartType.stackedColumn,
                    animator: animator,
                    isScrollable: isScrollable,
                    interactivityService: interactivityService
                }));
                layers.push(new visuals.DataDotChart());
                return;
            }
        }
        function getLayerData(dataViews, currentIdx, totalLayers) {
            if (totalLayers > 1) {
                if (dataViews && dataViews.length > currentIdx) return [ dataViews[currentIdx] ];
                return [];
            }
            return dataViews;
        }
        function hasMultipleYAxes(layers) {
            debug.assertValue(layers, "layers");
            return layers.length > 1;
        }
        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
            return layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties["showAxisTitle"] || layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties["secShowAxisTitle"];
        }
        function tryMergeYDomains(layers, visualOptions) {
            debug.assert(layers.length < 3, "merging of more than 2 layers is not supported");
            var noMerge = {
                domain: undefined,
                merged: false,
                tickCount: 3,
                forceStartToZero: false
            };
            if (layers.length < 2) return noMerge;
            var min;
            var max;
            var minOfMax;
            var maxOfMin;
            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
            var firstYDomain = y1props.scale.domain();
            var secondYDomain = y2props.scale.domain();
            if (firstYDomain[0] >= 0 && secondYDomain[0] >= 0) {
                noMerge.forceStartToZero = true;
            }
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
            }
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0]) return noMerge;
            min = Math.min(firstYDomain[0], secondYDomain[0]);
            max = Math.max(firstYDomain[1], secondYDomain[1]);
            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
            minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var range = max - min;
            if (range === 0) {
                return noMerge;
            }
            var intersection = Math.abs((minOfMax - maxOfMin) / range);
            if (intersection < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE) return noMerge; else return {
                domain: [ min, max ],
                merged: true,
                tickCount: noMerge.tickCount,
                forceStartToZero: false
            };
        }
        function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties) {
            debug.assertValue(layers, "layers");
            var visualOptions = {
                viewport: viewport,
                margin: margin,
                forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties["start"] : null, categoryAxisProperties ? categoryAxisProperties["end"] : null ],
                showXLabel: false,
                showYLabel: false
            };
            var yAxisWillMerge = false;
            var mergeResult;
            if (hasMultipleYAxes(layers)) {
                mergeResult = tryMergeYDomains(layers, visualOptions);
                yAxisWillMerge = mergeResult.merged;
                if (yAxisWillMerge) {
                    visualOptions.forcedYDomain = mergeResult.domain;
                } else {
                    visualOptions.forcedTickCount = mergeResult.tickCount;
                }
            }
            var forceValueDomainStartToZero = mergeResult ? mergeResult.forceStartToZero : false;
            visualOptions.forcedYDomain = valueAxisProperties ? [ valueAxisProperties["start"], valueAxisProperties["end"] ] : null;
            var result;
            for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                var currentlayer = layers[layerNumber];
                if (layerNumber === 1 && !yAxisWillMerge) {
                    visualOptions.forcedYDomain = valueAxisProperties ? [ valueAxisProperties["secStart"], valueAxisProperties["secEnd"] ] : null;
                }
                visualOptions.showXLabel = !!categoryAxisProperties && !!categoryAxisProperties["showAxisTitle"];
                visualOptions.showYLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                var axes = currentlayer.calculateAxesProperties(visualOptions);
                if (layerNumber === 0) {
                    result = {
                        x: axes[0],
                        y1: axes[1],
                        forceValueDomainStartToZero: forceValueDomainStartToZero
                    };
                } else if (axes && !result.y2) {
                    if (axes[0].axis.scale().domain().length > result.x.axis.scale().domain().length) {
                        visualOptions.showYLabel = !!valueAxisProperties && !!valueAxisProperties["showAxisTitle"];
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        result.x = axes[0];
                        result.y1 = axes[1];
                    } else {
                        currentlayer.overrideXScale(result.x);
                        if (!yAxisWillMerge) result.y2 = axes[1];
                    }
                }
            }
            return result;
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        function getColumnChartCapabilities(transposeAxes) {
            if (transposeAxes === void 0) {
                transposeAxes = false;
            }
            return {
                dataRoles: [ {
                    name: "Category",
                    kind: 0,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis")
                }, {
                    name: "Series",
                    kind: 0,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                }, {
                    name: "Y",
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value")
                }, {
                    name: "Gradient",
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            }
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                type: {
                                    formatting: {
                                        legendPosition: true
                                    }
                                }
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                type: {
                                    bool: true
                                }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                                type: {
                                    text: true
                                }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_YAxis") : powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                type: {
                                    formatting: {
                                        yAxisPosition: true
                                    }
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                type: {
                                    numeric: true
                                }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                type: {
                                    numeric: true
                                }
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                type: {
                                    formatting: {
                                        axisType: true
                                    }
                                }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                type: {
                                    bool: true
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    formatting: {
                                        axisStyle: true
                                    }
                                }
                            }
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_XAxis") : powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                type: {
                                    formatting: {
                                        yAxisPosition: true
                                    }
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                type: {
                                    numeric: true
                                }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                type: {
                                    numeric: true
                                }
                            },
                            intersection: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                type: {
                                    numeric: true
                                }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                type: {
                                    bool: true
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    formatting: {
                                        axisStyle: true
                                    }
                                }
                            }
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                type: {
                                    bool: true
                                }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: true
                                    }
                                }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Y: {
                            min: 0,
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "Y"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                } ],
                supportsHighlight: true,
                sorting: {
                    "default": {}
                }
            };
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
        visuals.columnChartProps = {
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            },
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            categoryAxis: {
                axisType: {
                    objectName: "categoryAxis",
                    propertyName: "axisType"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var flagBar = 1 << 1;
        var flagColumn = 1 << 2;
        var flagClustered = 1 << 3;
        var flagStacked = 1 << 4;
        var flagStacked100 = flagStacked | 1 << 5;
        (function(ColumnChartType) {
            ColumnChartType[ColumnChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
            ColumnChartType[ColumnChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
            ColumnChartType[ColumnChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
            ColumnChartType[ColumnChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
            ColumnChartType[ColumnChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
            ColumnChartType[ColumnChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
        })(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
        var ColumnChartType = visuals.ColumnChartType;
        var RoleNames = {
            category: "Category",
            series: "Series",
            y: "Y"
        };
        var ColumnChart = function() {
            function ColumnChart(options) {
                debug.assertValue(options, "options");
                var chartType = options.chartType;
                debug.assertValue(chartType, "chartType");
                this.chartType = chartType;
                this.categoryAxisType = null;
                this.animator = options.animator;
                this.isScrollable = options.isScrollable;
                this.interactivityService = options.interactivityService;
            }
            ColumnChart.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata) objects = dataViewMapping.metadata.objects;
                    if (visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) dataViewCategories.dataReductionAlgorithm = {
                        sample: {}
                    };
                }
            };
            ColumnChart.getSortableRoles = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata) objects = dataViewMapping.metadata.objects;
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) {
                        return [ "Category", "Y" ];
                    }
                }
                return null;
            };
            ColumnChart.prototype.updateVisualMetadata = function(x, y, margin) {
                this.xAxisProperties = x;
                this.yAxisProperties = y;
                this.margin = margin;
            };
            ColumnChart.prototype.init = function(options) {
                this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsContext = this.svg.append("g").classed("columnChartMainGraphicsContext", true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.interactivity = options.interactivity;
                this.colors = this.style.colorPalette.dataColors;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                var element = this.element = options.element;
                element.addClass(ColumnChart.ColumnChartClassName);
                switch (this.chartType) {
                  case ColumnChartType.clusteredBar:
                    this.columnChart = new visuals.ClusteredBarChartStrategy();
                    break;

                  case ColumnChartType.clusteredColumn:
                    this.columnChart = new visuals.ClusteredColumnChartStrategy();
                    break;

                  case ColumnChartType.stackedBar:
                  case ColumnChartType.hundredPercentStackedBar:
                    this.columnChart = new visuals.StackedBarChartStrategy();
                    break;

                  case ColumnChartType.stackedColumn:
                  case ColumnChartType.hundredPercentStackedColumn:
                  default:
                    this.columnChart = new visuals.StackedColumnChartStrategy();
                    break;
                }
            };
            ColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                var availableWidth;
                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                    availableWidth = this.currentViewport.height - (this.margin.top + this.margin.bottom);
                } else {
                    availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                }
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                return visuals.CartesianChart.getLayout(this.data, {
                    availableWidth: availableWidth,
                    categoryCount: numCategoryValues,
                    domain: domain,
                    isScalar: isScalar,
                    isScrollable: this.isScrollable
                });
            };
            ColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                if (is100PercentStacked === void 0) {
                    is100PercentStacked = false;
                }
                if (isScalar === void 0) {
                    isScalar = false;
                }
                if (supportsOverflow === void 0) {
                    supportsOverflow = false;
                }
                if (dataViewMetadata === void 0) {
                    dataViewMetadata = null;
                }
                debug.assertValue(dataView, "dataView");
                debug.assertValue(colors, "colors");
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                var converterStrategy = new ColumnChartConverterHelper(dataView);
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);
                var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked);
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects["labels"];
                    if (labelsObj) {
                        if (labelsObj.show !== undefined) labelSettings.show = labelsObj.show;
                        if (labelsObj.color !== undefined) {
                            labelSettings.labelColor = labelsObj.color.solid.color;
                            labelSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            labelSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : 0;
                        }
                    }
                    labelSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataViewMetadata.columns);
                }
                var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);
                var legend = legendAndSeriesInfo.legend.dataPoints;
                var seriesSources = legendAndSeriesInfo.seriesSources;
                var result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType);
                var columnSeries = result.series;
                var valuesMetadata = [];
                for (var j = 0, jlen = legend.length; j < jlen; j++) {
                    valuesMetadata.push(seriesSources[j]);
                }
                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                if (!EnumExtensions.hasFlag(chartType, flagColumn)) {
                    var temp = labels.xAxisLabel;
                    labels.xAxisLabel = labels.yAxisLabel;
                    labels.yAxisLabel = temp;
                }
                return {
                    categories: categories,
                    categoryFormatter: categoryFormatter,
                    series: columnSeries,
                    valuesMetadata: valuesMetadata,
                    legendData: legendAndSeriesInfo.legend,
                    hasHighlights: result.hasHighlights,
                    categoryMetadata: categoryMetadata,
                    scalarCategoryAxis: isScalar,
                    labelSettings: labelSettings,
                    axesLabels: {
                        x: labels.xAxisLabel,
                        y: labels.yAxisLabel
                    },
                    hasDynamicSeries: result.hasDynamicSeries,
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                    hasSelection: false
                };
            };
            ColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType) {
                if (is100PercentStacked === void 0) {
                    is100PercentStacked = false;
                }
                if (isScalar === void 0) {
                    isScalar = false;
                }
                if (supportsOverflow === void 0) {
                    supportsOverflow = false;
                }
                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                var categoryCount = categories.length;
                var seriesCount = legend.length;
                var columnSeries = [];
                if (seriesCount < 1 || categoryCount < 1) return {
                    series: columnSeries,
                    hasHighlights: false,
                    hasDynamicSeries: false
                };
                var dvCategories = dataViewCat.categories;
                var categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var baseValuesPos = [], baseValuesNeg = [];
                var rawValues = [];
                var rawHighlightValues = [];
                var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                var highlightsOverflow = false;
                var hasHighlights = converterStrategy.hasHighlightValues(0);
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesValues = [];
                    var seriesHighlightValues = [];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                        seriesValues[categoryIndex] = value;
                        if (hasHighlights) {
                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = highlightValue;
                            if (!(value >= 0 && highlightValue >= 0 && value >= highlightValue || value <= 0 && highlightValue <= 0 && value <= highlightValue)) {
                                highlightsOverflow = true;
                            }
                        }
                    }
                    rawValues.push(seriesValues);
                    if (hasHighlights) {
                        rawHighlightValues.push(seriesHighlightValues);
                    }
                }
                if (highlightsOverflow && !supportsOverflow) {
                    highlightsOverflow = false;
                    hasHighlights = false;
                    rawValues = rawHighlightValues;
                }
                var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesDataPoints = [], legendItem = legend[seriesIndex];
                    columnSeries.push({
                        displayName: legendItem.label,
                        key: "series" + seriesIndex,
                        index: seriesIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity
                    });
                    if (seriesCount > 1) dataPointObjects = seriesObjectsList[seriesIndex];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        if (seriesIndex === 0) {
                            baseValuesPos.push(0);
                            baseValuesNeg.push(0);
                        }
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                        if (value == null) {
                            if (seriesIndex > 0) continue;
                        }
                        var originalValue = value;
                        var categoryValue = categories[categoryIndex];
                        if (isDateTime && categoryValue) categoryValue = categoryValue.getTime();
                        if (isScalar && (categoryValue == null || isNaN(categoryValue))) continue;
                        var multipliers;
                        if (is100PercentStacked) multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                        var unadjustedValue = value, isNegative = value < 0;
                        if (multipliers) {
                            if (isNegative) value *= multipliers.neg; else value *= multipliers.pos;
                        }
                        var valueAbsolute = Math.abs(value);
                        var position;
                        if (isNegative) {
                            position = baseValuesNeg[categoryIndex];
                            if (!isNaN(valueAbsolute)) baseValuesNeg[categoryIndex] -= valueAbsolute;
                        } else {
                            if (!isNaN(valueAbsolute)) baseValuesPos[categoryIndex] += valueAbsolute;
                            position = baseValuesPos[categoryIndex];
                        }
                        var identity = visuals.SelectionId.createWithIdsAndMeasure(categoryIdentities ? categoryIdentities[categoryIndex] : undefined, hasDynamicSeries ? grouped[seriesIndex].identity : undefined, converterStrategy.getMeasureNameByIndex(seriesIndex));
                        var rawCategoryValue = categories[categoryIndex];
                        var color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat.categories, rawCategoryValue, dataViewCat.values, originalValue, null, seriesIndex);
                        var labelColor = color;
                        if (EnumExtensions.hasFlag(chartType, flagStacked)) {
                            var lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                            labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? color : "#FFFFFF";
                        }
                        var dataPoint = {
                            categoryValue: categoryValue,
                            value: value,
                            position: position,
                            valueAbsolute: valueAbsolute,
                            valueOriginal: unadjustedValue,
                            seriesIndex: seriesIndex,
                            categoryIndex: categoryIndex,
                            color: color,
                            selected: false,
                            originalValue: value,
                            originalPosition: position,
                            originalValueAbsolute: valueAbsolute,
                            identity: identity,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.overrideDefaultColor || is100PercentStacked ? labelSettings.labelColor : labelColor,
                            lastSeries: lastValue,
                            chartType: chartType
                        };
                        seriesDataPoints.push(dataPoint);
                        if (hasHighlights) {
                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                            var unadjustedValueHighlight = valueHighlight;
                            var highlightedTooltip = true;
                            if (valueHighlight === null) {
                                valueHighlight = 0;
                                highlightedTooltip = false;
                            }
                            if (is100PercentStacked) {
                                valueHighlight *= multipliers.pos;
                            }
                            var absoluteValueHighlight = Math.abs(valueHighlight);
                            var highlightPosition = position;
                            if (valueHighlight > 0) {
                                highlightPosition -= valueAbsolute - absoluteValueHighlight;
                            } else if (valueHighlight === 0 && value > 0) {
                                highlightPosition -= valueAbsolute;
                            }
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var rawCategoryValue = categories[categoryIndex];
                            var highlightedValue = highlightedTooltip ? valueHighlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat.categories, rawCategoryValue, dataViewCat.values, originalValue, null, seriesIndex, highlightedValue);
                            if (highlightedTooltip) {
                                dataPoint.tooltipInfo = tooltipInfo;
                            }
                            var highlightDataPoint = {
                                categoryValue: categoryValue,
                                value: valueHighlight,
                                position: highlightPosition,
                                valueAbsolute: absoluteValueHighlight,
                                valueOriginal: unadjustedValueHighlight,
                                seriesIndex: seriesIndex,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                highlight: true,
                                originalValue: value,
                                originalPosition: position,
                                originalValueAbsolute: valueAbsolute,
                                drawThinner: highlightsOverflow,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.overrideDefaultColor || is100PercentStacked ? labelSettings.labelColor : labelColor,
                                lastSeries: lastValue,
                                chartType: chartType
                            };
                            seriesDataPoints.push(highlightDataPoint);
                        }
                    }
                }
                return {
                    series: columnSeries,
                    hasHighlights: hasHighlights,
                    hasDynamicSeries: hasDynamicSeries
                };
            };
            ColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                debug.assertValue(legendItem, "legendItem");
                debug.assertValue(categoryIndex, "categoryIndex");
                debug.assertAnyValue(dataPointObjects, "dataPointObjects");
                if (dataPointObjects) {
                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                    if (colorOverride) return colorOverride;
                }
                return legendItem.color;
            };
            ColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                for (var i = seriesIndex + 1; i < seriesCount; i++) {
                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                    if (nextValues !== null && ((!isNegative || isNegative && seriesIndex === 0) && nextValues > 0 || isNegative && seriesIndex !== 0)) {
                        lastValue = false;
                        break;
                    }
                }
                return lastValue;
            };
            ColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                if (startIndex === void 0) {
                    startIndex = 0;
                }
                var newSeries = [];
                if (series && series.length > 0) {
                    for (var i = 0, len = series.length; i < len; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        iNewSeries.data = series[i].data.filter(function(d) {
                            return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                        });
                    }
                }
                return newSeries;
            };
            ColumnChart.getForcedTickValues = function(min, max, forcedTickCount) {
                debug.assert(min <= max, "min must be less or equal to max");
                debug.assert(forcedTickCount >= 0, "forcedTickCount must be greater or equal to zero");
                if (forcedTickCount <= 1) return [];
                var tickValues = [];
                var interval = (max - min) / (forcedTickCount - 1);
                for (var i = 0; i < forcedTickCount - 1; i++) {
                    tickValues.push(min + i * interval);
                }
                tickValues.push(max);
                if (tickValues.indexOf(0) === -1) tickValues.push(0);
                return tickValues;
            };
            ColumnChart.getTickInterval = function(tickValues) {
                if (tickValues.length === 0) return 0;
                if (tickValues.length === 1) return tickValues[0];
                tickValues.sort(function(a, b) {
                    return a - b;
                });
                return tickValues[1] - tickValues[0];
            };
            ColumnChart.prototype.setData = function(dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var is100PctStacked = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                this.data = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    valuesMetadata: [],
                    legendData: null,
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    hasSelection: false
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCat = this.dataViewCat = dataView.categorical;
                        var dvCategories = dataViewCat.categories;
                        var categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                        this.data = ColumnChart.converter(dataViewCat, this.colors, is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), this.supportsOverflow, dataView.metadata, this.chartType);
                        var series = this.data.series;
                        for (var i = 0, ilen = series.length; i < ilen; i++) {
                            var currentSeries = series[i];
                            if (this.interactivityService) {
                                if (this.interactivityService.applySelectionStateToData(currentSeries.data)) this.data.hasSelection = true;
                            }
                        }
                    }
                }
            };
            ColumnChart.prototype.calculateLegend = function() {
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    return this.createInteractiveLegendDataPoints(0);
                }
                var legendData = this.data ? this.data.legendData : null;
                var legendDataPoints = legendData ? legendData.dataPoints : [];
                if (ArrayExtensions.isUndefinedOrEmpty(legendDataPoints)) return null;
                return legendData;
            };
            ColumnChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
            };
            ColumnChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "dataPoint":
                    if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat)) return this.enumerateDataPoints();
                    break;

                  case "labels":
                    if (EnumExtensions.hasFlag(this.chartType, flagStacked100)) return visuals.dataLabelUtils.enumerateDataLabels(this.data.labelSettings, false);
                    return visuals.dataLabelUtils.enumerateDataLabels(this.data.labelSettings, false, true, true);
                }
                return null;
            };
            ColumnChart.prototype.enumerateDataPoints = function() {
                var data = this.data;
                if (!data) return;
                var instances = [], seriesCount = data.series.length;
                if (seriesCount === 0) return instances;
                var isMultiMeasure = !data.hasDynamicSeries && seriesCount > 1;
                if (!isMultiMeasure) {
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            defaultColor: {
                                solid: {
                                    color: data.defaultDataPointColor || this.colors.getColor(0).value
                                }
                            }
                        }
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesCount > 1;
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        }
                    });
                }
                if (data.hasDynamicSeries || seriesCount > 1) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: series.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series.data[0].color
                                    }
                                }
                            }
                        });
                    }
                } else {
                    var singleSeriesData = data.series[0].data;
                    var categoryFormatter = data.categoryFormatter;
                    for (var i = 0; i < singleSeriesData.length; i++) {
                        var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                            selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), true),
                            properties: {
                                fill: {
                                    solid: {
                                        color: singleSeriesDataPoints.color
                                    }
                                }
                            }
                        });
                    }
                }
                return instances;
            };
            ColumnChart.prototype.calculateAxesProperties = function(options) {
                var data = this.data;
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var origCatgSize = data && data.categories ? data.categories.length : 0;
                var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                    categoryCount: 0,
                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                    isScalar: false
                };
                this.categoryAxisType = chartLayout.isScalar ? powerbi.axisType.scalar : null;
                if (data && !chartLayout.isScalar && !this.isScrollable) {
                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = powerbi.Prototype.inherit(data);
                        data.series = ColumnChart.sliceSeries(data.series, catgSize);
                        data.categories = data.categories.slice(0, catgSize);
                    }
                }
                this.columnChart.setData(data);
                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= margin.left + margin.right;
                }
                preferredPlotArea.height -= margin.top + margin.bottom;
                var is100Pct = EnumExtensions.hasFlag(this.chartType, flagStacked100);
                var chartContext = {
                    height: preferredPlotArea.height,
                    width: preferredPlotArea.width,
                    duration: 0,
                    hostService: this.hostService,
                    mainGraphicsContext: this.mainGraphicsContext,
                    margin: this.margin,
                    layout: chartLayout,
                    animator: this.animator,
                    interactivityService: this.interactivityService,
                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                    is100Pct: is100Pct
                };
                this.ApplyInteractivity(chartContext);
                this.columnChart.setupVisualProps(chartContext);
                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                    var temp = options.forcedXDomain;
                    options.forcedXDomain = options.forcedYDomain;
                    options.forcedYDomain = temp;
                }
                this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain);
                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain);
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [ this.xAxisProperties, this.yAxisProperties ];
            };
            ColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                var viewport = {
                    height: this.currentViewport.height,
                    width: this.currentViewport.width
                };
                if (this.isScrollable && !isScalar) {
                    var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                        viewport.height = Math.max(preferredWidth, viewport.height);
                    } else viewport.width = Math.max(preferredWidth, viewport.width);
                }
                return viewport;
            };
            ColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                var _this = this;
                var interactivity = this.interactivity;
                if (interactivity) {
                    if (interactivity.dragDataPoint) {
                        chartContext.onDragStart = function(datum) {
                            if (!datum.identity) return;
                            _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        };
                    }
                    if (interactivity.isInteractiveLegend) {
                        var dragMove = function() {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]);
                            var x = mousePoint[0];
                            var y = mousePoint[1];
                            var index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        };
                        this.svg.on("click", dragMove);
                        d3.select(this.element.get(0)).on("click", dragMove);
                        var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                        this.svg.call(drag);
                        d3.select(this.element.get(0)).call(drag);
                    }
                }
            };
            ColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                if (force === void 0) {
                    force = false;
                }
                if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected) return;
                var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected);
                var legendDataPoints = legendData.dataPoints;
                this.cartesianVisualHost.updateLegend(legendData);
                if (legendDataPoints.length > 0) {
                    this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                }
                this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
            };
            ColumnChart.prototype.createInteractiveLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) return {
                    dataPoints: []
                };
                var formatStringProp = visuals.columnChartProps.general.formatString;
                var legendDataPoints = [];
                var category = data.categories && data.categories[columnIndex];
                var allSeries = data.series;
                for (var i = 0, len = allSeries.length; i < len; i++) {
                    var dataPoint = data.series[i].data[columnIndex];
                    var measure = dataPoint && dataPoint.valueOriginal;
                    var valueMetadata = data.valuesMetadata[i];
                    var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                    legendDataPoints.push({
                        color: dataPoint.color,
                        icon: 0,
                        label: formattedLabel,
                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                        identity: visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return {
                    dataPoints: legendDataPoints
                };
            };
            ColumnChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            };
            ColumnChart.prototype.render = function(duration) {
                var selection = this.columnChart.drawColumns(!!duration);
                var data = this.data;
                visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                if (this.interactivityService) {
                    var allDataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        allDataPoints = allDataPoints.concat(data.series[i].data);
                    }
                    var behaviorOptions = {
                        bars: selection,
                        datapoints: allDataPoints,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights,
                        mainGraphicsContext: this.mainGraphicsContext
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    if (this.data.series.length > 0) {
                        this.selectColumn(0, true);
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            ColumnChart.prototype.onClearSelection = function() {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                }
            };
            ColumnChart.prototype.accept = function(visitor, options) {
                visitor.visitColumnChart(options);
            };
            ColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return this.data ? this.data.scalarCategoryAxis : false;
            };
            ColumnChart.prototype.getSupportedCategoryAxisType = function() {
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                return isOrdinal ? powerbi.axisType.categorical : powerbi.axisType.both;
            };
            ColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = powerbi.Prototype.inherit(this.data);
                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                this.columnChart.setData(data);
                return data;
            };
            ColumnChart.ColumnChartClassName = "columnChart";
            ColumnChart.SeriesClasses = {
                "class": "series",
                selector: ".series"
            };
            return ColumnChart;
        }();
        visuals.ColumnChart = ColumnChart;
        var ColumnChartConverterHelper = function() {
            function ColumnChartConverterHelper(dataView) {
                this.dataView = dataView;
            }
            ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultColor) {
                var legend = [];
                var seriesSources = [];
                var seriesObjects = [];
                var grouped = false;
                var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                if (this.dataView && this.dataView.values) {
                    var allValues = this.dataView.values;
                    var valueGroups = allValues.grouped();
                    var hasDynamicSeries = !!(allValues && allValues.source);
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                        var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                        for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                            var series = values[valueIndex];
                            var source = series.source;
                            if (visuals.DataRoleHelper.hasRole(source, "Gradient") && !visuals.DataRoleHelper.hasRole(source, "Y")) continue;
                            seriesSources.push(source);
                            seriesObjects.push(series.objects);
                            var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                            var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                            var color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                            legend.push({
                                icon: 0,
                                color: color,
                                label: label,
                                identity: selectionId,
                                selected: false
                            });
                            if (series.identity && source.groupName !== undefined) {
                                grouped = true;
                            }
                        }
                    }
                    var dvValues = this.dataView.values;
                    var legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legend,
                    grouped: grouped
                };
                return {
                    legend: legendData,
                    seriesSources: seriesSources,
                    seriesObjects: seriesObjects
                };
            };
            ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                return this.dataView.values[series].values[category];
            };
            ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                return this.dataView.values[index].source.queryName;
            };
            ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                return column && !!column.highlights;
            };
            ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                return this.dataView.values[series].highlights[category];
            };
            return ColumnChartConverterHelper;
        }();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ClusteredColumnChartStrategy = function() {
            function ClusteredColumnChartStrategy() {}
            ClusteredColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
            };
            ClusteredColumnChartStrategy.prototype.setData = function(data) {
                this.data = data;
            };
            ClusteredColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax);
                var seriesLength = this.data.series.length;
                var columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                    return s.index;
                })).rangeBands([ 0, seriesLength * columnWidth ]);
                props.xLabelMaxWidth = this.categoryLayout.isScalar ? width / props.values.length : this.categoryLayout.categoryThickness;
                return props;
            };
            ClusteredColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain) {
                debug.assert(!is100Pct, "Cannot have 100% clustered chart.");
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true);
                var maxTickCount = visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height);
                var bestTickCount = visuals.ColumnUtil.getTickCount(valueDomain[0], valueDomain[1], this.data.valuesMetadata, maxTickCount, is100Pct, forcedTickCount);
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({
                    min: valueDomain[0],
                    max: valueDomain[1]
                });
                valueDomain = [ normalizedRange.min, normalizedRange.max ];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain);
                var yScale = d3.scale.linear().range([ height, 0 ]).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain));
                visuals.ColumnUtil.normalizeInfinityInScale(yScale);
                var yTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, yScale);
                var yAxis = d3.svg.axis().scale(yScale).tickValues(yTickValues);
                var yInterval = visuals.ColumnChart.getTickInterval(yTickValues);
                var yFormatter = visuals.ClusteredUtil.createValueFormatter(this.data.valuesMetadata, yInterval);
                yAxis.tickFormat(yFormatter.format);
                var values = yTickValues.map(function(d) {
                    return yFormatter.format(d);
                });
                var yProps = this.yProps = {
                    axis: yAxis,
                    scale: yScale,
                    formatter: yFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({
                        text: true
                    }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
                return yProps;
            };
            ClusteredColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                debug.assertValue(data, "data could not be null or undefined");
                this.columnsCenters = null;
                var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                };
                var clusteredColumnLayout = ClusteredColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, dataLabelSettings), true, false, this.yProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredColumnLayout,
                        itemCS: ClusteredColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, {
                                height: this.height,
                                width: this.width
                            });
                        } else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            ClusteredColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            ClusteredColumnChartStrategy.prototype.getColumnsCenters = function() {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var xScaleOffset = 0;
                        if (!this.categoryLayout.isScalar) xScaleOffset = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function(d) {
                            return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                        });
                    }
                }
                return this.columnsCenters;
            };
            ClusteredColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", true).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height
                    });
                    handle.append("circle").attr({
                        cx: x,
                        cy: this.height,
                        r: "6px"
                    }).classed("drag-handle", true);
                } else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        x1: x,
                        x2: x
                    });
                    handle.select("circle").attr({
                        cx: x
                    });
                }
            };
            ClusteredColumnChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar) xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        y: function(d) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0);
                        },
                        height: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset;
                        },
                        y: function(d) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0);
                        },
                        height: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue));
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        x: function(d) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        y: function(d) {
                            return scaledY0;
                        },
                        height: function(d) {
                            return 0;
                        }
                    }
                };
            };
            ClusteredColumnChartStrategy.prototype.getLabelLayoutXY = function(axisOptions, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var xScaleOffset = 0;
                var scaledY0 = yScale(0);
                if (isScalar) xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    x: function(d) {
                        return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0) + halfColumnWidth;
                    },
                    y: function(d) {
                        var outsidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                        var insidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) / 2 - visuals.dataLabelUtils.defaultColumnLabelMargin;
                        if (outsidePosition <= 0) {
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return insidePosition;
                        }
                        return outsidePosition;
                    }
                };
            };
            ClusteredColumnChartStrategy.classes = {
                item: {
                    "class": "column",
                    selector: ".column"
                }
            };
            return ClusteredColumnChartStrategy;
        }();
        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
        var ClusteredBarChartStrategy = function() {
            function ClusteredBarChartStrategy() {}
            ClusteredBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
            };
            ClusteredBarChartStrategy.prototype.setData = function(data) {
                this.data = data;
            };
            ClusteredBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax);
                var seriesLength = this.data.series.length;
                var columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                    return s.index;
                })).rangeBands([ 0, seriesLength * columnWidth ]);
                return props;
            };
            ClusteredBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain) {
                debug.assert(!is100Pct, "Cannot have 100% clustered chart.");
                debug.assert(forcedTickCount === undefined, "Cannot have clustered bar chart as combo chart.");
                var width = this.width;
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true);
                var bestTickCount = visuals.AxisHelper.getBestNumberOfTicks(valueDomain[0], valueDomain[1], this.data.valuesMetadata, visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width));
                var normalizedRange = visuals.AxisHelper.normalizeLinearDomain({
                    min: valueDomain[0],
                    max: valueDomain[1]
                });
                valueDomain = [ normalizedRange.min, normalizedRange.max ];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain);
                var xScale = d3.scale.linear().range([ 0, width ]).domain(combinedDomain).nice(bestTickCount || undefined).clamp(visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain));
                visuals.ColumnUtil.normalizeInfinityInScale(xScale);
                var xTickValues = visuals.AxisHelper.getRecommendedTickValuesForALinearRange(bestTickCount, xScale);
                var xAxis = d3.svg.axis().scale(xScale).tickSize(-height, 0).tickValues(xTickValues);
                var xInterval = visuals.ColumnChart.getTickInterval(xTickValues);
                var xFormatter = visuals.ClusteredUtil.createValueFormatter(this.data.valuesMetadata, xInterval);
                xAxis.tickFormat(xFormatter.format);
                var values = xTickValues.map(function(d) {
                    return xFormatter.format(d);
                });
                var xProps = this.xProps = {
                    axis: xAxis,
                    scale: xScale,
                    formatter: xFormatter,
                    values: values,
                    axisType: powerbi.ValueType.fromDescriptor({
                        numeric: true
                    }),
                    axisLabel: null,
                    isCategoryAxis: false
                };
                return xProps;
            };
            ClusteredBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                debug.assertValue(data, "data could not be null or undefined");
                this.barsCenters = null;
                var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                };
                var clusteredBarLayout = ClusteredBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, this.width, dataLabelSettings), false, false, this.xProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredBarLayout,
                        itemCS: ClusteredBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, {
                                height: this.height,
                                width: this.width
                            });
                        } else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            ClusteredBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            ClusteredBarChartStrategy.prototype.getBarsCenters = function() {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var yScaleOffset = 0;
                        if (!this.categoryLayout.isScalar) yScaleOffset = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function(d) {
                            return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset;
                        });
                    }
                }
                return this.barsCenters;
            };
            ClusteredBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", true).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    });
                    handle.append("circle").attr({
                        cx: 0,
                        cy: y,
                        r: "6px"
                    }).classed("drag-handle", true);
                } else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        y1: y,
                        y2: y
                    });
                    handle.select("circle").attr({
                        cy: y
                    });
                }
            };
            ClusteredBarChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledX0 = xScale(0);
                var xScaleOffset = 0;
                if (isScalar) xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        height: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue));
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset;
                        },
                        height: function(d) {
                            return columnWidth;
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return 0;
                        },
                        x: function(d) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                        },
                        y: function(d) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        height: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        }
                    }
                };
            };
            ClusteredBarChartStrategy.prototype.getLabelLayoutXY = function(axisOptions, visualWidth, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var xScaleOffset = 0;
                var scaledX0 = xScale(0);
                if (isScalar) xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    x: function(d) {
                        var properties = {
                            text: d.labeltext,
                            fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var outsidePosition = scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                        if (outsidePosition + textWidth > visualWidth) {
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) / 2 - textWidth / 2;
                        }
                        return outsidePosition;
                    },
                    y: function(d) {
                        return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0) + halfColumnWidth + visuals.dataLabelUtils.defaultColumnHalfLabelHeight;
                    }
                };
            };
            ClusteredBarChartStrategy.classes = {
                item: {
                    "class": "bar",
                    selector: ".bar"
                }
            };
            return ClusteredBarChartStrategy;
        }();
        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var StackedColumnChartStrategy = function() {
            function StackedColumnChartStrategy() {}
            StackedColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
            };
            StackedColumnChartStrategy.prototype.setData = function(data) {
                this.data = data;
            };
            StackedColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax);
                props.xLabelMaxWidth = this.categoryLayout.isScalar ? width / props.values.length : this.categoryLayout.categoryThickness;
                return props;
            };
            StackedColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.viewportHeight;
                var yProps = this.yProps = visuals.StackedUtil.getValueAxis(this.data, is100Pct, height, [ height, 0 ], forcedTickCount, forcedYDomain);
                return yProps;
            };
            StackedColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                debug.assertValue(data, "data should not be null or undefined");
                this.columnsCenters = null;
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                };
                var stackedColumnLayout = StackedColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, dataLabelSettings), true, this.graphicsContext.is100Pct, this.yProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: StackedColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, {
                                height: this.height,
                                width: this.width
                            });
                        } else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            StackedColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            StackedColumnChartStrategy.prototype.getColumnsCenters = function() {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var xScaleOffset = 0;
                        if (!this.categoryLayout.isScalar) xScaleOffset = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function(d) {
                            return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                        });
                    }
                }
                return this.columnsCenters;
            };
            StackedColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", true).attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height
                    });
                    handle.append("circle").attr({
                        cx: x,
                        cy: this.height,
                        r: "6px"
                    }).classed("drag-handle", true);
                } else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        x1: x,
                        x2: x
                    });
                    handle.select("circle").attr({
                        cx: x
                    });
                }
            };
            StackedColumnChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar) xScaleOffset = columnWidth / 2;
                return {
                    shapeLayout: {
                        width: function(d, i) {
                            return columnWidth;
                        },
                        x: function(d, i) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d, i) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                        },
                        height: function(d, i) {
                            return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d, i) {
                            return columnWidth;
                        },
                        x: function(d, i) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d, i) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.originalPosition, 0);
                        },
                        height: function(d, i) {
                            return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute);
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d, i) {
                            return columnWidth;
                        },
                        x: function(d, i) {
                            return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        y: function(d, i) {
                            return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                        },
                        height: function(d, i) {
                            return 0;
                        }
                    }
                };
            };
            StackedColumnChartStrategy.prototype.getLabelLayoutXY = function(axisOptions, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                var scaledY0 = yScale(0);
                var is100Pct = this.graphicsContext.is100Pct;
                var labelLayoutY = this.getLabelLayoutY;
                if (isScalar) xScaleOffset = halfColumnWidth;
                return {
                    x: function(d) {
                        return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset + halfColumnWidth;
                    },
                    y: function(d) {
                        return labelLayoutY(d, is100Pct, scaledY0, yScale, labelSettings);
                    }
                };
            };
            StackedColumnChartStrategy.prototype.getLabelLayoutY = function(d, is100Pct, scaledY0, yScale, labelSettings) {
                var insidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute) / 2 + visuals.dataLabelUtils.defaultColumnHalfLabelHeight;
                var outsidePosition = scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                if (is100Pct || !d.lastSeries) return insidePosition;
                if (outsidePosition <= 0) {
                    d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                    return insidePosition;
                }
                return outsidePosition;
            };
            StackedColumnChartStrategy.classes = {
                item: {
                    "class": "column",
                    selector: ".column"
                },
                highlightItem: {
                    "class": "highlightColumn",
                    selector: ".highlightColumn"
                }
            };
            return StackedColumnChartStrategy;
        }();
        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
        var StackedBarChartStrategy = function() {
            function StackedBarChartStrategy() {}
            StackedBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
            };
            StackedBarChartStrategy.prototype.setData = function(data) {
                this.data = data;
            };
            StackedBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax);
                return props;
            };
            StackedBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain) {
                debug.assert(forcedTickCount === undefined, "Cannot have stacked bar chart as combo chart.");
                var height = this.viewportHeight;
                var xProps = this.xProps = visuals.StackedUtil.getValueAxis(this.data, is100Pct, this.width, [ 0, this.width ], undefined, forcedXDomain);
                xProps.axis.tickSize(-height, 0);
                return xProps;
            };
            StackedBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                var data = this.data;
                debug.assertValue(data, "data should not be null or undefined");
                this.barsCenters = null;
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin
                };
                var stackedBarLayout = StackedBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var dataLabelLayout = null;
                if (dataLabelSettings != null) {
                    dataLabelLayout = visuals.dataLabelUtils.getColumnChartLabelLayout(data, this.getLabelLayoutXY(axisOptions, this.width, dataLabelSettings), false, this.graphicsContext.is100Pct, this.xProps.formatter, axisOptions);
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedBarLayout,
                        itemCS: StackedBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        labelGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        labelLayout: dataLabelLayout,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator);
                    if (dataLabelLayout !== null) {
                        if (dataLabelSettings.show) {
                            visuals.ColumnUtil.drawDefaultLabels(series, this.graphicsContext.mainGraphicsContext, dataLabelLayout, {
                                height: this.height,
                                width: this.width
                            });
                        } else {
                            visuals.dataLabelUtils.cleanDataLabels(this.graphicsContext.mainGraphicsContext);
                        }
                    }
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return shapes;
            };
            StackedBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            StackedBarChartStrategy.prototype.getBarsCenters = function() {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    if (this.data.series.length > 0) {
                        var yScaleOffset = 0;
                        if (!this.categoryLayout.isScalar) yScaleOffset = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function(d) {
                            return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset;
                        });
                    }
                }
                return this.barsCenters;
            };
            StackedBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                    handle.append("line").classed("interactive-hover-line", true).attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    });
                    handle.append("circle").classed("drag-handle", true).attr({
                        cx: 0,
                        cy: y,
                        r: "6px"
                    });
                } else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select("line").attr({
                        y1: y,
                        y2: y
                    });
                    handle.select("circle").attr({
                        cy: y
                    });
                }
            };
            StackedBarChartStrategy.getLayout = function(data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledX0 = xScale(0);
                var xScaleOffset = 0;
                if (isScalar) xScaleOffset = columnWidth / 2;
                return {
                    shapeLayout: {
                        width: function(d, i) {
                            return -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                        },
                        x: function(d, i) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0);
                        },
                        y: function(d, i) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        height: function(d, i) {
                            return columnWidth;
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d, i) {
                            return -visuals.StackedUtil.getSize(xScale, d.originalValueAbsolute);
                        },
                        x: function(d, i) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition - d.originalValueAbsolute, 0);
                        },
                        y: function(d, i) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        height: function(d, i) {
                            return columnWidth;
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d, i) {
                            return 0;
                        },
                        x: function(d, i) {
                            return scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0);
                        },
                        y: function(d, i) {
                            return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                        },
                        height: function(d, i) {
                            return columnWidth;
                        }
                    }
                };
            };
            StackedBarChartStrategy.prototype.getLabelLayoutXY = function(axisOptions, visualWidth, labelSettings) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = .5 * columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                var scaledX0 = xScale(0);
                var is100Pct = this.graphicsContext.is100Pct;
                if (isScalar) xScaleOffset = halfColumnWidth;
                return {
                    x: function(d) {
                        var properties = {
                            text: d.labeltext,
                            fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var insidePosition = scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.StackedUtil.getSize(xScale, d.valueAbsolute) / 2 - textWidth / 2;
                        var outsidePosition = scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                        if (is100Pct || !d.lastSeries) return insidePosition;
                        if (outsidePosition + textWidth > visualWidth) {
                            d.labelFill = labelSettings.overrideDefaultColor ? d.labelFill : visuals.dataLabelUtils.defaultInsideLabelColor;
                            return insidePosition;
                        }
                        return outsidePosition;
                    },
                    y: function(d) {
                        return yScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset + halfColumnWidth + visuals.dataLabelUtils.defaultColumnHalfLabelHeight;
                    }
                };
            };
            StackedBarChartStrategy.classes = {
                item: {
                    "class": "bar",
                    selector: ".bar"
                },
                highlightItem: {
                    "class": "highlightBar",
                    selector: ".highlightBar"
                }
            };
            return StackedBarChartStrategy;
        }();
        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ComboChart;
        (function(ComboChart) {
            ComboChart.capabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: 0,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Category")
                }, {
                    name: "Series",
                    kind: 0,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Series")
                }, {
                    name: "Y",
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y")
                }, {
                    name: "Y2",
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y2")
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            },
                            visualType1: {
                                type: {
                                    text: true
                                }
                            },
                            visualType2: {
                                type: {
                                    text: true
                                }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                type: {
                                    numeric: true
                                }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                type: {
                                    numeric: true
                                }
                            },
                            axisType: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                type: {
                                    formatting: {
                                        axisType: true
                                    }
                                }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                type: {
                                    bool: true
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    formatting: {
                                        axisStyle: true
                                    }
                                }
                            }
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            secShow: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ShowSecondery"),
                                type: {
                                    bool: true
                                }
                            },
                            axisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ColumnTitle"),
                                type: {
                                    none: true
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                type: {
                                    formatting: {
                                        yAxisPosition: true
                                    }
                                }
                            },
                            start: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                type: {
                                    numeric: true
                                }
                            },
                            end: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                type: {
                                    numeric: true
                                }
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                type: {
                                    bool: true
                                }
                            },
                            axisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    formatting: {
                                        axisStyle: true
                                    }
                                }
                            },
                            secAxisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_LineTitle"),
                                type: {
                                    none: true
                                }
                            },
                            secPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                type: {
                                    formatting: {
                                        yAxisPosition: true
                                    }
                                }
                            },
                            secStart: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                type: {
                                    numeric: true
                                }
                            },
                            secEnd: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                type: {
                                    numeric: true
                                }
                            },
                            secShowAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                type: {
                                    bool: true
                                }
                            },
                            secAxisStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                type: {
                                    formatting: {
                                        axisStyle: true
                                    }
                                }
                            }
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            position: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                type: {
                                    formatting: {
                                        legendPosition: true
                                    }
                                }
                            },
                            showTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                type: {
                                    bool: true
                                }
                            },
                            titleText: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                                type: {
                                    text: true
                                }
                            }
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        properties: {
                            defaultColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            showAllDataPoints: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                type: {
                                    bool: true
                                }
                            },
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        properties: {
                            show: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: true
                                }
                            },
                            color: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: true
                                        }
                                    }
                                }
                            },
                            labelDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: true
                                    }
                                }
                            },
                            labelPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "Y"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Y2: {
                            min: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                "for": {
                                    "in": "Y2"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                } ],
                supportsHighlight: true,
                sorting: {
                    custom: {}
                }
            };
        })(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
        visuals.comboChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DataColorPalette = function() {
            function DataColorPalette(colors) {
                this.sentimentColors = [ {
                    value: "#C0433A"
                }, {
                    value: "#E8D62E"
                }, {
                    value: "#79C75B"
                } ];
                this.basePickerColors = [ {
                    value: "#FFFFFF"
                }, {
                    value: "#000000"
                }, {
                    value: "#00B8AA"
                }, {
                    value: "#374649"
                }, {
                    value: "#FD625E"
                }, {
                    value: "#F2C811"
                }, {
                    value: "#5F6B6D"
                }, {
                    value: "#8AD4EB"
                }, {
                    value: "#FE9666"
                }, {
                    value: "#A66999"
                } ];
                this.colors = colors || ThemeManager.getDefaultTheme();
                this.defaultColors = d3.scale.ordinal().range(this.colors);
                this.palettes = {};
            }
            DataColorPalette.prototype.getColor = function(key) {
                return this.defaultColors(key);
            };
            DataColorPalette.prototype.getColorByScale = function(scaleKey, key) {
                var colors = this.palettes[scaleKey];
                if (colors === undefined) {
                    colors = d3.scale.ordinal().range(this.colors);
                    this.palettes[scaleKey] = colors;
                }
                return colors(key);
            };
            DataColorPalette.prototype.getSentimentColors = function() {
                return this.sentimentColors;
            };
            DataColorPalette.prototype.getBasePickerColors = function() {
                return this.basePickerColors;
            };
            return DataColorPalette;
        }();
        visuals.DataColorPalette = DataColorPalette;
        var ThemeManager = function() {
            function ThemeManager() {}
            ThemeManager.getDefaultTheme = function() {
                if (!ThemeManager.defaultTheme) {
                    ThemeManager.defaultTheme = [];
                    var baseColors = ThemeManager.defaultBaseColors;
                    for (var i = 0; i < ThemeManager.colorSectorCount; ++i) {
                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
                            ThemeManager.defaultTheme.push({
                                value: jsCommon.color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                            });
                        }
                    }
                }
                return ThemeManager.defaultTheme;
            };
            ThemeManager.colorSectorCount = 12;
            ThemeManager.defaultBaseColors = [ {
                value: "#01B8AA"
            }, {
                value: "#374649"
            }, {
                value: "#FD625E"
            }, {
                value: "#F2C80F"
            }, {
                value: "#5F6B6D"
            }, {
                value: "#8AD4EB"
            }, {
                value: "#FE9666"
            }, {
                value: "#A66999"
            }, {
                value: "#3599B8"
            }, {
                value: "#DFBFBF"
            }, {
                value: "#4AC5BB"
            }, {
                value: "#5F6B6D"
            }, {
                value: "#FB8281"
            }, {
                value: "#F4D25A"
            }, {
                value: "#7F898A"
            }, {
                value: "#A4DDEE"
            }, {
                value: "#FDAB89"
            }, {
                value: "#B687AC"
            }, {
                value: "#28738A"
            }, {
                value: "#A78F8F"
            }, {
                value: "#168980"
            }, {
                value: "#293537"
            }, {
                value: "#BB4A4A"
            }, {
                value: "#B59525"
            }, {
                value: "#475052"
            }, {
                value: "#6A9FB0"
            }, {
                value: "#BD7150"
            }, {
                value: "#7B4F71"
            }, {
                value: "#1B4D5C"
            }, {
                value: "#706060"
            }, {
                value: "#0F5C55"
            }, {
                value: "#1C2325"
            }, {
                value: "#7D3231"
            }, {
                value: "#796419"
            }, {
                value: "#303637"
            }, {
                value: "#476A75"
            }, {
                value: "#7E4B36"
            }, {
                value: "#52354C"
            }, {
                value: "#0D262E"
            }, {
                value: "#544848"
            } ];
            return ThemeManager;
        }();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DataDotChart = function() {
            function DataDotChart() {}
            DataDotChart.prototype.init = function(options) {
                this.options = options;
                this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsG = this.svg.append("g").classed("dataDotChartMainGraphicsContext", true);
                this.mainGraphicsContext = this.mainGraphicsG.append("svg");
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.cartesianVisualHost = options.cartesianHost;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.interactivity = options.interactivity;
                var element = this.element = options.element;
                element.addClass(DataDotChart.ClassName);
                element.css("overflow", "visible");
            };
            DataDotChart.prototype.setData = function(dataViews) {
                this.data = {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical;
                        var dvCategories = dataViewCategorical.categories;
                        var categoryType = powerbi.ValueType.fromDescriptor({
                            text: true
                        });
                        if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type) categoryType = dvCategories[0].source.type;
                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null));
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.series.data);
                        }
                    }
                }
            };
            DataDotChart.prototype.calculateAxesProperties = function(options) {
                var _this = this;
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.data;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var series = data ? data.series : null;
                var seriesArray = series && series.data && series.data.length > 0 ? [ series ] : [];
                var categoryCount = series && series.data ? series.data.length : 0;
                if (data.hasHighlights) {
                    categoryCount = categoryCount / 2;
                }
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (DataDotChart.hasDataPoint(series)) {
                    xMetaDataColumn = series.xCol;
                    yMetaDataColumn = series.yCol;
                }
                var layout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: false
                });
                var outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount);
                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, true);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatStringProp: DataDotChart.formatStringProp,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true
                });
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                    text: true
                });
                var xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, false, options.forcedXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatStringProp: DataDotChart.formatStringProp,
                    outerPadding: outerPadding,
                    isScalar: false,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    categoryThickness: layout.categoryThickness,
                    getValueFn: function(index, type) {
                        return _this.lookupXValue(index, type);
                    },
                    isCategoryAxis: false
                });
                return [ this.xAxisProperties, this.yAxisProperties ];
            };
            DataDotChart.createClippedDataIfOverflowed = function(data, categoryCount) {
                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, categoryCount * 2) : Math.min(data.series.data.length, categoryCount);
                if (requiredLength >= data.series.data.length) {
                    return data;
                }
                var clipped = powerbi.Prototype.inherit(data);
                clipped.series = powerbi.Prototype.inherit(data.series);
                clipped.series.data = clipped.series.data.slice(0, requiredLength);
                return clipped;
            };
            DataDotChart.hasDataPoint = function(series) {
                return series && series.data && series.data.length > 0;
            };
            DataDotChart.prototype.lookupXValue = function(index, type) {
                var data = this.clippedData;
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime) return new Date(index);
                if (data && data.series) {
                    var seriesData = data.series.data;
                    if (seriesData) {
                        var dataAtIndex = seriesData[index];
                        if (dataAtIndex) {
                            return dataAtIndex.categoryValue;
                        }
                    }
                }
                return index;
            };
            DataDotChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            };
            DataDotChart.prototype.render = function(duration) {
                var _this = this;
                var data = this.clippedData;
                var dataPoints = data.series.data;
                var hasHighlights = data.hasHighlights;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var dotRadius = dotWidth / 2;
                var dotColor = this.colors.getColor(DataDotChart.DotColorKey);
                var hasSelection = visuals.dataHasSelection(dataPoints);
                this.mainGraphicsContext.attr("width", width).attr("height", height);
                var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function(d) {
                    return d.identity.getKey();
                });
                dots.enter().append("circle").classed(DataDotChart.DotClassName, true);
                dots.style({
                    fill: dotColor.value
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                }).classed("null-value", function(d) {
                    return d.value === null;
                }).attr({
                    r: function(d) {
                        return dotRadius;
                    },
                    cx: function(d) {
                        return xScale(d.categoryIndex) + dotRadius;
                    },
                    cy: function(d) {
                        return yScale(d.value);
                    }
                });
                dots.exit().remove();
                var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function(d) {
                    return d.identity.getKey();
                });
                dotLabels.enter().append("text").classed(DataDotChart.DotLabelClassName, true).attr({
                    "text-anchor": DataDotChart.DotLabelTextAnchor,
                    dy: DataDotChart.DotLabelVerticalOffset
                });
                dotLabels.classed("null-value", function(d) {
                    return d.value === null;
                }).classed("overflowed", false).attr({
                    x: function(d) {
                        return xScale(d.categoryIndex) + dotRadius;
                    },
                    y: function(d) {
                        return yScale(d.value);
                    }
                }).text(function(d) {
                    return _this.yAxisProperties.formatter.format(d.value);
                });
                var overflowed = false;
                dotLabels.each(function() {
                    if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                        var width = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                        if (width > dotWidth) {
                            dotLabels.classed("overflowed", true);
                            overflowed = true;
                        }
                    }
                });
                dotLabels.exit().remove();
                if (this.interactivityService) {
                    var behaviorOptions = {
                        dots: dots,
                        datapoints: dataPoints,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DataDotChart.prototype.calculateLegend = function() {
                return this.createLegendDataPoints(0);
            };
            DataDotChart.prototype.hasLegend = function() {
                return this.data && this.data.hasDynamicSeries;
            };
            DataDotChart.prototype.createLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data) return null;
                var series = data.series;
                var seriesData = series.data;
                var legendDataPoints = [];
                var category;
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                    text: true
                });
                if (data.series && data.series.data) {
                    var firstDataPoint = data.series.data[0];
                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                }
                if (series.yCol) {
                    var formatStringProp = DataDotChart.formatStringProp;
                    var lineDataPoint = seriesData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp);
                    var dotColor = this.colors.getColor(DataDotChart.DotColorKey);
                    var dataViewCategoricalValues = this.dataViewCategorical.values;
                    var identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ? dataViewCategoricalValues[columnIndex].identity : null;
                    legendDataPoints.push({
                        color: dotColor.value,
                        icon: 2,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: identity ? visuals.SelectionId.createWithId(identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return {
                    dataPoints: legendDataPoints
                };
            };
            DataDotChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            DataDotChart.converter = function(dataView, blankCategoryValue) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: undefined,
                    values: [ blankCategoryValue ],
                    identity: undefined
                };
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                if (categorical.values) {
                    var measure = categorical.values[0];
                    var hasHighlights = !!measure.highlights;
                    var dataPoints = [];
                    for (var categoryIndex = 0, len = measure.values.length; categoryIndex < len; categoryIndex++) {
                        debug.assert(!category.identity || categoryIndex < category.identity.length, "Category identities is smaller than category values.");
                        var identity = category.identity ? visuals.SelectionId.createWithId(category.identity[categoryIndex]) : visuals.SelectionId.createWithMeasure(measure.source.queryName);
                        var categoryValue = categoryValues[categoryIndex];
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: measure.values[categoryIndex],
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlightValue = measure.highlights[categoryIndex];
                            dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: highlightValue,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: highlightIdentity,
                                highlight: true
                            });
                        }
                    }
                    return {
                        series: {
                            xCol: category.source,
                            yCol: measure.source,
                            data: dataPoints
                        },
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: true
                    };
                }
                return {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false
                };
            };
            DataDotChart.prototype.accept = function(visitor, options) {
                debug.assertValue(visitor, "visitor");
                visitor.visitDataDotChart(options);
            };
            DataDotChart.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            DataDotChart.ClassName = "dataDotChart";
            DataDotChart.DotClassName = "dot";
            DataDotChart.DotClassSelector = ".dot";
            DataDotChart.DotColorKey = "dataDot";
            DataDotChart.DotLabelClassName = "label";
            DataDotChart.DotLabelClassSelector = ".label";
            DataDotChart.DotLabelVerticalOffset = "0.4em";
            DataDotChart.DotLabelTextAnchor = "middle";
            DataDotChart.capabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: 0
                }, {
                    name: "Y",
                    kind: 1
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                "for": {
                                    "in": "Y"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            } ]
                        }
                    }
                } ]
            };
            return DataDotChart;
        }();
        visuals.DataDotChart = DataDotChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.donutChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
            }, {
                name: "Series",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
            }, {
                name: "Y",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: true
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            type: {
                                numeric: true
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    properties: {
                        show: {
                            type: {
                                bool: true
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        },
                        supported: {
                            min: 1
                        }
                    }
                }
            } ],
            sorting: {
                "default": {}
            },
            supportsHighlight: true
        };
        visuals.donutChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var DonutChart = function() {
            function DonutChart(options) {
                if (options) {
                    this.sliceWidthRatio = options.sliceWidthRatio;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                }
                if (this.sliceWidthRatio == null) {
                    this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio;
                }
            }
            DonutChart.converter = function(dataView, colors, suppressLabels) {
                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors);
                converter.convert();
                var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
                var dataPoints = d3PieLayout(converter.dataPoints);
                var data = {
                    dataPointsToDeprecate: converter.dataPoints,
                    dataPoints: dataPoints,
                    unCulledDataPoints: dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue
                };
                if (suppressLabels !== undefined) data.suppressLabels = suppressLabels;
                return data;
            };
            DonutChart.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                element.empty();
                this.parentViewport = options.viewport;
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width
                };
                this.formatter = visuals.valueFormatter.format;
                this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: {
                        title: "",
                        dataPoints: []
                    },
                    hasHighlights: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings()
                };
                this.drilled = false;
                this.allowDrilldown = false;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.radius = 0;
                this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                var donutChartSettings = this.options.settings;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.hostService = options.host;
                if (this.isInteractive) {
                    this.chartRotationAnimationDuration = donutChartSettings && donutChartSettings.chartRotationAnimationDuration ? donutChartSettings.chartRotationAnimationDuration : 0;
                    var legendContainer = this.legendContainer = d3.select(element.get(0)).append("div").classed(DonutChart.InteractiveLegendClassName, true);
                    this.interactivityState = {
                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options),
                        valueToAngleFactor: 0,
                        sliceAngles: [],
                        currentRotate: 0,
                        interactiveChosenSliceFinishedSetting: false,
                        lastChosenInteractiveSliceIndex: 0,
                        totalDragAngleDifference: 0,
                        currentIndexDrag: 0,
                        previousIndexDrag: 0,
                        previousDragAngle: 0,
                        donutCenter: {
                            x: 0,
                            y: 0
                        }
                    };
                }
                this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(DonutChart.ClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.mainGraphicsContext = this.svg.append("g");
                this.mainGraphicsContext.append("g").classed("slices", true);
                this.mainGraphicsContext.append("g").classed("labels", true);
                this.mainGraphicsContext.append("g").classed("lines", true);
                this.pie = d3.layout.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
            };
            DonutChart.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    this.data = DonutChart.converter(dataViews[0], this.colors);
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) this.renderLegend();
                    if (this.interactivityService) this.interactivityService.applySelectionStateToData(this.data.dataPoints.map(function(d) {
                        return d.data;
                    }));
                } else {
                    this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: {
                            title: "",
                            dataPoints: []
                        },
                        hasHighlights: false,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings()
                    };
                }
                this.initViewportDependantProperties();
                this.updateInternal(this.data, options.duration);
                this.hasSetData = true;
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (this.data.visibleGeometryCulled) {
                        var cullWarning = new visuals.SmallSlicesCulledWarning();
                        if (!warnings) warnings = [ cullWarning ]; else warnings.unshift(cullWarning);
                    }
                    if (warnings && warnings.length > 0) this.hostService.setWarnings(warnings);
                }
            };
            DonutChart.prototype.onResizing = function(viewport, duration) {
                this.parentViewport = viewport;
                if (this.currentViewport && (this.currentViewport.height === viewport.height && this.currentViewport.width === viewport.width)) return;
                this.parentViewport = viewport;
                if (this.hasSetData) this.renderLegend();
                this.initViewportDependantProperties(duration);
                this.updateInternal(this.data, duration);
                this.previousRadius = this.radius;
            };
            DonutChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "legend":
                    return this.enumerateLegend();

                  case "dataPoint":
                    return this.enumerateDataPoints();

                  case "labels":
                    if (this.data) return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true); else return visuals.dataLabelUtils.enumerateDataLabels(visuals.dataLabelUtils.getDefaultDonutLabelSettings(), false, true, true);

                  case "categoryLabels":
                    return this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(this.data.dataLabelsSettings, false, true) : visuals.dataLabelUtils.enumerateCategoryLabels(null, false, true);
                }
            };
            DonutChart.prototype.enumerateDataPoints = function() {
                var data = this.data;
                if (!data) return;
                var instances = [];
                var dataPoints = data.dataPointsToEnumerate;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dataPoint = dataPoints[i];
                    instances.push({
                        objectName: "dataPoint",
                        displayName: dataPoint.label,
                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                        properties: {
                            fill: {
                                solid: {
                                    color: dataPoint.color
                                }
                            }
                        }
                    });
                }
                return instances;
            };
            DonutChart.prototype.enumerateLegend = function() {
                var data = this.data;
                if (!data) return;
                var legendObjectProperties = {
                    legend: data.legendObjectProperties
                };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title);
                return [ {
                    selector: null,
                    objectName: "legend",
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText
                    }
                } ];
            };
            DonutChart.prototype.setInteractiveChosenSlice = function(sliceIndex) {
                var _this = this;
                if (this.interactivityState.sliceAngles.length === 0) return;
                this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex;
                this.interactivityState.interactiveChosenSliceFinishedSetting = false;
                var viewport = this.currentViewport;
                var moduledIndex = sliceIndex % this.data.dataPoints.length;
                var angle = this.interactivityState.sliceAngles[moduledIndex];
                this.svg.select("g").transition().duration(this.chartRotationAnimationDuration).ease("elastic").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle)).each("end", function() {
                    _this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                });
                this.interactivityState.currentRotate = angle;
                this.interactivityState.interactiveLegend.updateLegend(moduledIndex);
                this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                    return index === moduledIndex ? 1 : .6;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.calculateRadius = function() {
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    return Math.min(viewport.height, viewport.width) / 2;
                } else {
                    var hw = viewport.height / viewport.width;
                    var denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
            };
            DonutChart.prototype.initViewportDependantProperties = function(duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                this.currentViewport.height = this.parentViewport.height;
                this.currentViewport.width = this.parentViewport.width;
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    viewport.height -= DonutChart.InteractiveLegendContainerHeight;
                } else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height;
                    viewport.width -= legendMargins.width;
                }
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                if (this.isInteractive) {
                    this.legendContainer.style({
                        width: "100%",
                        height: DonutChart.InteractiveLegendContainerHeight + "px",
                        overflow: "hidden",
                        top: 0
                    });
                    this.svg.style("top", DonutChart.InteractiveLegendContainerHeight);
                }
                this.previousRadius = this.radius;
                var radius = this.radius = this.calculateRadius();
                this.arc = d3.svg.arc();
                this.outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                if (this.isInteractive) {
                    this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(viewport.width / 2, viewport.height / 2));
                } else {
                    this.mainGraphicsContext.transition().duration(duration).attr("transform", visuals.SVGUtil.translate(viewport.width / 2, viewport.height / 2));
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.mergeDatasets = function(first, second) {
                var secondSet = d3.set();
                second.forEach(function(d) {
                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                });
                var onlyFirst = first.filter(function(d) {
                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                }).map(function(d) {
                    var derived = powerbi.Prototype.inherit(d);
                    derived.percentage === undefined ? derived.data.percentage = 0 : derived.percentage = 0;
                    return derived;
                });
                return d3.merge([ second, onlyFirst ]);
            };
            DonutChart.prototype.updateInternal = function(data, duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                var viewport = this.currentViewport;
                this.data.dataPoints = DonutChart.cullDataByViewport(data, viewport);
                if (this.animator) {
                    var layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport);
                    var result;
                    var shapes;
                    var highlightShapes;
                    var animationOptions = {
                        viewModel: data,
                        colors: this.colors,
                        graphicsContext: this.mainGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        radius: this.radius,
                        sliceWidthRatio: this.sliceWidthRatio,
                        viewport: viewport
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    if (result.failed) {
                        shapes = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius);
                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius);
                        DonutChart.drawDefaultCategoryLabels(this.svg, data, layout, this.sliceWidthRatio, this.radius, this.currentViewport);
                    }
                    this.assignInteractions(shapes, highlightShapes, data);
                    visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    });
                    visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    });
                } else {
                    this.updateInternalToMove(data, duration);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.renderLegend = function() {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position) this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.parentViewport);
                } else {
                    this.legend.changeOrientation(0);
                    this.legend.drawLegend({
                        dataPoints: []
                    }, this.parentViewport);
                }
            };
            DonutChart.prototype.addInteractiveLegendArrow = function() {
                var arrowHeightOffset = 11;
                var arrowWidthOffset = 33 / 2;
                if (!this.interactiveLegendArrow) {
                    var interactiveLegendArrow = this.svg.append("g");
                    interactiveLegendArrow.append("path").classed(DonutChart.InteractiveLegendArrowClassName, true).attr("d", "M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z");
                    this.interactiveLegendArrow = interactiveLegendArrow;
                }
                var viewport = this.currentViewport;
                var distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + arrowHeightOffset;
                var middleOfChart = viewport.width / 2 - arrowWidthOffset;
                this.interactiveLegendArrow.attr("transform", visuals.SVGUtil.translate(middleOfChart, distanceBetweenLegendAndArrow));
            };
            DonutChart.prototype.calculateSliceAngles = function() {
                var angles = [];
                var data = this.data.dataPoints;
                if (data.length === 0) {
                    this.interactivityState.valueToAngleFactor = 0;
                    this.interactivityState.sliceAngles = [];
                    return;
                }
                var sum = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    sum += data[i].data.percentage;
                }
                debug.assert(sum !== 0, "sum of slices values cannot be zero");
                this.interactivityState.valueToAngleFactor = 360 / sum;
                var currentAngle = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    currentAngle += relativeAngle;
                    angles.push(relativeAngle / 2 - currentAngle);
                }
                this.interactivityState.sliceAngles = angles;
            };
            DonutChart.prototype.assignInteractions = function(slices, highlightSlices, data) {
                if (this.isInteractive) {
                    this.assignInteractiveChartInteractions(slices);
                } else if (this.interactivityService) {
                    var behaviorOptions = {
                        clearCatcher: this.clearCatcher,
                        datapoints: data.dataPoints.map(function(value) {
                            return value.data;
                        }),
                        slices: slices,
                        highlightSlices: highlightSlices,
                        allowDrilldown: this.allowDrilldown,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        svg: this.svg
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
            };
            DonutChart.prototype.setDrilldown = function(selection) {
                if (selection) {
                    var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                        return d.percentage;
                    });
                    var legendDataPoints = [ {
                        label: selection.label,
                        color: selection.color,
                        icon: 0,
                        identity: selection.identity,
                        selected: selection.selected
                    } ];
                    var legendData = {
                        title: "",
                        dataPoints: legendDataPoints
                    };
                    var drilledDataPoints = d3PieLayout(selection.internalDataPoints);
                    this.updateInternal({
                        dataPointsToDeprecate: selection.internalDataPoints,
                        dataPoints: drilledDataPoints,
                        unCulledDataPoints: drilledDataPoints,
                        legendData: legendData,
                        hasHighlights: false,
                        dataLabelsSettings: this.data.dataLabelsSettings
                    }, DonutChart.UpdateAnimationDuration);
                } else {
                    this.updateInternal(this.data, DonutChart.UpdateAnimationDuration);
                }
            };
            DonutChart.prototype.assignInteractiveChartInteractions = function(slice) {
                var _this = this;
                var svg = this.svg;
                this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                var svgRect = svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = {
                    x: svgRect.left + svgRect.width / 2,
                    y: svgRect.top + svgRect.height / 2
                };
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.currentRotate = 0;
                this.calculateSliceAngles();
                slice.on("click", function(d, clickedIndex) {
                    if (d3.event.defaultPrevented) return;
                    _this.setInteractiveChosenSlice(clickedIndex);
                });
                var drag = d3.behavior.drag().origin(Object).on("dragstart", function() {
                    return _this.interactiveDragStart();
                }).on("drag", function() {
                    return _this.interactiveDragMove();
                }).on("dragend", function() {
                    return _this.interactiveDragEnd();
                });
                svg.call(drag);
            };
            DonutChart.prototype.getAngleFromDragEvent = function() {
                var interactivityState = this.interactivityState;
                var pageX, pageY;
                var sourceEvent = d3.event.sourceEvent;
                if (sourceEvent.type.toLowerCase().indexOf("touch") !== -1) {
                    if (sourceEvent.touches.length !== 1) return null;
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX;
                    pageY = touch.pageY;
                } else {
                    pageX = sourceEvent.pageX;
                    pageY = sourceEvent.pageY;
                }
                var adjustedCoordinates = {
                    x: pageX - interactivityState.donutCenter.x,
                    y: -pageY + interactivityState.donutCenter.y
                };
                var angleToThePlane = Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) * 180 / Math.PI;
                return angleToThePlane;
            };
            DonutChart.prototype.interactiveDragStart = function() {
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            };
            DonutChart.prototype.interactiveDragMove = function() {
                var data = this.data.dataPoints;
                var viewport = this.currentViewport;
                var interactivityState = this.interactivityState;
                if (interactivityState.interactiveChosenSliceFinishedSetting === true) {
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle) return;
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff;
                    interactivityState.previousDragAngle = currentDragAngle;
                    interactivityState.currentRotate += angleDragDiff;
                    this.svg.select("g").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor;
                    var currentAngle = interactivityState.currentRotate <= 0 ? interactivityState.currentRotate * -1 % 360 : 360 - interactivityState.currentRotate % 360;
                    interactivityState.currentIndexDrag = 0;
                    var dataLength = data.length;
                    while (interactivityState.currentIndexDrag < dataLength && currentAngle > currentHigherLimit) {
                        if (interactivityState.currentIndexDrag < dataLength - 1) {
                            currentHigherLimit += data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor;
                        }
                        interactivityState.currentIndexDrag++;
                    }
                    if (interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag) {
                        interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag);
                        this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                        });
                        interactivityState.previousIndexDrag = interactivityState.currentIndexDrag;
                    }
                }
            };
            DonutChart.prototype.interactiveDragEnd = function() {
                if (this.interactivityState.totalDragAngleDifference !== 0) {
                    this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag);
                    d3.event.sourceEvent.stopPropagation();
                }
            };
            DonutChart.prototype.addSliceLabels = function(data, was, is, duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                var svg = this.svg;
                var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
                var key = this.key;
                var arc = this.arc;
                var outerArc = this.outerArc;
                var radius = this.radius;
                var formatter = this.formatter;
                var viewport = this.currentViewport;
                var sliceWidthRatio = this.sliceWidthRatio;
                var innerLinePointMultiplier = sliceWidthRatio ? 2.05 / (2 * (sliceWidthRatio + (1 - sliceWidthRatio) / 2)) : 2.05;
                var text = svg.select(".labels").selectAll("text").data(d3PieLayout(was), key);
                var ellipsisService = powerbi.TextMeasurementService.svgEllipsis;
                var spaceAvaliableForLabels = viewport.width / 2 - radius;
                var previousPosition;
                var previousTextAnchor;
                var fontSize = viewport.height < DonutChart.FontsizeThreshold ? DonutChart.SmallFontSize : DonutChart.NormalFontSize;
                text.enter().append("text").attr("dy", ".35em").style("opacity", 0).each(function(d) {
                    this._current = d;
                });
                text = svg.select(".labels").selectAll("text").data(d3PieLayout(is), key);
                text.text(function(d) {
                    return formatter(d.data.label);
                }).style("font-size", fontSize).each(function(d) {
                    var text = d3.select(this);
                    ellipsisService(text[0][0], spaceAvaliableForLabels);
                }).transition().duration(duration).attrTween("transform", function(d) {
                    var _this = this;
                    var interpolate = d3.interpolate(this._current, d);
                    return function(t) {
                        var d2 = interpolate(t);
                        _this._current = d2;
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (DonutChart.midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate(" + pos + ")";
                    };
                }).styleTween("text-anchor", function(d) {
                    var interpolate = d3.interpolate(this._current, d);
                    return function(t) {
                        var d2 = interpolate(t);
                        return DonutChart.midAngle(d2) < Math.PI ? "start" : "end";
                    };
                }).each("end", function(d) {
                    var opacity = 1;
                    var text = d3.select(this);
                    var transform = visuals.SVGUtil.parseTranslateTransform(text.attr("transform"));
                    var currentPosition = parseFloat(transform.y);
                    var currentTextAnchor = text.style("text-anchor");
                    d.data.isLabelOverlapping = false;
                    if (currentTextAnchor === previousTextAnchor) {
                        var deltaY = currentPosition - previousPosition;
                        if (Math.abs(deltaY) < parseInt(fontSize, 10)) {
                            opacity = 0;
                            d.data.isLabelOverlapping = true;
                        }
                    }
                    if (opacity === 1) previousPosition = currentPosition;
                    previousTextAnchor = currentTextAnchor;
                    text.style("opacity", opacity);
                });
                text = svg.select(".labels").selectAll("text").data(data, key);
                text.exit().transition().delay(duration).remove();
                var polyline = svg.select(".lines").selectAll("polyline").data(d3PieLayout(was), key);
                polyline.enter().append("polyline").style("opacity", 0).each(function(d) {
                    this._current = d;
                });
                polyline = svg.select(".lines").selectAll("polyline").data(d3PieLayout(is), key);
                polyline.transition().duration(duration).attrTween("points", function(d) {
                    var _this = this;
                    this._current = this._current;
                    var interpolate = d3.interpolate(this._current, d);
                    return function(t) {
                        var d2 = interpolate(t);
                        _this._current = d2;
                        var textPoint = outerArc.centroid(d2);
                        textPoint[0] = radius * .95 * (DonutChart.midAngle(d2) < Math.PI ? 1 : -1);
                        var midPoint = outerArc.centroid(d2);
                        var chartPoint = arc.centroid(d2);
                        chartPoint[0] *= innerLinePointMultiplier;
                        chartPoint[1] *= innerLinePointMultiplier;
                        return [ chartPoint, midPoint, textPoint ];
                    };
                }).each("end", function() {
                    polyline.style("opacity", function(d) {
                        return d.data.isLabelOverlapping ? 0 : DonutChart.PolylineOpacity;
                    });
                });
                polyline = svg.select(".lines").selectAll("polyline").data(data, key);
                polyline.exit().transition().delay(duration).remove();
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.midAngle = function(d) {
                return d.startAngle + (d.endAngle - d.startAngle) / 2;
            };
            DonutChart.prototype.accept = function(visitor, options) {
                visitor.visitDonutChart(options);
            };
            DonutChart.prototype.updateInternalToMove = function(data, duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                var svg = this.svg;
                var pie = this.pie;
                var key = this.key;
                var arc = this.arc;
                var radius = this.radius;
                var previousRadius = this.previousRadius;
                var sliceWidthRatio = this.sliceWidthRatio;
                var existingData = this.svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data().map(function(d) {
                    return d.data;
                });
                if (existingData.length === 0) {
                    existingData = data.dataPointsToDeprecate;
                }
                var was = this.mergeDatasets(data.dataPointsToDeprecate, existingData);
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate);
                var slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.enter().insert("path").classed(DonutChart.sliceClass.class, true).each(function(d) {
                    this._current = d;
                });
                slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(is), key);
                var innerRadius = radius * sliceWidthRatio;
                slice.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, data.hasHighlights);
                }).style("stroke", "white").transition().duration(duration).attrTween("d", function(d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                    this._current = i(0);
                    return function(t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                });
                slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.exit().transition().delay(duration).duration(0).remove();
                if (!this.isInteractive) this.addSliceLabels(pie(data.dataPointsToDeprecate), was, is, duration);
                if (data.hasHighlights) {
                    var highlightSlices = svg.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(pie(data.dataPointsToDeprecate), key);
                    highlightSlices.enter().insert("path").classed(DonutChart.sliceHighlightClass.class, true).each(function(d) {
                        this._current = d;
                    });
                    highlightSlices.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", 1).style("stroke", "white").transition().duration(duration).attrTween("d", function(d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                        this._current = i(0);
                        return function(t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    });
                    highlightSlices.exit().transition().delay(duration).duration(0).remove();
                } else {
                    svg.selectAll("path" + DonutChart.sliceHighlightClass.selector).transition().delay(duration).duration(0).remove();
                }
                this.assignInteractions(slice, highlightSlices, data);
                visuals.TooltipManager.addTooltip(slice, function(tooltipEvent) {
                    return tooltipEvent.data.data.tooltipInfo;
                });
                if (data.hasHighlights) {
                    visuals.TooltipManager.addTooltip(highlightSlices, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                if (this.isInteractive) {
                    this.addInteractiveLegendArrow();
                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate);
                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0);
                }
            };
            DonutChart.drawDefaultShapes = function(graphicsContext, donutData, layout, colors, radius, defaultColor) {
                var hasSelection = visuals.dataHasSelection(donutData.dataPoints.map(function(d) {
                    return d.data;
                }));
                var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(donutData.dataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                shapes.enter().insert("path").classed(DonutChart.sliceClass.class, true);
                shapes.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, donutData.hasHighlights);
                }).attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            DonutChart.drawDefaultHighlightShapes = function(graphicsContext, donutData, layout, colors, radius) {
                var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(donutData.dataPoints.filter(function(value) {
                    return value.data.highlightRatio != null;
                }), function(d) {
                    return d.data.identity.getKey();
                });
                shapes.enter().insert("path").classed(DonutChart.sliceHighlightClass.class, true).each(function(d) {
                    this._current = d;
                });
                shapes.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, donutData.hasHighlights);
                }).style("stroke", "white").attr(layout.highlightShapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            DonutChart.drawDefaultCategoryLabels = function(graphicsContext, donutData, layout, sliceWidthRatio, radius, viewport) {
                var arc = d3.svg.arc().innerRadius(0).outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                var outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                var dataPointsWithLabels = donutData.suppressLabels || !donutData.dataLabelsSettings.show && !donutData.dataLabelsSettings.showCategory ? [] : _.filter(donutData.dataPoints, function(d) {
                    return d.data.label != null && !d.data.isLabelOverlapping;
                });
                DonutChart.drawDefaultCategoryLabelText(graphicsContext, dataPointsWithLabels, layout, radius, viewport, outerArc);
                DonutChart.drawDefaultCategoryLabelLines(graphicsContext, dataPointsWithLabels, radius, sliceWidthRatio, arc, outerArc);
            };
            DonutChart.drawDefaultCategoryLabelText = function(graphicsContext, donutDataPoints, layout, radius, viewport, outerArc) {
                var formatter = visuals.valueFormatter.format;
                var text = graphicsContext.select(".labels").selectAll("text").data(donutDataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                var spaceAvaliableForLabels = viewport.width / 2 - radius;
                text.enter().append("text").attr("dy", ".35em").each(function(d) {
                    this._current = d;
                });
                text.text(function(d) {
                    return formatter(d.data.label);
                }).style({
                    "font-size": layout.fontSize,
                    "text-anchor": function(d) {
                        return DonutChart.midAngle(d) < Math.PI ? "start" : "end";
                    },
                    fill: function(d) {
                        return d.data.labelColor;
                    },
                    opacity: 1
                }).each(function(d) {
                    var text = d3.select(this);
                    text[0][0].textContent = visuals.dataLabelUtils.getLabelFormattedText(text[0][0].textContent, spaceAvaliableForLabels);
                }).attr("transform", function(d) {
                    this._current = d;
                    var pos = outerArc.centroid(d);
                    pos[0] = radius * (DonutChart.midAngle(d) < Math.PI ? 1 : -1);
                    return "translate(" + pos + ")";
                }).each(layout.categoryLabelTextOverlap);
                text.exit().remove();
                return text;
            };
            DonutChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            DonutChart.drawDefaultCategoryLabelLines = function(graphicsContext, donutDataPoints, radius, sliceWidthRatio, arc, outerArc) {
                var lines = graphicsContext.select(".lines").selectAll("polyline").data(donutDataPoints, function(d) {
                    return d.data.identity.getKey();
                });
                var innerLinePointMultiplier = 2.05;
                lines.enter().append("polyline").each(function(d) {
                    this._current = d;
                });
                lines.attr("points", function(d) {
                    var textPoint = outerArc.centroid(d);
                    textPoint[0] = radius * .95 * (DonutChart.midAngle(d) < Math.PI ? 1 : -1);
                    var midPoint = outerArc.centroid(d);
                    var chartPoint = arc.centroid(d);
                    chartPoint[0] *= innerLinePointMultiplier;
                    chartPoint[1] *= innerLinePointMultiplier;
                    return [ chartPoint, midPoint, textPoint ];
                }).style({
                    opacity: function(d) {
                        return d.data.isLabelOverlapping ? 0 : DonutChart.PolylineOpacity;
                    },
                    stroke: function(d) {
                        return d.data.labelColor;
                    }
                });
                lines.exit().remove();
                return lines;
            };
            DonutChart.getLayout = function(radius, sliceWidthRatio, viewport) {
                var innerRadius = radius * sliceWidthRatio;
                var arc = d3.svg.arc().innerRadius(innerRadius);
                var arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                var previousPosition;
                var previousTextAnchor;
                var fontSize = viewport.height < DonutChart.FontsizeThreshold ? DonutChart.SmallFontSize : DonutChart.NormalFontSize;
                return {
                    fontSize: fontSize,
                    shapeLayout: {
                        d: function(d) {
                            return arcWithRadius(d);
                        }
                    },
                    highlightShapeLayout: {
                        d: function(d) {
                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                            return highlightArc(d);
                        }
                    },
                    zeroShapeLayout: {
                        d: function(d) {
                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                            return zeroWithZeroRadius(d);
                        }
                    },
                    categoryLabelTextOverlap: function(d) {
                        var opacity = 1;
                        var text = d3.select(this);
                        var transform = visuals.SVGUtil.parseTranslateTransform(text.attr("transform"));
                        var currentPosition = parseFloat(transform.y);
                        var currentTextAnchor = text.style("text-anchor");
                        d.data.isLabelOverlapping = false;
                        if (currentTextAnchor === previousTextAnchor) {
                            var deltaY = currentPosition - previousPosition;
                            if (Math.abs(deltaY) < parseInt(fontSize, 10)) {
                                opacity = 0;
                                d.data.isLabelOverlapping = true;
                            }
                        }
                        if (opacity === 1) previousPosition = currentPosition; else text.style("opacity", opacity);
                        previousTextAnchor = currentTextAnchor;
                    }
                };
            };
            DonutChart.getHighlightRadius = function(radius, sliceWidthRatio, highlightRatio) {
                var innerRadius = radius * sliceWidthRatio;
                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
            };
            DonutChart.cullDataByViewport = function(data, viewport) {
                var dataPoints = data.unCulledDataPoints;
                var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
                var invisibleAngle = this.invisibleArcLengthInPixels / estimatedRadius;
                var minimumAngle = this.minimumArcLengthInPixels / estimatedRadius;
                var minimumValueCutoff = data.maxValue * .01;
                var culledDataPoints = [];
                var visibleGeometryCulled = false;
                for (var i = 0, ilen = dataPoints.length; i < ilen; i++) {
                    var dataPoint = dataPoints[i];
                    var angleDelta = Math.abs(dataPoint.endAngle - dataPoint.startAngle);
                    if (angleDelta >= invisibleAngle) {
                        if (angleDelta >= minimumAngle || dataPoint.value > minimumValueCutoff) {
                            culledDataPoints.push(dataPoint);
                        } else {
                            visibleGeometryCulled = true;
                        }
                    }
                }
                data.visibleGeometryCulled = visibleGeometryCulled;
                return culledDataPoints;
            };
            DonutChart.ClassName = "donutChart";
            DonutChart.InteractiveLegendClassName = "donutLegend";
            DonutChart.InteractiveLegendArrowClassName = "donutLegendArrow";
            DonutChart.UpdateAnimationDuration = 1e3;
            DonutChart.OuterArcRadiusRatio = .9;
            DonutChart.InnerArcRadiusRatio = .8;
            DonutChart.FontsizeThreshold = 150;
            DonutChart.SmallFontSize = "8px";
            DonutChart.NormalFontSize = "11px";
            DonutChart.InteractiveLegendContainerHeight = 70;
            DonutChart.OpaqueOpacity = 1;
            DonutChart.SemiTransparentOpacity = .6;
            DonutChart.defaultSliceWidthRatio = .48;
            DonutChart.invisibleArcLengthInPixels = 2;
            DonutChart.minimumArcLengthInPixels = 4;
            DonutChart.sliceClass = {
                "class": "slice",
                selector: ".slice"
            };
            DonutChart.sliceHighlightClass = {
                "class": "slice-highlight",
                selector: ".slice-highlight"
            };
            DonutChart.EffectiveZeroValue = 1e-9;
            DonutChart.PolylineOpacity = .5;
            return DonutChart;
        }();
        visuals.DonutChart = DonutChart;
        var DonutChartInteractiveLegend = function() {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions) {
                this.legendContainerParent = legendContainer;
                this.colors = colors;
                this.donutChart = donutChart;
                this.visualInitOptions = visualInitOptions;
                this.legendItemsPositions = [];
                var donutChartSettings = visualInitOptions.settings;
                this.legendTransitionAnimationDuration = donutChartSettings && donutChartSettings.legendTransitionAnimationDuration ? donutChartSettings.legendTransitionAnimationDuration : 0;
            }
            DonutChartInteractiveLegend.prototype.drawLegend = function(data) {
                var _this = this;
                this.data = data;
                this.currentNumberOfLegendItems = data.length;
                this.currentIndex = 0;
                this.leftMostIndex = 0;
                this.rightMostIndex = data.length - 1;
                if (this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty()) {
                    this.legendContainer = this.legendContainerParent.append("div").classed(DonutChartInteractiveLegend.LegendContainerClassName, true);
                }
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data);
                var legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width;
                var initialXOffset = legendContainerWidth / 2 - legendContainerWidth * .4 / 2 + DonutChartInteractiveLegend.ItemMargin;
                var currX = initialXOffset;
                this.currentXOffset = initialXOffset;
                var createLegendItem = function(itemDiv, datum) {
                    itemDiv.attr("data-legend-index", datum.index).css({
                        position: "absolute",
                        left: currX
                    });
                    var itemCategory = visuals.valueFormatter.format(datum.label);
                    var itemValue = visuals.valueFormatter.format(datum.measure, datum.measureFormat);
                    var itemPercentage = visuals.valueFormatter.format(datum.percentage, "0.00 %;-0.00 %;0.00 %");
                    var itemColor = datum.color;
                    var itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11);
                    var itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11);
                    var itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20);
                    var valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan);
                    var categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan);
                    var precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan);
                    var currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                    itemDiv.css("width", currentLegendBoxWidth);
                    var getLeftValue = function(spanWidth) {
                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                    };
                    var marginLeftValue = getLeftValue(valueSpanWidth);
                    var marginLeftCategory = getLeftValue(categorySpanWidth);
                    var marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css("color", itemColor);
                    itemDiv.append(itemCategorySpan);
                    itemDiv.append(itemPercentageSpan);
                    itemDiv.append(itemValueSpan);
                    _this.legendItemsPositions.push({
                        startX: currX,
                        boxWidth: currentLegendBoxWidth
                    });
                    currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                };
                legendItems.enter().insert("div").classed(DonutChartInteractiveLegend.LegendItemClassName, true).each(function(d) {
                    createLegendItem($(this), d);
                });
                legendItems.exit().remove();
                this.assignInteractions();
            };
            DonutChartInteractiveLegend.prototype.updateLegend = function(sliceIndex) {
                var _this = this;
                if (this.currentNumberOfLegendItems <= 1) return;
                var legendContainerWidth = this.legendContainerWidth;
                this.currentIndex = sliceIndex;
                this.updateLabelBlocks(sliceIndex);
                var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration;
                var nextXOffset = (this.legendItemsPositions[sliceIndex].startX + this.legendItemsPositions[sliceIndex].boxWidth / 2 - legendContainerWidth / 2) * -1;
                this.legendContainer.transition().styleTween("-webkit-transform", function(d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                }).styleTween("transform", function(d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                }).duration(legendTransitionAnimationDuration).ease("bounce").each("end", function() {
                    _this.currentXOffset = nextXOffset;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
            };
            DonutChartInteractiveLegend.prototype.assignInteractions = function() {
                var _this = this;
                var currentDX = 0;
                var hasChanged = false;
                var dragStart = function() {
                    currentDX = 0;
                    hasChanged = false;
                };
                var dragMove = function() {
                    currentDX += d3.event.dx;
                    if (hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX) return;
                    var dragDirectionLeft = currentDX < 0;
                    _this.dragLegend(dragDirectionLeft);
                    hasChanged = true;
                };
                var drag = d3.behavior.drag().origin(Object).on("drag", dragMove).on("dragstart", dragStart);
                this.legendContainer.call(drag);
            };
            DonutChartInteractiveLegend.prototype.dragLegend = function(dragDirectionLeft) {
                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1) {
                    this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft);
                } else {
                    if (this.shouldChangeIndexInNonCycling(dragDirectionLeft)) {
                        if (dragDirectionLeft) {
                            this.currentIndex++;
                        } else {
                            this.currentIndex--;
                        }
                    }
                }
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            };
            DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function(dragDirectionLeft) {
                if (this.currentIndex === 0 && !dragDirectionLeft || this.currentIndex === this.currentNumberOfLegendItems - 1 && dragDirectionLeft) {
                    return false;
                }
                return true;
            };
            DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function(dragDirectionLeft) {
                var dataLen = this.data.length;
                var delta = dragDirectionLeft ? 1 : -1;
                var newIndex = (this.currentIndex + delta) % (dataLen || 1);
                return newIndex < 0 ? newIndex + dataLen : newIndex;
            };
            DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function(rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer[0]);
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]");
                    smallestItem.remove().insertAfter(legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]"));
                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.leftMostIndex].startX = newX;
                    smallestItem.css("left", newX);
                    this.rightMostIndex = this.leftMostIndex;
                    this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                } else {
                    var highestItem = legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]");
                    highestItem.remove().insertBefore(legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]"));
                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.rightMostIndex].startX = newX;
                    highestItem.css("left", newX);
                    this.leftMostIndex = this.rightMostIndex;
                    this.rightMostIndex = this.rightMostIndex - 1 === -1 ? this.legendItemsPositions.length - 1 : this.rightMostIndex - 1;
                }
                if (numberOfLegendItemsBlocksToShift - 1 !== 0) {
                    this.updateLegendItemsBlocks(rightSidedShift, numberOfLegendItemsBlocksToShift - 1);
                }
            };
            DonutChartInteractiveLegend.prototype.updateLabelBlocks = function(index) {
                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                    if (this.rightMostIndex === index) this.updateLegendItemsBlocks(true, 2);
                    if (this.leftMostIndex === index) this.updateLegendItemsBlocks(false, 2);
                    if (this.rightMostIndex === index + 1 || this.rightMostIndex === 0 && index === this.currentNumberOfLegendItems - 1) this.updateLegendItemsBlocks(true, 1);
                    if (this.leftMostIndex === index - 1 || this.leftMostIndex === this.currentNumberOfLegendItems - 1 && index === 0) this.updateLegendItemsBlocks(false, 1);
                } else {
                    if (this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                        if (this.rightMostIndex === index) this.updateLegendItemsBlocks(true, 1);
                        if (this.leftMostIndex === index) this.updateLegendItemsBlocks(false, 1);
                    }
                }
            };
            DonutChartInteractiveLegend.createBasicLegendItemSpan = function(spanClass, text, fontSize) {
                return $("<span/>").addClass(spanClass).css({
                    "white-space": "nowrap",
                    "font-size": fontSize + "px"
                }).text(text);
            };
            DonutChartInteractiveLegend.createLegendItemSpan = function(existingSpan, marginLeft) {
                existingSpan.css({
                    overflow: "hidden",
                    "text-overflow": "ellipsis",
                    display: "inline-block",
                    width: "100%",
                    "margin-left": marginLeft
                });
                return existingSpan;
            };
            DonutChartInteractiveLegend.legendBoxSize = function(valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth;
                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : boxSize + 2;
                return boxSize;
            };
            DonutChartInteractiveLegend.spanWidth = function(span) {
                if (!this.FakeElementSpan) {
                    this.FakeElementSpan = $("<span>").hide().appendTo(document.body);
                }
                this.FakeElementSpan.empty();
                this.FakeElementSpan.append(span);
                return this.FakeElementSpan.width();
            };
            DonutChartInteractiveLegend.LegendContainerClassName = "legend-container";
            DonutChartInteractiveLegend.LegendContainerSelector = ".legend-container";
            DonutChartInteractiveLegend.LegendItemClassName = "legend-item";
            DonutChartInteractiveLegend.LegendItemSelector = ".legend-item";
            DonutChartInteractiveLegend.LegendItemCategoryClassName = "category";
            DonutChartInteractiveLegend.LegendItemPercentageClassName = "percentage";
            DonutChartInteractiveLegend.LegendItemValueClassName = "value";
            DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160;
            DonutChartInteractiveLegend.ItemMargin = 30;
            DonutChartInteractiveLegend.MinimumSwipeDX = 15;
            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3;
            return DonutChartInteractiveLegend;
        }();
        var DonutChartConversion;
        (function(DonutChartConversion) {
            var DonutChartConverter = function() {
                function DonutChartConverter(dataView, colors) {
                    var dataViewCategorical = dataView.categorical;
                    this.dataViewCategorical = dataViewCategorical;
                    this.dataViewMetadata = dataView.metadata;
                    this.seriesCount = dataViewCategorical.values ? dataViewCategorical.values.length : 0;
                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill);
                    this.maxValue = 0;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var category = dataViewCategorical.categories[0];
                        this.categoryIdentities = category.identity;
                        this.categoryValues = category.values;
                        this.allCategoryObjects = category.objects;
                        this.categoryColumnRef = category.identityFields;
                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                    }
                    var grouped = this.grouped = dataViewCategorical && dataViewCategorical.values ? dataViewCategorical.values.grouped() : undefined;
                    this.isMultiMeasure = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    this.isSingleMeasure = grouped && grouped.length === 1 && grouped[0].values && grouped[0].values.length === 1;
                    this.hasHighlights = this.seriesCount > 0 && !!dataViewCategorical.values[0].highlights;
                    this.highlightsOverflow = false;
                    this.total = 0;
                    this.highlightTotal = 0;
                    this.dataPoints = [];
                    this.legendDataPoints = [];
                    this.dataLabelsSettings = null;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        for (var measureIndex = 0; measureIndex < seriesData.values.length; measureIndex++) {
                            this.total += Math.abs(seriesData.values[measureIndex]);
                            this.highlightTotal += this.hasHighlights ? Math.abs(seriesData.highlights[measureIndex]) : 0;
                        }
                    }
                }
                DonutChartConverter.prototype.convert = function() {
                    var convertedData;
                    if (this.total !== 0) {
                        if (this.categoryValues) {
                            convertedData = this.convertCategoricalWithSlicing();
                        } else {
                            if (this.isSingleMeasure || this.isMultiMeasure) {
                                convertedData = this.convertMeasures();
                            } else {
                                convertedData = this.convertSeries();
                            }
                        }
                    } else {
                        convertedData = [];
                    }
                    var highlightsOverflow = false;
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount && !highlightsOverflow; i++) {
                        var point = convertedData[i];
                        if (Math.abs(point.highlight.measure) > Math.abs(point.nonHighlight.measure)) {
                            highlightsOverflow = true;
                        }
                    }
                    this.dataLabelsSettings = this.convertDataLableSettings();
                    var dataViewMetadata = this.dataViewMetadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            this.legendObjectProperties = objects["legend"];
                        }
                    }
                    this.dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var formatter = visuals.valueFormatter.create(visuals.dataLabelUtils.getLabelFormatterOptions(this.dataLabelsSettings));
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
                        var point = convertedData[i];
                        var measure = point.nonHighlight.measure;
                        var percentage = this.total > 0 ? point.nonHighlight.value / this.total : 0;
                        var highlightRatio = 0;
                        if (point.nonHighlight.value > this.maxValue) this.maxValue = point.nonHighlight.value;
                        if (point.highlight.value > this.maxValue) this.maxValue = point.nonHighlight.value;
                        if (this.hasHighlights) {
                            if (highlightsOverflow) {
                                measure = point.highlight.measure;
                                percentage = this.highlightTotal > 0 ? point.highlight.value / this.highlightTotal : 0;
                                highlightRatio = 1;
                            } else {
                                highlightRatio = point.highlight.value / point.nonHighlight.value;
                            }
                            if (!highlightRatio) {
                                highlightRatio = DonutChart.EffectiveZeroValue;
                            }
                        }
                        var formattedMeasure = formatter.format(measure);
                        if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) point.label += " " + formattedMeasure; else point.label = this.dataLabelsSettings.show ? formattedMeasure : point.label;
                        var value = measure;
                        var categoryValue = point.categoryLabel;
                        var categorical = this.dataViewCategorical;
                        var valueIndex = categorical.categories ? null : i;
                        valueIndex = point.seriesIndex !== undefined ? point.seriesIndex : valueIndex;
                        var highlightedValue = this.hasHighlights && point.highlight.value !== 0 ? point.highlight.measure : undefined;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, valueIndex, highlightedValue);
                        this.dataPoints.push({
                            identity: point.identity,
                            measure: measure,
                            measureFormat: point.measureFormat,
                            percentage: percentage,
                            index: point.index,
                            label: point.label,
                            highlightRatio: highlightRatio,
                            selected: false,
                            tooltipInfo: tooltipInfo,
                            color: point.color,
                            labelColor: this.dataLabelsSettings.labelColor
                        });
                    }
                    this.legendData = {
                        title: this.getLegendTitle(),
                        dataPoints: this.legendDataPoints
                    };
                };
                DonutChartConverter.prototype.getLegendTitle = function() {
                    if (this.total !== 0) {
                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source ? this.dataViewCategorical.values.source.displayName : "";
                        var dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source ? this.dataViewCategorical.categories[0].source.displayName : "";
                        if (this.categoryValues) {
                            return dvCategorySourceName;
                        } else {
                            return dvValuesSourceName;
                        }
                    } else {
                        return "";
                    }
                };
                DonutChartConverter.prototype.convertCategoricalWithSlicing = function() {
                    var dataViewCategorical = this.dataViewCategorical;
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var dataPoints = [];
                    for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                        var categoryValue = this.categoryValues[categoryIndex];
                        var thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : undefined;
                        var legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]);
                        var color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue);
                        var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                        for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var seriesData = dataViewCategorical.values[seriesIndex];
                            var label = this.isSingleMeasure ? categoryLabel : visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                            var nonHighlight = seriesData.values[categoryIndex] || 0;
                            var highlight = this.hasHighlights ? seriesData.highlights[categoryIndex] || 0 : 0;
                            var identity = this.isMultiMeasure ? visuals.SelectionId.createWithIdAndMeasure(this.categoryIdentities[categoryIndex], seriesData.source.queryName) : visuals.SelectionId.createWithIds(this.categoryIdentities[categoryIndex], seriesData.identity);
                            var dataPoint = {
                                identity: identity,
                                measureFormat: visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true),
                                nonHighlight: {
                                    measure: nonHighlight,
                                    value: Math.abs(nonHighlight)
                                },
                                highlight: {
                                    measure: highlight,
                                    value: Math.abs(highlight)
                                },
                                index: categoryIndex,
                                label: label,
                                categoryLabel: categoryLabel,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint);
                        }
                        this.legendDataPoints.push({
                            label: categoryLabel,
                            color: color,
                            icon: 0,
                            identity: legendIdentity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertMeasures = function() {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                        var measureData = dataViewCategorical.values[measureIndex];
                        var measureFormat = visuals.valueFormatter.getFormatString(measureData.source, formatStringProp, true);
                        var measureLabel = measureData.source.displayName;
                        var identity = visuals.SelectionId.createWithMeasure(measureData.source.queryName);
                        debug.assert(measureData.values.length > 0, "measure should have data points");
                        debug.assert(!this.hasHighlights || measureData.highlights.length > 0, "measure with highlights should have highlight data points");
                        var nonHighlight = measureData.values[0] || 0;
                        var highlight = this.hasHighlights ? measureData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForMeasure(measureData.source.objects, measureData.source.queryName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: measureFormat,
                            nonHighlight: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight)
                            },
                            highlight: {
                                measure: highlight,
                                value: Math.abs(highlight)
                            },
                            index: measureIndex,
                            label: measureLabel,
                            categoryLabel: measureLabel,
                            color: color
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: 0,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertSeries = function() {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        var seriesFormat = visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true);
                        var label = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                        var identity = visuals.SelectionId.createWithId(seriesData.identity);
                        var seriesName = visuals.converterHelper.getSeriesName(seriesData.source);
                        var seriesObjects = seriesData.objects && seriesData.objects[0];
                        debug.assert(seriesData.values.length > 0, "measure should have data points");
                        debug.assert(!this.hasHighlights || seriesData.highlights.length > 0, "measure with highlights should have highlight data points");
                        var nonHighlight = seriesData.values[0] || 0;
                        var highlight = this.hasHighlights ? seriesData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForSeriesValue(seriesObjects, dataViewCategorical.values.identityFields, seriesName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: seriesFormat,
                            nonHighlight: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight)
                            },
                            highlight: {
                                measure: highlight,
                                value: Math.abs(highlight)
                            },
                            index: seriesIndex,
                            label: label,
                            categoryLabel: label,
                            color: color,
                            seriesIndex: seriesIndex
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: 0,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertDataLableSettings = function() {
                    var dataViewMetadata = this.dataViewMetadata;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var labelsObj = objects["labels"];
                            if (labelsObj) {
                                if (labelsObj.show !== undefined) dataLabelsSettings.show = labelsObj.show;
                                if (labelsObj.color !== undefined) {
                                    dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                                    dataLabelsSettings.overrideDefaultColor = true;
                                }
                                if (labelsObj.labelDisplayUnits !== undefined) {
                                    dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                                }
                                if (labelsObj.labelPrecision !== undefined) {
                                    dataLabelsSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : 0;
                                }
                            }
                            dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataViewMetadata.columns);
                            var categoryLabelsObject = objects["categoryLabels"];
                            if (categoryLabelsObject) {
                                var category = categoryLabelsObject["show"];
                                if (category !== undefined) dataLabelsSettings.showCategory = category;
                            }
                        }
                    }
                    return dataLabelsSettings;
                };
                return DonutChartConverter;
            }();
            DonutChartConversion.DonutChartConverter = DonutChartConverter;
        })(DonutChartConversion || (DonutChartConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.filledMapCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                preferredTypes: [ {
                    geography: {
                        address: true
                    }
                }, {
                    geography: {
                        city: true
                    }
                }, {
                    geography: {
                        continent: true
                    }
                }, {
                    geography: {
                        country: true
                    }
                }, {
                    geography: {
                        county: true
                    }
                }, {
                    geography: {
                        place: true
                    }
                }, {
                    geography: {
                        postalCode: true
                    }
                }, {
                    geography: {
                        region: true
                    }
                }, {
                    geography: {
                        stateOrProvince: true
                    }
                } ]
            }, {
                name: "Series",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
            }, {
                name: "Size",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: true
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Size",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "Size"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.funnelChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
            }, {
                name: "Y",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            }, {
                name: "Gradient",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
            } ],
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 0
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 0
                    },
                    Y: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 1
                        }
                    }
                }
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        labelPosition: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Position"),
                            type: {
                                formatting: {
                                    labelPosition: true
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: true
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            type: {
                                numeric: true
                            }
                        }
                    }
                }
            },
            supportsHighlight: true,
            sorting: {
                "default": {}
            }
        };
        visuals.funnelChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var FunnelChart = function() {
            function FunnelChart(options) {
                this.labelPositionObjects = [ powerbi.labelPosition.outsideEnd, powerbi.labelPosition.insideCenter ];
                if (options && options.animator) {
                    this.animator = options.animator;
                }
            }
            FunnelChart.converter = function(dataView, colors, defaultDataPointColor) {
                var slices = [];
                var formatStringProp = visuals.funnelChartProps.general.formatString;
                var valueMetaData = dataView.metadata ? dataView.metadata.columns.filter(function(d) {
                    return d.isMeasure;
                }) : [];
                var categories = dataView.categorical.categories || [];
                var values = dataView.categorical.values;
                var hasHighlights = values && values[0] && !!values[0].highlights;
                var highlightsOverflow = false;
                var categorical = dataView.categorical;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultFunnelLabelSettings(defaultDataPointColor);
                var colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor);
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects["labels"];
                    if (labelsObj) {
                        dataLabelsSettings.show = labelsObj.show !== undefined ? labelsObj.show : dataLabelsSettings.show;
                        dataLabelsSettings.position = labelsObj.labelPosition !== undefined ? labelsObj.labelPosition : dataLabelsSettings.position;
                        if (labelsObj.color !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            dataLabelsSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : 0;
                        }
                    }
                    dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                }
                if (categories.length === 1 && categories[0].values.length > 1 && values) {
                    var category = categories[0];
                    var categoryValues = category.values;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);
                    for (var i = 0, ilen = categoryValues.length; i < ilen; i++) {
                        var measureName = values[0].source.queryName;
                        var identity = category.identity ? visuals.SelectionId.createWithIdAndMeasure(category.identity[i], measureName) : visuals.SelectionId.createWithMeasure(measureName);
                        var value = d3.sum(values.map(function(d) {
                            return d.values[i];
                        }));
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0);
                        if (hasHighlights) {
                            var highlight = d3.sum(values.map(function(d) {
                                return d.highlights[i];
                            }));
                            if (highlight !== 0) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0, highlight);
                            }
                        }
                        var color = colorHelper.getColorForMeasure(category.objects && category.objects[i], "");
                        slices.push({
                            label: formattedCategoryValue,
                            value: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = d3.sum(values.map(function(d) {
                                return d.highlights[i];
                            }));
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, formattedCategoryValue, categorical.values, value, null, 0, highlightedValue);
                            slices.push({
                                label: formattedCategoryValue,
                                value: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                selected: false,
                                key: highlightIdentity.getKey(),
                                highlight: true,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo,
                                color: color
                            });
                        }
                    }
                } else if (valueMetaData.length > 0 && values) {
                    for (var i = 0, len = values.length; i < len; i++) {
                        var valueColumn = values[i];
                        var value = d3.sum(valueColumn.values);
                        var identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName);
                        var categoryValue = valueMetaData[i].displayName;
                        var valueIndex = categorical.categories ? null : i;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, valueIndex);
                        var color = colorHelper.getColorForMeasure(valueColumn.source.objects, "");
                        if (hasHighlights) {
                            var highlight = d3.sum(values.map(function(d) {
                                return d.highlights[i];
                            }));
                            if (highlight !== 0) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlight);
                            }
                        }
                        slices.push({
                            label: valueMetaData[i].displayName,
                            value: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = d3.sum(values[i].highlights);
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlightedValue);
                            slices.push({
                                label: valueMetaData[i].displayName,
                                value: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: false,
                                highlight: true,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo,
                                color: color
                            });
                        }
                    }
                }
                return {
                    slices: slices,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    dataLabelsSettings: dataLabelsSettings
                };
            };
            FunnelChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "dataPoint":
                    var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                    var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                    if (!hasGradientRole) {
                        return this.enumerateDataPoints();
                    }
                    break;

                  case "labels":
                    return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, true, true, true, this.labelPositionObjects);
                }
            };
            FunnelChart.prototype.enumerateDataPoints = function() {
                var data = this.data;
                if (!data) return;
                var instances = [];
                var slices = data.slices;
                instances.push({
                    objectName: "dataPoint",
                    selector: null,
                    properties: {
                        defaultColor: {
                            solid: {
                                color: this.defaultDataPointColor || this.colors.getColor(0).value
                            }
                        }
                    }
                });
                for (var i = 0; i < slices.length; i++) {
                    var slice = slices[i];
                    if (slice.highlight) continue;
                    var color = slice.color;
                    var selector = slice.identity.getSelector();
                    var isSingleSeries = !!selector.data;
                    var dataPointInstance = {
                        objectName: "dataPoint",
                        displayName: slice.label,
                        selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                        properties: {
                            fill: {
                                solid: {
                                    color: color
                                }
                            }
                        }
                    };
                    instances.push(dataPointInstance);
                }
                return instances;
            };
            FunnelChart.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0)).append("svg").classed(FunnelChart.VisualClassName, true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.currentViewport = options.viewport;
                this.margin = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                var style = options.style;
                this.colors = style.colorPalette.dataColors;
                this.hostServices = options.host;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.funnelGraphicsContext = svg.append("g");
                this.axisGraphicsContext = svg.append("g");
                var lgc = this.labelGraphicsContext = svg.append("g");
                lgc.classed(FunnelChart.InnerTextGroupClassName, true);
                this.updateViewportProperties();
            };
            FunnelChart.prototype.updateViewportProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            };
            FunnelChart.prototype.update = function(options) {
                debug.assertValue(options, "options");
                this.data = {
                    slices: [],
                    valuesMetadata: [],
                    hasHighlights: false,
                    highlightsOverflow: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultFunnelLabelSettings()
                };
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                        if (defaultColor) this.defaultDataPointColor = defaultColor;
                    }
                    if (dataView.categorical) {
                        this.data = FunnelChart.converter(dataView, this.colors, this.defaultDataPointColor);
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.slices);
                        }
                    }
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0) this.hostServices.setWarnings(warnings);
                }
                this.updateViewportProperties();
                this.updateInternal(true);
            };
            FunnelChart.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || 0,
                    viewport: this.currentViewport
                });
            };
            FunnelChart.prototype.onResizing = function(viewport, duration) {
                this.currentViewport = viewport;
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewport: this.currentViewport
                });
            };
            FunnelChart.prototype.getMaxLeftMargin = function(labels, properties) {
                var max = 0;
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                for (var i = 0, len = labels.length; i < len; i++) {
                    properties.text = labels[i];
                    max = Math.max(max, textMeasurer(properties));
                }
                return max + FunnelChart.LabelFunnelPadding;
            };
            FunnelChart.prototype.updateInternal = function(useAnimation) {
                if (this.data == null) return;
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function(d) {
                    return !d.highlight;
                });
                var axisOptions = this.setUpAxis();
                var margin = axisOptions.margin;
                var verticalRange = axisOptions.verticalRange;
                var funnelContext = this.funnelGraphicsContext.attr("transform", visuals.SVGUtil.translateAndRotate(margin.left, margin.top, verticalRange / 2, verticalRange / 2, 90));
                this.svg.style("font-size", FunnelChart.StandardTextProperties.fontSize);
                this.svg.style("font-weight", FunnelChart.StandardTextProperties.fontWeight);
                this.svg.style("font-family", FunnelChart.StandardTextProperties.fontFamily);
                var layout = FunnelChart.getLayout(data, axisOptions);
                var labelLayout = visuals.dataLabelUtils.getFunnelChartLabelLayout(data, axisOptions, FunnelChart.InnerTextHeightDelta, FunnelChart.InnerTextMinimumPadding, data.dataLabelsSettings, this.currentViewport);
                var result;
                var shapes;
                var dataLabels;
                if (this.animator) {
                    var animationOptions = {
                        viewModel: data,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        axisGraphicsContext: this.axisGraphicsContext,
                        shapeGraphicsContext: funnelContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        axisOptions: axisOptions,
                        slicesWithoutHighlights: slicesWithoutHighlights,
                        colors: this.colors,
                        labelLayout: labelLayout
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    dataLabels = result.dataLabels;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions);
                    shapes = FunnelChart.drawDefaultShapes(data, slices, funnelContext, layout, this.colors);
                    if (data.dataLabelsSettings.show && !axisOptions.hideInnerLabels) {
                        visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(slicesWithoutHighlights, this.labelGraphicsContext, labelLayout);
                    } else {
                        visuals.dataLabelUtils.cleanDataLabels(this.labelGraphicsContext);
                    }
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        datapoints: slices,
                        bars: shapes,
                        labels: dataLabels,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            FunnelChart.prototype.setUpAxis = function() {
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function(d) {
                    return !d.highlight;
                });
                var categoryLabels = slicesWithoutHighlights.map(function(d) {
                    return d.label;
                });
                var hideInnerLabels = false;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var horizontalRange = viewport.height - (margin.top + margin.bottom);
                if (categoryLabels.length > 0 && horizontalRange / categoryLabels.length < FunnelChart.MinBarThickness) {
                    categoryLabels = [];
                    hideInnerLabels = true;
                } else {
                    var textProperties = FunnelChart.StandardTextProperties;
                    margin.left = this.getMaxLeftMargin(categoryLabels, textProperties);
                }
                var verticalRange = viewport.width - (margin.left + margin.right);
                var barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                var maxScore = d3.max(slices.map(function(d) {
                    return d.value;
                }));
                var minScore = 0;
                var rangeStart = 0;
                var rangeEnd = horizontalRange;
                if (categoryLabels.length > 0 && horizontalRange / categoryLabels.length > FunnelChart.MaxBarWidth) {
                    var delta = horizontalRange - categoryLabels.length * FunnelChart.MaxBarWidth;
                    rangeStart = Math.ceil(delta / 2);
                    rangeEnd = Math.ceil(horizontalRange - delta / 2);
                    barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                }
                var yScale = d3.scale.linear().domain([ minScore, maxScore ]).range([ verticalRange, 0 ]);
                var xScale = d3.scale.ordinal().domain(d3.range(0, slicesWithoutHighlights.length)).rangeBands([ rangeStart, rangeEnd ], barToSpaceRatio);
                return {
                    margin: margin,
                    xScale: xScale,
                    yScale: yScale,
                    maxScore: maxScore,
                    verticalRange: verticalRange,
                    rangeStart: rangeStart,
                    rangeEnd: rangeEnd,
                    barToSpaceRatio: barToSpaceRatio,
                    hideInnerLabels: hideInnerLabels,
                    categoryLabels: categoryLabels
                };
            };
            FunnelChart.prototype.accept = function(visitor, options) {
                visitor.visitFunnel(options);
            };
            FunnelChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            FunnelChart.getLayout = function(data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow;
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var maxScore = axisOptions.maxScore;
                var columnWidth = xScale.rangeBand();
                var overFlowHighlightColumnWidth = columnWidth * FunnelChart.OverflowingHighlightWidthRatio;
                var overFlowHighlightOffset = overFlowHighlightColumnWidth / 2;
                return {
                    shapeLayout: {
                        width: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth;
                        },
                        height: function(d) {
                            return Math.abs(yScale(d.highlight ? d.highlightValue : d.value) - yScale(0));
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function(d) {
                            return yScale(d.highlight ? d.highlightValue : d.value) - (Math.abs(yScale(maxScore) - yScale(0)) - Math.abs(yScale(d.highlight ? d.highlightValue : d.value) - yScale(0))) / 2;
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function(d) {
                            return columnWidth;
                        },
                        height: function(d) {
                            return Math.abs(yScale(d.value) - yScale(0));
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + 0;
                        },
                        y: function(d) {
                            return yScale(d.value) - (Math.abs(yScale(maxScore) - yScale(0)) - Math.abs(yScale(d.value) - yScale(0))) / 2;
                        }
                    },
                    zeroShapeLayout: {
                        width: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth;
                        },
                        height: function(d) {
                            return 0;
                        },
                        x: function(d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function(d) {
                            return yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);
                        }
                    }
                };
            };
            FunnelChart.drawDefaultAxis = function(graphicsContext, axisOptions) {
                var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio);
                var xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(FunnelChart.TickPadding).innerTickSize(FunnelChart.InnerTickSize);
                graphicsContext.classed("axis", true).attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
            };
            FunnelChart.drawDefaultShapes = function(data, slices, graphicsContext, layout, colors) {
                var hasHighlights = data.hasHighlights;
                var columns = graphicsContext.selectAll(".funnelBar").data(slices, function(d) {
                    return d.key;
                });
                columns.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? "funnelBar highlight" : "funnelBar";
                });
                columns.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights);
                    };
                }).attr(layout.shapeLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.DefaultBarOpacity = 1;
            FunnelChart.DimmedBarOpacity = .4;
            FunnelChart.InnerTextClassName = "labelSeries";
            FunnelChart.VisualClassName = "funnelChart";
            FunnelChart.BarToSpaceRatio = .1;
            FunnelChart.MaxBarWidth = 40;
            FunnelChart.MinBarThickness = 12;
            FunnelChart.LabelFunnelPadding = 6;
            FunnelChart.InnerTextMinimumPadding = 10;
            FunnelChart.InnerTextHeightDelta = 4;
            FunnelChart.InnerTextGroupClassName = "innerTextGroup";
            FunnelChart.StandardTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: "12px"
            };
            FunnelChart.OverflowingHighlightWidthRatio = .5;
            FunnelChart.TickPadding = 0;
            FunnelChart.InnerTickSize = 0;
            return FunnelChart;
        }();
        visuals.FunnelChart = FunnelChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var RoleNames = {
            y: "Y",
            minValue: "MinValue",
            maxValue: "MaxValue",
            targetValue: "TargetValue"
        };
        var Gauge = function() {
            function Gauge(options) {
                this.lastAngle = -Math.PI / 2;
                if (options) {
                    if (options.gaugeSmallViewPortProperties) {
                        this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties;
                    }
                }
            }
            Gauge.prototype.init = function(options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.options = options;
                this.settings = Gauge.DefaultStyleProperties;
                this.targetSettings = Gauge.DefaultTargetSettings;
                this.setMargins();
                this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function(color) {
                    return color.value;
                }));
                this.hostService = options.host;
                var svg = this.svg = d3.select(this.element.get(0)).append("svg");
                svg.classed(Gauge.VisualClassName, true);
                var mainGraphicsContext = this.mainGraphicsContext = svg.append("g");
                mainGraphicsContext.attr("class", Gauge.MainGaugeGroupElementName);
                this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
                var foregroundArc = this.foregroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append("path").classed("backgroundArc", true).attr("d", backgroundArc);
                this.foregroundArcPath = mainGraphicsContext.append("path").datum({
                    endAngle: -Math.PI / 2
                }).classed("foregroundArc", true).attr("d", foregroundArc);
                var g = this.animatedNumberGrapicsContext = svg.append("g");
                this.animatedNumber = new visuals.AnimatedNumber(g);
                this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumber.svg.attr("transform", animatedNumberProperties.transformString);
                this.animatedNumber.onResizing(animatedNumberProperties.viewport, 0);
            };
            Gauge.prototype.update = function(options) {
                debug.assertValue(options, "options");
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                this.data = Gauge.converter(dataViews[0]);
                this.targetSettings = this.data.targetSettings;
                if (dataViews[0]) dataViews[0].single = {
                    value: this.data.total
                };
                this.showTargetLabel = this.targetSettings.target != null && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || !this.showMinMaxLabelsOnBottom()) && this.showSideNumbersLabelText();
                this.setMargins();
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.drawViewPort(this.gaugeVisualProperties);
                this.updateInternal(options.duration);
                this.animatedNumber.svg.attr("transform", animatedNumberProperties.transformString);
                this.animatedNumber.update({
                    viewport: animatedNumberProperties.viewport,
                    dataViews: options.dataViews,
                    duration: options.duration
                });
                var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                if (warnings && warnings.length > 0) this.hostService.setWarnings(warnings);
            };
            Gauge.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    duration: options.duration || 0,
                    viewport: this.currentViewport
                });
            };
            Gauge.prototype.onResizing = function(viewport, duration) {
                this.update({
                    dataViews: this.dataViews,
                    duration: duration,
                    viewMode: 0,
                    viewport: viewport
                });
            };
            Gauge.prototype.onStyleChanged = function(newStyle) {
                this.style = newStyle;
                this.color = d3.scale.ordinal().range(newStyle.colorPalette.dataColors.getSentimentColors().map(function(color) {
                    return color.value;
                }));
                this.updateInternal(0);
            };
            Gauge.getValidSettings = function(targetData) {
                var maxVal = targetData.max === Gauge.MAX_VALUE ? Gauge.DEFAULT_MAX : targetData.max;
                var minVal = targetData.min === Gauge.MIN_VALUE ? Gauge.DEFAULT_MIN : targetData.min;
                var targetVal = targetData.target;
                return {
                    min: minVal,
                    max: maxVal,
                    target: targetVal
                };
            };
            Gauge.getGaugeData = function(dataView) {
                var settings = {
                    max: Gauge.MAX_VALUE,
                    min: Gauge.MIN_VALUE,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length === values.length, "length");
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[RoleNames.y]) {
                                settings.total = value;
                                if (value) settings.tooltipItems.push({
                                    value: value,
                                    metadata: values[i]
                                });
                            } else if (col.roles[RoleNames.minValue]) {
                                settings.min = value;
                            } else if (col.roles[RoleNames.maxValue]) {
                                settings.max = value;
                            } else if (col.roles[RoleNames.targetValue]) {
                                settings.target = value;
                                if (value) settings.tooltipItems.push({
                                    value: value,
                                    metadata: values[i]
                                });
                            }
                        }
                    }
                }
                return settings;
            };
            Gauge.converter = function(dataView) {
                var gaugeData = Gauge.getGaugeData(dataView);
                var total = gaugeData.total;
                if (total > 0 && gaugeData.max === Gauge.MAX_VALUE) {
                    var hasPercent = false;
                    var columns = dataView.metadata.columns;
                    if (!_.isEmpty(columns)) {
                        var formatString = visuals.valueFormatter.getFormatString(dataView.metadata.columns[0], Gauge.formatStringProp, true);
                        hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent;
                    }
                    gaugeData.max = hasPercent ? Gauge.DEFAULT_MAX : total * 2;
                }
                var settings = Gauge.getValidSettings(gaugeData);
                var adjustedTotal = Math.max(total, settings.min);
                adjustedTotal = Math.min(adjustedTotal, settings.max);
                var percent = settings.min !== settings.max ? (adjustedTotal - settings.min) / (settings.max - settings.min) : 0;
                var tooltipInfo;
                if (dataView) {
                    if (gaugeData.tooltipItems.length > 0) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, null, null, gaugeData.tooltipItems, null, null);
                    } else {
                        var dataViewCat = dataView.categorical;
                        if (dataViewCat && dataViewCat.values && dataViewCat.values.length > 0) {
                            var categoryValue = dataViewCat.values[0];
                            var value = categoryValue.values[0];
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, dataViewCat.values, value, null, null, null);
                        }
                    }
                }
                return {
                    percent: percent,
                    adjustedTotal: adjustedTotal,
                    total: total,
                    metadataColumn: Gauge.getMetaDataColumn(dataView),
                    targetSettings: settings,
                    tooltipInfo: tooltipInfo
                };
            };
            Gauge.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
                return null;
            };
            Gauge.prototype.initKpiBands = function() {
                if (!this.settings.kpiBands.show) return;
                var kpiArcs = this.kpiArcs = [];
                var kpiArcPaths = this.kpiArcPaths = [];
                var mainGraphicsContext = this.mainGraphicsContext;
                for (var i = 0; i < 3; i++) {
                    var arc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(0).endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append("path").attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            };
            Gauge.prototype.updateKpiBands = function(radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (!this.settings.kpiBands.show) return;
                for (var i = 0; i < kpiAngleAttr.length; i++) {
                    this.kpiArcs[i].innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)).outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc).startAngle(kpiAngleAttr[i].start).endAngle(kpiAngleAttr[i].end);
                    this.kpiArcPaths[i].attr("fill", kpiAngleAttr[i].fill).attr("d", this.kpiArcs[i]).attr("transform", tString);
                }
            };
            Gauge.prototype.removeTargetElements = function() {
                if (this.targetLine) {
                    this.targetLine.remove();
                    this.targetText.remove();
                    this.targetConnector.remove();
                    this.targetLine = this.targetConnector = this.targetText = null;
                }
            };
            Gauge.prototype.updateTargetLine = function(radius, innerRadius, left, top) {
                var targetSettings = this.targetSettings;
                if (!this.targetLine) {
                    this.targetLine = this.mainGraphicsContext.append("line");
                }
                var angle = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min) * Math.PI;
                var outY = top - radius * Math.sin(angle);
                var outX = left - radius * Math.cos(angle);
                var inY = top - innerRadius * Math.sin(angle);
                var inX = left - innerRadius * Math.cos(angle);
                this.targetLine.attr({
                    x1: inX,
                    y1: inY,
                    x2: outX,
                    y2: outY
                });
            };
            Gauge.prototype.getAnimatedNumberProperties = function(radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4;
                var scale = 1;
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show ? Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness : 0);
                var innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle);
                var innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle);
                var innerY = top - innerRSin;
                var innerX = left - innerRCos;
                var innerY = innerY * scale;
                var innerX = innerX * scale;
                var animatedNumberWidth = innerRCos * 2;
                var properties = {
                    transformString: visuals.SVGUtil.translate(innerX, innerY),
                    viewport: {
                        height: innerRSin,
                        width: animatedNumberWidth
                    }
                };
                return properties;
            };
            Gauge.prototype.getGaugeVisualProperties = function() {
                var viewport = this.currentViewport;
                var margin = this.margin;
                var width = viewport.width - margin.right - margin.left;
                var halfWidth = width / 2;
                var height = viewport.height - margin.top - margin.bottom;
                var radius = Math.min(halfWidth, height);
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var left = margin.left + halfWidth;
                var top = radius + (height - radius) / 2 + margin.top;
                var tString = visuals.SVGUtil.translate(left, top);
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var gaugeData = {
                    radius: radius,
                    innerRadiusOfArc: innerRadiusOfArc,
                    left: left,
                    top: top,
                    height: height,
                    width: width,
                    margin: margin,
                    transformString: tString,
                    innerRadiusFactor: innerRadiusFactor
                };
                return gaugeData;
            };
            Gauge.prototype.drawViewPort = function(drawOptions) {
                debug.assertAnyValue(drawOptions, "Gauge options");
                var separation = this.settings.kpiBands.separationRadians;
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var backgroudArc = this.backgroundArc;
                var color = this.color;
                var attrs = [ {
                    fill: color(0),
                    start: -Math.PI / 2,
                    end: -Math.PI / 2 + Math.PI / 4 - separation
                }, {
                    fill: color(1),
                    start: -Math.PI / 2 + Math.PI * 1 / 4 + separation,
                    end: -Math.PI / 2 + Math.PI * 3 / 4 - separation
                }, {
                    fill: color(2),
                    start: -Math.PI / 2 + Math.PI * 3 / 4 + separation,
                    end: Math.PI / 2
                } ];
                var radius = drawOptions.radius;
                var transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
                backgroudArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
                this.backgroundArcPath.attr("d", backgroudArc).attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                foregroundArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2);
                this.foregroundArcPath.datum({
                    endAngle: this.lastAngle
                }).attr("transform", transformString).attr("d", foregroundArc);
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc;
                var left = drawOptions.left;
                var top = drawOptions.top;
                var margin = drawOptions.margin;
                var height = drawOptions.height;
                var targetSettings = this.targetSettings;
                if (!this.settings.targetLine.show || targetSettings.target == null) {
                    this.removeTargetElements();
                } else {
                    if (targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target) {
                        this.removeTargetElements();
                    } else {
                        this.updateTargetLine(radius, innerRadiusOfArc, left, top);
                        this.appendTargetTextAlongArc(radius, height, drawOptions.width, margin);
                    }
                }
                this.svg.attr("height", this.currentViewport.height).attr("width", this.currentViewport.width);
            };
            Gauge.prototype.createTicks = function(total) {
                var settings = this.settings;
                var targetSettings = this.targetSettings;
                var total = targetSettings.max - targetSettings.min;
                var numberOfLabels = settings.labels.count;
                var step = total / numberOfLabels;
                var arr = [];
                var formatter = visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp),
                    value: targetSettings.min,
                    value2: targetSettings.max,
                    formatSingleValues: true,
                    allowFormatBeautification: true
                });
                for (var i = 0; i < numberOfLabels + 1; i++) {
                    arr.push(formatter.format(targetSettings.min + i * step));
                }
                return arr;
            };
            Gauge.prototype.updateInternal = function(duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                var height = this.gaugeVisualProperties.height;
                var width = this.gaugeVisualProperties.width;
                var radius = this.gaugeVisualProperties.radius;
                var margin = this.margin;
                var data = this.data;
                var lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * data.percent;
                var ticks = this.createTicks(data.adjustedTotal);
                this.foregroundArcPath.transition().ease(this.settings.transition.ease).duration(duration).call(this.arcTween, [ lastAngle, this.foregroundArc ]);
                this.appendTextAlongArc(ticks, radius, height, width, margin);
                this.updateVisualConfigurations();
                this.updateVisualStyles();
                visuals.TooltipManager.addTooltip(this.foregroundArcPath, function(tooltipEvent) {
                    return data.tooltipInfo;
                });
            };
            Gauge.prototype.updateVisualStyles = function() {
                this.mainGraphicsContext.selectAll("text").style({
                    fill: this.style.labelText.color.value
                });
            };
            Gauge.prototype.updateVisualConfigurations = function() {
                var configOptions = this.settings;
                this.mainGraphicsContext.select("line").attr({
                    stroke: configOptions.targetLine.color,
                    "stroke-width": configOptions.targetLine.thickness
                });
                this.backgroundArcPath.style("fill", configOptions.arcColors.background);
                this.foregroundArcPath.style("fill", configOptions.arcColors.foreground);
            };
            Gauge.prototype.appendTextAlongArc = function(ticks, radius, height, width, margin) {
                this.svg.selectAll(Gauge.LabelText.selector).remove();
                var total = ticks.length;
                var divisor = total - 1;
                var top = radius + (height - radius) / 2 + margin.top;
                var showMinMaxLabelsOnBottom = this.showMinMaxLabelsOnBottom();
                var fontSize = this.style.labelText.fontSize;
                var padding = this.settings.labels.padding;
                for (var count = 0; count < total; count++) {
                    if (Math.floor(total / 2) === count) continue;
                    if (this.showSideNumbersLabelText()) {
                        var x = margin.left + width / 2 - radius * Math.cos(Math.PI * count / divisor);
                        var y = top - radius * Math.sin(Math.PI * count / divisor);
                        var anchor;
                        var onRight = count * 2 > total;
                        var onBottom = false;
                        if (showMinMaxLabelsOnBottom && (count === 0 || count === total - 1)) {
                            onBottom = true;
                            y += padding / 2;
                            anchor = onRight ? "end" : "start";
                        } else {
                            anchor = onRight ? "start" : "end";
                            x += padding * (onRight ? 1 : -1);
                        }
                        var text = this.mainGraphicsContext.append("text").attr({
                            x: x,
                            y: y,
                            dy: onBottom ? fontSize : 0,
                            "class": Gauge.LabelText.class
                        }).style({
                            "text-anchor": anchor,
                            "font-size": fontSize
                        }).text(ticks[count]);
                        if (!onBottom) this.truncateTextIfNeeded(text, x, onRight);
                    }
                }
            };
            Gauge.prototype.truncateTextIfNeeded = function(text, positionX, onRight) {
                var availableSpace = onRight ? this.currentViewport.width - positionX : positionX;
                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
            };
            Gauge.prototype.appendTargetTextAlongArc = function(radius, height, width, margin) {
                var targetSettings = this.targetSettings;
                var target = targetSettings.target;
                var tRatio = (target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                var top = radius + (height - radius) / 2 + margin.top;
                var flag = tRatio > .5;
                var padding = this.settings.labels.padding;
                var anchor = flag ? "start" : "end";
                var formatter = visuals.valueFormatter.create({
                    format: visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp),
                    value: targetSettings.min,
                    value2: targetSettings.max,
                    formatSingleValues: true,
                    allowFormatBeautification: true
                });
                var maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI;
                var finalRatio = tRatio < maxRatio || tRatio > 1 - maxRatio ? flag ? 1 - maxRatio : maxRatio : tRatio;
                var targetX = margin.left + width / 2 - (radius + padding) * Math.cos(Math.PI * finalRatio);
                var targetY = top - (radius + padding) * Math.sin(Math.PI * finalRatio);
                if (!this.targetText) {
                    this.targetText = this.mainGraphicsContext.append("text").classed(Gauge.TargetText.class, true);
                }
                this.targetText.attr({
                    x: targetX,
                    y: targetY
                }).style({
                    "text-anchor": anchor,
                    display: this.showTargetLabel ? "" : "none",
                    "font-size": this.style.labelText.fontSize
                }).text(formatter.format(target));
                this.truncateTextIfNeeded(this.targetText, targetX, flag);
                if (!this.targetConnector) {
                    this.targetConnector = this.mainGraphicsContext.append("line").classed(Gauge.TargetConnector.class, true);
                }
                if (tRatio === finalRatio) {
                    this.targetConnector.style("display", "none");
                } else {
                    this.targetConnector.attr({
                        x1: margin.left + width / 2 - radius * Math.cos(Math.PI * tRatio),
                        y1: top - radius * Math.sin(Math.PI * tRatio),
                        x2: targetX,
                        y2: targetY
                    }).style({
                        "stroke-width": this.settings.targetLine.thickness,
                        stroke: this.settings.targetLine.color,
                        display: ""
                    });
                }
            };
            Gauge.prototype.arcTween = function(transition, arr) {
                transition.attrTween("d", function(d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function(t) {
                        d.endAngle = interpolate(t);
                        return arr[1](d);
                    };
                });
            };
            Gauge.prototype.showMinMaxLabelsOnBottom = function() {
                return this.currentViewport.height > this.currentViewport.width && this.settings.labels.count <= 3;
            };
            Gauge.prototype.setMargins = function() {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                        this.margin = {
                            top: margins,
                            bottom: margins,
                            left: margins,
                            right: margins
                        };
                        return;
                    }
                }
                this.margin = {
                    top: Gauge.DefaultTopBottomMargin,
                    bottom: Gauge.DefaultTopBottomMargin,
                    left: Gauge.DefaultLeftRightMargin,
                    right: Gauge.DefaultLeftRightMargin
                };
                if (!this.showSideNumbersLabelText() || this.showMinMaxLabelsOnBottom()) {
                    var targetSettings = this.targetSettings;
                    if (this.showTargetLabel) {
                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                        if (tRatio > .5) this.margin.left = Gauge.ReducedLeftRightMargin; else this.margin.right = Gauge.ReducedLeftRightMargin;
                    } else {
                        this.margin.left = this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                }
            };
            Gauge.prototype.showSideNumbersLabelText = function() {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort) {
                        if (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Gauge.MIN_VALUE = -Infinity;
            Gauge.MAX_VALUE = +Infinity;
            Gauge.MinDistanceFromBottom = 10;
            Gauge.MinWidthForTargetLabel = 150;
            Gauge.DefaultTopBottomMargin = 20;
            Gauge.DefaultLeftRightMargin = 45;
            Gauge.ReducedLeftRightMargin = 15;
            Gauge.DEFAULT_MAX = 1;
            Gauge.DEFAULT_MIN = 0;
            Gauge.VisualClassName = "gauge";
            Gauge.DefaultStyleProperties = {
                transition: {
                    ease: "bounce"
                },
                arcColors: {
                    background: "#e9e9e9",
                    foreground: "#00B8AA"
                },
                targetLine: {
                    show: true,
                    color: "#666666",
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5
                },
                kpiBands: {
                    show: false,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                }
            };
            Gauge.DefaultTargetSettings = {
                min: 0,
                max: 1,
                target: undefined
            };
            Gauge.InnerRadiusFactor = .7;
            Gauge.KpiBandDistanceFromMainArc = 2;
            Gauge.MainGaugeGroupElementName = "mainGroup";
            Gauge.LabelText = {
                "class": "labelText",
                selector: ".labelText"
            };
            Gauge.TargetConnector = {
                "class": "targetConnector",
                selector: ".targetConnector"
            };
            Gauge.TargetText = {
                "class": "targetText",
                selector: ".targetText"
            };
            Gauge.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            Gauge.capabilities = {
                dataRoles: [ {
                    name: RoleNames.y,
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value")
                }, {
                    name: RoleNames.minValue,
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MinValue")
                }, {
                    name: RoleNames.maxValue,
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MaxValue")
                }, {
                    name: RoleNames.targetValue,
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_TargetValue")
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Y: {
                            max: 1
                        },
                        MinValue: {
                            max: 1
                        },
                        MaxValue: {
                            max: 1
                        },
                        TargetValue: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        values: {
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "MinValue"
                                }
                            }, {
                                bind: {
                                    to: "MaxValue"
                                }
                            }, {
                                bind: {
                                    to: "TargetValue"
                                }
                            } ]
                        }
                    }
                } ]
            };
            return Gauge;
        }();
        visuals.Gauge = Gauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ImageVisual = function() {
            function ImageVisual() {}
            ImageVisual.prototype.init = function(options) {
                this.element = options.element;
            };
            ImageVisual.prototype.onDataChanged = function(options) {
                this.element.empty();
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0) return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general) return;
                var div = $("<div class='imageBackground' />");
                if (objects.general.imageUrl) div.css("backgroundImage", "url(" + objects.general.imageUrl + ")");
                div.appendTo(this.element);
            };
            ImageVisual.prototype.onResizing = function(viewport, duration) {};
            ImageVisual.capabilities = {
                objects: {
                    general: {
                        properties: {
                            imageUrl: {
                                type: {
                                    misc: {
                                        imageUrl: true
                                    }
                                }
                            }
                        }
                    }
                }
            };
            return ImageVisual;
        }();
        visuals.ImageVisual = ImageVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    (function(VisualDataRoleKind) {
        VisualDataRoleKind[VisualDataRoleKind["Grouping"] = 0] = "Grouping";
        VisualDataRoleKind[VisualDataRoleKind["Measure"] = 1] = "Measure";
        VisualDataRoleKind[VisualDataRoleKind["GroupingOrMeasure"] = 2] = "GroupingOrMeasure";
    })(powerbi.VisualDataRoleKind || (powerbi.VisualDataRoleKind = {}));
    var VisualDataRoleKind = powerbi.VisualDataRoleKind;
    (function(VisualDataChangeOperationKind) {
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Create"] = 0] = "Create";
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Append"] = 1] = "Append";
    })(powerbi.VisualDataChangeOperationKind || (powerbi.VisualDataChangeOperationKind = {}));
    var VisualDataChangeOperationKind = powerbi.VisualDataChangeOperationKind;
    (function(ViewMode) {
        ViewMode[ViewMode["View"] = 0] = "View";
        ViewMode[ViewMode["Edit"] = 1] = "Edit";
    })(powerbi.ViewMode || (powerbi.ViewMode = {}));
    var ViewMode = powerbi.ViewMode;
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var SettingsUtil;
    (function(SettingsUtil) {
        function copyCommonSettings(settings) {
            return {
                DisplayUnitSystemType: settings.DisplayUnitSystemType
            };
        }
        SettingsUtil.copyCommonSettings = copyCommonSettings;
    })(SettingsUtil = powerbi.SettingsUtil || (powerbi.SettingsUtil = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.lineChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis")
            }, {
                name: "Series",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
            }, {
                name: "Y",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: true
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            type: {
                                numeric: true
                            }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            type: {
                                numeric: true
                            }
                        },
                        axisType: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                            type: {
                                formatting: {
                                    axisType: true
                                }
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            type: {
                                formatting: {
                                    yAxisPosition: true
                                }
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            type: {
                                numeric: true
                            }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            type: {
                                numeric: true
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: true
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            type: {
                                numeric: true
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        min: 1,
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                "for": {
                                    "in": "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    }
                }
            } ],
            sorting: {
                "default": {}
            }
        };
        visuals.lineChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            categoryAxis: {
                axisType: {
                    objectName: "categoryAxis",
                    propertyName: "axisType"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        (function(LineChartType) {
            LineChartType[LineChartType["default"] = 1] = "default";
            LineChartType[LineChartType["area"] = 2] = "area";
            LineChartType[LineChartType["smooth"] = 4] = "smooth";
            LineChartType[LineChartType["lineShadow"] = 8] = "lineShadow";
        })(visuals.LineChartType || (visuals.LineChartType = {}));
        var LineChartType = visuals.LineChartType;
        var LineChart = function() {
            function LineChart(options) {
                this.isScrollable = options.isScrollable ? options.isScrollable : false;
                this.lineType = options.chartType ? options.chartType : 1;
                this.interactivityService = options.interactivityService;
                this.animator = options.animator;
            }
            LineChart.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!jsCommon.ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata) objects = dataViewMapping.metadata.objects;
                    if (visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType)) dataViewCategories.dataReductionAlgorithm = {
                        sample: {}
                    };
                }
            };
            LineChart.getSortableRoles = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!jsCommon.ArrayExtensions.isUndefinedOrEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects;
                    if (dataViewMapping.metadata) objects = dataViewMapping.metadata.objects;
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType)) return [ "Category" ];
                }
                return null;
            };
            LineChart.converter = function(dataView, blankCategoryValue, colors, isScalar, interactivityService) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                    source: undefined,
                    values: [ blankCategoryValue ],
                    identity: undefined
                };
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                var series = [];
                var seriesLen = categorical.values ? categorical.values.length : 0;
                var hasDynamicSeries = !!(categorical.values && categorical.values.source);
                var values = categorical.values;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                if (dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects["labels"];
                    if (labelsObj) {
                        if (labelsObj.show !== undefined) dataLabelsSettings.show = labelsObj.show;
                        if (labelsObj.color !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                        if (labelsObj.labelDisplayUnits !== undefined) {
                            dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                        }
                        if (labelsObj.labelPrecision !== undefined) {
                            dataLabelsSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : 0;
                        }
                    }
                    dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                }
                var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultDataPointColor);
                var grouped;
                if (dataView.categorical.values) grouped = dataView.categorical.values.grouped();
                for (var seriesIndex = 0; seriesIndex < seriesLen; seriesIndex++) {
                    var column = categorical.values[seriesIndex];
                    var dataPoints = [];
                    var groupedIdentity = grouped[seriesIndex];
                    var identity = hasDynamicSeries ? visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName) : visuals.SelectionId.createWithMeasure(column.source.queryName);
                    var key = identity.getKey();
                    var color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
                    for (var categoryIndex = 0, len = column.values.length; categoryIndex < len; categoryIndex++) {
                        var categoryValue = categoryValues[categoryIndex];
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(column.values[categoryIndex]);
                        if (isScalar && (categoryValue == null || value == null)) continue;
                        var categorical = dataView.categorical;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, seriesIndex);
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: value,
                            categoryIndex: categoryIndex,
                            seriesIndex: seriesIndex,
                            tooltipInfo: tooltipInfo,
                            selected: false,
                            identity: identity,
                            key: JSON.stringify({
                                ser: key,
                                catIdx: categoryIndex
                            }),
                            labelFill: dataLabelsSettings.overrideDefaultColor ? dataLabelsSettings.labelColor : color
                        });
                    }
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    series.push({
                        key: key,
                        lineIndex: seriesIndex,
                        color: color,
                        xCol: category.source,
                        yCol: column.source,
                        data: dataPoints,
                        identity: identity,
                        selected: false
                    });
                }
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                var valuesMetadataArray = [];
                if (values) {
                    for (var i = 0; i < values.length; i++) {
                        if (values[i] && values[i].source && values[i].source.displayName) {
                            valuesMetadataArray.push({
                                displayName: values[i].source.displayName
                            });
                        }
                    }
                }
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                var hasSelection = false;
                if (interactivityService) {
                    if (interactivityService.applySelectionStateToData(series)) hasSelection = true;
                }
                return {
                    series: series,
                    isScalar: isScalar,
                    dataLabelsSettings: dataLabelsSettings,
                    axesLabels: {
                        x: axesLabels.xAxisLabel,
                        y: axesLabels.yAxisLabel
                    },
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                    hasDynamicSeries: hasDynamicSeries,
                    hasSelection: hasSelection,
                    categoryMetadata: category.source,
                    categories: categoryValues
                };
            };
            LineChart.getColor = function(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                var objects;
                if (hasDynamicSeries) {
                    if (grouped) objects = grouped[seriesIndex].objects;
                } else {
                    objects = values[seriesIndex].source.objects;
                }
                return hasDynamicSeries ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name) : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
            };
            LineChart.prototype.init = function(options) {
                this.options = options;
                var element = this.element = options.element;
                this.host = options.host;
                this.currentViewport = options.viewport;
                this.colors = options.style.colorPalette.dataColors;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                element.addClass(LineChart.ClassName);
                var svg = options.svg;
                this.clearCatcher = svg.select(".clearCatcher");
                this.mainGraphicsSVG = svg.append("svg");
                this.mainGraphicsContext = this.mainGraphicsSVG.append("g").classed(LineChart.MainGraphicsContextClassName, true);
                this.dataLabelsSVG = svg.append("g").classed(LineChart.DataLabelsSVGClassName, true);
                this.toolTipContext = svg.append("g").classed("hover-line", true);
                this.toolTipContext.append(LineChart.LineElementName).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
                var hoverLine = this.hoverLine = this.toolTipContext.select(LineChart.LineElementName);
                if (this.isInteractiveChart) {
                    hoverLine.classed("interactive", true);
                }
                this.selectionCircles = [];
                var callout = visuals.AxisHelper.ToolTip.createCallout();
                this.element.append(callout);
                hoverLine.style("opacity", visuals.SVGUtil.AlmostZero);
                callout.css("opacity", visuals.SVGUtil.AlmostZero);
                var that = this;
                this.xAxisProperties = {
                    axis: null,
                    scale: null,
                    axisType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: null,
                    axisLabel: null,
                    isCategoryAxis: true
                };
                var dragMove = function() {
                    var x = d3.mouse(this)[0];
                    var index = that.findIndex(x);
                    that.selectColumn(index);
                };
                if (this.isInteractiveChart) {
                    var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                    svg.call(drag);
                    d3.select(this.element.get(0)).call(drag);
                    svg.on("click", dragMove);
                    d3.select(this.element.get(0)).on("click", dragMove);
                }
            };
            LineChart.prototype.setData = function(dataViews) {
                this.data = {
                    series: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    hasSelection: false,
                    categories: [],
                    categoryMetadata: undefined
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            var dvCategories = dataViewCat.categories;
                            var categoryType = powerbi.ValueType.fromDescriptor({
                                text: true
                            });
                            if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type) categoryType = dvCategories[0].source.type;
                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.colors, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType), this.interactivityService);
                            this.data = convertedData;
                        }
                    }
                }
            };
            LineChart.prototype.calculateLegend = function() {
                return this.createLegendDataPoints(0);
            };
            LineChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
            };
            LineChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var catgSize = endIndex - startIndex;
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = LineChart.sliceSeries(data.series, catgSize, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            LineChart.prototype.calculateAxesProperties = function(options) {
                var _this = this;
                var data = this.data;
                var viewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
                var categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness;
                var isScalar = this.data.isScalar;
                var preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= margin.left + margin.right;
                }
                preferredPlotArea.height -= margin.top + margin.bottom;
                this.clippedData = undefined;
                if (data && !isScalar && !this.isScrollable) {
                    var categoryCount = this.getCategoryCount(origCatgSize);
                    var catgSize = Math.min(origCatgSize, categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = this.clippedData = powerbi.Prototype.inherit(data);
                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize);
                    }
                }
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (data.series && data.series.length > 0) {
                    xMetaDataColumn = data.series[0].xCol;
                    yMetaDataColumn = data.series[0].yCol;
                }
                var valueDomain = visuals.AxisHelper.createValueDomain(data.series, false);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatStringProp: visuals.lineChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    shouldClamp: visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain)
                });
                var xDomain = visuals.AxisHelper.createDomain(data.series, this.xAxisProperties.axisType, this.data.isScalar, options.forcedXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatStringProp: visuals.lineChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: this.data.isScalar,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function(index, type) {
                        return _this.lookupXValue(index, type);
                    },
                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar),
                    isCategoryAxis: true
                });
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [ this.xAxisProperties, this.yAxisProperties ];
            };
            LineChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "dataPoint":
                    return this.enumerateDataPoints();

                  case "labels":
                    return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true);
                }
            };
            LineChart.prototype.enumerateDataPoints = function() {
                var data = this.data;
                if (!data || !data.series || data.series.length === 0) return;
                var instances = [];
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                if (data.hasDynamicSeries) {
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            defaultColor: {
                                solid: {
                                    color: data.defaultDataPointColor || this.colors.getColor(0).value
                                }
                            }
                        }
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesLength > 1;
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        }
                    });
                    if (!showAllDataPoints) return instances;
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                for (var i = 0; i < seriesLength; i++) {
                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector());
                    var label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                    instances.push({
                        objectName: "dataPoint",
                        displayName: label,
                        selector: selector,
                        properties: {
                            fill: {
                                solid: {
                                    color: singleSeriesData[i].color
                                }
                            }
                        }
                    });
                }
                return instances;
            };
            LineChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            };
            LineChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            LineChart.prototype.render = function(duration) {
                if (this.animator) this.renderNew(duration); else this.renderOld(duration);
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            LineChart.prototype.renderNew = function(duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data) return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = visuals.dataHasSelection(data.series);
                var renderAreas = EnumExtensions.hasFlag(this.lineType, 2);
                var area;
                if (renderAreas) {
                    area = d3.svg.area().x(function(d) {
                        return xScale(_this.getXValue(d));
                    }).y0(height).y1(function(d) {
                        return yScale(d.value);
                    }).defined(function(d) {
                        return d.value !== null;
                    });
                }
                var line = d3.svg.line().x(function(d) {
                    return xScale(_this.getXValue(d));
                }).y(function(d) {
                    return yScale(d.value);
                }).defined(function(d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4)) {
                    line.interpolate("basis");
                    if (area) {
                        area.interpolate("basis");
                    }
                }
                var extraLineShift = this.extraLineShift();
                this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.dataLabelsSVG.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth());
                this.toolTipContext.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                if (renderAreas) {
                    var areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector).data(data.series, function(d) {
                        return d.identity.getKey();
                    });
                    areas.enter().append(LineChart.PathElementName).classed(LineChart.CategoryAreaClassName, true);
                    areas.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                    }).transition().ease("linear").duration(duration).attr("d", function(d) {
                        return area(d.data);
                    });
                    areas.exit().remove();
                }
                var lines = this.mainGraphicsContext.selectAll(".line").data(data.series, function(d) {
                    return d.identity.getKey();
                });
                lines.enter().append(LineChart.PathElementName).classed("line", true);
                lines.style("stroke", function(d) {
                    return d.color;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                }).transition().ease("linear").duration(duration).attr("d", function(d) {
                    return line(d.data);
                });
                lines.exit().remove();
                var interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function(d) {
                    return d.identity.getKey();
                });
                interactivityLines.enter().append(LineChart.PathElementName).classed("interactivity-line", true);
                interactivityLines.attr("d", function(d) {
                    return line(d.data);
                });
                interactivityLines.exit().remove();
                var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).data(data.series, function(d) {
                    return d.identity.getKey();
                });
                dotGroups.enter().append("g").classed(LineChart.CategoryClassName, true);
                dotGroups.exit().remove();
                var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector).data(function(series) {
                    return series.data.filter(function(value, i) {
                        return _this.shouldDrawCircle(series, i);
                    });
                }, function(d) {
                    return d.key;
                });
                dots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint.class, true);
                dots.style("fill", function() {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                }).style("fill-opacity", function() {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                }).transition().duration(duration).attr({
                    cx: function(d, i) {
                        return xScale(_this.getXValue(d));
                    },
                    cy: function(d, i) {
                        return yScale(d.value);
                    },
                    r: LineChart.CircleRadius
                });
                dots.exit().remove();
                if (data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getLineChartLabelLayout(xScale, yScale, data.dataLabelsSettings, data.isScalar);
                    var dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, layout, this.currentViewport);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                var seriesTooltipApplier = function(tooltipEvent) {
                    var pointX = tooltipEvent.elementCoordinates[0];
                    return LineChart.getTooltipInfoByPointX(_this, tooltipEvent.data, pointX);
                };
                visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, true);
                if (renderAreas) visuals.TooltipManager.addTooltip(areas, seriesTooltipApplier, true);
                visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                }, true);
                if (this.interactivityService) {
                    var dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    var options = {
                        dataPoints: dataPointsToBind,
                        lines: lines,
                        interactivityLines: interactivityLines,
                        dots: dots,
                        areas: areas,
                        background: d3.selectAll(this.element.toArray()),
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, options);
                }
            };
            LineChart.prototype.renderOld = function(duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data) return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = this.data.hasSelection;
                var area;
                if (EnumExtensions.hasFlag(this.lineType, 2)) {
                    area = d3.svg.area().x(function(d) {
                        return xScale(_this.getXValue(d));
                    }).y0(height).y1(function(d) {
                        return yScale(d.value);
                    }).defined(function(d) {
                        return d.value !== null;
                    });
                }
                var line = d3.svg.line().x(function(d) {
                    return xScale(_this.getXValue(d));
                }).y(function(d) {
                    return yScale(d.value);
                }).defined(function(d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4)) {
                    line.interpolate("basis");
                    if (area) {
                        area.interpolate("basis");
                    }
                }
                var extraLineShift = this.extraLineShift();
                this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.dataLabelsSVG.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth());
                this.toolTipContext.attr("transform", visuals.SVGUtil.translate(LineChart.HorizontalShift + extraLineShift, 0));
                if (EnumExtensions.hasFlag(this.lineType, 2)) {
                    var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector).data(data.series, function(d) {
                        return d.identity.getKey();
                    });
                    var catAreaEnter = catAreaSelect.enter().append("g").classed(LineChart.CategoryAreaClassName, true);
                    catAreaEnter.append(LineChart.PathElementName);
                    var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaClassSelector);
                    catAreaUpdate.select(LineChart.PathElementName).transition().ease("linear").duration(duration).attr("d", function(d) {
                        return area(d.data);
                    }).style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                    });
                    catAreaSelect.exit().remove();
                }
                var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).data(data.series, function(d) {
                    return d.identity.getKey();
                });
                var catEnter = catSelect.enter().append("g").classed(LineChart.CategoryClassName, true);
                catEnter.append(LineChart.PathElementName);
                catEnter.selectAll(LineChart.CategoryValuePoint.selector).data(function(d) {
                    return d.data;
                }).enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint.class, true);
                catSelect.exit().remove();
                if (this.isInteractiveChart && !this.dragHandle) {
                    var handleTop = this.getAvailableHeight();
                    this.dragHandle = this.toolTipContext.append("circle").attr("cx", 0).attr("cy", handleTop).attr("r", "6px").classed("drag-handle", true);
                }
                var linesCount = catSelect.data().length;
                while (this.selectionCircles.length < linesCount) {
                    var addedCircle = this.toolTipContext.append(LineChart.CircleElementName).classed(LineChart.CircleClassName, true).attr("r", LineChart.CircleRadius).style("opacity", 0);
                    this.selectionCircles.push(addedCircle);
                }
                while (this.selectionCircles.length > linesCount) {
                    this.selectionCircles.pop().remove();
                }
                var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector);
                var lineSelection = catUpdate.select(LineChart.PathElementName).classed("line", true).style("stroke", function(d) {
                    return d.color;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                });
                lineSelection.transition().ease("linear").duration(duration).attr("d", function(d) {
                    return line(d.data);
                });
                var that = this;
                var updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector);
                var transitions = updateSelection.style("fill", function() {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                }).style("fill-opacity", function() {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                }).transition().duration(duration).attr({
                    cx: function(d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? xScale(that.getXValue(d)) : 0;
                    },
                    cy: function(d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? yScale(d.value) : 0;
                    },
                    r: function(d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? LineChart.CircleRadius : 0;
                    }
                });
                if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                    var selectionSize = updateSelection.size();
                    var endedTransitionCount = 0;
                    transitions.each("end", function() {
                        endedTransitionCount++;
                        if (endedTransitionCount === selectionSize) {
                            _this.selectColumn(0, true);
                        }
                    });
                }
                if (data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getLineChartLabelLayout(xScale, yScale, data.dataLabelsSettings, data.isScalar);
                    var dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, layout, this.currentViewport);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                visuals.TooltipManager.addTooltip(catSelect, function(tooltipEvent) {
                    var pointX = tooltipEvent.elementCoordinates[0];
                    return LineChart.getTooltipInfoByPointX(that, tooltipEvent.data, pointX);
                }, true);
                catSelect.exit().remove();
                if (this.interactivityService) {
                    var dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    var options = {
                        dataPoints: dataPointsToBind,
                        lines: lineSelection,
                        interactivityLines: lineSelection,
                        dots: this.mainGraphicsContext.selectAll(".cat .dot"),
                        areas: catAreaUpdate,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, options);
                }
            };
            LineChart.getTooltipInfoByPointX = function(lineChart, pointData, pointX) {
                var index = 0;
                if (lineChart.data.isScalar) {
                    var currentX = powerbi.visuals.AxisHelper.invertScale(lineChart.xAxisProperties.scale, pointX);
                    index = lineChart.findClosestXAxisIndex(currentX, pointData.data);
                } else {
                    var scale = lineChart.xAxisProperties.scale;
                    index = visuals.AxisHelper.getOrdinalScaleClosestDataPointIndex(scale, pointX);
                }
                return pointData.data[index].tooltipInfo;
            };
            LineChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return this.data ? this.data.isScalar : false;
            };
            LineChart.prototype.getSupportedCategoryAxisType = function() {
                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : undefined;
                var categoryType = powerbi.ValueType.fromDescriptor({
                    text: true
                });
                if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type) categoryType = dvCategories[0].source.type;
                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                return isOrdinal ? powerbi.axisType.categorical : powerbi.axisType.both;
            };
            LineChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar);
            };
            LineChart.prototype.getCategoryCount = function(origCatgSize) {
                var availableWidth = this.getAvailableWidth();
                var categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
            };
            LineChart.prototype.getAvailableWidth = function() {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            LineChart.prototype.getAvailableHeight = function() {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            LineChart.sliceSeries = function(series, newLength, startIndex) {
                if (startIndex === void 0) {
                    startIndex = 0;
                }
                var newSeries = [];
                if (series && series.length > 0) {
                    debug.assert(series[0].data.length >= newLength, "invalid newLength");
                    for (var i = 0, len = series.length; i < len; i++) {
                        newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                    }
                }
                return newSeries;
            };
            LineChart.prototype.extraLineShift = function() {
                if (!this.data.isScalar) {
                    var xScale = this.xAxisProperties.scale;
                    if (xScale.rangeBand) return xScale.rangeBand() / 2;
                }
                return 0;
            };
            LineChart.prototype.hasDataPoint = function(series) {
                if (series.length === 0) return false;
                for (var i = 0, len = series.length; i < len; i++) {
                    if (series[i].data.length > 0) return true;
                }
                return false;
            };
            LineChart.prototype.lookupXValue = function(index, type) {
                debug.assertValue(this.data, "this.data");
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime && this.data.isScalar) return new Date(index);
                if (this.data && this.data.series && this.data.series.length > 0) {
                    var firstSeries = this.data.series[0];
                    if (firstSeries) {
                        var data = firstSeries.data;
                        if (data) {
                            var dataAtIndex = data[index];
                            if (dataAtIndex) {
                                if (isDateTime) return new Date(dataAtIndex.categoryValue);
                                return dataAtIndex.categoryValue;
                            }
                        }
                    }
                }
                return index;
            };
            LineChart.prototype.getXValue = function(d) {
                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
            };
            LineChart.prototype.shouldDrawCircle = function(d, i) {
                var dataLength = d.data.length;
                var isLastPoint = i === dataLength - 1;
                var isFirstPoint = i === 0;
                if (i > dataLength - 1 || d.data[i] === null || d.data[i].value === null) return false;
                if (isFirstPoint && isLastPoint) return true;
                if (isFirstPoint && dataLength > 1 && d.data[i + 1].value === null) return true;
                if (!isFirstPoint && isLastPoint && d.data[i - 1].value === null) return true;
                if (!isFirstPoint && !isLastPoint && d.data[i - 1].value === null && d.data[i + 1].value === null) return true;
                return false;
            };
            LineChart.prototype.selectColumn = function(columnIndex, force) {
                if (force === void 0) {
                    force = false;
                }
                if (!force && this.lastInteractiveSelectedColumnIndex === columnIndex) return;
                this.lastInteractiveSelectedColumnIndex = columnIndex;
                var x = this.getChartX(columnIndex);
                this.setHoverLine(x);
                var legendItems = this.createLegendDataPoints(columnIndex);
                this.options.cartesianHost.updateLegend(legendItems);
            };
            LineChart.prototype.setHoverLine = function(chartX) {
                this.hoverLine.attr("x1", chartX).attr("x2", chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style("opacity", 1);
                var that = this;
                this.mainGraphicsContext.selectAll(LineChart.CategoryClassSelector).selectAll(LineChart.PathElementName).each(function(series) {
                    var _this = this;
                    var color = series.color;
                    var circleToChange = that.selectionCircles[series.lineIndex];
                    circleToChange.attr({
                        cx: chartX,
                        cy: function() {
                            var pathElement = d3.select(_this).node();
                            var pos = that.getPosition(chartX, pathElement);
                            return pos.y;
                        }
                    }).style({
                        opacity: 1,
                        fill: color
                    });
                    if (that.dragHandle) that.dragHandle.attr("cx", chartX);
                });
            };
            LineChart.prototype.getChartX = function(columnIndex) {
                var x;
                if (this.data.isScalar) {
                    x = Math.max(0, this.xAxisProperties.scale(this.data.series[0].data[columnIndex].categoryValue));
                } else {
                    x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                }
                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                x = Math.min(x, rangeEnd);
                if (isNaN(x)) {
                    return;
                }
                return x;
            };
            LineChart.prototype.findIndex = function(x) {
                x -= this.margin.left + powerbi.visuals.LineChart.HorizontalShift;
                var currentX = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, x);
                var index = currentX;
                if (this.data.isScalar) {
                    index = this.findClosestXAxisIndex(currentX, this.data.series[0].data);
                }
                return index;
            };
            LineChart.prototype.findClosestXAxisIndex = function(currentX, xAxisValues) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                for (var i in xAxisValues) {
                    var distance = Math.abs(currentX - xAxisValues[i].categoryValue);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = i;
                    }
                }
                return closestValueIndex;
            };
            LineChart.prototype.getPosition = function(x, pathElement) {
                var pathLength = pathElement.getTotalLength();
                var pos;
                var beginning = 0, end = pathLength, target;
                while (true) {
                    target = Math.floor((beginning + end) / 2);
                    pos = pathElement.getPointAtLength(target);
                    visuals.SVGUtil.ensureValidSVGPoint(pos);
                    if ((target === end || target === beginning) && pos.x !== x) break;
                    if (pos.x > x) end = target; else if (pos.x < x) beginning = target; else break;
                }
                return pos;
            };
            LineChart.prototype.createLegendDataPoints = function(columnIndex) {
                var data = this.data;
                if (!data) return null;
                var legendDataPoints = [];
                var category;
                if (data.series.length > 0) {
                    var lineDatePointFirstSeries = data.series[0].data[columnIndex];
                    var isDateTime = visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType);
                    var value = isDateTime && this.data.isScalar ? lineDatePointFirstSeries.categoryValue : columnIndex;
                    category = lineDatePointFirstSeries && this.lookupXValue(value, this.xAxisProperties.axisType);
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var seriesYCol = null;
                for (var i = 0, len = data.series.length; i < len; i++) {
                    var series = data.series[i];
                    var lineData = series.data;
                    var lineDataPoint = lineData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                    seriesYCol = series.yCol;
                    legendDataPoints.push({
                        color: series.color,
                        icon: 2,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: series.identity,
                        selected: false
                    });
                }
                var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
                var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                return {
                    title: title,
                    dataPoints: legendDataPoints
                };
            };
            LineChart.prototype.accept = function(visitor, options) {
                visitor.visitLineChart(options);
            };
            LineChart.ClassName = "lineChart";
            LineChart.MainGraphicsContextClassName = "mainGraphicsContext";
            LineChart.DataLabelsSVGClassName = "dataLabelsSVG";
            LineChart.CategoryClassName = "cat";
            LineChart.CategoryClassSelector = ".cat";
            LineChart.CategoryValuePoint = {
                "class": "dot",
                selector: ".dot"
            };
            LineChart.CategoryAreaClassName = "catArea";
            LineChart.CategoryAreaClassSelector = ".catArea";
            LineChart.HorizontalShift = 0;
            LineChart.CircleRadius = 4;
            LineChart.PathElementName = "path";
            LineChart.CircleElementName = "circle";
            LineChart.CircleClassName = "selection-circle";
            LineChart.LineElementName = "line";
            LineChart.AreaFillOpacity = .4;
            LineChart.DimmedAreaFillOpacity = .2;
            return LineChart;
        }();
        visuals.LineChart = LineChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Point = function() {
            function Point(x, y) {
                if (x === void 0) {
                    x = 0;
                }
                if (y === void 0) {
                    y = 0;
                }
                this.x = x || 0;
                this.y = y || 0;
            }
            return Point;
        }();
        visuals.Point = Point;
        var Rect = function() {
            function Rect(left, top, width, height) {
                if (left === void 0) {
                    left = 0;
                }
                if (top === void 0) {
                    top = 0;
                }
                if (width === void 0) {
                    width = 0;
                }
                if (height === void 0) {
                    height = 0;
                }
                this.left = left || 0;
                this.top = top || 0;
                this.width = width || 0;
                this.height = height || 0;
            }
            return Rect;
        }();
        visuals.Rect = Rect;
        var Transform = function() {
            function Transform(m) {
                this.matrix = m || {
                    m00: 1,
                    m01: 0,
                    m02: 0,
                    m10: 0,
                    m11: 1,
                    m12: 0
                };
            }
            Transform.prototype.applyToPoint = function(point) {
                if (!point) {
                    return point;
                }
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12
                };
            };
            Transform.prototype.applyToRect = function(rect) {
                if (!rect) {
                    return rect;
                }
                var x0 = rect.left;
                var y0 = rect.top;
                var m = this.matrix;
                var isScaled = m.m00 !== 1 || m.m11 !== 1;
                var isRotated = m.m01 !== 0 || m.m10 !== 0;
                if (!isRotated && !isScaled) {
                    return {
                        left: x0 + m.m02,
                        top: y0 + m.m12,
                        width: rect.width,
                        height: rect.height
                    };
                }
                var x1 = rect.left + rect.width;
                var y1 = rect.top + rect.height;
                var minX;
                var maxX;
                var minY;
                var maxY;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x);
                    maxX = Math.max(p0x, p1x, p2x, p3x);
                    minY = Math.min(p0y, p1y, p2y, p3y);
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                } else {
                    var p0x = m.m00 * x0 + m.m02;
                    var p0y = m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m02;
                    var p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x);
                    maxX = Math.max(p0x, p3x);
                    minY = Math.min(p0y, p3y);
                    maxY = Math.max(p0y, p3y);
                }
                return {
                    left: minX,
                    top: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            };
            Transform.prototype.translate = function(xOffset, yOffset) {
                if (xOffset !== 0 || yOffset !== 0) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.scale = function(xScale, yScale) {
                if (xScale !== 1 || yScale !== 1) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.rotate = function(angleInRadians) {
                if (angleInRadians !== 0) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = mutliplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.add = function(other) {
                if (other) {
                    this.matrix = mutliplyMatrices(this.matrix, other.matrix);
                    this._inverse = null;
                }
            };
            Transform.prototype.getInverse = function() {
                if (!this._inverse) {
                    this._inverse = new Transform(createInverseMatrix(this.matrix));
                }
                return this._inverse;
            };
            return Transform;
        }();
        visuals.Transform = Transform;
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1,
                m01: 0,
                m02: xOffset,
                m10: 0,
                m11: 1,
                m12: yOffset
            };
        }
        visuals.createTranslateMatrix = createTranslateMatrix;
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale,
                m01: 0,
                m02: 0,
                m10: 0,
                m11: yScale,
                m12: 0
            };
        }
        visuals.createScaleMatrix = createScaleMatrix;
        function createRotationMatrix(angleInRads) {
            var a = angleInRads;
            var sinA = Math.sin(a);
            var cosA = Math.cos(a);
            return {
                m00: cosA,
                m01: -sinA,
                m02: 0,
                m10: sinA,
                m11: cosA,
                m12: 0
            };
        }
        visuals.createRotationMatrix = createRotationMatrix;
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
            var invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        visuals.createInverseMatrix = createInverseMatrix;
        function mutliplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12
            };
        }
        var defaultLevelOfDetail = 11;
        var MapPolygonInfo = function() {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            MapPolygonInfo.prototype.reCalc = function(mapControl, width, height) {
                var baseLocations = [ this._locationRect.getNorthwest(), this._locationRect.getSoutheast() ];
                var width = width / 2;
                var height = height / 2;
                if (!this._baseRect) {
                    var l0 = powerbi.visuals.BI.Services.MapServices.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
                    var l1 = powerbi.visuals.BI.Services.MapServices.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            };
            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function() {
                    if (this._baseRect) {
                        return this._currentRect.width / this._baseRect.width;
                    }
                    return 1;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function() {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    transform.translate(current.left, current.top);
                    transform.scale(current.width / base.width, current.height / base.height);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function() {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    transform.scale(scale, scale);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.setViewBox = function(svg) {
                var rect = svg.getBoundingClientRect();
                var current = this._currentRect;
                svg.setAttribute("viewBox", [ -current.left, -current.top, rect.width, rect.height ].join(" "));
            };
            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function() {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new Transform();
                    var scale = current.width / base.width;
                    transform.scale(scale, scale);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.transformToString = function(transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            };
            return MapPolygonInfo;
        }();
        visuals.MapPolygonInfo = MapPolygonInfo;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var BI;
        (function(BI) {
            var Services;
            (function(Services) {
                var GeocodingManager;
                (function(GeocodingManager) {
                    "use strict";
                    GeocodingManager.Settings = {
                        MaxBingRequest: 6,
                        MaxCacheSize: 3e3,
                        MaxCacheSizeOverflow: 100,
                        BingKey: "AidYBxBA7LCx2Uo3v-4QJE2zRVgvqg4KquhupR_dRRIGbmKd1A1CpWnjEJulgAUe",
                        BingUrl: "https://dev.virtualearth.net/REST/v1/Locations?",
                        BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                        UseDoubleArrayGeodataResult: true,
                        UseDoubleArrayDequeueTimeout: 0
                    };
                    GeocodingManager.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
                    GeocodingManager.BingAjaxCall = $.ajax;
                    GeocodingManager.CategoryTypes = {
                        Address: "Address",
                        City: "City",
                        Continent: "Continent",
                        CountryRegion: "Country",
                        County: "County",
                        Longitude: "Longitude",
                        Latitude: "Latitude",
                        Place: "Place",
                        PostalCode: "PostalCode",
                        StateOrProvince: "StateOrProvince"
                    };
                    GeocodingManager.CategoryTypeArray = [ "Address", "City", "Continent", "Country", "County", "Longitude", "Latitude", "Place", "PostalCode", "StateOrProvince" ];
                    function isCategoryType(value) {
                        return GeocodingManager.CategoryTypeArray.indexOf(value) > -1;
                    }
                    GeocodingManager.isCategoryType = isCategoryType;
                    GeocodingManager.BingEntities = {
                        Continent: "Continent",
                        Sovereign: "Sovereign",
                        CountryRegion: "CountryRegion",
                        AdminDivision1: "AdminDivision1",
                        AdminDivision2: "AdminDivision2",
                        PopulatedPlace: "PopulatedPlace",
                        Postcode: "Postcode",
                        Postcode1: "Postcode1",
                        Neighborhood: "Neighborhood",
                        Address: "Address"
                    };
                    var geocodeQueue;
                    var activeRequests;
                    var categoryToBingEntity;
                    var categoryToBingEntityGeodata;
                    var geocodingCache;
                    var GeocodeQuery = function() {
                        function GeocodeQuery(query, category) {
                            if (query === void 0) {
                                query = "";
                            }
                            if (category === void 0) {
                                category = "";
                            }
                            this.query = query;
                            this.category = category;
                            this.key = (this.query + "/" + this.category).toLowerCase();
                            this._cacheHits = 0;
                            if (!geocodingCache) {
                                geocodingCache = Services.createGeocodingCache(GeocodingManager.Settings.MaxCacheSize, GeocodingManager.Settings.MaxCacheSizeOverflow);
                            }
                        }
                        GeocodeQuery.prototype.incrementCacheHit = function() {
                            this._cacheHits++;
                        };
                        GeocodeQuery.prototype.getCacheHits = function() {
                            return this._cacheHits;
                        };
                        GeocodeQuery.prototype.getBingEntity = function() {
                            var category = this.category.toLowerCase();
                            if (!categoryToBingEntity) {
                                categoryToBingEntity = {};
                                categoryToBingEntity[GeocodingManager.CategoryTypes.Continent.toLowerCase()] = GeocodingManager.BingEntities.Continent;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.CountryRegion.toLowerCase()] = GeocodingManager.BingEntities.Sovereign;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.StateOrProvince.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision1;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.County.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision2;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.City.toLowerCase()] = GeocodingManager.BingEntities.PopulatedPlace;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.PostalCode.toLowerCase()] = GeocodingManager.BingEntities.Postcode;
                                categoryToBingEntity[GeocodingManager.CategoryTypes.Address.toLowerCase()] = GeocodingManager.BingEntities.Address;
                            }
                            return categoryToBingEntity[category] || "";
                        };
                        GeocodeQuery.prototype.getUrl = function() {
                            var url = GeocodingManager.Settings.BingUrl + "key=" + GeocodingManager.Settings.BingKey;
                            var entityType = this.getBingEntity();
                            var queryAdded = false;
                            if (entityType) {
                                if (entityType === GeocodingManager.BingEntities.Postcode) {
                                    url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4";
                                } else if (this.query.indexOf(",") === -1 && (entityType === GeocodingManager.BingEntities.AdminDivision1 || entityType === GeocodingManager.BingEntities.AdminDivision2)) {
                                    queryAdded = true;
                                    url += "&adminDistrict=" + decodeURIComponent(this.query);
                                } else {
                                    url += "&includeEntityTypes=" + entityType;
                                }
                            }
                            if (!queryAdded) {
                                url += "&q=" + decodeURIComponent(this.query);
                            }
                            var cultureName = navigator.userLanguage || navigator["language"];
                            if (cultureName) {
                                url += "&c=" + cultureName;
                            }
                            url += "&maxRes=20";
                            return url;
                        };
                        return GeocodeQuery;
                    }();
                    GeocodingManager.GeocodeQuery = GeocodeQuery;
                    var GeocodeBoundaryQuery = function(_super) {
                        __extends(GeocodeBoundaryQuery, _super);
                        function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                            if (maxGeoData === void 0) {
                                maxGeoData = 3;
                            }
                            _super.call(this, [ latitude, longitude, levelOfDetail, maxGeoData ].join(","), category);
                            this.latitude = latitude;
                            this.longitude = longitude;
                            this.levelOfDetail = levelOfDetail;
                            this.maxGeoData = maxGeoData;
                        }
                        GeocodeBoundaryQuery.prototype.getBingEntity = function() {
                            var category = this.category.toLowerCase();
                            if (!categoryToBingEntityGeodata) {
                                categoryToBingEntityGeodata = {};
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.CountryRegion.toLowerCase()] = GeocodingManager.BingEntities.CountryRegion;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.StateOrProvince.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision1;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.County.toLowerCase()] = GeocodingManager.BingEntities.AdminDivision2;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.City.toLowerCase()] = GeocodingManager.BingEntities.PopulatedPlace;
                                categoryToBingEntityGeodata[GeocodingManager.CategoryTypes.PostalCode.toLowerCase()] = GeocodingManager.BingEntities.Postcode1;
                            }
                            return categoryToBingEntityGeodata[category] || "";
                        };
                        GeocodeBoundaryQuery.prototype.getUrl = function() {
                            var url = GeocodingManager.Settings.BingUrlGeodata + "key=" + GeocodingManager.Settings.BingKey + "&$format=json";
                            var entityType = this.getBingEntity();
                            if (!entityType) {
                                return null;
                            }
                            var cultureName = navigator.userLanguage || navigator["language"];
                            var cultures = cultureName.split("-");
                            var data = [ this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'" ];
                            if (cultures.length > 1) {
                                data.push("'" + cultures[1] + "'");
                            }
                            return url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                        };
                        return GeocodeBoundaryQuery;
                    }(GeocodeQuery);
                    GeocodingManager.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
                    function geocodeCore(geocodeQuery) {
                        var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery) : undefined;
                        var deferred = $.Deferred();
                        if (result) {
                            deferred.resolve(result);
                        } else {
                            geocodeQueue.push({
                                query: geocodeQuery,
                                deferred: deferred
                            });
                            dequeue();
                        }
                        return deferred;
                    }
                    GeocodingManager.geocodeCore = geocodeCore;
                    function geocode(query, category) {
                        if (category === void 0) {
                            category = "";
                        }
                        return geocodeCore(new GeocodeQuery(query, category));
                    }
                    GeocodingManager.geocode = geocode;
                    function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData) {
                        if (category === void 0) {
                            category = "";
                        }
                        if (levelOfDetail === void 0) {
                            levelOfDetail = 2;
                        }
                        if (maxGeoData === void 0) {
                            maxGeoData = 3;
                        }
                        return geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData));
                    }
                    GeocodingManager.geocodeBoundary = geocodeBoundary;
                    function dequeue(decrement) {
                        if (decrement === void 0) {
                            decrement = 0;
                        }
                        activeRequests -= decrement;
                        while (activeRequests < GeocodingManager.Settings.MaxBingRequest) {
                            if (geocodeQueue.length === 0) {
                                break;
                            }
                            activeRequests++;
                            makeRequest(geocodeQueue.shift());
                        }
                    }
                    function makeRequest(item) {
                        var result = geocodingCache ? geocodingCache.getCoordinates(item.query) : undefined;
                        if (result) {
                            setTimeout(function() {
                                return dequeue(1);
                            });
                            item.deferred.resolve(result);
                            return;
                        }
                        var config = {
                            type: "GET",
                            dataType: "jsonp",
                            jsonp: "jsonp"
                        };
                        var url = item.query.getUrl();
                        if (!url) {
                            completeRequest(item, new Error("Unsupported query."));
                        }
                        GeocodingManager.BingAjaxCall(url, config).then(function(data) {
                            try {
                                if (item.query instanceof GeocodeBoundaryQuery) {
                                    var result = data;
                                    if (result && result.d && Array.isArray(result.d.results) && result.d.results.length > 0) {
                                        var entity = result.d.results[0];
                                        var primitives = entity.Primitives;
                                        if (primitives && primitives.length > 0) {
                                            var coordinates = {
                                                latitude: item.query.latitude,
                                                longitude: item.query.longitude,
                                                locations: []
                                            };
                                            primitives.sort(function(a, b) {
                                                if (a.Shape.length < b.Shape.length) {
                                                    return 1;
                                                }
                                                if (a.Shape.length > b.Shape.length) {
                                                    return -1;
                                                }
                                                return 0;
                                            });
                                            var maxGeoData = Math.min(primitives.length, item.query.maxGeoData);
                                            for (var i = 0; i < maxGeoData; i++) {
                                                var ringStr = primitives[i].Shape;
                                                var ringArray = ringStr.split(",");
                                                for (var j = 1; j < ringArray.length; j++) {
                                                    coordinates.locations.push({
                                                        nativeBing: ringArray[j]
                                                    });
                                                }
                                            }
                                            completeRequest(item, null, coordinates);
                                        } else {
                                            completeRequest(item, new Error("Geocode result is empty."));
                                        }
                                    } else {
                                        completeRequest(item, new Error("Geocode result is empty."));
                                    }
                                } else {
                                    var resources = data.resourceSets[0].resources;
                                    if (Array.isArray(resources) && resources.length > 0) {
                                        var index = getBestResultIndex(resources, item.query);
                                        var pointData = resources[index].point.coordinates;
                                        var coordinates = {
                                            latitude: parseFloat(pointData[0]),
                                            longitude: parseFloat(pointData[1])
                                        };
                                        completeRequest(item, null, coordinates);
                                    } else {
                                        completeRequest(item, new Error("Geocode result is empty."));
                                    }
                                }
                            } catch (error) {
                                completeRequest(item, error);
                            }
                        }, function(error) {
                            completeRequest(item, error);
                        });
                    }
                    var dequeueTimeoutId;
                    function completeRequest(item, error, coordinate) {
                        if (coordinate === void 0) {
                            coordinate = null;
                        }
                        dequeueTimeoutId = setTimeout(function() {
                            return dequeue(1);
                        }, GeocodingManager.Settings.UseDoubleArrayGeodataResult ? GeocodingManager.Settings.UseDoubleArrayDequeueTimeout : 0);
                        if (error) {
                            item.deferred.reject(error);
                        } else {
                            if (geocodingCache) geocodingCache.registerCoordinates(item.query, coordinate);
                            item.deferred.resolve(coordinate);
                        }
                    }
                    function getBestResultIndex(resources, query) {
                        var targetEntity = query.getBingEntity().toLowerCase();
                        for (var index = 0; index < resources.length; index++) {
                            var resultEntity = (resources[index].entityType || "").toLowerCase();
                            if (resultEntity === targetEntity) {
                                return index;
                            }
                        }
                        return 0;
                    }
                    function reset() {
                        geocodeQueue = [];
                        activeRequests = 0;
                        categoryToBingEntity = null;
                        clearTimeout(dequeueTimeoutId);
                    }
                    GeocodingManager.reset = reset;
                    reset();
                })(GeocodingManager = Services.GeocodingManager || (Services.GeocodingManager = {}));
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var BI;
        (function(BI) {
            var Services;
            (function(Services) {
                var MapServices;
                (function(MapServices) {
                    "use strict";
                    MapServices.MinAllowedLatitude = -85.05112878;
                    MapServices.MaxAllowedLatitude = 85.05112878;
                    MapServices.MinAllowedLongitude = -180;
                    MapServices.MaxAllowedLongitude = 180;
                    MapServices.TileSize = 256;
                    MapServices.MaxLevelOfDetail = 23;
                    MapServices.MinLevelOfDetail = 1;
                    MapServices.MaxAutoZoomLevel = 5;
                    MapServices.DefaultLevelOfDetail = 11;
                    MapServices.WorkerErrorName = "___error___";
                    var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
                    function clip(n, minValue, maxValue) {
                        return Math.min(Math.max(n, minValue), maxValue);
                    }
                    MapServices.clip = clip;
                    function getMapSize(levelOfDetail) {
                        if (levelOfDetail === 23) return 2147483648;
                        if (Math.floor(levelOfDetail) === levelOfDetail) return 256 << levelOfDetail;
                        return 256 * Math.pow(2, levelOfDetail);
                    }
                    MapServices.getMapSize = getMapSize;
                    function latLongToPixelXYArray(latLongArray, levelOfDetail) {
                        var result = new Float64Array(latLongArray.length);
                        for (var i = 0; i < latLongArray.length; i += 2) {
                            var latitude = clip(latLongArray[i], MapServices.MinAllowedLatitude, MapServices.MaxAllowedLatitude);
                            var longitude = clip(latLongArray[i + 1], MapServices.MinAllowedLongitude, MapServices.MaxAllowedLongitude);
                            var x = (longitude + 180) / 360;
                            var sinLatitude = Math.sin(latitude * Math.PI / 180);
                            var y = .5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
                            var mapSize = getMapSize(levelOfDetail);
                            result[i] = clip(x * mapSize + .5, 0, mapSize - 1);
                            result[i + 1] = clip(y * mapSize + .5, 0, mapSize - 1);
                        }
                        return result;
                    }
                    MapServices.latLongToPixelXYArray = latLongToPixelXYArray;
                    function pointArrayToString(array) {
                        var maxLength = 8e4;
                        if (array.length > maxLength) {
                            var result = "";
                            for (var i = 0; i < array.length; i += maxLength) {
                                var array1 = Array.apply([], array.subarray(i, i + maxLength));
                                result += array1.join(" ") + " ";
                            }
                            return result;
                        }
                        return Array.apply([], array).join(" ");
                    }
                    MapServices.pointArrayToString = pointArrayToString;
                    function pointArrayToArray(array) {
                        var maxLength = 8e4;
                        var result = [];
                        if (array.length > maxLength) {
                            for (var i = 0; i < array.length; i += maxLength) {
                                var array1 = Array.apply([], array.subarray(i, i + maxLength));
                                result.concat(array1);
                            }
                            return result;
                        }
                        return Array.apply([], array);
                    }
                    MapServices.pointArrayToArray = pointArrayToArray;
                    function getLocationBoundaries(latLongArray) {
                        var northWest = {
                            latitude: -90,
                            longitude: 180
                        };
                        var southEast = {
                            latitude: 90,
                            longitude: -180
                        };
                        for (var i = 0; i < latLongArray.length; i += 2) {
                            northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
                            northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
                            southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
                            southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                        }
                        northWest.longitude = clip(northWest.longitude, -180, 180);
                        southEast.longitude = clip(southEast.longitude, -180, 180);
                        return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
                    }
                    MapServices.getLocationBoundaries = getLocationBoundaries;
                    function parseEncodedSpatialValueArray(value) {
                        var list = [];
                        var index = 0;
                        var xsum = 0;
                        var ysum = 0;
                        var max = 4294967296;
                        while (index < value.length) {
                            var n = 0;
                            var k = 0;
                            while (1) {
                                if (index >= value.length) {
                                    return null;
                                }
                                var b = safeCharacters.indexOf(value.charAt(index++));
                                if (b === -1) {
                                    return null;
                                }
                                var tmp = (b & 31) * Math.pow(2, k);
                                var ht = tmp / max;
                                var lt = tmp % max;
                                var hn = n / max;
                                var ln = n % max;
                                var nl = (lt | ln) >>> 0;
                                n = (ht | hn) * max + nl;
                                k += 5;
                                if (b < 32) break;
                            }
                            var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                            n -= diagonal * (diagonal + 1) / 2;
                            var ny = Math.floor(n);
                            var nx = diagonal - ny;
                            nx = nx >> 1 ^ -(nx & 1);
                            ny = ny >> 1 ^ -(ny & 1);
                            xsum += nx;
                            ysum += ny;
                            var lat = ysum * 1e-5;
                            var lon = xsum * 1e-5;
                            list.push(lat);
                            list.push(lon);
                        }
                        return new Float64Array(list);
                    }
                    MapServices.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
                    function calcGeoData(data) {
                        var locations = data.locations;
                        for (var i = 0; i < locations.length; i++) {
                            var location = locations[i];
                            if (!location.geographic) {
                                location.geographic = MapServices.parseEncodedSpatialValueArray(location.nativeBing);
                            }
                            var polygon = location.geographic;
                            if (polygon) {
                                if (!location.absolute) {
                                    location.absolute = MapServices.latLongToPixelXYArray(polygon, MapServices.DefaultLevelOfDetail);
                                    location.absoluteString = MapServices.pointArrayToString(location.absolute);
                                    location.geographicBounds = MapServices.getLocationBoundaries(polygon);
                                    location.absoluteBounds = MapServices.locationRectToRectXY(location.geographicBounds, MapServices.DefaultLevelOfDetail);
                                }
                            }
                        }
                    }
                    MapServices.calcGeoData = calcGeoData;
                    function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                        var array = latLongToPixelXYArray(new Float64Array([ latitude, longitude ]), levelOfDetail);
                        return new powerbi.visuals.Point(array[0], array[1]);
                    }
                    MapServices.latLongToPixelXY = latLongToPixelXY;
                    function locationToPixelXY(location, levelOfDetail) {
                        return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
                    }
                    MapServices.locationToPixelXY = locationToPixelXY;
                    function locationRectToRectXY(locationRect, levelOfDetail) {
                        var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
                        var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                        return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
                    }
                    MapServices.locationRectToRectXY = locationRectToRectXY;
                    function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                        var mapSize = getMapSize(levelOfDetail);
                        var x = clip(pixelX, 0, mapSize - 1) / mapSize - .5;
                        var y = .5 - clip(pixelY, 0, mapSize - 1) / mapSize;
                        var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                        var longitude = 360 * x;
                        return new Microsoft.Maps.Location(latitude, longitude);
                    }
                    MapServices.pixelXYToLocation = pixelXYToLocation;
                })(MapServices = Services.MapServices || (Services.MapServices = {}));
            })(Services = BI.Services || (BI.Services = {}));
        })(BI = visuals.BI || (visuals.BI = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        (function(LegendIcon) {
            LegendIcon[LegendIcon["Box"] = 0] = "Box";
            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
            LegendIcon[LegendIcon["Line"] = 2] = "Line";
        })(visuals.LegendIcon || (visuals.LegendIcon = {}));
        var LegendIcon = visuals.LegendIcon;
        (function(LegendPosition) {
            LegendPosition[LegendPosition["Top"] = 0] = "Top";
            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
            LegendPosition[LegendPosition["Right"] = 2] = "Right";
            LegendPosition[LegendPosition["Left"] = 3] = "Left";
            LegendPosition[LegendPosition["None"] = 4] = "None";
        })(visuals.LegendPosition || (visuals.LegendPosition = {}));
        var LegendPosition = visuals.LegendPosition;
        visuals.legendProps = {
            show: "show",
            position: "position",
            titleText: "titleText",
            showTitle: "showTitle"
        };
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
            if (isScrollable === void 0) {
                isScrollable = false;
            }
            if (legendPosition === void 0) {
                legendPosition = 0;
            }
            if (interactive) return new CartesianChartInteractiveLegend(legendParentElement); else return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
        }
        visuals.createLegend = createLegend;
        function getIconClass(iconType) {
            switch (iconType) {
              case 1:
                return "icon circle";

              case 0:
                return "icon tall";

              case 2:
                return "icon short";

              default:
                debug.assertFail("Invalid Chart type: " + iconType);
            }
        }
        visuals.getIconClass = getIconClass;
        function getLabelMaxSize(currentViewport, numItems, hasTitle) {
            var viewportWidth = currentViewport.width;
            var smallTileWidth = 250;
            var mediumTileWidth = 490;
            var largeTileWidth = 750;
            var tileMargins = 20;
            var legendMarkerWidth = 28;
            var legendItems;
            if (numItems < 1) return "48px";
            if (viewportWidth <= smallTileWidth) {
                legendItems = hasTitle ? 4 : 3;
                return Math.floor((smallTileWidth - tileMargins - legendMarkerWidth * legendItems) / Math.min(numItems, legendItems)) + "px";
            }
            if (viewportWidth <= mediumTileWidth) {
                legendItems = hasTitle ? 6 : 5;
                return Math.floor((mediumTileWidth - tileMargins - legendMarkerWidth * legendItems) / Math.min(numItems, legendItems)) + "px";
            }
            if (viewportWidth <= largeTileWidth) {
                legendItems = hasTitle ? 8 : 7;
                return Math.floor((largeTileWidth - tileMargins - legendMarkerWidth * legendItems) / Math.min(numItems, legendItems)) + "px";
            }
            legendItems = hasTitle ? 10 : 9;
            return Math.floor((viewportWidth - tileMargins - legendMarkerWidth * legendItems) / Math.min(numItems, legendItems)) + "px";
        }
        visuals.getLabelMaxSize = getLabelMaxSize;
        var SVGLegend = function() {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                this.svg = d3.select(element.get(0)).insert("svg", ":first-child");
                this.svg.style("display", "inherit");
                this.svg.classed("legend", true);
                this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.interactivityService = interactivityService;
                this.element = element;
                this.changeOrientation(legendPosition);
                this.parentViewport = {
                    height: 0,
                    width: 0
                };
                this.calculateViewport();
                this.updateLayout();
            }
            SVGLegend.prototype.updateLayout = function() {
                var viewport = this.viewport;
                var orientation = this.orientation;
                this.svg.attr({
                    height: viewport.height || (orientation === 4 ? 0 : this.parentViewport.height),
                    width: viewport.width || (orientation === 4 ? 0 : this.parentViewport.width)
                });
                this.svg.style({
                    "float": this.getFloat(),
                    position: orientation === 1 ? "absolute" : "",
                    bottom: orientation === 1 ? "0px" : ""
                });
            };
            SVGLegend.prototype.calculateViewport = function() {
                switch (this.orientation) {
                  case 0:
                  case 1:
                    this.viewport = {
                        height: SVGLegend.TopLegendHeight,
                        width: 0
                    };
                    return;

                  case 2:
                  case 3:
                    this.viewport = {
                        height: 0,
                        width: this.parentViewport.width * SVGLegend.LegendMaxWidthFactor
                    };
                    return;

                  case 4:
                    this.viewport = {
                        height: 0,
                        width: 0
                    };
                }
            };
            SVGLegend.prototype.getFloat = function() {
                switch (this.orientation) {
                  case 2:
                    return "right";

                  case 3:
                    return "left";

                  default:
                    return "";
                }
            };
            SVGLegend.prototype.accept = function(visitor, options) {
                visitor.visitLegend(options);
            };
            SVGLegend.prototype.getMargins = function() {
                return this.viewport;
            };
            SVGLegend.prototype.isVisible = function() {
                return this.orientation !== 4;
            };
            SVGLegend.prototype.changeOrientation = function(orientation) {
                if (orientation) {
                    this.orientation = orientation;
                } else {
                    this.orientation = 0;
                }
                this.svg.attr("orientation", orientation);
            };
            SVGLegend.prototype.getOrientation = function() {
                return this.orientation;
            };
            SVGLegend.prototype.drawLegend = function(data, viewport) {
                var marker = jsCommon.PerformanceUtil.create("drawLegend");
                this.parentViewport = viewport;
                if (data.dataPoints.length === 0) {
                    this.changeOrientation(4);
                }
                if (this.getOrientation() === 4) {
                    data.dataPoints = [];
                }
                var mapControl = this.element.children(".mapControl");
                if (mapControl.length > 0 && !this.isTopOrBottom(this.orientation)) {
                    mapControl.css("display", "inline-block");
                }
                this.calculateViewport();
                var layout = this.calculateLayout(data);
                var titleLayout = layout.title;
                var titleData = titleLayout ? [ titleLayout ] : [];
                var legendTitle = this.svg.selectAll(SVGLegend.LegendTitle.selector).data(titleData);
                legendTitle.enter().append("text").style({
                    "font-size": SVGLegend.LegendTitleTextProperties.fontSize,
                    "font-family": SVGLegend.LegendTitleTextProperties.fontFamily
                }).classed(SVGLegend.LegendTitle.class, true);
                legendTitle.text(function(d) {
                    return d.text;
                }).attr({
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y;
                    }
                });
                legendTitle.exit().remove();
                var dataPointsLayout = layout.dataPoints;
                var legendItems = this.svg.selectAll(SVGLegend.LegendItem.selector).data(dataPointsLayout, function(d) {
                    return d.label + d.color;
                });
                var itemsEnter = legendItems.enter().append("g").classed(SVGLegend.LegendItem.class, true);
                itemsEnter.append("circle").classed(SVGLegend.LegendIcon.class, true);
                itemsEnter.append("title");
                itemsEnter.append("text").classed(SVGLegend.LegendText.class, true).style({
                    "font-size": SVGLegend.LegendTextProperties.fontSize,
                    "font-family": SVGLegend.LegendTextProperties.fontFamily
                });
                legendItems.select(SVGLegend.LegendIcon.selector).attr({
                    cx: function(d, i) {
                        return d.glyphPosition.x;
                    },
                    cy: function(d) {
                        return d.glyphPosition.y;
                    },
                    r: SVGLegend.LegendIconRadius
                }).style("fill", function(d) {
                    return d.color;
                });
                legendItems.select("title").text(function(d) {
                    return d.tooltip;
                });
                legendItems.select(SVGLegend.LegendText.selector).attr({
                    x: function(d) {
                        return d.textPosition.x;
                    },
                    y: function(d) {
                        return d.textPosition.y;
                    }
                }).text(function(d) {
                    return d.label;
                });
                if (this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
                    var behaviorOptions = {
                        datapoints: dataPointsLayout,
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                legendItems.exit().remove();
                this.updateLayout();
                marker.end();
            };
            SVGLegend.prototype.calculateTitleLayout = function(title) {
                var width = 0;
                var hasTitle = !jsCommon.StringExtensions.isNullOrEmpty(title);
                if (hasTitle) {
                    var properties = SVGLegend.LegendTextProperties;
                    var text = properties.text = title;
                    var isHorizontal = this.isTopOrBottom(this.orientation);
                    var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                    var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding + fixedHorizontalIconShift;
                    var maxHorizotalSpaceAvaliable = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                    var maxMeasureLength = isHorizontal ? SVGLegend.MaxTitleLength : maxHorizotalSpaceAvaliable;
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    if (width > maxMeasureLength) {
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxMeasureLength);
                        width = maxMeasureLength;
                    }
                    if (isHorizontal) width += SVGLegend.TitlePadding;
                    return {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width
                    };
                }
                return null;
            };
            SVGLegend.prototype.calculateLayout = function(data) {
                if (data.dataPoints.length === 0) {
                    return {
                        dataPoints: [],
                        title: null
                    };
                }
                var dataPoints = data.dataPoints;
                var title = this.calculateTitleLayout(data.title);
                var copy = $.extend(true, [], dataPoints);
                if (this.isTopOrBottom(this.orientation)) return {
                    dataPoints: this.calculateHorizontalLayout(copy, title),
                    title: title
                };
                return {
                    dataPoints: this.calculateVerticalLayout(copy, title),
                    title: title
                };
            };
            SVGLegend.prototype.calculateHorizontalLayout = function(dataPoints, title) {
                var fixedTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding;
                var fixedIconShift = 11;
                var fixedTextShift = fixedIconShift + 4;
                var totalSpaceOccupiedThusFar = 0;
                var iconTotalItemPadding = SVGLegend.LegendIconRadius * 2 + SVGLegend.TextAndIconPadding * 3;
                if (title) {
                    totalSpaceOccupiedThusFar = title.width;
                    title.y = fixedTextShift;
                }
                var dataPointLength = dataPoints.length;
                var parentWidth = this.parentViewport.width;
                var maxTextLength = dataPointLength > 0 ? (parentWidth - totalSpaceOccupiedThusFar - iconTotalItemPadding * dataPointLength) / dataPointLength | 0 : 0;
                maxTextLength = maxTextLength > SVGLegend.MaxTextLength ? maxTextLength : SVGLegend.MaxTextLength;
                for (var i = 0; i < dataPointLength; i++) {
                    var dp = dataPoints[i];
                    dp.glyphPosition = {
                        x: totalSpaceOccupiedThusFar + SVGLegend.LegendIconRadius,
                        y: fixedIconShift
                    };
                    dp.textPosition = {
                        x: totalSpaceOccupiedThusFar + fixedTextShift,
                        y: fixedTextShift
                    };
                    var properties = SVGLegend.LegendTextProperties;
                    properties.text = dp.label;
                    dp.tooltip = dp.label;
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var spaceTakenByItem = 0;
                    if (width < maxTextLength) {
                        spaceTakenByItem = iconTotalItemPadding + width;
                    } else {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxTextLength);
                        dp.label = text;
                        spaceTakenByItem = iconTotalItemPadding + maxTextLength;
                    }
                    totalSpaceOccupiedThusFar += spaceTakenByItem;
                    if (totalSpaceOccupiedThusFar > parentWidth) {
                        dataPoints.length = i;
                        break;
                    }
                }
                return dataPoints;
            };
            SVGLegend.prototype.calculateVerticalLayout = function(dataPoints, title) {
                var verticalLegendHeight = 20;
                var spaceNeededByTitle = 15;
                var totalSpaceOccupiedThusFar = verticalLegendHeight;
                var extraShiftForTextAlignmentToIcon = 4;
                var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + SVGLegend.TextAndIconPadding + fixedHorizontalIconShift;
                var maxHorizotalSpaceAvaliable = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                var maxHorizontalSpaceUsed = 0;
                var parentHeight = this.parentViewport.height;
                if (title) {
                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
                    title.x = SVGLegend.TextAndIconPadding;
                    title.y = spaceNeededByTitle;
                    maxHorizontalSpaceUsed = title.width || 0;
                }
                for (var i = 0, len = dataPoints.length; i < len; i++) {
                    var dp = dataPoints[i];
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: totalSpaceOccupiedThusFar
                    };
                    dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    var properties = SVGLegend.LegendTextProperties;
                    properties.text = dp.label;
                    dp.tooltip = dp.label;
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    if (width > maxHorizontalSpaceUsed) {
                        maxHorizontalSpaceUsed = width;
                    }
                    if (width > maxHorizotalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxHorizotalSpaceAvaliable);
                        dp.label = text;
                    }
                    totalSpaceOccupiedThusFar += verticalLegendHeight;
                    if (totalSpaceOccupiedThusFar > parentHeight) {
                        dataPoints.length = i;
                        break;
                    }
                }
                if (maxHorizontalSpaceUsed + fixedHorizontalTextShift < maxHorizotalSpaceAvaliable) {
                    this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth);
                } else {
                    this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor);
                }
                return dataPoints;
            };
            SVGLegend.prototype.isTopOrBottom = function(orientation) {
                switch (orientation) {
                  case 0:
                  case 1:
                    return true;

                  default:
                    return false;
                }
            };
            SVGLegend.prototype.reset = function() {};
            SVGLegend.LegendIconRadius = 5;
            SVGLegend.MaxTextLength = 60;
            SVGLegend.MaxTitleLength = 80;
            SVGLegend.TextAndIconPadding = 5;
            SVGLegend.TitlePadding = 15;
            SVGLegend.LegendEdgeMariginWidth = 10;
            SVGLegend.LegendMaxWidthFactor = .3;
            SVGLegend.TopLegendHeight = 24;
            SVGLegend.LegendTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: "11px"
            };
            SVGLegend.LegendTitleTextProperties = {
                fontFamily: "wf_segoe-ui_Semibold",
                fontSize: "11px"
            };
            SVGLegend.LegendItem = {
                "class": "legendItem",
                selector: ".legendItem"
            };
            SVGLegend.LegendText = {
                "class": "legendText",
                selector: ".legendText"
            };
            SVGLegend.LegendIcon = {
                "class": "legendIcon",
                selector: ".legendIcon"
            };
            SVGLegend.LegendTitle = {
                "class": "legendTitle",
                selector: ".legendTitle"
            };
            return SVGLegend;
        }();
        var CartesianChartInteractiveLegend = function() {
            function CartesianChartInteractiveLegend(element) {
                this.element = element;
            }
            CartesianChartInteractiveLegend.getIconClass = function(chartType) {
                switch (chartType) {
                  case 1:
                  case 0:
                  case 2:
                    return "icon";

                  default:
                    debug.assertFail("Invalid Chart type: " + chartType);
                }
            };
            CartesianChartInteractiveLegend.prototype.getMargins = function() {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            };
            CartesianChartInteractiveLegend.prototype.drawLegend = function(legendData) {
                debug.assertValue(legendData, "legendData");
                var data = legendData.dataPoints;
                debug.assertValue(data, "dataPoints");
                if (data.length < 1) return;
                var legendContainerDiv = this.legendContainerDiv;
                if (!legendContainerDiv) {
                    if (!data.length) return;
                    var divToPrepend = $("<div></div>").height(this.getMargins().height).addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                    this.element.prepend(divToPrepend);
                    this.legendContainerDiv = legendContainerDiv = d3.select(divToPrepend.get(0));
                }
                this.drawTitle(data);
                this.drawLegendItems(data);
            };
            CartesianChartInteractiveLegend.prototype.reset = function() {
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.remove();
                    this.legendContainerDiv = null;
                }
            };
            CartesianChartInteractiveLegend.prototype.isVisible = function() {
                return true;
            };
            CartesianChartInteractiveLegend.prototype.changeOrientation = function(orientation) {};
            CartesianChartInteractiveLegend.prototype.getOrientation = function() {
                return 0;
            };
            CartesianChartInteractiveLegend.prototype.drawTitle = function(data) {
                debug.assert(data && data.length > 0, "data is null or empty");
                var titleDiv = this.legendContainerDiv.selectAll("div." + CartesianChartInteractiveLegend.LegendTitleClass);
                var item = titleDiv.data([ data[0] ]);
                var itemEnter = item.enter();
                var titleDivEnter = itemEnter.append("div").attr("class", CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter.filter(function(d) {
                    return d.iconOnlyOnLabel;
                }).append("span").attr("class", CartesianChartInteractiveLegend.legendIconClass).html(CartesianChartInteractiveLegend.legendPlaceSelector);
                titleDivEnter.append("span");
                item.filter(function(d) {
                    return d.iconOnlyOnLabel;
                }).select("span." + CartesianChartInteractiveLegend.legendIconClass).style(CartesianChartInteractiveLegend.legendColorCss, function(d) {
                    return d.color;
                });
                item.select("span:last-child").text(function(d) {
                    return d.category;
                });
            };
            CartesianChartInteractiveLegend.prototype.drawLegendItems = function(data) {
                this.ensureLegendTableCreated();
                var dataPointsMatrix = CartesianChartInteractiveLegend.splitArrayToOddEven(data);
                var legendItemsContainer = this.legendContainerDiv.select("tbody").selectAll("tr").data(dataPointsMatrix);
                var legendItemsEnter = legendItemsContainer.enter();
                var rowEnter = legendItemsEnter.append("tr");
                var cellEnter = rowEnter.selectAll("td").data(function(d) {
                    return d;
                }, function(d) {
                    return d.label;
                }).enter().append("td").attr("class", CartesianChartInteractiveLegend.LegendItem);
                var cellSpanEnter = cellEnter.append("span");
                cellSpanEnter.filter(function(d) {
                    return !d.iconOnlyOnLabel;
                }).append("span").html(CartesianChartInteractiveLegend.legendPlaceSelector).attr("class", CartesianChartInteractiveLegend.legendIconClass).style("color", function(d) {
                    return d.color;
                }).attr("white-space", "nowrap");
                cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemNameClass);
                cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemMeasureClass);
                var legendCells = legendItemsContainer.selectAll("td").data(function(d) {
                    return d;
                }, function(d) {
                    return d.label;
                });
                legendCells.select("span." + CartesianChartInteractiveLegend.legendItemNameClass).html(function(d) {
                    return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label);
                });
                legendCells.select("span." + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function(d) {
                    return "&nbsp;" + d.measure;
                });
                legendCells.exit().remove();
            };
            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function() {
                if (this.legendContainerDiv.select("div table").empty()) {
                    var legendTable = this.legendContainerDiv.append("div").append("table");
                    legendTable.style("table-layout", "fixed").append("tbody");
                    this.setPanGestureOnLegend(legendTable);
                }
            };
            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function(legendTable) {
                var viewportWidth = $(this.legendContainerDiv.select("div:nth-child(2)")[0]).width();
                var xscale = d3.scale.linear().domain([ 0, viewportWidth ]).range([ 0, viewportWidth ]);
                var zoom = d3.behavior.zoom().scaleExtent([ 1, 1 ]).x(xscale).on("zoom", function() {
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate();
                        var tx = t[0];
                        var ty = t[1];
                        tx = Math.min(tx, 0);
                        tx = Math.max(tx, viewportWidth - $(legendTable[0]).width());
                        zoom.translate([ tx, ty ]);
                        legendTable.style("transform", function() {
                            return visuals.SVGUtil.translateXWithPixels(tx);
                        });
                    }
                });
                legendTable.call(zoom);
            };
            CartesianChartInteractiveLegend.splitArrayToOddEven = function(data) {
                var oddData = [];
                var evenData = [];
                for (var i = 0; i < data.length; ++i) {
                    if (i % 2 === 0) {
                        evenData.push(data[i]);
                    } else {
                        oddData.push(data[i]);
                    }
                }
                return [ evenData, oddData ];
            };
            CartesianChartInteractiveLegend.LegendHeight = 65;
            CartesianChartInteractiveLegend.LegendContainerClass = "interactive-legend";
            CartesianChartInteractiveLegend.LegendTitleClass = "title";
            CartesianChartInteractiveLegend.LegendItem = "item";
            CartesianChartInteractiveLegend.legendPlaceSelector = "■";
            CartesianChartInteractiveLegend.legendIconClass = "icon";
            CartesianChartInteractiveLegend.legendColorCss = "color";
            CartesianChartInteractiveLegend.legendItemNameClass = "itemName";
            CartesianChartInteractiveLegend.legendItemMeasureClass = "itemMeasure";
            return CartesianChartInteractiveLegend;
        }();
        var LegendData;
        (function(LegendData) {
            function update(legendData, legendObject) {
                debug.assertValue(legendData, "legendData");
                debug.assertValue(legendObject, "legendObject");
                if (legendObject[visuals.legendProps.show] == null) {
                    legendObject[visuals.legendProps.show] = true;
                }
                if (legendObject[visuals.legendProps.show] === false) legendData.dataPoints = [];
                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null) {
                    legendObject[visuals.legendProps.position] = powerbi.legendPosition.top;
                }
                if (legendObject[visuals.legendProps.showTitle] === false) legendData.title = ""; else if (legendObject[visuals.legendProps.titleText] !== undefined) {
                    legendData.title = legendObject[visuals.legendProps.titleText];
                }
            }
            LegendData.update = update;
        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.mapCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                preferredTypes: [ {
                    geography: {
                        address: true
                    }
                }, {
                    geography: {
                        city: true
                    }
                }, {
                    geography: {
                        continent: true
                    }
                }, {
                    geography: {
                        country: true
                    }
                }, {
                    geography: {
                        county: true
                    }
                }, {
                    geography: {
                        place: true
                    }
                }, {
                    geography: {
                        postalCode: true
                    }
                }, {
                    geography: {
                        region: true
                    }
                }, {
                    geography: {
                        stateOrProvince: true
                    }
                } ]
            }, {
                name: "Series",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
            }, {
                name: "X",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Longitude"),
                preferredTypes: [ {
                    geography: {
                        longitude: true
                    }
                } ]
            }, {
                name: "Y",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Latitude"),
                preferredTypes: [ {
                    geography: {
                        latitude: true
                    }
                } ]
            }, {
                name: "Size",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            }, {
                name: "Gradient",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: true
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            }
        };
        visuals.mapProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                },
                showAllDataPoints: {
                    objectName: "dataPoint",
                    propertyName: "showAllDataPoints"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var MapServices = visuals.BI.Services.MapServices;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var MapOneD3DataPointRenderer = function() {
            function MapOneD3DataPointRenderer() {
                this.values = [];
            }
            MapOneD3DataPointRenderer.prototype.init = function(mapControl) {
                this.mapControl = mapControl;
                var root = this.mapControl.getRootElement();
                root.setAttribute("drag-resize-disabled", "true");
                var svg = this.svg = d3.select(root).append("svg").style("position", "absolute");
                this.clearCatcher = visuals.appendClearCatcher(svg);
                this.bubbleGraphicsContext = svg.append("g").classed("mapBubbles", true);
                this.sliceGraphicsContext = svg.append("g").classed("mapSlices", true);
                this.sliceLayout = d3.layout.pie().sort(null).value(function(d) {
                    return d.value;
                });
                this.arc = d3.svg.arc();
                this.clearMaxDataPointRadius();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
            };
            MapOneD3DataPointRenderer.prototype.addDataPoint = function(dataPoint) {
                this.values.push(dataPoint);
            };
            MapOneD3DataPointRenderer.prototype.clearDataPoints = function() {
                this.values = [];
            };
            MapOneD3DataPointRenderer.prototype.getDataPointCount = function() {
                return this.values.length;
            };
            MapOneD3DataPointRenderer.prototype.getDataPointPadding = function() {
                return this.maxDataPointRadius * 2;
            };
            MapOneD3DataPointRenderer.prototype.clearMaxDataPointRadius = function() {
                this.maxDataPointRadius = 0;
            };
            MapOneD3DataPointRenderer.prototype.setMaxDataPointRadius = function(dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            };
            MapOneD3DataPointRenderer.prototype.beginDataPointUpdate = function(geocodingCategory, dataPointCount) {
                this.values.length = 0;
            };
            MapOneD3DataPointRenderer.prototype.getDefaultMap = function(geocodingCategory, dataPointCount) {
                this.values.length = 0;
            };
            MapOneD3DataPointRenderer.prototype.converter = function(viewPort, dataView, interactivityService, labelSettings) {
                var mapControl = this.mapControl;
                var widthOverTwo = viewPort.width / 2;
                var heightOverTwo = viewPort.height / 2;
                this.svg.style("width", viewPort.width.toString() + "px").style("height", viewPort.width.toString() + "px");
                var strokeWidth = 1;
                this.dataLabelsSettings.show = labelSettings.show;
                this.dataLabelsSettings.labelColor = labelSettings.labelColor;
                this.dataLabelsSettings.overrideDefaultColor = labelSettings.overrideDefaultColor;
                var radiusScale = Math.min(viewPort.width, viewPort.height) / 384;
                this.clearMaxDataPointRadius();
                var bubbleData = [];
                var sliceData = [];
                var formatStringProp = visuals.mapProps.general.formatString;
                for (var i = 0, len = this.values.length; i < len; i++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var canvasDataPoint = this.values[i];
                    var categoryValue = canvasDataPoint.categoryValue;
                    var location = canvasDataPoint.cachedLocation;
                    if (location) {
                        var xy = mapControl.tryLocationToPixel(location);
                        var x = xy.x + widthOverTwo;
                        var y = xy.y + heightOverTwo;
                        var radius = canvasDataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var sliceCount = canvasDataPoint.seriesInfo.sizeValuesForGroup.length;
                        if (sliceCount === 1) {
                            var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                            var value = sizeValueForGroup.value;
                            var index = sizeValueForGroup.index;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                            var mapBubble = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                            bubbleData.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: mapBubble.fill,
                                stroke: mapBubble.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: tooltipInfo,
                                identity: visuals.SelectionId.createWithId(canvasDataPoint.categoryIdentity),
                                selected: false,
                                labelFill: labelSettings.overrideDefaultColor ? labelSettings.labelColor : mapBubble.fill
                            });
                        } else {
                            var slices = [];
                            for (var j = 0; j < sliceCount; ++j) {
                                var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[j];
                                var value = sizeValueForGroup.value;
                                var index = sizeValueForGroup.index;
                                var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                                var mapSlice = canvasDataPoint.seriesInfo.sizeValuesForGroup[j];
                                slices.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: mapSlice.fill,
                                    stroke: mapSlice.stroke,
                                    strokeWidth: strokeWidth,
                                    value: value,
                                    tooltipInfo: tooltipInfo,
                                    identity: visuals.SelectionId.createWithIds(canvasDataPoint.categoryIdentity, mapSlice.seriesId),
                                    selected: false,
                                    labelFill: labelSettings.labelColor
                                });
                            }
                            if (interactivityService) {
                                interactivityService.applySelectionStateToData(slices);
                            }
                            sliceData.push(slices);
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(bubbleData);
                }
                return {
                    bubbleData: bubbleData,
                    sliceData: sliceData
                };
            };
            MapOneD3DataPointRenderer.prototype.updateInternal = function(data) {
                var arc = this.arc;
                var hasSelection = false;
                if (visuals.dataHasSelection(data.bubbleData)) hasSelection = true;
                if (!hasSelection) {
                    for (var i = 0, ilen = data.sliceData.length; i < ilen; i++) {
                        if (visuals.dataHasSelection(data.sliceData[i])) hasSelection = true;
                    }
                }
                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function(d) {
                    return d.identity.getKey();
                });
                bubbles.enter().append("circle").classed("bubble", true);
                bubbles.attr("cx", function(d) {
                    return d.x;
                }).attr("cy", function(d) {
                    return d.y;
                }).attr("r", function(d) {
                    return d.radius;
                }).style("fill", function(d) {
                    return d.fill;
                }).style("stroke", function(d) {
                    return d.stroke;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                }).style("strokeWidth", function(d) {
                    return d.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                }).style("cursor", "default");
                bubbles.exit().remove();
                visuals.TooltipManager.addTooltip(bubbles, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                var sliceData = data.sliceData;
                var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                sliceContainers.enter().append("g").classed("sliceContainer", true);
                sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout;
                var slices = sliceContainers.selectAll(".slice").data(function(d) {
                    return sliceLayout(d);
                }, function(d) {
                    return d.data.identity.getKey();
                });
                slices.enter().append("path").classed("slice", true);
                slices.style("fill", function(t) {
                    return t.data.fill;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false);
                }).style("stroke", function(t) {
                    return t.data.stroke;
                }).style("strokeWidth", function(t) {
                    return t.data.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false);
                }).style("cursor", "default").attr("transform", function(t) {
                    return visuals.SVGUtil.translate(t.data.x, t.data.y);
                }).attr("d", function(t) {
                    return arc.innerRadius(0).outerRadius(function(t) {
                        return t.data.radius;
                    })(t);
                });
                slices.exit().remove();
                if (this.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getMapLabelLayout(this.dataLabelsSettings);
                    var dataPoints = [];
                    for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                        dataPoints.push(sliceData[i][0]);
                    }
                    for (var j = 0, jlen = data.bubbleData.length; j < jlen; j++) {
                        dataPoints.push(data.bubbleData[j]);
                    }
                    var viewPort = {
                        height: this.mapControl.getHeight(),
                        width: this.mapControl.getWidth()
                    };
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.bubbleGraphicsContext, layout, viewPort);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(this.bubbleGraphicsContext);
                }
                visuals.TooltipManager.addTooltip(slices, function(tooltipEvent) {
                    return tooltipEvent.data.data.tooltipInfo;
                });
                var allData = data.bubbleData.slice();
                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                    allData.push.apply(allData, sliceData[i]);
                }
                var behaviorOptions = {
                    bubbles: bubbles,
                    slices: this.sliceGraphicsContext.selectAll("path"),
                    clearCatcher: this.clearCatcher,
                    dataPoints: allData
                };
                return behaviorOptions;
            };
            return MapOneD3DataPointRenderer;
        }();
        visuals.MapOneD3DataPointRenderer = MapOneD3DataPointRenderer;
        var MapShapeDataPointRenderer = function() {
            function MapShapeDataPointRenderer() {
                this.values = [];
                this.dataPointCount = 0;
            }
            MapShapeDataPointRenderer.getFilledMapParams = function(category, dataCount) {
                switch (category) {
                  case visuals.BI.Services.GeocodingManager.CategoryTypes.Continent:
                  case visuals.BI.Services.GeocodingManager.CategoryTypes.CountryRegion:
                    if (dataCount < 10) {
                        return {
                            level: 2,
                            maxPolygons: 50,
                            strokeWidth: 0
                        };
                    } else if (dataCount < 30) {
                        return {
                            level: 2,
                            maxPolygons: 20,
                            strokeWidth: 0
                        };
                    }
                    return {
                        level: 1,
                        maxPolygons: 3,
                        strokeWidth: 0
                    };

                  default:
                    if (dataCount < 100) {
                        return {
                            level: 1,
                            maxPolygons: 5,
                            strokeWidth: 6
                        };
                    }
                    if (dataCount < 200) {
                        return {
                            level: 0,
                            maxPolygons: 5,
                            strokeWidth: 6
                        };
                    }
                    return {
                        level: 0,
                        maxPolygons: 5,
                        strokeWidth: 0
                    };
                }
            };
            MapShapeDataPointRenderer.buildPaths = function(locations) {
                var paths = [];
                for (var i = 0; i < locations.length; i++) {
                    var location = locations[i];
                    var polygon = location.geographic;
                    if (polygon.length > 2) {
                        paths.push(location);
                    }
                }
                return paths;
            };
            MapShapeDataPointRenderer.prototype.init = function(mapControl) {
                this.mapControl = mapControl;
                this.polygonInfo = new powerbi.visuals.MapPolygonInfo();
                var root = this.mapControl.getRootElement();
                root.setAttribute("drag-resize-disabled", "true");
                var svg = this.svg = d3.select(root).append("svg").style("position", "absolute");
                this.clearCatcher = visuals.appendClearCatcher(svg);
                this.shapeGraphicsContext = svg.append("g").classed("mapShapes", true);
                this.clearMaxShapeDimension();
            };
            MapShapeDataPointRenderer.prototype.beginDataPointUpdate = function(geocodingCategory, dataPointCount) {
                this.geocodingCategory = geocodingCategory;
                this.dataPointCount = dataPointCount;
                this.values = [];
            };
            MapShapeDataPointRenderer.prototype.addDataPoint = function(dataPoint) {
                this.values.push(dataPoint);
            };
            MapShapeDataPointRenderer.prototype.clearDataPoints = function() {
                this.values = [];
            };
            MapShapeDataPointRenderer.prototype.getDataPointCount = function() {
                return this.dataPointCount;
            };
            MapShapeDataPointRenderer.prototype.converter = function(viewport, dataView, interactivityService) {
                this.viewport = viewport;
                this.clearMaxShapeDimension();
                this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.width.toString() + "px");
                var strokeWidth = 1;
                var shapeData = [];
                var formatStringProp = visuals.mapProps.general.formatString;
                for (var categoryIndex = 0, categoryCount = this.values.length; categoryIndex < categoryCount; categoryIndex++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var canvasDataPoint = this.values[categoryIndex];
                    var categoryValue = canvasDataPoint.categoryValue;
                    var location = canvasDataPoint.cachedLocation;
                    if (location) {
                        var sizeValueForGroup = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                        var value = sizeValueForGroup.value;
                        var index = sizeValueForGroup.index;
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                        var paths = canvasDataPoint.paths;
                        var identity = visuals.SelectionId.createWithId(canvasDataPoint.categoryIdentity);
                        var idKey = identity.getKey();
                        for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                            var path = paths[pathIndex];
                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                            shapeData.push({
                                path: path.absoluteString,
                                fill: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].fill,
                                stroke: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: tooltipInfo,
                                identity: identity,
                                selected: false,
                                key: JSON.stringify({
                                    id: idKey,
                                    pIdx: pathIndex
                                })
                            });
                        }
                    }
                }
                if (interactivityService) interactivityService.applySelectionStateToData(shapeData);
                return {
                    shapeData: shapeData
                };
            };
            MapShapeDataPointRenderer.prototype.updateInternal = function(data) {
                if (!this.viewport) return;
                var viewport = this.viewport;
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                var hasSelection = visuals.dataHasSelection(data.shapeData);
                var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function(d) {
                    return d.key;
                });
                shapes.enter().append("polygon").classed("shape", true).attr("points", function(d) {
                    return d.path;
                });
                shapes.style("fill", function(d) {
                    return d.fill;
                }).style("stroke", function(d) {
                    return d.stroke;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                }).style("strokeWidth", function(d) {
                    return d.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false);
                }).style("cursor", "default");
                shapes.exit().remove();
                visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                var behaviorOptions = {
                    shapes: shapes,
                    clearCatcher: this.clearCatcher,
                    dataPoints: data.shapeData
                };
                return behaviorOptions;
            };
            MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function() {
                this.maxShapeDimension = 0;
            };
            MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function(width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
                this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            };
            MapShapeDataPointRenderer.prototype.getDataPointPadding = function() {
                return 12;
            };
            return MapShapeDataPointRenderer;
        }();
        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
        var Map = function() {
            function Map(options) {
                if (options.filledMap) {
                    this.dataPointRenderer = new MapShapeDataPointRenderer();
                    this.enableGeoShaping = true;
                } else {
                    this.dataPointRenderer = new MapOneD3DataPointRenderer();
                    this.enableGeoShaping = false;
                }
            }
            Map.prototype.init = function(options) {
                var _this = this;
                debug.assertValue(options, "options");
                var element = this.element = options.element;
                this.pendingGeocodingRender = false;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService);
                this.legendHeight = 0;
                this.legendData = {
                    dataPoints: []
                };
                this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
                this.host = options.host;
                this.resetBounds();
                jsCommon.ensureMap(function() {
                    Microsoft.Maps.loadModule("Microsoft.Maps.Overlays.Style", {
                        callback: function() {
                            _this.initialize(element[0]);
                        }
                    });
                });
            };
            Map.prototype.addDataPoint = function(dataPoint) {
                var location = dataPoint.cachedLocation;
                this.updateBounds(location.latitude, location.longitude);
                this.dataPointRenderer.addDataPoint(dataPoint);
                this.scheduleRedraw();
            };
            Map.prototype.scheduleRedraw = function() {
                var _this = this;
                if (!this.pendingGeocodingRender && this.mapControl) {
                    this.pendingGeocodingRender = true;
                    setTimeout(function() {
                        _this.updateInternal();
                        _this.pendingGeocodingRender = false;
                    }, 1e3);
                }
            };
            Map.prototype.enqueueGeoCode = function(dataPoint) {
                var _this = this;
                visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function(location) {
                    if (location) {
                        dataPoint.cachedLocation = location;
                        _this.addDataPoint(dataPoint);
                    }
                });
            };
            Map.prototype.enqueueGeoCodeAndGeoShape = function(dataPoint, params) {
                var _this = this;
                visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function(location) {
                    if (location) {
                        dataPoint.cachedLocation = location;
                        _this.enqueueGeoShape(dataPoint, params);
                    }
                });
            };
            Map.prototype.enqueueGeoShape = function(dataPoint, params) {
                var _this = this;
                debug.assertValue(dataPoint.cachedLocation, "cachedLocation");
                visuals.BI.Services.GeocodingManager.geocodeBoundary(dataPoint.cachedLocation.latitude, dataPoint.cachedLocation.longitude, this.geocodingCategory, params.level, params.maxPolygons).then(function(result) {
                    var paths;
                    if (result.locations.length === 0 || result.locations[0].geographic) {
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    } else {
                        visuals.BI.Services.MapServices.calcGeoData(result);
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    dataPoint.paths = paths;
                    _this.addDataPoint(dataPoint);
                });
            };
            Map.prototype.getOptimumLevelOfDetail = function(width, height) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (dataPointCount === 0) return MapServices.MinLevelOfDetail;
                var threshold = this.dataPointRenderer.getDataPointPadding();
                for (var levelOfDetail = MapServices.MaxLevelOfDetail; levelOfDetail >= MapServices.MinLevelOfDetail; levelOfDetail--) {
                    var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                    var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
                        if (dataPointCount < 2) levelOfDetail = Math.min(MapServices.MaxAutoZoomLevel, levelOfDetail);
                        return levelOfDetail;
                    }
                }
                return MapServices.MinLevelOfDetail;
            };
            Map.prototype.getViewCenter = function(levelOfDetail) {
                var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                return MapServices.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2, (maxXminY.y + minXmaxY.y) / 2, levelOfDetail);
            };
            Map.prototype.resetBounds = function() {
                this.minLongitude = MapServices.MaxAllowedLongitude;
                this.maxLongitude = MapServices.MinAllowedLongitude;
                this.minLatitude = MapServices.MaxAllowedLatitude;
                this.maxLatitude = MapServices.MinAllowedLatitude;
            };
            Map.prototype.updateBounds = function(latitude, longitude) {
                if (longitude < this.minLongitude) {
                    this.minLongitude = longitude;
                }
                if (longitude > this.maxLongitude) {
                    this.maxLongitude = longitude;
                }
                if (latitude < this.minLatitude) {
                    this.minLatitude = latitude;
                }
                if (latitude > this.maxLatitude) {
                    this.maxLatitude = latitude;
                }
            };
            Map.legendObject = function(dataView) {
                return dataView && dataView.metadata && dataView.metadata.objects && dataView.metadata.objects["legend"];
            };
            Map.isLegendHidden = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject != null && legendObject[visuals.legendProps.show] === false;
            };
            Map.legendPosition = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
            };
            Map.isShowLegendTitle = function(dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.showTitle];
            };
            Map.prototype.legendTitle = function() {
                var legendObject = Map.legendObject(this.dataView);
                return legendObject && legendObject[visuals.legendProps.titleText] || this.legendData.title;
            };
            Map.prototype.renderLegend = function(legendData) {
                var hideLegend = Map.isLegendHidden(this.dataView);
                var showTitle = Map.isShowLegendTitle(this.dataView);
                var title = this.legendTitle();
                var clonedLegendData = {
                    dataPoints: hideLegend ? [] : legendData.dataPoints,
                    grouped: legendData.grouped,
                    title: showTitle ? title : ""
                };
                var targetOrientation = Map.legendPosition(this.dataView);
                if (targetOrientation !== undefined && this.legend.getOrientation() !== targetOrientation) {
                    this.legend.changeOrientation(targetOrientation);
                } else {
                    this.legend.changeOrientation(0);
                }
                this.legend.drawLegend(clonedLegendData, this.currentViewport);
            };
            Map.calculateGroupSizes = function(categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                var categoryCount = categorical.values[0].values.length;
                var seriesCount = grouped.length;
                for (var i = 0, len = categoryCount; i < len; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) {
                        for (var j = 0; j < seriesCount; ++j) {
                            var value = grouped[j].values[sizeMeasureIndex].values[i];
                            if (value) {
                                if (groupTotal === null) {
                                    groupTotal = value;
                                } else {
                                    groupTotal += value;
                                }
                            }
                        }
                    }
                    groupSizeTotals.push(groupTotal);
                    if (groupTotal) {
                        if (!currentValueScale) {
                            currentValueScale = {
                                min: groupTotal,
                                max: groupTotal
                            };
                        } else {
                            currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
                            currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
                        }
                    }
                }
                return currentValueScale;
            };
            Map.createMapDataPoint = function(group, value, seriesInfo, radius, colors, categoryIdentity) {
                if (seriesInfo && seriesInfo.sizeValuesForGroup && seriesInfo.sizeValuesForGroup.length > 0) {
                    var latitude = seriesInfo.latitude;
                    var longitude = seriesInfo.longitude;
                    var dp = {
                        geocodingQuery: group,
                        location: latitude !== null && longitude !== null ? new Microsoft.Maps.Location(latitude, longitude) : null,
                        value: value,
                        radius: radius,
                        seriesInfo: seriesInfo,
                        categoryIdentity: categoryIdentity,
                        categoryValue: group
                    };
                    if (dp.geocodingQuery === null && dp.location === null) {
                        return null;
                    }
                    dp.cachedLocation = dp.location;
                    return dp;
                }
                return null;
            };
            Map.calculateSeriesLegend = function(grouped, groupIndex, sizeMeasureIndex, colors, defaultDataPointColor, seriesSource) {
                var seriesCount = grouped.length;
                var legendData = [];
                var colorHelper = new visuals.ColorHelper(colors, visuals.mapProps.dataPoint.fill, defaultDataPointColor);
                for (var i = 0; i < seriesCount; ++i) {
                    var seriesValues = grouped[i];
                    var sizeValueForCategory;
                    var measureQueryName;
                    if (sizeMeasureIndex >= 0) {
                        var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                        sizeValueForCategory = sizeMeasure.values[groupIndex];
                        measureQueryName = sizeMeasure.source.queryName;
                    } else {
                        sizeValueForCategory = null;
                        measureQueryName = "";
                    }
                    if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                        var identity = seriesValues.identity ? visuals.SelectionId.createWithId(seriesValues.identity) : visuals.SelectionId.createNull();
                        var color = seriesSource !== undefined ? colorHelper.getColorForSeriesValue(seriesValues.objects, seriesSource, seriesValues.name) : colorHelper.getColorForMeasure(seriesValues.objects, measureQueryName);
                        legendData.push({
                            color: color,
                            label: visuals.valueFormatter.format(seriesValues.name),
                            icon: 1,
                            identity: identity,
                            selected: false
                        });
                    }
                }
                return legendData;
            };
            Map.calculateSeriesInfo = function(grouped, groupIndex, sizeMeasureIndex, longitudeMeasureIndex, latitudeMeasureIndex, colors, defaultDataPointColor, objectsDefinitions, seriesSource) {
                var latitude = null;
                var longitude = null;
                var sizeValuesForGroup = [];
                var seriesCount = grouped.length;
                var colorHelper = new visuals.ColorHelper(colors, visuals.mapProps.dataPoint.fill, defaultDataPointColor);
                for (var i = 0; i < seriesCount; ++i) {
                    var seriesValues = grouped[i];
                    var sizeValueForCategory;
                    var measureQueryName;
                    if (sizeMeasureIndex >= 0) {
                        var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                        sizeValueForCategory = sizeMeasure.values[groupIndex];
                        measureQueryName = sizeMeasure.source.queryName;
                    } else {
                        sizeValueForCategory = null;
                        measureQueryName = "";
                    }
                    var objects = objectsDefinitions && objectsDefinitions[groupIndex] || seriesValues && seriesValues.objects;
                    if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                        var seriesIdentity = grouped[i].identity;
                        var color = seriesSource !== undefined ? colorHelper.getColorForSeriesValue(objects, seriesSource, seriesValues.name) : colorHelper.getColorForMeasure(objects, measureQueryName);
                        var colorRgb = jsCommon.color.parseRgb(color);
                        var stroke = jsCommon.color.rgbToHexString(jsCommon.color.darken(colorRgb, Map.StrokeDarkenColorValue));
                        var fill = jsCommon.color.rgbWithAlphaString(colorRgb, .6);
                        sizeValuesForGroup.push({
                            value: sizeValueForCategory,
                            index: i,
                            fill: fill,
                            stroke: stroke,
                            seriesId: seriesIdentity
                        });
                    }
                    latitude = Map.getOptionalMeasure(seriesValues, latitudeMeasureIndex, groupIndex, latitude);
                    longitude = Map.getOptionalMeasure(seriesValues, longitudeMeasureIndex, groupIndex, longitude);
                }
                return {
                    sizeValuesForGroup: sizeValuesForGroup,
                    latitude: latitude,
                    longitude: longitude
                };
            };
            Map.getOptionalMeasure = function(seriesValues, measureIndex, groupIndex, defaultValue) {
                if (measureIndex >= 0) {
                    var value = seriesValues.values[measureIndex].values[groupIndex];
                    if (value != null) return value;
                }
                return defaultValue;
            };
            Map.calculateRadius = function(range, rangeDiff, value) {
                var radius = 6;
                if (rangeDiff !== 0) {
                    radius = 14 * ((value - range.min) / rangeDiff) + 6;
                }
                return radius;
            };
            Map.getGeocodingCategory = function(categorical, geoTaggingAnalyzerService) {
                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                    var type = categorical.categories[0].source.type;
                    if (type && type.categoryString) {
                        return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                    }
                    var categoryName = categorical.categories[0].source.displayName;
                    var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                    if (geotaggedResult) return geotaggedResult;
                    var roles = categorical.categories[0].source.roles;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var i = 0, len = roleNames.length; i < len; ++i) {
                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                            if (typeFromRoleName) return typeFromRoleName;
                        }
                    }
                }
                return undefined;
            };
            Map.hasSizeField = function(values, defaultIndexIfNoRole) {
                if (ArrayExtensions.isUndefinedOrEmpty(values)) return false;
                for (var i = 0, ilen = values.length; i < ilen; i++) {
                    var roles = values[i].source.roles;
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric) return true;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
                            var role = roleNames[j];
                            if (role === "Size") return true;
                        }
                    }
                }
                return false;
            };
            Map.createDefaultValueColumns = function(categorical) {
                var categoryValues = [];
                if (categorical.categories && categorical.categories.length > 0) {
                    for (var i = 0, len = categorical.categories[0].values.length; i < len; i++) categoryValues.push(1);
                }
                var source = {
                    displayName: "col",
                    isMeasure: true,
                    queryName: "",
                    roles: {
                        Size: true
                    },
                    type: powerbi.ValueType.fromDescriptor({
                        numeric: true
                    }),
                    isAutoGeneratedColumn: true
                };
                var categoricalValues = [ {
                    source: source,
                    values: categoryValues
                } ];
                var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(categorical);
                var hasGradient = gradientMeasureIndex >= 0;
                if (hasGradient) {
                    var gradientColumn = categorical.values[gradientMeasureIndex];
                    categoricalValues.push(gradientColumn);
                }
                return powerbi.data.DataViewTransform.createValueColumns(categoricalValues);
            };
            Map.shouldEnumerateDataPoints = function(dataView, usesSizeForGradient) {
                var hasSeries = visuals.DataRoleHelper.hasRoleInDataView(dataView, "Series");
                var gradientRole = usesSizeForGradient ? "Size" : "Gradient";
                var hasGradientRole = visuals.DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                return hasSeries || !hasGradientRole;
            };
            Map.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "dataPoint":
                    if (Map.shouldEnumerateDataPoints(this.dataView, this.enableGeoShaping)) return this.enumerateDataPoints();
                    break;

                  case "categoryLabels":
                    return visuals.dataLabelUtils.enumerateCategoryLabels(this.dataLabelsSettings, true);

                  case "legend":
                    return Map.enumerateLegend(this.dataView, this.legend, this.legendTitle());
                }
            };
            Map.prototype.enumerateDataPoints = function() {
                var data = this.legendData;
                var instances = [];
                var hasDynamicSeries = this.hasDynamicSeries;
                var showAllDataPoints = this.showAllDataPoints;
                var seriesLength = data.dataPoints.length;
                instances.push({
                    objectName: "dataPoint",
                    selector: null,
                    properties: {
                        defaultColor: {
                            solid: {
                                color: this.defaultDataPointColor || this.colors.getColor(0).value
                            }
                        }
                    }
                });
                var showAllDataPoints = showAllDataPoints !== undefined ? showAllDataPoints : seriesLength > 1;
                instances.push({
                    objectName: "dataPoint",
                    selector: null,
                    properties: {
                        showAllDataPoints: showAllDataPoints
                    }
                });
                if (!showAllDataPoints) return instances;
                if (hasDynamicSeries) {
                    for (var i = 0; i < data.dataPoints.length; i++) {
                        var dataPoint = data.dataPoints[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: dataPoint.label,
                            selector: dataPoint.identity.getSelector(),
                            properties: {
                                fill: {
                                    solid: {
                                        color: dataPoint.color
                                    }
                                }
                            }
                        });
                    }
                } else {
                    var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.interactivityService, this.dataLabelsSettings);
                    var bubbleData = mapData.bubbleData;
                    for (var i = 0; i < bubbleData.length; i++) {
                        var bubbleDataPoint = bubbleData[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: bubbleDataPoint.labeltext,
                            selector: bubbleDataPoint.identity.getSelector(),
                            properties: {
                                fill: {
                                    solid: {
                                        color: jsCommon.color.rgbaStringToHexString(bubbleDataPoint.fill)
                                    }
                                }
                            }
                        });
                    }
                }
                return instances;
            };
            Map.enumerateLegend = function(dataView, legend, legendTitle) {
                return [ {
                    selector: null,
                    properties: {
                        show: !Map.isLegendHidden(dataView),
                        position: visuals.LegendPosition[legend.getOrientation()],
                        showTitle: Map.isShowLegendTitle(dataView),
                        titleText: legendTitle
                    },
                    objectName: "legend"
                } ];
            };
            Map.prototype.onDataChanged = function(options) {
                var _this = this;
                debug.assertValue(options, "options");
                var dataView = options.dataViews[0];
                this.dataView = dataView;
                var enableGeoShaping = this.enableGeoShaping;
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                this.defaultDataPointColor = null;
                this.showAllDataPoints = null;
                if (dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor);
                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints);
                        var labelsObj = objects["categoryLabels"];
                        if (labelsObj) {
                            this.dataLabelsSettings.show = labelsObj["show"] !== undefined ? labelsObj["show"] : this.dataLabelsSettings.show;
                            if (labelsObj["color"] !== undefined) {
                                this.dataLabelsSettings.labelColor = labelsObj["color"].solid.color;
                                this.dataLabelsSettings.overrideDefaultColor = true;
                            }
                        }
                    }
                    var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
                    if (warnings && warnings.length > 0) this.host.setWarnings(warnings);
                    var categorical = dataView.categorical;
                    if (categorical && categorical.categories && categorical.categories.length > 0) {
                        this.resetBounds();
                        var grouped;
                        if (Map.hasSizeField(categorical.values, 0)) {
                            grouped = categorical.values.grouped();
                        } else {
                            var valueColumns = Map.createDefaultValueColumns(categorical);
                            categorical.values = valueColumns;
                            grouped = [ {
                                values: valueColumns
                            } ];
                        }
                        var hasDynamicSeries = !!categorical.values.source;
                        this.hasDynamicSeries = hasDynamicSeries;
                        var seriesSource;
                        if (hasDynamicSeries) {
                            seriesSource = categorical.values.identityFields;
                        } else if (categorical.values.length > 0) {
                            seriesSource = categorical.categories[0].identityFields;
                        }
                        var sizeIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size", 0);
                        var longIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                        var latIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                        var groupSizeTotals = [];
                        this.valueScale = null;
                        this.valueScale = Map.calculateGroupSizes(categorical, grouped, groupSizeTotals, sizeIndex, this.valueScale);
                        this.geocodingCategory = Map.getGeocodingCategory(categorical, this.geoTaggingAnalyzerService);
                        var scaleDiff = this.valueScale ? this.valueScale.max - this.valueScale.min : 0;
                        jsCommon.ensureMap(function() {
                            var groupValues = categorical.categories[0].values;
                            var categoryIdentities = dataView.categorical.categories[0].identity;
                            _this.dataPointRenderer.beginDataPointUpdate(_this.geocodingCategory, groupValues.length);
                            var objectDefinitions = dataView.categorical.categories[0].objects;
                            for (var i = 0, ilen = groupValues.length; i < ilen; i++) {
                                var group = groupValues[i];
                                var value = groupSizeTotals[i];
                                var seriesInfo = Map.calculateSeriesInfo(grouped, i, sizeIndex, longIndex, latIndex, _this.colors, _this.defaultDataPointColor, objectDefinitions, seriesSource);
                                var radius = Map.calculateRadius(_this.valueScale, scaleDiff, value);
                                var params;
                                if (enableGeoShaping) {
                                    params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, groupValues.length);
                                }
                                var dp = Map.createMapDataPoint(group, value, seriesInfo, radius, _this.colors, categoryIdentities ? categoryIdentities[i] : undefined);
                                if (dp) {
                                    if (!dp.location) {
                                        if (enableGeoShaping) _this.enqueueGeoCodeAndGeoShape(dp, params); else _this.enqueueGeoCode(dp);
                                    } else if (enableGeoShaping && !dp.paths) {
                                        _this.enqueueGeoShape(dp, params);
                                    } else {
                                        _this.addDataPoint(dp);
                                    }
                                }
                            }
                            var legendDataPoints = Map.calculateSeriesLegend(grouped, i, sizeIndex, _this.colors, _this.defaultDataPointColor, seriesSource);
                            if (legendDataPoints.length === 1) legendDataPoints = [];
                            var dvValues = categorical.values;
                            var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                            _this.legendData = {
                                title: title,
                                dataPoints: legendDataPoints
                            };
                            _this.renderLegend(_this.legendData);
                        });
                    } else {
                        this.clearDataPoints();
                    }
                } else {
                    this.clearDataPoints();
                }
                this.scheduleRedraw();
            };
            Map.showLocationMissingWarningIfNecessary = function(dataView) {
                var metadata = dataView.metadata;
                if (metadata && metadata.columns) {
                    var columns = metadata.columns;
                    var foundLocation = false;
                    for (var i = 0; i < columns.length; i++) {
                        if (visuals.DataRoleHelper.hasRole(columns[i], "Category")) {
                            foundLocation = true;
                        }
                    }
                    if (!foundLocation) {
                        return [ new visuals.NoMapLocationWarning() ];
                    }
                }
                return null;
            };
            Map.prototype.onResizing = function(viewport, duration) {
                if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
                    this.currentViewport = viewport;
                    this.renderLegend(this.legendData);
                    this.updateInternal();
                }
            };
            Map.prototype.initialize = function(container) {
                var _this = this;
                var mapOptions = {
                    credentials: visuals.BI.Services.GeocodingManager.Settings.BingKey,
                    showMapTypeSelector: false,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    mapTypeId: Microsoft.Maps.MapTypeId.road,
                    customizeOverlays: true,
                    showDashboard: false,
                    showScalebar: false,
                    disableKeyboardInput: true
                };
                var divQuery = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                this.mapControl = new Microsoft.Maps.Map(divQuery[0], mapOptions);
                Microsoft.Maps.Events.addHandler(this.mapControl, "viewchange", function() {
                    _this.onViewChanged();
                });
                this.dataPointRenderer.init(this.mapControl);
                if (!this.pendingGeocodingRender) {
                    this.updateInternal();
                }
            };
            Map.prototype.onViewChanged = function() {
                this.updateOffsets();
            };
            Map.prototype.getMapViewPort = function() {
                var currentViewport = this.currentViewport;
                var legendMargins = this.legend.getMargins();
                var mapViewport = {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height
                };
                return mapViewport;
            };
            Map.prototype.updateInternal = function() {
                if (this.mapControl) {
                    var legendHeight = this.legend.getMargins().height;
                    if (legendHeight <= 1) this.legendData = {
                        dataPoints: []
                    };
                    var mapDiv = this.element.children(Map.MapContainer.selector);
                    var mapViewport = this.getMapViewPort();
                    mapDiv.height(mapViewport.height);
                    mapDiv.width(mapViewport.width);
                    this.updateOffsets();
                    var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
                    var center = this.getViewCenter(levelOfDetail);
                    this.mapControl.setView({
                        center: center,
                        zoom: levelOfDetail,
                        animate: true
                    });
                }
            };
            Map.prototype.updateOffsets = function() {
                var dataView = this.dataView;
                var data;
                if (dataView && dataView.categorical) {
                    var viewPort = this.getMapViewPort();
                    data = this.dataPointRenderer.converter(viewPort, this.dataView, this.interactivityService, this.dataLabelsSettings);
                } else {
                    data = {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: []
                    };
                }
                var behaviorOptions = this.dataPointRenderer.updateInternal(data);
                if (this.interactivityService && behaviorOptions) {
                    this.interactivityService.apply(this, behaviorOptions);
                }
            };
            Map.prototype.accept = function(visitor, options) {
                visitor.visitMap(options);
            };
            Map.prototype.onClearSelection = function() {
                this.interactivityService.clearSelection();
                this.updateOffsets();
            };
            Map.prototype.clearDataPoints = function() {
                this.dataPointRenderer.clearDataPoints();
            };
            Map.MapContainer = {
                cssClass: "visual mapControl",
                selector: ".visual.mapControl"
            };
            Map.StrokeDarkenColorValue = 255 * .25;
            return Map;
        }();
        visuals.Map = Map;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var MultiRowCard = function() {
            function MultiRowCard() {
                this.isCardWrapped = false;
                this.isInteractivityOverflowHidden = false;
            }
            MultiRowCard.prototype.init = function(options) {
                debug.assertValue(options, "options");
                this.options = options;
                this.style = options.style;
                var viewport = this.currentViewport = options.viewport;
                var interactivity = this.interactivity = options.interactivity;
                if (interactivity && interactivity.overflow === "hidden") this.isInteractivityOverflowHidden = true;
                this.settings = MultiRowCard.DefaultStyle;
                var multiRowCardDiv = $("<div/>").addClass(MultiRowCard.multiRowCardClass);
                options.element.append(multiRowCardDiv);
                var element = this.element = multiRowCardDiv;
                element.css("height", this.getPixelString(viewport.height));
                this.initializeCardRowSelection();
            };
            MultiRowCard.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                }
                var resetScrollbarPosition = options.operationKind !== 1;
                this.updateInternal(resetScrollbarPosition);
                this.waitingForData = false;
            };
            MultiRowCard.prototype.onResizing = function(viewport, duration) {
                var viewport = this.currentViewport = viewport;
                this.element.css("height", this.getPixelString(viewport.height));
                this.updateInternal();
            };
            MultiRowCard.converter = function(dataView, columnCount, maxCards, isDashboardVisual) {
                if (isDashboardVisual === void 0) {
                    isDashboardVisual = false;
                }
                var details = [];
                var tableDataRows = dataView.table.rows;
                var columnMetadata = dataView.table.columns;
                for (var i = 0, len = maxCards; i < len; i++) {
                    var row = tableDataRows[i];
                    var isValuePromoted = undefined;
                    var title = undefined;
                    var cardData = [];
                    for (var j = 0; j < columnCount; j++) {
                        var column = columnMetadata[j];
                        var columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp));
                        var columnDetail = columnMetadata[j].displayName;
                        if (!isDashboardVisual && !column.type.numeric) {
                            if (isValuePromoted === undefined) {
                                isValuePromoted = true;
                                title = columnCaption;
                            } else if (isValuePromoted) {
                                isValuePromoted = false;
                            }
                        }
                        cardData.push({
                            caption: columnCaption,
                            details: columnDetail
                        });
                    }
                    details.push({
                        title: isValuePromoted ? title : undefined,
                        cardItemsData: isValuePromoted ? cardData.filter(function(d) {
                            return d.caption !== title;
                        }) : cardData
                    });
                }
                return details;
            };
            MultiRowCard.prototype.updateInternal = function(resetScrollbarPosition) {
                if (resetScrollbarPosition === void 0) {
                    resetScrollbarPosition = false;
                }
                var dataView = this.dataView;
                if (!(dataView && dataView.metadata && dataView.table && dataView.table.rows && dataView.table.rows.length > 0 && dataView.table.columns && dataView.table.columns.length > 0)) {
                    this.listView.empty();
                    return;
                }
                this.setCardDimensions();
                var cardHeightTotal = this.cardHeightTotal;
                var dataModel = this.dataModel;
                debug.assertValue(cardHeightTotal, "cardHeightTotal");
                debug.assert(cardHeightTotal > 0, "cardHeightTotal should be more than 0");
                this.listView.viewport(this.currentViewport).rowHeight(cardHeightTotal).data(dataModel, function(d) {
                    return dataModel.indexOf(d);
                }).render(true, resetScrollbarPosition);
            };
            MultiRowCard.prototype.initializeCardRowSelection = function() {
                var _this = this;
                var settings = this.settings;
                var cardHeightTotal = this.cardHeightTotal;
                var rowHeight = this.cardHeight;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var rowEnter = function(rowSelection) {
                    var cardRow = rowSelection.append("div").style({
                        color: settings.card.color,
                        "overflow-y": "hidden",
                        "box-sizing": "border-box"
                    }).classed(MultiRowCard.Card.class, true);
                    if (isDashboardVisual) {
                        cardRow.style("padding-top", _this.isCardWrapped ? "0px" : _this.getPixelString(settings.card.topPadding));
                    } else {
                        cardRow.style({
                            "border-left": _this.getPixelString(settings.card.leftBorderWidth) + " " + settings.card.borderStyle,
                            "border-left-color": settings.card.leftBorderColor,
                            "padding-left": _this.getPixelString(settings.card.leftPadding)
                        });
                        if (_this.cardHasTitle) {
                            cardRow.append("div").classed(MultiRowCard.Title.class, true).style({
                                height: _this.getPixelString(settings.title.height),
                                "margin-bottom": _this.isCardWrapped ? "0px" : _this.getPixelString(settings.title.marginBottom)
                            });
                        }
                    }
                    var cardItem = cardRow.selectAll(MultiRowCard.CardItemContainer.selector).data(function(d) {
                        return d.cardItemsData;
                    }).enter().append("div").classed(MultiRowCard.CardItemContainer.class, true).style({
                        "box-sizing": "border-box",
                        height: _this.getPixelString(_this.cardItemContainerHeight),
                        "margin-right": _this.isSingleValueCard ? "0px" : _this.getPixelString(settings.cardItemContainer.marginRight),
                        "float": "left",
                        "padding-top": _this.isCardWrapped ? isDashboardVisual ? _this.getPixelString(settings.cardItemContainer.topPadding) : _this.getPixelString(settings.cardItemContainer.topPaddingCanvas) : "0px"
                    });
                    cardItem.append("div").classed(MultiRowCard.Caption.class, true).style({
                        height: _this.getPixelString(settings.caption.height),
                        "font-size": _this.getPixelString(settings.caption.fontSize),
                        color: settings.caption.color,
                        "text-align": "left",
                        "white-space": "nowrap",
                        "text-overflow": "ellipsis",
                        overflow: "hidden"
                    });
                    cardItem.append("div").classed(MultiRowCard.Details.class, true).style({
                        height: _this.getPixelString(settings.details.height),
                        "font-size": _this.getPixelString(settings.details.fontSize),
                        color: settings.details.color,
                        "text-align": "left",
                        "white-space": "nowrap",
                        "text-overflow": "ellipsis",
                        overflow: "hidden"
                    });
                };
                var rowUpdate = function(rowSelection) {
                    rowHeight = _this.cardHeight;
                    if (!isDashboardVisual && _this.cardHasTitle) rowSelection.selectAll(MultiRowCard.Title.selector).text(function(d) {
                        return d.title;
                    });
                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector).style({
                        height: _this.getPixelString(rowHeight),
                        width: _this.getPixelString(_this.cardWidth)
                    });
                    var cardItemContainerWidth = _this.isSingleValueCard ? _this.columnWidth : _this.columnWidth - settings.cardItemContainer.marginRight;
                    cardSelection.selectAll(MultiRowCard.CardItemContainer.selector).style("width", _this.getPixelString(cardItemContainerWidth));
                    cardSelection.selectAll(MultiRowCard.Caption.selector).text(function(d) {
                        return d.caption;
                    });
                    cardSelection.selectAll(MultiRowCard.Details.selector).text(function(d) {
                        return d.details;
                    });
                    if (isDashboardVisual) {
                        var dataModel = _this.dataModel;
                        if (dataModel && dataModel.length > 0) cardSelection = cardSelection.filter(function(d) {
                            return d !== dataModel[dataModel.length - 1];
                        });
                        cardSelection.style({
                            "border-bottom-style": settings.card.borderStyle,
                            "border-bottom-width": _this.getPixelString(settings.card.bottomBorderWidth),
                            "border-bottom-color": settings.card.borderColor,
                            "padding-bottom": _this.getPixelString(settings.card.bottomPadding)
                        });
                    }
                    cardSelection.style("margin-bottom", isDashboardVisual ? "0px" : _this.isSingleRowCard ? "0px" : _this.getPixelString(settings.card.marginBottom));
                };
                var rowExit = function(rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: cardHeightTotal,
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function() {
                        return _this.onLoadMoreData();
                    },
                    viewport: this.currentViewport,
                    baseContainer: d3.select(this.element.get(0))
                };
                this.listView = visuals.ListViewFactory.createHTMLListView(listViewOptions);
            };
            MultiRowCard.prototype.setCardDimensions = function() {
                var dataView = this.dataView;
                debug.assertValue(dataView, "dataView");
                var columnMetadata = dataView.table.columns;
                var tableRows = dataView.table.rows;
                var viewport = this.currentViewport;
                var settings = this.settings;
                var cardRowColumnCount = 0;
                var maxCardColumns = cardRowColumnCount = columnMetadata.length;
                var viewportWidth = viewport.width;
                this.cardHasTitle = false;
                if (this.isInteractivityOverflowHidden) {
                    if (viewportWidth <= MultiRowCard.SmallTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsSmallTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsSmallTile, maxCardColumns);
                    } else if (viewportWidth <= MultiRowCard.MediumTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsMediumTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsMediumTile, maxCardColumns);
                    } else if (viewportWidth <= MultiRowCard.LargeTileWidth) {
                        cardRowColumnCount = Math.min(settings.cardRowColumns.maxRowColumnsLargeTile, cardRowColumnCount);
                        maxCardColumns = Math.min(settings.cardItems.maxItemsLargeTile, maxCardColumns);
                    }
                    this.calculateCardDimensions(viewport, cardRowColumnCount, maxCardColumns, tableRows.length);
                    this.dataModel = MultiRowCard.converter(dataView, maxCardColumns, this.maxCardsDisplayed, this.isInteractivityOverflowHidden);
                } else {
                    var dataModel = this.dataModel = MultiRowCard.converter(dataView, maxCardColumns, tableRows.length);
                    maxCardColumns = 0;
                    if (dataModel && dataModel.length > 0) {
                        maxCardColumns = dataModel[0].cardItemsData ? dataModel[0].cardItemsData.length : 0;
                        this.cardHasTitle = dataModel[0].title !== undefined;
                        this.isSingleRowCard = dataModel.length === 1 ? true : false;
                    }
                    this.calculateCardDimensions(viewport, maxCardColumns, maxCardColumns, dataModel.length);
                    if (this.cardHasTitle) {
                        var cardHeight = this.cardHeight += settings.title.height + (this.isCardWrapped ? 0 : settings.title.marginBottom);
                        this.cardHeightTotal = this.getTotalCardHeight(cardHeight);
                    }
                }
            };
            MultiRowCard.prototype.calculateCardDimensions = function(viewport, cardRowColumnCount, maxCardColumns, maxCards) {
                var settings = this.settings;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var cardWidth = viewport.width - settings.scrollbar.padding;
                var cardRowColumnCountDisplayed = cardRowColumnCount;
                var cardItemContainerHeight = settings.caption.height + settings.details.height;
                var isCardWrapped = false;
                if (!isDashboardVisual) cardWidth -= settings.card.leftBorderWidth + settings.card.leftPadding;
                var columnWidth = cardWidth / cardRowColumnCount;
                if (cardRowColumnCount === maxCardColumns) {
                    columnWidth = Math.max(columnWidth, settings.cardItemContainer.maxWidth);
                    columnWidth = Math.min(columnWidth, cardWidth);
                    cardRowColumnCountDisplayed = Math.floor(cardWidth / columnWidth);
                }
                this.isSingleValueCard = cardRowColumnCountDisplayed === 1;
                var totalRowsDisplayed = Math.ceil(maxCardColumns / cardRowColumnCountDisplayed);
                if (totalRowsDisplayed > 1) {
                    cardItemContainerHeight += isDashboardVisual ? settings.cardItemContainer.topPadding : settings.cardItemContainer.topPaddingCanvas;
                    columnWidth = cardWidth / cardRowColumnCountDisplayed;
                    isCardWrapped = true;
                }
                var cardHeight = Math.ceil(totalRowsDisplayed * cardItemContainerHeight);
                if (isDashboardVisual) {
                    cardHeight += settings.card.bottomBorderWidth + settings.card.bottomPadding + settings.card.topPadding;
                }
                var cardHeightTotal = cardHeight;
                if (isDashboardVisual) {
                    maxCards = Math.min(Math.floor(viewport.height / cardHeight), maxCards);
                } else {
                    cardHeightTotal = this.getTotalCardHeight(cardHeight);
                    cardWidth += settings.card.leftBorderWidth + settings.card.leftPadding;
                }
                this.cardHeight = cardHeight;
                this.columnWidth = columnWidth;
                this.cardWidth = cardWidth;
                this.cardHeightTotal = cardHeightTotal;
                this.maxCardsDisplayed = maxCards;
                this.cardItemContainerHeight = cardItemContainerHeight;
                this.isCardWrapped = isCardWrapped;
            };
            MultiRowCard.prototype.getPixelString = function(value) {
                return value + "px";
            };
            MultiRowCard.prototype.onLoadMoreData = function() {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.options.host.loadMoreData();
                    this.waitingForData = true;
                }
            };
            MultiRowCard.prototype.getTotalCardHeight = function(cardHeight) {
                return cardHeight + (this.isSingleRowCard ? 0 : this.settings.card.marginBottom);
            };
            MultiRowCard.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            MultiRowCard.multiRowCardClass = "multiRowCard";
            MultiRowCard.Card = {
                "class": "card",
                selector: ".card"
            };
            MultiRowCard.Title = {
                "class": "title",
                selector: ".title"
            };
            MultiRowCard.CardItemContainer = {
                "class": "cardItemContainer",
                selector: ".cardItemContainer"
            };
            MultiRowCard.Caption = {
                "class": "caption",
                selector: ".caption"
            };
            MultiRowCard.Details = {
                "class": "details",
                selector: ".details"
            };
            MultiRowCard.SmallTileWidth = 250;
            MultiRowCard.MediumTileWidth = 490;
            MultiRowCard.LargeTileWidth = 750;
            MultiRowCard.DefaultStyle = {
                card: {
                    bottomBorderWidth: 1,
                    leftBorderWidth: 3,
                    borderStyle: "solid",
                    leftBorderColor: "#A6A6A6",
                    borderColor: "#C8C8C8",
                    bottomPadding: 5,
                    leftPadding: 10,
                    topPadding: 5,
                    color: "#767676",
                    marginBottom: 20
                },
                title: {
                    height: 37,
                    marginBottom: 5
                },
                cardItemContainer: {
                    marginRight: 20,
                    maxWidth: 100,
                    topPadding: 5,
                    topPaddingCanvas: 7
                },
                caption: {
                    height: 20,
                    fontSize: 14,
                    color: "#333333"
                },
                details: {
                    height: 16,
                    fontSize: 12,
                    color: "#A6A6A6"
                },
                scrollbar: {
                    padding: 8
                },
                cardItems: {
                    maxItemsSmallTile: 4,
                    maxItemsMediumTile: 6,
                    maxItemsLargeTile: 6
                },
                cardRowColumns: {
                    maxRowColumnsSmallTile: 2,
                    maxRowColumnsMediumTile: 3,
                    maxRowColumnsLargeTile: 6
                },
                cards: {
                    maxCardsSmallTile: 1,
                    maxCardsMediumTile: 3,
                    maxCardsLargeTile: 8
                }
            };
            MultiRowCard.capabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: 2,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields")
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    table: {
                        rows: {
                            "for": {
                                "in": "Values"
                            },
                            dataReductionAlgorithm: {
                                window: {}
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                } ],
                suppressDefaultTitle: true
            };
            return MultiRowCard;
        }();
        visuals.MultiRowCard = MultiRowCard;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var RichTextbox = function() {
            function RichTextbox() {}
            RichTextbox.prototype.init = function(options) {
                this.element = options.element;
                this.host = options.host;
                this.viewPort = options.viewport;
                this.element.addClass("richtextbox");
                this.element.css({
                    "font-family": RichText.defaultFont,
                    "font-size": RichText.defaultFontSize
                });
                this.readOnly = this.host.getViewMode() === 0;
                this.paragraphs = [];
                this.refreshView();
            };
            RichTextbox.prototype.onResizing = function(viewport, duration) {
                this.viewPort = viewport;
                this.updateSize();
            };
            RichTextbox.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                var dataViews = options.dataViews;
                this.paragraphs = [];
                if (dataViews && dataViews.length > 0) {
                    var objects = dataViews[0].metadata.objects;
                    if (objects && objects.general) this.paragraphs = objects.general.paragraphs;
                }
                this.refreshView();
            };
            RichTextbox.prototype.destroy = function() {};
            RichTextbox.prototype.onViewModeChanged = function(viewMode) {
                this.readOnly = viewMode === 0;
                this.refreshView();
            };
            RichTextbox.prototype.setSelection = function(start, end) {
                debug.assertValue(this.editor, "editor");
                if (this.editor) this.editor.setSelection(start, end);
            };
            RichTextbox.prototype.refreshView = function() {
                var _this = this;
                if (this.readOnly) {
                    if (this.editor) {
                        this.editor.formatUrls();
                        this.saveContents();
                        this.editor = null;
                    }
                    this.element.empty();
                    this.element.append(RichTextbox.convertParagraphsToHtml(this.paragraphs));
                } else {
                    if (!this.editor) {
                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host);
                        this.editor.textChanged = function(delta, source) {
                            return _this.saveContents();
                        };
                        this.element.empty();
                        this.element.append(this.editor.getElement());
                    }
                    this.editor.setContents(RichTextbox.convertParagraphsToOps(this.paragraphs));
                }
                this.updateSize();
            };
            RichTextbox.prototype.saveContents = function() {
                if (!this.editor) return;
                var contents = this.editor.getContents();
                this.paragraphs = RichTextbox.convertDeltaToParagraphs(contents);
                var changes = [ {
                    objectName: "general",
                    properties: {
                        paragraphs: this.paragraphs
                    },
                    selector: null
                } ];
                this.host.persistProperties(changes);
            };
            RichTextbox.prototype.updateSize = function() {
                if (this.editor) this.editor.resize(this.viewPort);
            };
            RichTextbox.convertDeltaToParagraphs = function(contents) {
                var paragraphs = [];
                var paragraph = {
                    textRuns: []
                };
                for (var i = 0, len = contents.ops.length; i < len; i++) {
                    var insertOp = contents.ops[i];
                    debug.assertValue(insertOp, "operation should be an insert");
                    if (typeof insertOp.insert === "string") {
                        var text = insertOp.insert;
                        var attributes = insertOp.attributes;
                        if (attributes && attributes.align) {
                            debug.assert(paragraph.horizontalTextAlignment === undefined || paragraph.horizontalTextAlignment === attributes.align, "paragraph should not have more than one horizontal alignment");
                            paragraph.horizontalTextAlignment = attributes.align;
                        }
                        var start = 0;
                        var end = 0;
                        var newParagraph;
                        do {
                            end = text.indexOf("\n", start);
                            if (end < 0) {
                                newParagraph = false;
                                end = text.length;
                            } else {
                                newParagraph = true;
                            }
                            if (end - start > 0) {
                                var span = text.substring(start, end);
                                var textRun = {
                                    value: span
                                };
                                if (attributes) {
                                    if (attributes.link !== undefined) textRun.url = attributes.link;
                                    var textStyle = RichTextbox.convertFormatAttributesToTextStyle(attributes);
                                    if (textStyle) textRun.textStyle = textStyle;
                                }
                                paragraph.textRuns.push(textRun);
                            }
                            if (newParagraph) {
                                if (paragraph.textRuns.length === 0) paragraph.textRuns.push({
                                    value: ""
                                });
                                paragraphs.push(paragraph);
                                paragraph = {
                                    textRuns: []
                                };
                            }
                            start = end + 1;
                        } while (start < text.length);
                    } else {
                        debug.assertFail("embeds not supported");
                    }
                }
                if (paragraph.textRuns.length > 0) {
                    if (paragraph.textRuns[0].value.length > 0) paragraphs.push(paragraph);
                }
                return paragraphs;
            };
            RichTextbox.convertParagraphsToHtml = function(paragraphs) {
                var $paragraphs = $();
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    var isParagraphEmpty = true;
                    var $paragraph = $("<div>");
                    if (paragraphDef.horizontalTextAlignment) $paragraph.css("text-align", paragraphDef.horizontalTextAlignment);
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var $textRun = $("<span>");
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            var css = {};
                            if (styleDef.fontFamily) {
                                css["font-family"] = RichText.getFontFamily(styleDef.fontFamily);
                            }
                            if (styleDef.fontSize) {
                                css["font-size"] = styleDef.fontSize;
                            }
                            if (styleDef.fontStyle) {
                                css["font-style"] = styleDef.fontStyle;
                            }
                            if (styleDef.fontWeight) {
                                css["font-weight"] = styleDef.fontWeight;
                            }
                            if (styleDef.textDecoration) {
                                css["text-decoration"] = styleDef.textDecoration;
                            }
                            $textRun.css(css);
                        }
                        var text = textRunDef.value;
                        if (!jsCommon.StringExtensions.isNullOrEmpty(text)) isParagraphEmpty = false;
                        if (textRunDef.url !== undefined) {
                            var $link = $("<a>").attr("href", textRunDef.url).attr("target", "_blank").text(text);
                            $textRun.append($link);
                        } else {
                            $textRun.text(text);
                        }
                        $paragraph.append($textRun);
                    }
                    if (isParagraphEmpty) $paragraph.append($("<br>"));
                    $paragraphs = $paragraphs.add($paragraph);
                }
                return $paragraphs;
            };
            RichTextbox.convertParagraphsToOps = function(paragraphs) {
                var ops = [];
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var formats = {};
                        if (paragraphDef.horizontalTextAlignment) formats.align = paragraphDef.horizontalTextAlignment;
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                formats.font = RichText.getFontFamily(styleDef.fontFamily);
                            }
                            if (styleDef.fontSize) {
                                formats.size = styleDef.fontSize;
                            }
                            formats.italic = styleDef.fontStyle === "italic";
                            formats.bold = styleDef.fontWeight === "bold";
                            formats.underline = styleDef.textDecoration === "underline";
                        }
                        var text = textRunDef.value;
                        var op = {
                            insert: text,
                            attributes: formats
                        };
                        ops.push(op);
                        if (textRunIndex === jlen - 1 && !jsCommon.StringExtensions.endsWith(text, "\n")) {
                            ops.push({
                                insert: "\n",
                                attributes: formats
                            });
                        }
                    }
                }
                return ops;
            };
            RichTextbox.convertFormatAttributesToTextStyle = function(attributes) {
                var style = {};
                if (attributes.bold) {
                    style.fontWeight = "bold";
                }
                if (attributes.font) {
                    style.fontFamily = attributes.font;
                }
                if (attributes.italic) {
                    style.fontStyle = "italic";
                }
                if (attributes.size) {
                    style.fontSize = attributes.size;
                }
                if (attributes.underline) {
                    style.textDecoration = "underline";
                }
                return style;
            };
            RichTextbox.capabilities = {
                objects: {
                    general: {
                        properties: {
                            paragraphs: {
                                type: {}
                            }
                        }
                    }
                },
                suppressDefaultTitle: true
            };
            return RichTextbox;
        }();
        visuals.RichTextbox = RichTextbox;
        var RichText;
        (function(RichText) {
            var fontMap = {
                "Segoe (Bold)": "wf_segoe-ui_bold",
                "Segoe UI": "wf_segoe-ui_normal",
                "Segoe UI Light": "wf_segoe-ui_light",
                Heading: "wf_segoe-ui_light",
                Body: "wf_segoe-ui_normal"
            };
            var fonts = [ "Arial", "Arial Black", "Arial Unicode MS", "Calibri", "Cambria", "Cambria Math", "Candara", "Comic Sans MS", "Consolas", "Constantia", "Corbel", "Courier New", "Georgia", "Lucida Sans Unicode", "Segoe (Bold)", "Segoe UI", "Segoe UI Light", "Symbol", "Tahoma", "Times New Roman", "Trebuchet MS", "Verdana", "Wingdings", "Wingdings 2", "Wingdings 3" ].map(function(font) {
                return {
                    label: font,
                    value: getFontFamily(font)
                };
            });
            RichText.defaultFont = getFontFamily("Segoe UI Light");
            var fontSizes = [ "8", "9", "10", "10.5", "11", "12", "14", "16", "18", "20", "24", "28", "32", "36", "40", "42", "44", "54", "60", "66", "72", "80", "88", "96" ].map(function(size) {
                return {
                    label: size,
                    value: size + "px"
                };
            });
            RichText.defaultFontSize = "14px";
            var textAlignments = [ "Left", "Center", "Right" ].map(function(alignment) {
                return {
                    label: alignment,
                    value: alignment.toLowerCase()
                };
            });
            function getFontFamily(font) {
                var family = fontMap[font];
                return family !== undefined ? family : font;
            }
            RichText.getFontFamily = getFontFamily;
            var QuillWrapper = function() {
                function QuillWrapper(readOnly, host) {
                    var _this = this;
                    this.QuillPackage = {
                        javaScriptFiles: QuillWrapper.quillJsFiles,
                        cssFiles: QuillWrapper.quillCssFiles
                    };
                    this.textChanged = function(d, s) {};
                    this.host = host;
                    this.$container = $("<div>");
                    this.readOnly = readOnly;
                    this.localizationProvider = {
                        get: function(stringId) {
                            return _this.host.getLocalizedString(stringId);
                        }
                    };
                    if (QuillWrapper.loadQuillResources) {
                        this.initialized = false;
                        this.dependenciesLoaded = $.Deferred();
                        this.dependenciesLoaded.done(function() {
                            _this.rebuildQuillEditor();
                            _this.initialized = true;
                        });
                        jsCommon.requires(this.QuillPackage, function() {
                            return _this.dependenciesLoaded.resolve();
                        });
                    } else {
                        this.rebuildQuillEditor();
                        this.initialized = true;
                    }
                }
                QuillWrapper.prototype.getElement = function() {
                    return this.$container;
                };
                QuillWrapper.prototype.getToolbar = function() {
                    return this.$toolbarDiv;
                };
                QuillWrapper.prototype.getContents = function() {
                    return this.editor.getContents();
                };
                QuillWrapper.prototype.setContents = function(contents) {
                    var _this = this;
                    if (!this.initialized) {
                        this.dependenciesLoaded.done(function() {
                            return _this.setContents(contents);
                        });
                        return;
                    }
                    this.editor.setHTML("", "api");
                    if (contents) this.editor.setContents(contents, "api");
                    this.formatUrls();
                };
                QuillWrapper.prototype.resize = function(viewport) {
                    if (!this.initialized) return;
                    this.$container.width(viewport.width);
                    this.$container.height(viewport.height);
                };
                QuillWrapper.prototype.setReadOnly = function(readOnly) {
                    var readOnlyChanged = readOnly !== this.readOnly;
                    this.readOnly = readOnly;
                    if (this.initialized && readOnlyChanged) {
                        this.rebuildQuillEditor();
                    }
                };
                QuillWrapper.prototype.formatUrls = function() {
                    var text = this.editor.getText();
                    var urlRegex = /http[s]?:\/\/(\S)+/gi;
                    this.editor.formatText(0, text.length, "link", false, "api");
                    var matches;
                    while ((matches = urlRegex.exec(text)) !== null) {
                        var url = matches[0];
                        var start = matches.index;
                        var end = urlRegex.lastIndex;
                        this.editor.formatText(start, end, "link", url, "api");
                    }
                };
                QuillWrapper.prototype.setSelection = function(start, end) {
                    this.editor.setSelection(start, end, "api");
                };
                QuillWrapper.prototype.getSelection = function() {
                    return this.editor.getSelection();
                };
                QuillWrapper.prototype.rebuildQuillEditor = function() {
                    var _this = this;
                    var contents = null;
                    if (this.editor) {
                        this.editor.removeAllListeners();
                        contents = this.editor.getContents();
                    }
                    this.$container.empty();
                    this.$container.keydown(function(e) {
                        return e.stopPropagation();
                    });
                    var $editorDiv = this.$editorDiv = $("<div>");
                    $editorDiv.css("font-family", RichText.defaultFont);
                    $editorDiv.css("font-size", RichText.defaultFontSize);
                    var configs = {
                        readOnly: this.readOnly,
                        formats: [ "bold", "italic", "underline", "font", "size", "link", "align" ]
                    };
                    this.editor = new Quill($editorDiv.get(0), configs);
                    if (!this.readOnly) {
                        var $toolbarDiv = this.$toolbarDiv;
                        if (!$toolbarDiv) {
                            var toolbar = new Toolbar.Toolbar(this.editor, this.localizationProvider);
                            this.$toolbarDiv = $toolbarDiv = toolbar.$container;
                        }
                        $toolbarDiv.addClass("unselectable");
                        this.host.setToolbar($toolbarDiv);
                        this.editor.addModule("toolbar", {
                            container: $toolbarDiv.get(0)
                        });
                        $editorDiv.attr("drag-resize-disabled", "true");
                    }
                    this.$container.append($editorDiv);
                    if (contents) this.setContents(contents);
                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                    this.editor.on("text-change", function(delta, source) {
                        if (source !== "api") textChangeThrottler.run(function() {
                            return _this.onTextChanged(delta, source);
                        });
                    });
                    var formatUrlThrottler = new jsCommon.ThrottleUtility(QuillWrapper.formatUrlThrottle);
                    this.editor.on("text-change", function(delta, source) {
                        if (source !== "api") formatUrlThrottler.run(function() {
                            return _this.formatUrls();
                        });
                    });
                    this.editor.root.addEventListener("blur", function(event) {
                        var target = event.relatedTarget || document.activeElement;
                        if (target && target.tagName === "SELECT") {
                            return;
                        }
                        _this.setSelection(null, null);
                    }, false);
                    try {
                        this.editor.focus();
                    } catch (e) {}
                };
                QuillWrapper.prototype.onTextChanged = function(delta, source) {
                    this.textChanged(delta, source);
                };
                QuillWrapper.textChangeThrottle = 200;
                QuillWrapper.formatUrlThrottle = 1e3;
                QuillWrapper.loadQuillResources = true;
                QuillWrapper.quillJsFiles = [ powerbi.build + "/externals/quill.min.js" ];
                QuillWrapper.quillCssFiles = [ powerbi.build + "/externals/quill.base.css" ];
                return QuillWrapper;
            }();
            RichText.QuillWrapper = QuillWrapper;
            var Toolbar;
            (function(_Toolbar) {
                function setSelectValue($select, value) {
                    $select.val(value);
                    var evt = document.createEvent("UIEvent");
                    evt.initUIEvent("change", false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                _Toolbar.setSelectValue = setSelectValue;
                function formatGroup() {
                    return span().addClass("ql-format-group").attr("drag-resize-disabled", "true");
                }
                function label(text) {
                    return $("<label>").text(text);
                }
                function div() {
                    return $("<div>");
                }
                function span() {
                    return $("<span>");
                }
                var Toolbar = function() {
                    function Toolbar(editor, localizationProvider) {
                        this.localizationProvider = localizationProvider;
                        var fontPicker = this.picker("Font", fonts, "font", RichText.defaultFont, function($option, option) {
                            $option.css("font-family", option.value);
                            return $option;
                        });
                        this.$container = div().addClass("toolbar ql-toolbar").append(formatGroup().append(label(localizationProvider.get("RichTextbox_Font_Label"))).append(fontPicker).append(this.picker("Size", fontSizes, "size", RichText.defaultFontSize))).append(formatGroup().append(this.formatButton(this.getLocalizationString("Bold"), "bold")).append(this.formatButton(this.getLocalizationString("Italic"), "italic")).append(this.formatButton(this.getLocalizationString("Underline"), "underline"))).append(formatGroup().append(this.toggleGroup("Text Alignment", textAlignments, "align", "Left")));
                    }
                    Toolbar.prototype.toggleGroup = function(title, list, format, defaultValue) {
                        var _this = this;
                        var $group = span().attr("localize-tooltip", this.getLocalizationString(title)).addClass("ql-toggle-group");
                        var $select = this.selector(title, list, defaultValue).addClass("ql-picker ql-" + format).css("display", "none");
                        var $buttons = list.map(function(option) {
                            var $button = _this.formatButton(_this.getLocalizationString(option.label)).attr("data-value", option.value).click(function(e) {
                                return setSelectValue($select, option.value);
                            });
                            return $button;
                        });
                        $select.change(function(e) {
                            var newValue = $select.val();
                            for (var i = 0; i < $buttons.length; i++) {
                                $buttons[i].toggleClass("ql-active", $buttons[i].attr("data-value") === newValue);
                            }
                        });
                        $group.append($select);
                        $group.append($buttons);
                        return $group;
                    };
                    Toolbar.prototype.picker = function(title, list, format, defaultValue, optionModifier) {
                        var $selector = this.selector(title, list, defaultValue, optionModifier).addClass("ql-picker ql-" + format);
                        return $selector;
                    };
                    Toolbar.prototype.selector = function(title, list, defaultValue, optionModifier) {
                        var $selector = $("<select>").attr("localize-tooltip", this.getLocalizationString(title));
                        for (var i = 0; i < list.length; i++) {
                            var option = list[i];
                            var $option = $("<option>").attr("value", option.value).text(option.label);
                            if (option.value === defaultValue) $option.attr("selected", "selected");
                            if (optionModifier !== undefined) $option = optionModifier($option, option);
                            $selector.append($option);
                        }
                        return $selector;
                    };
                    Toolbar.prototype.formatButton = function(tooltip, format) {
                        var $button = span().addClass("ql-format-button");
                        if (tooltip != null) $button.attr("localize-tooltip", tooltip);
                        if (format != null) $button.addClass("ql-" + format);
                        $button.on("selectstart", function() {
                            return false;
                        });
                        return $button;
                    };
                    Toolbar.prototype.getLocalizationString = function(title) {
                        return "RichTextbox_" + title + "_ToolTip";
                    };
                    return Toolbar;
                }();
                _Toolbar.Toolbar = Toolbar;
            })(Toolbar || (Toolbar = {}));
        })(RichText = visuals.RichText || (visuals.RichText = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            }
        };
        var CheerMeter = function() {
            function CheerMeter() {
                this.isFirstTime = true;
            }
            CheerMeter.converter = function(dataView) {
                var catValues = dataView.categorical.categories[0].values;
                var values = dataView.categorical.values[0].values;
                var objects = dataView.categorical.categories[0].objects;
                var color1 = powerbi.DataViewObjects.getFillColor(objects[0], visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var color2 = powerbi.DataViewObjects.getFillColor(objects[1], visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2
                    }
                };
                return data;
            };
            CheerMeter.prototype.init = function(options) {
                var svg = this.svg = d3.select(options.element.get(0)).append("svg");
                this.textOne = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily);
                this.textTwo = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily);
            };
            CheerMeter.prototype.onResizing = function(viewport, duration) {};
            CheerMeter.prototype.onDataChanged = function(options) {};
            CheerMeter.prototype.update = function(options) {
                var data = CheerMeter.converter(options.dataViews[0]);
                this.draw(data, options.duration, options.viewport);
            };
            CheerMeter.prototype.getRecomendedFontProperties = function(text1, text2, parentViewport) {
                var textProperties = {
                    fontSize: "",
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                };
                var min = 1;
                var max = 1e3;
                var i;
                var maxWidth = parentViewport.width;
                var width = 0;
                while (min <= max) {
                    i = (min + max) / 2 | 0;
                    textProperties.fontSize = i + "px";
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (maxWidth > width) min = i + 1; else if (maxWidth < width) max = i - 1; else break;
                }
                textProperties.fontSize = i + "px";
                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (width > maxWidth) {
                    i--;
                    textProperties.fontSize = i + "px";
                }
                return textProperties;
            };
            CheerMeter.prototype.calculateLayout = function(data, viewport) {
                var text1 = data.teamA.name;
                var text2 = data.teamB.name;
                var avaliableViewport = {
                    height: viewport.height,
                    width: viewport.width - CheerMeter.PaddingBetweenText
                };
                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                recomendedFontProperties.text = text2;
                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                var padding = (viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2 | 0;
                debug.assert(padding > 0, "padding");
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties) | 0;
                var max = 100;
                var availableHeight = viewport.height - offsetHeight;
                var y1 = (max - data.teamA.value) / max * availableHeight + offsetHeight / 2 | 0;
                var y2 = (max - data.teamB.value) / max * availableHeight + offsetHeight / 2 | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            };
            CheerMeter.prototype.ensureStartState = function(layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = false;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        x: layout.x1,
                        y: startY
                    });
                    this.textTwo.attr({
                        x: layout.x2,
                        y: startY
                    });
                }
            };
            CheerMeter.prototype.draw = function(data, duration, viewport) {
                var easeName = "back";
                var textOne = this.textOne;
                var textTwo = this.textTwo;
                this.svg.attr({
                    height: viewport.height,
                    width: viewport.width
                }).style("background-color", CheerMeter.DefaultBackgroundColor);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport);
                textOne.style("font-size", layout.fontSize).style("fill", data.teamA.color).text(data.teamA.name);
                textTwo.style("fill", data.teamB.color).style("font-size", layout.fontSize).text(data.teamB.name);
                textOne.transition().duration(duration).ease(easeName).attr({
                    y: layout.y1,
                    x: layout.x1
                });
                textTwo.transition().duration(duration).ease(easeName).attr({
                    y: layout.y2,
                    x: layout.x2
                });
            };
            CheerMeter.prototype.destroy = function() {
                this.svg = null;
                this.textOne = this.textTwo = null;
            };
            CheerMeter.capabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: 0
                }, {
                    name: "Y",
                    kind: 1
                } ],
                dataViewMappings: [ {
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            }
                        }
                    }
                } ],
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                }
            };
            CheerMeter.DefaultFontFamily = "cursive";
            CheerMeter.DefaultFontColor = "rgb(165, 172, 175)";
            CheerMeter.DefaultBackgroundColor = "#243C18";
            CheerMeter.PaddingBetweenText = 15;
            return CheerMeter;
        }();
        visuals.CheerMeter = CheerMeter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.scatterChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
            }, {
                name: "Series",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
            }, {
                name: "X",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X")
            }, {
                name: "Y",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y")
            }, {
                name: "Size",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size")
            }, {
                name: "Gradient",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
            } ],
            objects: {
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        defaultColor: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        showAllDataPoints: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                            type: {
                                bool: true
                            }
                        },
                        fill: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Category" ]
                                }
                            }
                        }
                    }
                },
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            type: {
                                numeric: true
                            }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            type: {
                                numeric: true
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            type: {
                                formatting: {
                                    yAxisPosition: true
                                }
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            type: {
                                numeric: true
                            }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            type: {
                                numeric: true
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 1
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                }, {
                    Category: {
                        max: 1
                    },
                    Series: {
                        max: 0
                    },
                    X: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    },
                    Size: {
                        max: 1
                    },
                    Gradient: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        },
                        dataReductionAlgorithm: {
                            sample: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Series",
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            sorting: {
                custom: {}
            }
        };
        visuals.scatterChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var ScatterChart = function() {
            function ScatterChart(options) {
                this.interactivityService = options.interactivityService;
            }
            ScatterChart.prototype.init = function(options) {
                this.options = options;
                var element = this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.host = options.host;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                element.addClass(ScatterChart.ClassName);
                var svg = this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.mainGraphicsG = svg.append("g").classed(ScatterChart.MainGraphicsContextClassName, true);
                this.mainGraphicsContext = this.mainGraphicsG.append("svg");
                this.dataLabelsContext = this.mainGraphicsG.append("g").classed(ScatterChart.DataLabelsContextClassName, true);
            };
            ScatterChart.converter = function(dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities;
                var dataViewCategorical = dataView.categorical;
                var dataViewMetadata = dataView.metadata;
                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                    categoryValues = dataViewCategorical.categories[0].values;
                    categoryFormatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString),
                        value: categoryValues[0],
                        value2: categoryValues[categoryValues.length - 1]
                    });
                    categoryIdentities = dataViewCategorical.categories[0].identity;
                    categoryObjects = dataViewCategorical.categories[0].objects;
                } else {
                    categoryValues = [ null ];
                }
                var categories = dataViewCategorical.categories;
                var dataValues = dataViewCategorical.values;
                var hasDynamicSeries = !!dataValues.source;
                var grouped = dataValues.grouped();
                var dvSource = dataValues.source;
                var scatterMetadata = ScatterChart.getMetadata(grouped, dvSource);
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    var defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    var showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    var labelsObj = objects["categoryLabels"];
                    if (labelsObj) {
                        dataLabelsSettings.show = labelsObj["show"] !== undefined ? labelsObj["show"] : dataLabelsSettings.show;
                        dataLabelsSettings.precision = labelsObj["labelsPrecision"] !== undefined ? +labelsObj["labelsPrecision"] : dataLabelsSettings.precision;
                        if (labelsObj["color"] !== undefined) {
                            dataLabelsSettings.labelColor = labelsObj["color"].solid.color;
                            dataLabelsSettings.overrideDefaultColor = true;
                        }
                    }
                }
                var dataPoints = ScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor);
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                }
                var legendItems = hasDynamicSeries ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor) : [];
                var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                if (!legendTitle) {
                    legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legendItems
                };
                var sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.x = null;
                }
                if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.y = null;
                }
                return {
                    xCol: scatterMetadata.cols.x,
                    yCol: scatterMetadata.cols.y,
                    dataPoints: dataPoints,
                    legendData: legendData,
                    axesLabels: scatterMetadata.axesLabels,
                    hasSelection: false,
                    selectedIds: [],
                    size: scatterMetadata.cols.size,
                    sizeRange: sizeRange,
                    dataLabelsSettings: dataLabelsSettings,
                    defaultDataPointColor: defaultDataPointColor,
                    hasDynamicSeries: hasDynamicSeries,
                    showAllDataPoints: showAllDataPoints
                };
            };
            ScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                var result = {};
                if (dataViewValueGroups) {
                    dataViewValueGroups.forEach(function(group) {
                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                        var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        if (result.min == null || result.min > currentRange.min) {
                            result.min = currentRange.min;
                        }
                        if (result.max == null || result.max < currentRange.max) {
                            result.max = currentRange.max;
                        }
                    });
                }
                return result;
            };
            ScatterChart.createDataPoints = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, defaultDataPointColor) {
                var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                    var categoryValue = categoryValues[categoryIdx];
                    for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                        var grouping = grouped[seriesIdx];
                        var seriesValues = grouping.values;
                        var measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);
                        var measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);
                        var measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);
                        var xVal = measureX && measureX.values ? measureX.values[categoryIdx] : null;
                        var yVal = measureY && measureY.values ? measureY.values[categoryIdx] : 0;
                        var size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;
                        var hasNullValue = xVal == null || yVal == null;
                        if (hasNullValue) continue;
                        var color;
                        if (hasDynamicSeries) {
                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        } else {
                            var measureSource = measureSize != null ? measureSize.source.queryName : "";
                            color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                        }
                        var identity = visuals.SelectionId.createWithIds(categoryIdentities ? categoryIdentities[categoryIdx] : undefined, hasDynamicSeries ? grouping.identity : undefined);
                        var seriesData = [];
                        if (dataValueSource) {
                            seriesData.push({
                                value: grouping.name,
                                metadata: {
                                    source: dataValueSource,
                                    values: []
                                }
                            });
                        }
                        if (measureX) {
                            seriesData.push({
                                value: xVal,
                                metadata: measureX
                            });
                        }
                        if (measureY) {
                            seriesData.push({
                                value: yVal,
                                metadata: measureY
                            });
                        }
                        if (measureSize && measureSize.values && measureSize.values.length > 0) {
                            seriesData.push({
                                value: measureSize.values[categoryIdx],
                                metadata: measureSize
                            });
                        }
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categories, categoryValue, null, null, seriesData);
                        var dataPoint = {
                            x: xVal,
                            y: yVal,
                            size: size,
                            radius: {
                                sizeMeasure: measureSize,
                                index: categoryIdx
                            },
                            fill: color,
                            category: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                            selected: false,
                            identity: identity,
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.overrideDefaultColor ? labelSettings.labelColor : color
                        };
                        dataPoints.push(dataPoint);
                    }
                }
                return dataPoints;
            };
            ScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                var grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                var legendItems = [];
                for (var i = 0, len = grouped.length; i < len; i++) {
                    var grouping = grouped[i];
                    var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    legendItems.push({
                        color: color,
                        icon: 1,
                        label: visuals.valueFormatter.format(grouping.name, formatString),
                        identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return legendItems;
            };
            ScatterChart.getBubbleRadius = function(radiusData, sizeRange, viewPort) {
                var actualSizeDataRange = null;
                var bubblePixelAreaSizeRange = null;
                var measureSize = radiusData.sizeMeasure;
                if (!measureSize) return ScatterChart.BubbleRadius;
                var minSize = sizeRange.min ? sizeRange.min : 0;
                var maxSize = sizeRange.max ? sizeRange.max : 0;
                var min = Math.min(minSize, 0);
                var max = Math.max(maxSize, 0);
                actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                };
                bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewPort, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange);
                if (measureSize.values) {
                    var sizeValue = measureSize.values[radiusData.index];
                    if (sizeValue != null) {
                        return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                    }
                }
                return ScatterChart.BubbleRadius;
            };
            ScatterChart.getMeasureValue = function(measureIndex, seriesValues) {
                if (measureIndex >= 0) return seriesValues[measureIndex];
                return null;
            };
            ScatterChart.getMetadata = function(grouped, source) {
                var xIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                var yIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                var sizeIndex = visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
                var xCol;
                var yCol;
                var sizeCol;
                var xAxisLabel = "";
                var yAxisLabel = "";
                if (grouped && grouped.length) {
                    var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                    if (!(xIndex >= 0)) xIndex = ScatterChart.getDefaultMeasureIndex(measureCount, yIndex, sizeIndex);
                    if (!(yIndex >= 0)) yIndex = ScatterChart.getDefaultMeasureIndex(measureCount, xIndex, sizeIndex);
                    if (!(sizeIndex >= 0)) sizeIndex = ScatterChart.getDefaultMeasureIndex(measureCount, xIndex, yIndex);
                    if (xIndex >= 0) {
                        xCol = firstGroup.values[xIndex].source;
                        xAxisLabel = firstGroup.values[xIndex].source.displayName;
                    }
                    if (yIndex >= 0) {
                        yCol = firstGroup.values[yIndex].source;
                        yAxisLabel = firstGroup.values[yIndex].source.displayName;
                    }
                    if (sizeIndex >= 0) {
                        sizeCol = firstGroup.values[sizeIndex].source;
                    }
                }
                return {
                    idx: {
                        x: xIndex,
                        y: yIndex,
                        size: sizeIndex
                    },
                    cols: {
                        x: xCol,
                        y: yCol,
                        size: sizeCol
                    },
                    axesLabels: {
                        x: xAxisLabel,
                        y: yAxisLabel
                    }
                };
            };
            ScatterChart.getDefaultMeasureIndex = function(count, usedIndex, usedIndex2) {
                for (var i = 0; i < count; i++) {
                    if (i !== usedIndex && i !== usedIndex2) return i;
                }
            };
            ScatterChart.prototype.setData = function(dataViews) {
                this.data = {
                    xCol: undefined,
                    yCol: undefined,
                    dataPoints: [],
                    legendData: {
                        dataPoints: []
                    },
                    axesLabels: {
                        x: "",
                        y: ""
                    },
                    selectedIds: [],
                    sizeRange: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    defaultDataPointColor: null,
                    hasDynamicSeries: false
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, true);
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, true);
                        this.dataView = dataView;
                        if (dataView.categorical && dataView.categorical.values) {
                            this.data = ScatterChart.converter(dataView, this.currentViewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);
                        }
                    }
                }
            };
            ScatterChart.prototype.calculateLegend = function() {
                return this.data.legendData;
            };
            ScatterChart.prototype.hasLegend = function() {
                return this.data && this.data.hasDynamicSeries;
            };
            ScatterChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "dataPoint":
                    var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                    if (!visuals.GradientUtils.hasGradientRole(categoricalDataView)) return this.enumerateDataPoints();

                  case "categoryAxis":
                    return [ {
                        selector: null,
                        properties: {
                            showAxisTitle: !this.categoryAxisProperties || this.categoryAxisProperties["showAxisTitle"] == null ? true : this.categoryAxisProperties["showAxisTitle"]
                        },
                        objectName: "categoryAxis"
                    } ];

                  case "valueAxis":
                    return [ {
                        selector: null,
                        properties: {
                            showAxisTitle: !this.valueAxisProperties || this.valueAxisProperties["showAxisTitle"] == null ? true : this.valueAxisProperties["showAxisTitle"]
                        },
                        objectName: "valueAxis"
                    } ];

                  case "categoryLabels":
                    return this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(this.data.dataLabelsSettings, true) : visuals.dataLabelUtils.enumerateCategoryLabels(null, true);
                }
            };
            ScatterChart.prototype.enumerateDataPoints = function() {
                var data = this.data;
                if (!data) return;
                var instances = [], seriesCount = data.dataPoints.length;
                if (data.hasDynamicSeries) {
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            defaultColor: {
                                solid: {
                                    color: data.defaultDataPointColor || this.colors.getColor(0).value
                                }
                            }
                        }
                    });
                    var showAllDataPoints = data.showAllDataPoints !== undefined ? data.showAllDataPoints : seriesCount > 1;
                    instances.push({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            showAllDataPoints: showAllDataPoints
                        }
                    });
                    if (!showAllDataPoints) return instances;
                }
                if (data.legendData.dataPoints.length === 0) {
                    for (var i = 0; i < seriesCount; i++) {
                        var seriesDataPoints = data.dataPoints[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: seriesDataPoints.category,
                            selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), true),
                            properties: {
                                fill: {
                                    solid: {
                                        color: seriesDataPoints.fill
                                    }
                                }
                            }
                        });
                    }
                } else {
                    var legendDataPointLength = data.legendData.dataPoints.length;
                    for (var i = 0; i < legendDataPointLength; i++) {
                        var series = data.legendData.dataPoints[i];
                        instances.push({
                            objectName: "dataPoint",
                            displayName: series.label,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: series.color
                                    }
                                }
                            }
                        });
                    }
                }
                return instances;
            };
            ScatterChart.prototype.calculateAxesProperties = function(options) {
                var data = this.data;
                var dataPoints = data.dataPoints;
                var viewport = this.currentViewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var minY = 0, maxY = 10, minX = 0, maxX = 10;
                if (dataPoints.length > 0) {
                    minY = d3.min(dataPoints, function(d) {
                        return d.y;
                    });
                    maxY = d3.max(dataPoints, function(d) {
                        return d.y;
                    });
                    minX = d3.min(dataPoints, function(d) {
                        return d.x;
                    });
                    maxX = d3.max(dataPoints, function(d) {
                        return d.x;
                    });
                }
                var xDomain = [ minX, maxX ];
                var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedXDomain,
                    metaDataColumn: data.xCol,
                    formatStringProp: visuals.scatterChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true
                });
                this.xAxisProperties.axis.tickSize(-height, 0);
                this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ minY, maxY ]);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: data.yCol,
                    formatStringProp: visuals.scatterChartProps.general.formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                });
                this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                return [ this.xAxisProperties, this.yAxisProperties ];
            };
            ScatterChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            };
            ScatterChart.prototype.render = function(duration) {
                if (!this.data) return;
                var data = this.data;
                var dataPoints = this.data.dataPoints;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = visuals.dataHasSelection(dataPoints);
                this.mainGraphicsContext.attr("width", width).attr("height", height);
                var sortedData = dataPoints.sort(function(a, b) {
                    return b.radius.sizeMeasure ? b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index] : 0;
                });
                var scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);
                if (this.data.dataLabelsSettings.show) {
                    var layout = visuals.dataLabelUtils.getScatterChartLabelLayout(xScale, yScale, this.data.dataLabelsSettings, viewport, data.sizeRange);
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsContext, layout, this.currentViewport);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsContext);
                }
                if (this.interactivityService) {
                    var options = {
                        host: this.cartesianVisualHost,
                        root: this.svg,
                        dataPointsSelection: scatterMarkers,
                        mainContext: this.mainGraphicsContext,
                        data: this.data,
                        visualInitOptions: this.options,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0)),
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, options);
                }
                visuals.TooltipManager.addTooltip(scatterMarkers, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            ScatterChart.prototype.drawScatterMarkers = function(scatterData, hasSelection, sizeRange, duration) {
                var _this = this;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var markers = this.mainGraphicsContext.selectAll(ScatterChart.DotClasses.selector).data(scatterData, function(d) {
                    return d.identity.getKey();
                });
                markers.enter().append(ScatterChart.ScatterChartCircleTagName).classed(ScatterChart.DotClasses.class, true);
                markers.style({
                    "stroke-opacity": function(d) {
                        return ScatterChart.getBubbleOpacity(d, hasSelection);
                    },
                    "stroke-width": "1px",
                    stroke: function(d) {
                        return d.fill;
                    },
                    fill: function(d) {
                        return d.fill;
                    },
                    "fill-opacity": function(d) {
                        return d.size != null ? ScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                    }
                }).transition().duration(duration).attr({
                    r: function(d) {
                        return ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.currentViewport);
                    },
                    cx: function(d) {
                        return xScale(d.x);
                    },
                    cy: function(d) {
                        return yScale(d.y);
                    }
                });
                markers.exit().remove();
                return markers;
            };
            ScatterChart.getBubblePixelAreaSizeRange = function(viewPort, minSizeRange, maxSizeRange) {
                var ratio = 1;
                if (viewPort.height > 0 && viewPort.width > 0) {
                    var minSize = Math.min(viewPort.height, viewPort.width);
                    ratio = minSize * minSize / ScatterChart.AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio);
                var maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            };
            ScatterChart.project = function(value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
                    return ScatterChart.rangeContains(actualSizeDataRange, value) ? bubblePixelAreaSizeRange.minRange : null;
                }
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            };
            ScatterChart.projectSizeToPixels = function(size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    projectedSize = bubblePixelAreaSizeRange.maxRange;
                    if (actualSizeDataRange.delta !== 0) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
                }
                return Math.round(projectedSize);
            };
            ScatterChart.rangeContains = function(range, value) {
                return range.minRange <= value && value <= range.maxRange;
            };
            ScatterChart.getBubbleOpacity = function(d, hasSelection) {
                if (hasSelection && !d.selected) {
                    return ScatterChart.DimmedBubbleOpacity;
                }
                return ScatterChart.DefaultBubbleOpacity;
            };
            ScatterChart.prototype.accept = function(visitor, options) {
                visitor.visitScatterChart(options);
            };
            ScatterChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            ScatterChart.prototype.getSupportedCategoryAxisType = function() {
                return powerbi.axisType.scalar;
            };
            ScatterChart.ScatterChartCircleTagName = "circle";
            ScatterChart.BubbleRadius = 3 * 2;
            ScatterChart.DefaultBubbleOpacity = .85;
            ScatterChart.DimmedBubbleOpacity = .4;
            ScatterChart.AreaOf300By300Chart = 9e4;
            ScatterChart.MinSizeRange = 200;
            ScatterChart.MaxSizeRange = 3e3;
            ScatterChart.ClassName = "scatterChart";
            ScatterChart.MainGraphicsContextClassName = "mainGraphicsContext";
            ScatterChart.DataLabelsContextClassName = "dataLabelsContext";
            ScatterChart.DotClasses = {
                "class": "dot",
                selector: ".dot"
            };
            return ScatterChart;
        }();
        visuals.ScatterChart = ScatterChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.slicerCapabilities = {
            dataRoles: [ {
                name: "Values",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Field")
            } ],
            dataViewMappings: [ {
                conditions: [ {
                    Values: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Values"
                        },
                        dataReductionAlgorithm: {
                            window: {}
                        }
                    }
                }
            } ],
            objects: {
                general: {
                    properties: {
                        selected: {
                            type: {
                                bool: true
                            }
                        },
                        filter: {
                            type: {
                                filter: {}
                            },
                            rule: {
                                output: {
                                    property: "selected",
                                    selector: [ "Values" ]
                                }
                            }
                        },
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                }
            },
            sorting: {
                custom: {}
            },
            suppressDefaultTitle: true
        };
        visuals.slicerProps = {
            selectedPropertyIdentifier: {
                objectName: "general",
                propertyName: "selected"
            },
            filterPropertyIdentifier: {
                objectName: "general",
                propertyName: "filter"
            },
            formatString: {
                objectName: "general",
                propertyName: "formatString"
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Slicer = function() {
            function Slicer() {}
            Slicer.converter = function(dataView) {
                var slicerData;
                if (dataView) {
                    var dataViewCategorical = dataView.categorical;
                    if (dataViewCategorical && dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var categories = dataViewCategorical.categories[0];
                        var categoryValuesLen = categories && categories.values ? categories.values.length : 0;
                        var slicerDataPoints = [];
                        var hasSelection = undefined;
                        for (var idx = 0; idx < categoryValuesLen; idx++) {
                            var selected = visuals.WebInteractivityService.isSelected(visuals.slicerProps.selectedPropertyIdentifier, categories, idx);
                            if (selected !== undefined) {
                                hasSelection = selected;
                                break;
                            }
                        }
                        for (var idx = 0; idx < categoryValuesLen; idx++) {
                            var categoryIdentity = categories.identity ? categories.identity[idx] : null;
                            var selectedCategory = visuals.WebInteractivityService.isSelected(visuals.slicerProps.selectedPropertyIdentifier, categories, idx);
                            if (selectedCategory === undefined && hasSelection !== undefined) {
                                selectedCategory = !hasSelection;
                            }
                            slicerDataPoints.push({
                                value: categories.values[idx],
                                mouseOver: false,
                                mouseOut: true,
                                identity: visuals.SelectionId.createWithId(categoryIdentity),
                                selected: selectedCategory
                            });
                        }
                        slicerData = {
                            categorySourceName: categories.source.displayName,
                            formatString: visuals.valueFormatter.getFormatString(categories.source, visuals.slicerProps.formatString),
                            slicerDataPoints: slicerDataPoints
                        };
                    }
                }
                return slicerData;
            };
            Slicer.prototype.init = function(options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.hostServices = options.host;
                var settings = this.settings = options.settings;
                if (!settings || !settings.slicerSettings) {
                    settings = this.settings = options.settings = {
                        slicerSettings: Slicer.DefaultStyleProperties
                    };
                }
                this.initContainer();
            };
            Slicer.prototype.onDataChanged = function(options) {
                var dataViews = options.dataViews;
                debug.assertValue(dataViews, "dataViews");
                var existingDataView = this.dataView;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                }
                var resetScrollbarPosition = options.operationKind !== 1 && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                this.updateInternal(resetScrollbarPosition);
                this.waitingForData = false;
            };
            Slicer.prototype.onResizing = function(finalViewport, duration) {
                this.currentViewport = finalViewport;
                var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                this.slicerBody.style({
                    height: visuals.SVGUtil.convertToPixelString(slicerViewport.height),
                    width: visuals.SVGUtil.convertToPixelString(slicerViewport.width)
                });
                this.slicerHeader.select(Slicer.HeaderText.selector).style("width", this.getSlicerHeaderTextWidth());
                this.updateInternal();
            };
            Slicer.prototype.accept = function(visitor, options) {
                visitor.visitSlicer(options);
            };
            Slicer.prototype.updateInternal = function(resetScrollbarPosition) {
                if (resetScrollbarPosition === void 0) {
                    resetScrollbarPosition = false;
                }
                var data = this.slicerData = Slicer.converter(this.dataView);
                if (!data) {
                    this.listView.empty();
                    return;
                }
                this.listView.viewport(this.getSlicerBodyViewport(this.currentViewport)).rowHeight(this.getRowHeight()).data(data.slicerDataPoints, function(d) {
                    return $.inArray(d, data.slicerDataPoints);
                }).render(true, resetScrollbarPosition);
            };
            Slicer.prototype.initContainer = function() {
                var _this = this;
                var settings = this.settings.slicerSettings;
                var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);
                this.slicerContainer = d3.select(this.element.get(0)).classed(Slicer.Container.class, true);
                this.slicerHeader = this.slicerContainer.append("div").classed(Slicer.Header.class, true).style("height", visuals.SVGUtil.convertToPixelString(settings.header.height));
                this.slicerHeader.append("div").classed(Slicer.HeaderText.class, true).style({
                    "margin-left": visuals.SVGUtil.convertToPixelString(settings.headerText.marginLeft),
                    "margin-top": visuals.SVGUtil.convertToPixelString(settings.headerText.marginTop),
                    width: this.getSlicerHeaderTextWidth()
                });
                this.slicerHeader.append("span").classed(Slicer.Clear.class, true).attr("title", this.hostServices.getLocalizedString(Slicer.clearTextKey));
                this.slicerBody = this.slicerContainer.append("div").classed(Slicer.Body.class, true).style({
                    height: visuals.SVGUtil.convertToPixelString(slicerBodyViewport.height),
                    width: visuals.SVGUtil.convertToPixelString(slicerBodyViewport.width)
                });
                var rowEnter = function(rowSelection) {
                    var labelWidth = visuals.SVGUtil.convertToPixelString(_this.currentViewport.width - (settings.slicerItemContainer.marginLeft + settings.slicerText.marginLeft));
                    var listItemElement = rowSelection.append("li").classed(Slicer.ItemContainer.class, true).style({
                        height: visuals.SVGUtil.convertToPixelString(settings.slicerItemContainer.height),
                        "margin-left": visuals.SVGUtil.convertToPixelString(settings.slicerItemContainer.marginLeft)
                    });
                    var labelElement = listItemElement.append("label").classed(Slicer.Input.class, true);
                    labelElement.append("input").attr("type", "checkbox");
                    labelElement.append("span").classed(Slicer.LabelText.class, true).style("width", labelWidth);
                };
                var rowUpdate = function(rowSelection) {
                    var formatString;
                    if (_this.slicerData) {
                        _this.slicerHeader.select(Slicer.HeaderText.selector).text(_this.slicerData.categorySourceName);
                        formatString = _this.slicerData.formatString;
                    }
                    var slicerText = rowSelection.selectAll(Slicer.LabelText.selector);
                    slicerText.text(function(d) {
                        return visuals.valueFormatter.format(d.value, formatString);
                    });
                    if (_this.interactivityService && _this.slicerData && _this.slicerBody) {
                        var slicerBody = _this.slicerBody.attr("width", _this.currentViewport.width);
                        var slicerItemContainers = slicerBody.selectAll(Slicer.ItemContainer.selector);
                        var slicerItemLabels = slicerBody.selectAll(Slicer.LabelText.selector);
                        var slicerItemInputs = slicerBody.selectAll(Slicer.Input.selector);
                        var slicerClear = _this.slicerHeader.select(Slicer.Clear.selector);
                        var behaviorOptions = {
                            datapoints: _this.slicerData.slicerDataPoints,
                            slicerItemContainers: slicerItemContainers,
                            slicerItemLabels: slicerItemLabels,
                            slicerItemInputs: slicerItemInputs,
                            slicerClear: slicerClear
                        };
                        _this.interactivityService.apply(_this, behaviorOptions);
                    }
                    rowSelection.select(Slicer.Input.selector).select("input").property("checked", function(d) {
                        return d.selected;
                    });
                };
                var rowExit = function(rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: this.getRowHeight(),
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function() {
                        return _this.onLoadMoreData();
                    },
                    viewport: this.getSlicerBodyViewport(this.currentViewport),
                    baseContainer: this.slicerBody
                };
                this.listView = visuals.ListViewFactory.createHTMLListView(listViewOptions);
            };
            Slicer.prototype.onLoadMoreData = function() {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Slicer.prototype.getSlicerBodyViewport = function(currentViewport) {
                var settings = this.settings.slicerSettings;
                var slicerBodyHeight = currentViewport.height - (settings.header.height + 1);
                return {
                    height: slicerBodyHeight,
                    width: currentViewport.width
                };
            };
            Slicer.prototype.getSlicerHeaderTextWidth = function() {
                var slicerSettings = this.settings.slicerSettings;
                return visuals.SVGUtil.convertToPixelString(this.currentViewport.width - (slicerSettings.headerText.marginLeft + slicerSettings.clear.width + slicerSettings.clear.totalMargin));
            };
            Slicer.prototype.getRowHeight = function() {
                var slicerItemSettings = this.settings.slicerSettings.slicerItemContainer;
                return slicerItemSettings.height;
            };
            Slicer.clearTextKey = "Slicer_Clear";
            Slicer.Container = {
                "class": "slicerContainer",
                selector: ".slicerContainer"
            };
            Slicer.Header = {
                "class": "slicerHeader",
                selector: ".slicerHeader"
            };
            Slicer.HeaderText = {
                "class": "headerText",
                selector: ".headerText"
            };
            Slicer.Body = {
                "class": "slicerBody",
                selector: ".slicerBody"
            };
            Slicer.ItemContainer = {
                "class": "slicerItemContainer",
                selector: ".slicerItemContainer"
            };
            Slicer.LabelText = {
                "class": "slicerText",
                selector: ".slicerText"
            };
            Slicer.Input = {
                "class": "slicerCheckbox",
                selector: ".slicerCheckbox"
            };
            Slicer.Clear = {
                "class": "clear",
                selector: ".clear"
            };
            Slicer.DefaultStyleProperties = {
                header: {
                    height: 22
                },
                headerText: {
                    marginLeft: 8,
                    marginTop: 0
                },
                slicerText: {
                    color: "#666666",
                    hoverColor: "#212121",
                    selectionColor: "#212121",
                    marginLeft: 8
                },
                slicerItemContainer: {
                    height: 24,
                    marginTop: 5,
                    marginLeft: 8
                },
                clear: {
                    width: 11,
                    totalMargin: 10
                }
            };
            return Slicer;
        }();
        visuals.Slicer = Slicer;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var TableHierarchyNavigator = function() {
            function TableHierarchyNavigator(tableDataView, formatter) {
                debug.assertValue(tableDataView, "tableDataView");
                debug.assertValue(formatter, "formatter");
                this.tableDataView = tableDataView;
                this.formatter = formatter;
            }
            TableHierarchyNavigator.prototype.getDepth = function(hierarchy) {
                return 1;
            };
            TableHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                return hierarchy.length;
            };
            TableHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                return hierarchy[index];
            };
            TableHierarchyNavigator.prototype.getParent = function(item) {
                return null;
            };
            TableHierarchyNavigator.prototype.getIndex = function(item) {
                if (this.isRow(item)) return item.index;
                return this.getColumnIndex(item);
            };
            TableHierarchyNavigator.prototype.isRow = function(item) {
                var row = item;
                return row.index !== undefined && row.values !== undefined;
            };
            TableHierarchyNavigator.prototype.getColumnIndex = function(item) {
                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
            };
            TableHierarchyNavigator.prototype.isLeaf = function(item) {
                return true;
            };
            TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function(cornerItem) {
                return false;
            };
            TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(cornerItem) {
                return true;
            };
            TableHierarchyNavigator.prototype.isLastItem = function(item, items) {
                return false;
            };
            TableHierarchyNavigator.prototype.getChildren = function(item) {
                return null;
            };
            TableHierarchyNavigator.prototype.getCount = function(items) {
                return items.length;
            };
            TableHierarchyNavigator.prototype.getAt = function(items, index) {
                return items[index];
            };
            TableHierarchyNavigator.prototype.getLevel = function(item) {
                return 0;
            };
            TableHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                var value;
                var isTotal = false;
                var isBottomMost = false;
                var columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                var totalRow = rowItem;
                if (totalRow.totalCells != null) {
                    isTotal = true;
                    value = totalRow.totalCells[columnIndex];
                } else {
                    var bottomRow = this.tableDataView.visualRows[this.tableDataView.visualRows.length - 1];
                    isBottomMost = bottomRow === rowItem;
                    value = rowItem.values[columnIndex];
                }
                var formattedValue = this.formatter(value, visuals.valueFormatter.getFormatString(columnItem, Table.formatStringProp));
                return {
                    value: formattedValue,
                    isMeasure: columnItem.isMeasure,
                    isTotal: isTotal,
                    isBottomMost: isBottomMost,
                    showUrl: visuals.UrlHelper.isValidUrl(columnItem, formattedValue)
                };
            };
            TableHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                return null;
            };
            TableHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                return item1 === item2;
            };
            TableHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                return item1 === item2;
            };
            TableHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                return true;
            };
            TableHierarchyNavigator.prototype.update = function(table) {
                this.tableDataView = table;
            };
            TableHierarchyNavigator.getIndex = function(items, item) {
                for (var index = 0, len = items.length; index < len; index++) {
                    var arrayItem = items[index];
                    if (arrayItem.index != null && item.index != null && arrayItem.index === item.index) {
                        return index;
                    } else {
                        if (item === items[index]) return index;
                    }
                }
                return -1;
            };
            return TableHierarchyNavigator;
        }();
        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
        var TableBinder = function() {
            function TableBinder(options) {
                this.options = options;
            }
            TableBinder.prototype.onStartRenderingSession = function() {};
            TableBinder.prototype.onEndRenderingSession = function() {};
            TableBinder.prototype.bindRowHeader = function(item, cell) {
                this.ensureHeight(item, cell);
                if (this.options.onBindRowHeader) this.options.onBindRowHeader(item);
            };
            TableBinder.prototype.unbindRowHeader = function(item, cell) {};
            TableBinder.prototype.bindColumnHeader = function(item, cell) {
                var _this = this;
                cell.extension.setContainerStyle(TableBinder.columnHeaderClassName);
                cell.extension.disableDragResize();
                cell.extension.contentHost.textContent = item.displayName;
                if (this.options.onColumnHeaderClick) {
                    var handler = function(e) {
                        _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName);
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            TableBinder.prototype.unbindColumnHeader = function(item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = "";
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            TableBinder.prototype.bindBodyCell = function(item, cell) {
                if (item.showUrl) visuals.controls.internal.TablixUtils.appendATagToBodyCell(item.value, cell); else cell.extension.contentHost.textContent = item.value;
                var classNames = item.isTotal ? TableBinder.footerClassName : item.isBottomMost ? TableBinder.lastRowClassName : TableBinder.rowClassName;
                if (item.isMeasure) classNames += " " + TableBinder.numericCellClassName;
                cell.extension.setContainerStyle(classNames);
            };
            TableBinder.prototype.unbindBodyCell = function(item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = "";
            };
            TableBinder.prototype.bindCornerCell = function(item, cell) {};
            TableBinder.prototype.unbindCornerCell = function(item, cell) {};
            TableBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {};
            TableBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {};
            TableBinder.prototype.bindEmptySpaceFooterCell = function(cell) {};
            TableBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {};
            TableBinder.prototype.getHeaderLabel = function(item) {
                return item.displayName;
            };
            TableBinder.prototype.getCellContent = function(item) {
                return item;
            };
            TableBinder.prototype.hasRowGroups = function() {
                return false;
            };
            TableBinder.prototype.ensureHeight = function(item, cell) {
                if (!item.values) return;
                var count = item.values.length;
                if (count === 0) return;
                var allValuesEmpty = true;
                for (var i = 0; i < count; i++) {
                    if (item.values[i]) {
                        allValuesEmpty = false;
                        break;
                    }
                }
                if (allValuesEmpty) cell.extension.contentHost.innerHTML = TableBinder.nonBreakingSpace;
            };
            TableBinder.columnHeaderClassName = "bi-table-column-header";
            TableBinder.rowClassName = "bi-table-row";
            TableBinder.lastRowClassName = "bi-table-last-row";
            TableBinder.footerClassName = "bi-table-footer";
            TableBinder.numericCellClassName = "bi-table-cell-numeric";
            TableBinder.nonBreakingSpace = "&nbsp;";
            return TableBinder;
        }();
        visuals.TableBinder = TableBinder;
        var Table = function() {
            function Table() {
                this.lastAllowHeaderResize = true;
            }
            Table.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata) return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = Table.shouldShowTotals(objects) ? 1 : 0;
            };
            Table.getSortableRoles = function() {
                return [ "Values" ];
            };
            Table.prototype.init = function(options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatRaw;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.getLocalizedString = options.host.getLocalizedString;
                this.hostServices = options.host;
            };
            Table.converter = function(table) {
                debug.assertValue(table, "table");
                debug.assertValue(table.rows, "table.rows");
                var visualTable = powerbi.Prototype.inherit(table);
                visualTable.visualRows = [];
                for (var i = 0; i < table.rows.length; i++) {
                    var visualRow = {
                        index: i,
                        values: table.rows[i]
                    };
                    visualTable.visualRows.push(visualRow);
                }
                return visualTable;
            };
            Table.prototype.onResizing = function(finalViewport, duration) {
                this.updateViewport(finalViewport);
            };
            Table.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    this.dataView = dataViews[0];
                    if (options.operationKind === 1) {
                        var visualTable = Table.converter(this.dataView.table);
                        this.hierarchyNavigator.update(visualTable);
                        this.tablixControl.updateModels(false, visualTable.visualRows);
                        this.refreshControl(false);
                    } else {
                        this.updateInternal(this.dataView);
                    }
                }
                this.waitingForData = false;
            };
            Table.prototype.updateViewport = function(newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Table.prototype.refreshControl = function(clear) {
                if (this.element.visible() || this.getLayoutKind() === 1) {
                    this.tablixControl.refresh(clear);
                }
            };
            Table.prototype.getLayoutKind = function() {
                return this.isInteractive ? 0 : 1;
            };
            Table.prototype.createControl = function(dataNavigator) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var tableBinderOptions = {
                    onBindRowHeader: function(item) {
                        return _this.onBindRowHeader(item);
                    },
                    onColumnHeaderClick: function(queryName) {
                        return _this.onColumnHeaderClick(queryName);
                    }
                };
                var tableBinder = new TableBinder(tableBinderOptions);
                var layoutManager = layoutKind === 1 ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
                var tablixContainer = document.createElement("div");
                tablixContainer.className = "tablixContainer";
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: false,
                    layoutKind: layoutKind
                };
                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
            };
            Table.prototype.updateInternal = function(dataView) {
                var _this = this;
                var visualTable = Table.converter(dataView.table);
                if (!this.tablixControl) {
                    var dataNavigator = new TableHierarchyNavigator(visualTable, this.formatter);
                    this.hierarchyNavigator = dataNavigator;
                    this.tablixControl = this.createControl(dataNavigator);
                } else {
                    this.hierarchyNavigator.update(visualTable);
                }
                this.verifyHeaderResize();
                this.tablixControl.updateModels(true, visualTable.visualRows, visualTable.columns);
                var totals = this.createTotalsRow(dataView);
                this.tablixControl.rowDimension.setFooter(totals);
                this.tablixControl.viewport = this.currentViewport;
                setTimeout(function() {
                    _this.refreshControl(true);
                }, 0);
            };
            Table.prototype.createTotalsRow = function(dataView) {
                if (!this.shouldShowTotals(dataView)) return null;
                var totals = dataView.table.totals;
                if (!totals || totals.length === 0) return null;
                var totalRow = [];
                var columns = dataView.table.columns;
                for (var i = 0, len = columns.length; i < len; ++i) {
                    var column = columns[i];
                    var totalValue = totals[column.index];
                    if (totalValue != null) {
                        totalRow.push(totalValue);
                    } else {
                        totalRow.push(i === 0 ? this.getLocalizedString("TableTotalLabel") : "");
                    }
                }
                return {
                    totalCells: totalRow
                };
            };
            Table.prototype.shouldShowTotals = function(dataView) {
                var objects = dataView.metadata.objects;
                return Table.shouldShowTotals(objects);
            };
            Table.shouldShowTotals = function(objects) {
                if (objects && objects.general) return objects.general.totals !== false;
                return true;
            };
            Table.prototype.onBindRowHeader = function(item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Table.prototype.onColumnHeaderClick = function(queryName) {
                var sortDescriptors = [ {
                    queryName: queryName
                } ];
                var args = {
                    sortDescriptors: sortDescriptors
                };
                this.hostServices.onCustomSort(args);
            };
            Table.prototype.needsMoreData = function(item) {
                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment) return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
            };
            Table.prototype.enumerateObjectInstances = function(options) {
                var instances = [];
                if (this.dataView && options.objectName === "general") {
                    instances.push({
                        selector: null,
                        properties: {
                            totals: this.shouldShowTotals(this.dataView)
                        },
                        objectName: options.objectName
                    });
                }
                return instances;
            };
            Table.prototype.shouldAllowHeaderResize = function() {
                return this.hostServices.getViewMode() === 1;
            };
            Table.prototype.verifyHeaderResize = function() {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Table.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            Table.preferredLoadMoreThreshold = .8;
            Table.capabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: 2
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            },
                            totals: {
                                type: {
                                    bool: true
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Totals")
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    table: {
                        rows: {
                            "for": {
                                "in": "Values"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 100
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                } ],
                sorting: {
                    custom: {}
                },
                suppressDefaultTitle: true
            };
            return Table;
        }();
        visuals.Table = Table;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var RoleNames = {
            rows: "Rows",
            columns: "Columns",
            values: "Values"
        };
        function createMatrixHierarchyNavigator(matrix, formatter) {
            return new MatrixHierarchyNavigator(matrix, formatter);
        }
        visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
        var MatrixHierarchyNavigator = function() {
            function MatrixHierarchyNavigator(matrix, formatter) {
                this.matrix = matrix;
                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows);
                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns);
                this.formatter = formatter;
                this.update();
            }
            MatrixHierarchyNavigator.prototype.getDataViewMatrix = function() {
                return this.matrix;
            };
            MatrixHierarchyNavigator.prototype.getDepth = function(hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy) return Math.max(matrixHierarchy.levels.length, 1);
                debug.assertFail("Hierarchy cannot be found");
                return 0;
            };
            MatrixHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy) return matrixHierarchy.leafNodes.length;
                debug.assertFail("Hierarchy cannot be found");
                return 0;
            };
            MatrixHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy) return matrixHierarchy.leafNodes[index];
                return null;
            };
            MatrixHierarchyNavigator.prototype.getLeafIndex = function(item) {
                debug.assertValue(item, "item");
                return item.leafIndex;
            };
            MatrixHierarchyNavigator.prototype.getParent = function(item) {
                debug.assertValue(item, "item");
                if (item.level === 0) return null;
                return item.parent;
            };
            MatrixHierarchyNavigator.prototype.getIndex = function(item) {
                debug.assertValue(item, "item");
                return item.index;
            };
            MatrixHierarchyNavigator.prototype.isLeaf = function(item) {
                debug.assertValue(item, "item");
                return !item.children || item.children.length === 0;
            };
            MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function(item) {
                return true;
            };
            MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(item) {
                return false;
            };
            MatrixHierarchyNavigator.prototype.isLastItem = function(item, items) {
                debug.assertValue(item, "item");
                return items[items.length - 1] === item;
            };
            MatrixHierarchyNavigator.prototype.getChildren = function(item) {
                debug.assertValue(item, "item");
                return item.children;
            };
            MatrixHierarchyNavigator.prototype.getCount = function(items) {
                debug.assertValue(items, "items");
                return items.length;
            };
            MatrixHierarchyNavigator.prototype.getAt = function(items, index) {
                debug.assertValue(items, "items");
                return items[index];
            };
            MatrixHierarchyNavigator.prototype.getLevel = function(item) {
                debug.assertValue(item, "item");
                return item.level;
            };
            MatrixHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                debug.assertValue(rowItem, "rowItem");
                debug.assertValue(columnItem, "columnItem");
                var isSubtotalItem = rowItem.isSubtotal === true || columnItem.isSubtotal === true;
                if (!rowItem.values) return {
                    content: "",
                    isSubtotal: isSubtotalItem
                };
                var intersection = rowItem.values[columnItem.leafIndex];
                if (!intersection) return {
                    content: "",
                    isSubtotal: isSubtotalItem
                };
                var formatString = visuals.valueFormatter.getFormatString(this.matrix.valueSources[intersection.valueSourceIndex ? intersection.valueSourceIndex : 0], Matrix.formatStringProp);
                var formattedValue = this.formatter(intersection.value, formatString);
                return {
                    content: formattedValue,
                    isSubtotal: isSubtotalItem
                };
            };
            MatrixHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                debug.assert(rowLevel >= 0, "rowLevel");
                debug.assert(columnLevel >= 0, "columnLevel");
                var columnLevels = this.columnHierarchy.levels;
                var rowLevels = this.rowHierarchy.levels;
                if (columnLevel === columnLevels.length - 1 || columnLevels.length === 0) {
                    var levelSource = rowLevels[rowLevel];
                    if (levelSource) return {
                        metadata: levelSource.sources[0],
                        isColumnHeaderLeaf: true,
                        isRowHeaderLeaf: rowLevel === rowLevels.length - 1
                    };
                }
                if (rowLevel === rowLevels.length - 1) {
                    var levelSource = columnLevels[columnLevel];
                    if (levelSource) return {
                        metadata: levelSource.sources[0],
                        isColumnHeaderLeaf: false,
                        isRowHeaderLeaf: true
                    };
                }
                return {
                    metadata: null,
                    isColumnHeaderLeaf: false,
                    isRowHeaderLeaf: false
                };
            };
            MatrixHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                return item1 === item2;
            };
            MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                return item1 === item2;
            };
            MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                return item1 === item2;
            };
            MatrixHierarchyNavigator.prototype.update = function(dataViewMatrix) {
                if (dataViewMatrix) {
                    this.matrix = dataViewMatrix;
                    this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows);
                    this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns);
                }
                this.updateHierarchy(this.rowHierarchy);
                this.updateHierarchy(this.columnHierarchy);
                MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy);
            };
            MatrixHierarchyNavigator.prototype.updateRows = function() {
                this.updateHierarchy(this.rowHierarchy);
            };
            MatrixHierarchyNavigator.wrapMatrixHierarchy = function(hierarchy) {
                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                matrixHierarchy.leafNodes = [];
                return matrixHierarchy;
            };
            MatrixHierarchyNavigator.prototype.updateHierarchy = function(hierarchy) {
                if (hierarchy.leafNodes.length > 0) hierarchy.leafNodes.length = 0;
                if (hierarchy.root.children) this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
            };
            MatrixHierarchyNavigator.prototype.updateRecursive = function(hierarchy, nodes, parent, cache) {
                var level;
                for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                    var node = nodes[i];
                    if (parent) node.parent = parent;
                    if (!level) level = hierarchy.levels[node.level];
                    if (level) {
                        var source = level.sources[node.levelSourceIndex ? node.levelSourceIndex : 0];
                        var formatString = visuals.valueFormatter.getFormatString(source, Matrix.formatStringProp);
                        if (formatString) node.name = this.formatter(node.value, formatString);
                    }
                    node.index = i;
                    if (node.children && node.children.length > 0) {
                        this.updateRecursive(hierarchy, node.children, node, cache);
                    } else {
                        node.leafIndex = cache.length;
                        cache.push(node);
                    }
                }
            };
            MatrixHierarchyNavigator.updateStaticColumnHeaders = function(columnHierarchy) {
                var columnLeafNodes = columnHierarchy.leafNodes;
                if (columnLeafNodes && columnLeafNodes.length > 0) {
                    var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources;
                    for (var i = 0, ilen = columnLeafNodes.length; i < ilen; i++) {
                        var columnLeafNode = columnLeafNodes[i];
                        if (!columnLeafNode.identity && columnLeafNode.value === undefined) {
                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                            if (source) columnLeafNode.name = source.displayName;
                        }
                    }
                }
            };
            MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function(rootNodes) {
                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes) return this.rowHierarchy;
                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                if (columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes) return this.columnHierarchy;
                return null;
            };
            return MatrixHierarchyNavigator;
        }();
        var MatrixBinder = function() {
            function MatrixBinder(hierarchyNavigator, options) {
                this.hierarchyNavigator = hierarchyNavigator;
                this.options = options;
            }
            MatrixBinder.prototype.onStartRenderingSession = function() {};
            MatrixBinder.prototype.onEndRenderingSession = function() {};
            MatrixBinder.prototype.bindRowHeader = function(item, cell) {
                var styleClasses;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    if (!item.identity) styleClasses = MatrixBinder.rowHeaderStaticLeafClassName; else styleClasses = MatrixBinder.rowHeaderLeafClassName;
                } else styleClasses = MatrixBinder.headerClassName;
                if (item.isSubtotal) styleClasses += " " + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                this.bindHeader(item, cell, this.getRowHeaderMetadata(item));
                if (this.options.onBindRowHeader) this.options.onBindRowHeader(item);
            };
            MatrixBinder.prototype.unbindRowHeader = function(item, cell) {
                cell.extension.clearContainerStyle();
                visuals.controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
            };
            MatrixBinder.prototype.bindColumnHeader = function(item, cell) {
                var styleClasses;
                var overwriteTotalLabel = false;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    styleClasses = MatrixBinder.columnHeaderLeafClassName;
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    if (sortableHeaderColumnMetadata) {
                        this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell);
                    }
                    if (item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal) overwriteTotalLabel = true;
                } else {
                    styleClasses = MatrixBinder.headerClassName;
                }
                if (item.isSubtotal) styleClasses += " " + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                cell.extension.disableDragResize();
                this.bindHeader(item, cell, this.getColumnHeaderMetadata(item), overwriteTotalLabel);
            };
            MatrixBinder.prototype.unbindColumnHeader = function(item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = "";
                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                if (sortableHeaderColumnMetadata) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            MatrixBinder.prototype.bindBodyCell = function(item, cell) {
                var styleClasses = MatrixBinder.bodyCellClassName;
                if (item.isSubtotal) styleClasses += " " + MatrixBinder.totalClassName;
                cell.extension.setContainerStyle(styleClasses);
                cell.extension.contentHost.textContent = item.content;
            };
            MatrixBinder.prototype.unbindBodyCell = function(item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = "";
            };
            MatrixBinder.prototype.registerColumnHeaderClickHandler = function(columnMetadata, cell) {
                var _this = this;
                if (this.options.onColumnHeaderClick) {
                    var handler = function(e) {
                        _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName);
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function(cell) {
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            MatrixBinder.prototype.bindCornerCell = function(item, cell) {
                var styleClasses;
                if (item.isColumnHeaderLeaf) {
                    styleClasses = MatrixBinder.columnHeaderLeafClassName;
                    var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                    if (cornerHeaderMetadata) this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell);
                }
                if (item.isRowHeaderLeaf) {
                    if (styleClasses) styleClasses += " "; else styleClasses = "";
                    styleClasses += MatrixBinder.rowHeaderLeafClassName;
                }
                if (styleClasses) cell.extension.setContainerStyle(styleClasses); else cell.extension.setContainerStyle(MatrixBinder.headerClassName);
                cell.extension.disableDragResize();
                cell.extension.contentHost.textContent = item.metadata ? item.metadata.displayName : "";
            };
            MatrixBinder.prototype.unbindCornerCell = function(item, cell) {
                cell.extension.clearContainerStyle();
                cell.extension.contentHost.textContent = "";
                if (item.isColumnHeaderLeaf) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            MatrixBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {};
            MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {};
            MatrixBinder.prototype.bindEmptySpaceFooterCell = function(cell) {};
            MatrixBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {};
            MatrixBinder.prototype.getHeaderLabel = function(item) {
                return MatrixBinder.getNodeLabel(item);
            };
            MatrixBinder.prototype.getCellContent = function(item) {
                return item.content;
            };
            MatrixBinder.prototype.hasRowGroups = function() {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0) return false;
                return true;
            };
            MatrixBinder.getNodeLabel = function(node) {
                if (node.name) return node.name;
                if (node.value != null) return node.value.toString();
                return "";
            };
            MatrixBinder.prototype.bindHeader = function(item, cell, metadata, overwriteSubtotalLabel) {
                if (item.isSubtotal && !overwriteSubtotalLabel) {
                    cell.extension.contentHost.textContent = this.options.totalLabel;
                    return;
                }
                var value = MatrixBinder.getNodeLabel(item);
                if (!value) {
                    cell.extension.contentHost.innerHTML = MatrixBinder.nonBreakingSpace;
                    return;
                }
                if (metadata && visuals.UrlHelper.isValidUrl(metadata, value)) {
                    visuals.controls.internal.TablixUtils.appendATagToBodyCell(item.value, cell);
                } else cell.extension.contentHost.textContent = value;
            };
            MatrixBinder.prototype.getSortableCornerColumnMetadata = function(item) {
                if (!item.isColumnHeaderLeaf) return null;
                return item.metadata;
            };
            MatrixBinder.prototype.getRowHeaderMetadata = function(item) {
                if (!this.hierarchyNavigator || !item) return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows) return;
                return this.getHierarchyMetadata(dataView.rows, item.level);
            };
            MatrixBinder.prototype.getColumnHeaderMetadata = function(item) {
                if (!this.hierarchyNavigator || !item) return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.columns) return;
                return this.getHierarchyMetadata(dataView.columns, item.level);
            };
            MatrixBinder.prototype.getHierarchyMetadata = function(hierarchy, level) {
                if (!hierarchy || !hierarchy.levels || hierarchy.levels.length < level) return;
                var levelInfo = hierarchy.levels[level];
                if (!levelInfo || !levelInfo.sources || levelInfo.sources.length === 0) return;
                return levelInfo.sources[0];
            };
            MatrixBinder.prototype.getSortableHeaderColumnMetadata = function(item) {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0) return null;
                var columnGroupCount = dataView.columns ? dataView.columns.levels.length - 1 : 0;
                var valueIndex = -1;
                if (columnGroupCount === 0) {
                    valueIndex = item.levelSourceIndex;
                } else if (item.isSubtotal) {
                    var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
                    if (isMultiMeasure) {
                        if (item.parent && item.parent.level === 0) valueIndex = item.levelSourceIndex;
                    } else {
                        if (item.level === 0) valueIndex = item.levelSourceIndex;
                    }
                }
                if (valueIndex !== -1) {
                    valueIndex = valueIndex ? valueIndex : 0;
                    return dataView.valueSources[valueIndex];
                }
                return null;
            };
            MatrixBinder.headerClassName = "bi-tablix-header";
            MatrixBinder.columnHeaderLeafClassName = "bi-tablix-column-header-leaf";
            MatrixBinder.rowHeaderLeafClassName = "bi-tablix-row-header-leaf";
            MatrixBinder.rowHeaderStaticLeafClassName = "bi-tablix-row-header-static-leaf";
            MatrixBinder.bodyCellClassName = "bi-matrix-body-cell";
            MatrixBinder.totalClassName = "total";
            MatrixBinder.nonBreakingSpace = "&nbsp;";
            return MatrixBinder;
        }();
        visuals.MatrixBinder = MatrixBinder;
        var Matrix = function() {
            function Matrix() {
                this.lastAllowHeaderResize = true;
            }
            Matrix.customizeQuery = function(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata) return;
                var dataViewMatrix = dataViewMapping.matrix;
                var objects = dataViewMapping.metadata.objects;
                dataViewMatrix.rows.for.in.subtotalType = Matrix.shouldShowRowSubtotals(objects) ? 2 : 0;
                dataViewMatrix.columns.for.in.subtotalType = Matrix.shouldShowColumnSubtotals(objects) ? 2 : 0;
            };
            Matrix.getSortableRoles = function() {
                return [ "Rows", "Values" ];
            };
            Matrix.prototype.init = function(options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatRaw;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.hostServices = options.host;
            };
            Matrix.prototype.onResizing = function(finalViewport, duration) {
                this.updateViewport(finalViewport);
            };
            Matrix.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                if (options.dataViews && options.dataViews.length > 0) {
                    this.dataView = options.dataViews[0];
                    if (options.operationKind === 1) {
                        this.hierarchyNavigator.updateRows();
                        this.refreshControl(false);
                    } else {
                        this.updateInternal();
                    }
                }
                this.waitingForData = false;
            };
            Matrix.prototype.updateViewport = function(newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Matrix.prototype.refreshControl = function(clear) {
                if (this.element.visible() || this.getLayoutKind() === 1) {
                    this.tablixControl.refresh(clear);
                }
            };
            Matrix.prototype.getLayoutKind = function() {
                return this.isInteractive ? 0 : 1;
            };
            Matrix.prototype.createControl = function(matrixNavigator) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var matrixBinderOptions = {
                    onBindRowHeader: function(item) {
                        _this.onBindRowHeader(item);
                    },
                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                    onColumnHeaderClick: function(queryName) {
                        return _this.onColumnHeaderClick(queryName);
                    }
                };
                var matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions);
                var layoutManager = layoutKind === 1 ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder);
                var tablixContainer = document.createElement("div");
                tablixContainer.className = "tablixContainer";
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: false
                };
                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
            };
            Matrix.prototype.updateInternal = function() {
                var _this = this;
                var dataView = this.dataView;
                if (!this.tablixControl) {
                    var matrixNavigator = createMatrixHierarchyNavigator(dataView.matrix, this.formatter);
                    this.hierarchyNavigator = matrixNavigator;
                    this.tablixControl = this.createControl(matrixNavigator);
                } else {
                    this.hierarchyNavigator.update(dataView.matrix);
                }
                this.verifyHeaderResize();
                this.tablixControl.updateModels(true, dataView.matrix.rows.root.children, dataView.matrix.columns.root.children);
                this.tablixControl.viewport = this.currentViewport;
                setTimeout(function() {
                    _this.refreshControl(true);
                }, 0);
            };
            Matrix.prototype.onBindRowHeader = function(item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Matrix.prototype.onColumnHeaderClick = function(queryName) {
                var sortDescriptors = [ {
                    queryName: queryName
                } ];
                var args = {
                    sortDescriptors: sortDescriptors
                };
                this.hostServices.onCustomSort(args);
            };
            Matrix.prototype.needsMoreData = function(item) {
                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment) return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
            };
            Matrix.shouldShowRowSubtotals = function(objects) {
                if (objects && objects.general) return objects.general.rowSubtotals !== false;
                return true;
            };
            Matrix.shouldShowColumnSubtotals = function(objects) {
                if (objects && objects.general) return objects.general.columnSubtotals !== false;
                return true;
            };
            Matrix.prototype.getMatrixDataViewObjects = function() {
                if (this.dataView && this.dataView.metadata && this.dataView.metadata.objects) return this.dataView.metadata.objects;
            };
            Matrix.prototype.enumerateObjectInstances = function(options) {
                var instances = [];
                if (options.objectName === "general") {
                    var objects = this.getMatrixDataViewObjects();
                    instances.push({
                        selector: null,
                        properties: {
                            rowSubtotals: Matrix.shouldShowRowSubtotals(objects),
                            columnSubtotals: Matrix.shouldShowColumnSubtotals(objects)
                        },
                        objectName: options.objectName
                    });
                }
                return instances;
            };
            Matrix.prototype.shouldAllowHeaderResize = function() {
                return this.hostServices.getViewMode() === 1;
            };
            Matrix.prototype.verifyHeaderResize = function() {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Matrix.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            Matrix.preferredLoadMoreThreshold = .8;
            Matrix.TotalLabel = "TableTotalLabel";
            Matrix.capabilities = {
                dataRoles: [ {
                    name: RoleNames.rows,
                    kind: 0
                }, {
                    name: RoleNames.columns,
                    kind: 0
                }, {
                    name: RoleNames.values,
                    kind: 1
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: {
                                type: {
                                    formatting: {
                                        formatString: true
                                    }
                                }
                            },
                            rowSubtotals: {
                                type: {
                                    bool: true
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_RowTotals")
                            },
                            columnSubtotals: {
                                type: {
                                    bool: true
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_ColumnTotals")
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Rows: {
                            max: 0
                        },
                        Columns: {
                            max: 0
                        },
                        Values: {
                            min: 1
                        }
                    }, {
                        Rows: {
                            min: 1
                        },
                        Columns: {
                            min: 0
                        },
                        Values: {
                            min: 0
                        }
                    }, {
                        Rows: {
                            min: 0
                        },
                        Columns: {
                            min: 1
                        },
                        Values: {
                            min: 0
                        }
                    } ],
                    matrix: {
                        rows: {
                            "for": {
                                "in": "Rows"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 100
                                }
                            }
                        },
                        columns: {
                            "for": {
                                "in": "Columns"
                            },
                            dataReductionAlgorithm: {
                                top: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            "for": {
                                "in": "Values"
                            }
                        }
                    }
                } ],
                filterMappings: {
                    measureFilter: {
                        targetRoles: [ RoleNames.rows ]
                    }
                },
                sorting: {
                    custom: {}
                },
                suppressDefaultTitle: true
            };
            return Matrix;
        }();
        visuals.Matrix = Matrix;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Textbox = function() {
            function Textbox() {}
            Textbox.translateFontFamily = function(fontFamily) {
                return fontFamily === "Heading" ? "Segoe UI Light" : fontFamily;
            };
            Textbox.prototype.init = function(options) {
                this.element = options.element;
            };
            Textbox.prototype.onResizing = function(viewport, duration) {};
            Textbox.prototype.onDataChanged = function(options) {
                this.element.empty();
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0) return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general) return;
                var paragraphs = objects.general.paragraphs;
                if (!paragraphs) return;
                var textboxDiv = $("<div class='textbox'></div>");
                for (var i = 0, len = paragraphs.length; i < len; ++i) {
                    var paraDef = paragraphs[i];
                    var paraDiv = $("<div />");
                    if (paraDef.horizontalTextAlignment) {
                        paraDiv.css("textAlign", paraDef.horizontalTextAlignment);
                    }
                    for (var j = 0, jlen = paraDef.textRuns.length; j < jlen; ++j) {
                        var textRunDef = paraDef.textRuns[j];
                        var textRunSpan = $("<span/>");
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                textRunSpan.css("fontFamily", Textbox.translateFontFamily(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                textRunSpan.css("fontSize", styleDef.fontSize);
                            }
                            if (styleDef.fontStyle) {
                                textRunSpan.css("fontStyle", styleDef.fontStyle);
                            }
                            if (styleDef.fontWeight) {
                                textRunSpan.css("fontWeight", styleDef.fontWeight);
                            }
                            if (styleDef.textDecoration) {
                                textRunSpan.css("textDecoration", styleDef.textDecoration);
                            }
                        }
                        textRunSpan.text(textRunDef.value);
                        textRunSpan.appendTo(paraDiv);
                    }
                    paraDiv.appendTo(textboxDiv);
                }
                textboxDiv.appendTo(this.element);
            };
            Textbox.capabilities = {
                objects: {
                    general: {
                        properties: {
                            paragraphs: {
                                type: {}
                            }
                        }
                    }
                },
                suppressDefaultTitle: true
            };
            return Textbox;
        }();
        visuals.Textbox = Textbox;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.treemapCapabilities = {
            dataRoles: [ {
                name: "Group",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
            }, {
                name: "Details",
                kind: 0,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
            }, {
                name: "Values",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
            }, {
                name: "Gradient",
                kind: 1,
                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                    properties: {
                        fill: {
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                            type: {
                                fillRule: {}
                            },
                            rule: {
                                inputRole: "Gradient",
                                output: {
                                    property: "fill",
                                    selector: [ "Group" ]
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true,
                                mainShow: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Group: {
                        max: 1
                    },
                    Details: {
                        max: 0
                    },
                    Gradient: {
                        max: 1
                    }
                }, {
                    Group: {
                        max: 1
                    },
                    Details: {
                        min: 1,
                        max: 1
                    },
                    Values: {
                        max: 1
                    },
                    Gradient: {
                        max: 0
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Group"
                        },
                        dataReductionAlgorithm: {
                            top: {}
                        }
                    },
                    values: {
                        group: {
                            by: "Details",
                            select: [ {
                                bind: {
                                    to: "Values"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        }
                    },
                    rowCount: {
                        preferred: {
                            min: 2
                        }
                    }
                }
            } ],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [ {
                        role: "Values",
                        direction: 2
                    } ]
                }
            }
        };
        visuals.treemapProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var CssConstants = jsCommon.CssConstants;
        var StringExtensions = jsCommon.StringExtensions;
        var Treemap = function() {
            function Treemap(options) {
                if (options && options.animator) {
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                }
            }
            Treemap.prototype.init = function(options) {
                this.options = options;
                var element = options.element;
                element.empty();
                this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(Treemap.ClassName, true);
                this.shapeGraphicsContext = this.svg.append("g").classed(Treemap.ShapesClassName, true);
                this.labelGraphicsContext = this.svg.append("g").classed(Treemap.LabelsClassName, true);
                this.element = element;
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width
                };
                this.style = options.style;
                this.treemap = d3.layout.treemap().sticky(false).sort(function(a, b) {
                    return a.size - b.size;
                }).value(function(d) {
                    return d.size;
                }).round(false);
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.colors = this.style.colorPalette.dataColors;
                this.hostService = options.host;
            };
            Treemap.converter = function(dataView, colors, labelSettings, interactivityService, legendObjectProperties) {
                var rootNode = {
                    key: "root",
                    name: "root",
                    children: [],
                    selected: false,
                    highlightMultiplier: 0,
                    identity: visuals.SelectionId.createNull(),
                    color: undefined
                };
                var allNodes = [];
                var hasHighlights;
                var legendDataPoints = [];
                var legendTitle = "";
                var legendData = {
                    title: legendTitle,
                    dataPoints: legendDataPoints
                };
                var colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill);
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects["labels"];
                    if (labelsObj) {
                        labelSettings.show = labelsObj.show !== undefined ? labelsObj.show : labelSettings.show;
                        labelSettings.labelColor = labelsObj.color !== undefined ? labelsObj.color.solid.color : labelSettings.labelColor;
                    }
                }
                if (dataView && dataView.categorical && dataView.categorical.values) {
                    var data = dataView.categorical;
                    var valueColumns = data.values;
                    hasHighlights = !!(valueColumns.length > 0 && valueColumns[0].highlights);
                    var formatStringProp = visuals.treemapProps.general.formatString;
                    var result = Treemap.getValuesFromCategoricalDataView(data, hasHighlights);
                    var values = result.values;
                    var highlights = result.highlights;
                    if (result.highlightsOverflow) {
                        hasHighlights = false;
                        values = highlights;
                    }
                    var grouped = valueColumns.grouped();
                    var isMultiSeries = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    var hasDynamicSeries = !!valueColumns.source;
                    if (data.categories == null && values) {
                        for (var i = 0, ilen = values[0].length; i < ilen; i++) {
                            var value = values[0][i];
                            if (!Treemap.checkValueForShape(value)) continue;
                            var valueColumn = valueColumns[i];
                            var nodeName = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, valueColumns, formatStringProp);
                            var identity = hasDynamicSeries ? visuals.SelectionId.createWithId(valueColumns[i].identity) : visuals.SelectionId.createWithMeasure(valueColumns[i].source.queryName);
                            var key = identity.getKey();
                            var color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueColumn.objects && valueColumn.objects[0], data.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source)) : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
                            var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                            var categorical = dataView.categorical;
                            var valueIndex = i;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, nodeName, categorical.values, value, null, valueIndex);
                            var highlightedTooltipInfo;
                            if (highlightedValue !== undefined) {
                                highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, nodeName, categorical.values, value, null, valueIndex, highlightedValue);
                            }
                            var node = {
                                key: key,
                                name: nodeName,
                                size: value,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo
                            };
                            if (hasHighlights && highlights) {
                                node.highlightMultiplier = value ? highlights[0][i] / value : 0;
                            }
                            rootNode.children.push(node);
                            allNodes.push(node);
                            legendDataPoints.push({
                                label: nodeName,
                                color: color,
                                icon: 0,
                                identity: identity,
                                selected: false
                            });
                        }
                    } else if (data.categories && data.categories.length > 0) {
                        var categoryColumn = data.categories[0];
                        var valueColumnCount = valueColumns.length;
                        legendTitle = categoryColumn.source ? categoryColumn.source.displayName : "";
                        for (var i = 0, ilen = values.length; i < ilen; i++) {
                            var categoryIdentity = categoryColumn.identity ? categoryColumn.identity[i] : undefined;
                            var identity = categoryIdentity ? visuals.SelectionId.createWithId(categoryIdentity) : visuals.SelectionId.createNull();
                            var key = identity.getKey();
                            var objects = categoryColumn.objects && categoryColumn.objects[i];
                            var color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[i]);
                            var categoryValue = visuals.valueFormatter.format(categoryColumn.values[i], visuals.valueFormatter.getFormatString(categoryColumn.values[i], formatStringProp));
                            var value = values[i][0];
                            var highlightedValue = hasHighlights && highlights ? highlights[i][0] : undefined;
                            var categorical = dataView.categorical;
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value);
                            var highlightedTooltipInfo;
                            if (highlightedValue !== undefined) {
                                highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, 0, highlightedValue);
                            }
                            var node = {
                                key: key,
                                name: categoryValue,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo
                            };
                            legendDataPoints.push({
                                label: categoryValue,
                                color: color,
                                icon: 0,
                                identity: identity,
                                selected: false
                            });
                            var total = 0;
                            var highlightTotal = 0;
                            var omitSecondLevel = valueColumnCount === 1 && valueColumns[0].source.groupName == null;
                            var currentValues = values[i];
                            for (var j = 0, jlen = currentValues.length; j < jlen; j++) {
                                var valueColumn = valueColumns[j];
                                var value = currentValues[j];
                                var highlight;
                                if (!Treemap.checkValueForShape(value)) continue;
                                total += value;
                                if (hasHighlights) {
                                    highlight = highlights[i][j];
                                    highlightTotal += highlight;
                                }
                                if (!omitSecondLevel) {
                                    var childName = null;
                                    var childKey = {
                                        parentId: node.key,
                                        nodeId: undefined
                                    };
                                    if (isMultiSeries) {
                                        childKey.nodeId = {
                                            name: childName,
                                            index: j
                                        };
                                        childName = valueColumn.source.displayName;
                                    } else {
                                        childKey.nodeId = valueColumn.identity.key;
                                        childName = valueColumn.source.groupName;
                                    }
                                    var childIdentity = visuals.SelectionId.createWithIdsAndMeasure(categoryIdentity, hasDynamicSeries ? valueColumn.identity : undefined, isMultiSeries ? valueColumn.source.queryName : undefined);
                                    var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                                    var categorical = dataView.categorical;
                                    var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, j);
                                    var highlightedTooltipInfo;
                                    if (highlightedValue !== undefined) {
                                        highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, j, highlightedValue);
                                    }
                                    var childNode = {
                                        key: childIdentity.getKey(),
                                        name: childName,
                                        size: value,
                                        color: color,
                                        selected: false,
                                        identity: childIdentity,
                                        tooltipInfo: tooltipInfo,
                                        highlightedTooltipInfo: highlightedTooltipInfo
                                    };
                                    if (hasHighlights) childNode.highlightMultiplier = value ? highlight / value : 0;
                                    if (node.children == null) node.children = [];
                                    node.children.push(childNode);
                                    allNodes.push(childNode);
                                }
                            }
                            if (Treemap.checkValueForShape(total)) {
                                node.size = total;
                                rootNode.children.push(node);
                                allNodes.push(node);
                            }
                            if (hasHighlights) node.highlightMultiplier = total ? highlightTotal / total : 0;
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(allNodes);
                }
                legendData = {
                    title: legendTitle,
                    dataPoints: legendDataPoints
                };
                return {
                    root: rootNode,
                    hasHighlights: hasHighlights,
                    legendData: legendData,
                    dataLabelsSettings: labelSettings,
                    legendObjectProperties: legendObjectProperties
                };
            };
            Treemap.getValuesFromCategoricalDataView = function(data, hasHighlights) {
                var valueColumns = data.values;
                var categoryValueCount;
                if (valueColumns && data.categories == null) {
                    categoryValueCount = 1;
                } else if (valueColumns && data.categories && data.categories.length > 0) {
                    categoryValueCount = data.categories[0].values.length;
                }
                var values = [];
                var highlights = [];
                for (var i = 0; i < categoryValueCount; i++) {
                    values.push([]);
                    if (hasHighlights) highlights.push([]);
                }
                var highlightsOverflow;
                for (var j = 0; j < valueColumns.length; j++) {
                    var valueColumn = valueColumns[j];
                    for (var i = 0; i < categoryValueCount; i++) {
                        var value = valueColumn.values[i];
                        values[i].push(value);
                        if (hasHighlights) {
                            var highlight = valueColumn.highlights[i];
                            if (!highlight) highlight = 0;
                            highlights[i].push(highlight);
                            if (highlight > value) highlightsOverflow = true;
                        }
                    }
                }
                return {
                    values: values,
                    highlights: hasHighlights ? highlights : undefined,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : undefined
                };
            };
            Treemap.prototype.update = function(options) {
                debug.assertValue(options, "options");
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                var labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                var legendObjectProperties = null;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    var dataView = dataViews[0];
                    var dataViewMetadata = dataView.metadata;
                    var objects;
                    if (dataViewMetadata) objects = dataViewMetadata.objects;
                    if (objects) {
                        legendObjectProperties = objects["legend"];
                    }
                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, legendObjectProperties);
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false, false, false);
                    if (warnings && warnings.length > 0) this.hostService.setWarnings(warnings);
                } else {
                    var rootNode = {
                        key: "root",
                        name: "root",
                        children: [],
                        selected: false,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: undefined
                    };
                    var legendData = {
                        title: "",
                        dataPoints: []
                    };
                    var treeMapData = {
                        root: rootNode,
                        hasHighlights: false,
                        legendData: legendData,
                        dataLabelsSettings: labelSettings
                    };
                    this.data = treeMapData;
                }
                var duration = options.duration == null ? this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0 : options.duration;
                this.updateInternal(!!duration, duration);
            };
            Treemap.prototype.onDataChanged = function(options) {
                this.update({
                    duration: options.duration || (this.animator ? visuals.AnimatorCommon.MinervaAnimationDuration : 0),
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            };
            Treemap.prototype.onResizing = function(viewport, duration) {
                this.update({
                    duration: duration || 0,
                    dataViews: this.dataViews,
                    viewport: viewport
                });
            };
            Treemap.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            Treemap.prototype.enumerateObjectInstances = function(options) {
                var data = this.data;
                if (!data) return;
                var objectName = options.objectName;
                switch (objectName) {
                  case "dataPoint":
                    var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                    var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                    if (!hasGradientRole) return this.enumerateDataPoints(data);
                    break;

                  case "legend":
                    return this.enumerateLegend(data);

                  case "labels":
                    return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false);
                }
            };
            Treemap.prototype.enumerateDataPoints = function(data) {
                var rootChildren = data.root.children;
                if (_.isEmpty(rootChildren)) return;
                var instances = [];
                for (var y = 0; y < rootChildren.length; y++) {
                    var treemapNode = rootChildren[y];
                    instances.push({
                        displayName: treemapNode.name,
                        selector: treemapNode.identity.getSelector(),
                        properties: {
                            fill: {
                                solid: {
                                    color: treemapNode.color
                                }
                            }
                        },
                        objectName: "dataPoint"
                    });
                }
                return instances;
            };
            Treemap.prototype.enumerateLegend = function(data) {
                var legendObjectProperties = {
                    legend: data.legendObjectProperties
                };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title);
                return [ {
                    selector: null,
                    objectName: "legend",
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText
                    }
                } ];
            };
            Treemap.checkValueForShape = function(value) {
                if (!value) return false;
                return value > 0;
            };
            Treemap.prototype.calculateTreemapSize = function() {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            };
            Treemap.prototype.initViewportDependantProperties = function(duration) {
                if (duration === void 0) {
                    duration = 0;
                }
                var viewport = this.calculateTreemapSize();
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.isMajorLabel = function(node) {
                return node.depth === 1;
            };
            Treemap.hasChildrenWithIdentity = function(node) {
                var children = node.children;
                if (!children) return false;
                var count = children.length;
                if (count === 0) return false;
                for (var i = count - 1; i >= 0; i--) {
                    if (children[i].identity.hasIdentity()) return true;
                }
                return false;
            };
            Treemap.canDisplayLabel = function(node) {
                if (node.depth < 1 || node.depth > 2) return false;
                if (StringExtensions.isNullOrEmpty(node.name)) return false;
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                var isMajorLabel = Treemap.isMajorLabel(node);
                var minTextWidth = isMajorLabel ? Treemap.MinTextWidthForMajorLabel : Treemap.MinTextWidthForMinorLabel;
                if (availableWidth < minTextWidth) return false;
                var textHeight = isMajorLabel ? Treemap.MajorLabelTextSize : Treemap.MinorLabelTextSize;
                var textHeightWithMargin = textHeight + Treemap.TextMargin * 2;
                if (node.dy < textHeightWithMargin) return false;
                if (node.depth === 2) {
                    var parent = node.parent;
                    var roomTop = Math.max(parent.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2, node.y);
                    if (node.y + node.dy - roomTop < textHeightWithMargin) return false;
                }
                return true;
            };
            Treemap.createLabelForShape = function(node) {
                var baseTextProperties = Treemap.isMajorLabel(node) ? Treemap.MajorLabelTextProperties : Treemap.MinorLabelTextProperties;
                var textProperties = {
                    text: node.name,
                    fontFamily: baseTextProperties.fontFamily,
                    fontSize: baseTextProperties.fontSize
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, node.dx - Treemap.TextMargin * 2);
            };
            Treemap.getFill = function(d, isHighlightRect) {
                if (d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect) return CssConstants.noneValue;
                if (Treemap.hasChildrenWithIdentity(d)) return CssConstants.noneValue;
                return d.color;
            };
            Treemap.getFillOpacity = function(d, hasSelection, hasHighlights, isHighlightRect) {
                if (hasHighlights) {
                    if (isHighlightRect) return null;
                    return Treemap.DimmedShapeOpacity.toString();
                }
                if (!hasSelection || d.selected) return null;
                if (d.depth > 1 && d.parent.selected) return null;
                if (Treemap.hasChildrenWithIdentity(d)) return null;
                return Treemap.DimmedShapeOpacity.toString();
            };
            Treemap.prototype.updateInternal = function(useAnimation, duration) {
                if (useAnimation === void 0) {
                    useAnimation = true;
                }
                if (duration === void 0) {
                    duration = 0;
                }
                var data = this.data;
                var hasHighlights = data && data.hasHighlights;
                var labelSettings = data ? data.dataLabelsSettings : null;
                if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend) && this.data) {
                    this.renderLegend();
                }
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap.size([ viewport.width, viewport.height ]);
                var nodes = data && data.root ? this.treemap.nodes(data.root) : [];
                var highlightNodes = nodes.filter(function(value) {
                    return value.highlightMultiplier != null && (!value.children || value.children.length === 0);
                });
                var labeledNodes = labelSettings.show ? nodes.filter(function(d) {
                    return Treemap.canDisplayLabel(d);
                }) : [];
                var shapes;
                var highlightShapes;
                var labels;
                var result;
                if (this.animator && useAnimation) {
                    var options = {
                        viewModel: data,
                        nodes: nodes,
                        highlightNodes: highlightNodes,
                        labeledNodes: labeledNodes,
                        shapeGraphicsContext: this.shapeGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        interactivityService: this.interactivityService
                    };
                    result = this.animator.animate(options);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    labels = result.labels;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    var hasSelection = nodes.some(function(value) {
                        return value.selected;
                    });
                    var shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights);
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights);
                    labels = Treemap.drawDefaultLabels(this.labelGraphicsContext, labeledNodes, labelSettings);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        labels: labels,
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        nodes: nodes,
                        hasHighlights: data.hasHighlights
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                    return tooltipEvent.data.highlightedTooltipInfo;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.prototype.renderLegend = function() {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position) this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.currentViewport);
                } else {
                    this.legend.changeOrientation(0);
                    this.legend.drawLegend({
                        dataPoints: []
                    }, this.currentViewport);
                }
            };
            Treemap.prototype.accept = function(visitor, options) {
                visitor.visitTreemap(options);
            };
            Treemap.getNodeClass = function(d, highlight) {
                var nodeClass;
                switch (d.depth) {
                  case 1:
                    nodeClass = Treemap.ParentGroupClassName;
                    break;

                  case 2:
                    nodeClass = Treemap.NodeGroupClassName;
                    break;

                  case 0:
                    nodeClass = Treemap.RootNodeClassName;
                    break;

                  default:
                    debug.assertFail("Treemap only supports 2 levels maxiumum");
                }
                nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
                return nodeClass;
            };
            Treemap.createTreemapShapeLayout = function(isHighlightRect) {
                if (isHighlightRect === void 0) {
                    isHighlightRect = false;
                }
                return {
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0);
                    },
                    width: function(d) {
                        return Math.max(0, d.dx);
                    },
                    height: function(d) {
                        return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1));
                    }
                };
            };
            Treemap.createTreemapZeroShapeLayout = function() {
                return {
                    x: function(d) {
                        return d.x;
                    },
                    y: function(d) {
                        return d.y + d.dy;
                    },
                    width: function(d) {
                        return Math.max(0, d.dx);
                    },
                    height: function(d) {
                        return 0;
                    }
                };
            };
            Treemap.drawDefaultShapes = function(context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = false;
                var shapes = context.selectAll("." + Treemap.TreemapNodeClassName).data(nodes, function(d) {
                    return d.key;
                });
                shapes.enter().append("rect").attr("class", Treemap.layout.shapeClass);
                shapes.style("fill", function(d) {
                    return Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(Treemap.layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            Treemap.drawDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll("." + Treemap.HighlightNodeClassName).data(nodes, function(d) {
                    return d.key + "highlight";
                });
                highlightShapes.enter().append("rect").attr("class", Treemap.layout.highlightShapeClass);
                highlightShapes.style("fill", function(d) {
                    return Treemap.getFill(d, isHighlightShape);
                }).style("fill-opacity", function(d) {
                    return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                }).attr(Treemap.layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            Treemap.drawDefaultLabels = function(context, nodes, labelSettings) {
                var labels = context.selectAll("text").data(nodes, function(d) {
                    return d.key;
                });
                labels.enter().append("text").attr("class", Treemap.layout.labelClass);
                labels.attr(Treemap.layout.labelLayout).text(Treemap.layout.labelText).style("fill", function() {
                    return labelSettings.labelColor;
                });
                labels.exit().remove();
                return labels;
            };
            Treemap.DimmedShapeOpacity = .4;
            Treemap.ClassName = "treemap";
            Treemap.LabelsClassName = "labels";
            Treemap.MajorLabelClassName = "majorLabel";
            Treemap.MinorLabelClassName = "minorLabel";
            Treemap.ShapesClassName = "shapes";
            Treemap.TreemapNodeClassName = "treemapNode";
            Treemap.RootNodeClassName = "rootNode";
            Treemap.ParentGroupClassName = "parentGroup";
            Treemap.NodeGroupClassName = "nodeGroup";
            Treemap.HighlightNodeClassName = "treemapNodeHighlight";
            Treemap.TextMargin = 5;
            Treemap.MinorLabelTextSize = 10;
            Treemap.MinTextWidthForMinorLabel = 18;
            Treemap.MinorLabelTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: Treemap.MinorLabelTextSize + "px"
            };
            Treemap.MajorLabelTextSize = 12;
            Treemap.MinTextWidthForMajorLabel = 22;
            Treemap.MajorLabelTextProperties = {
                fontFamily: "wf_segoe-ui_normal",
                fontSize: Treemap.MajorLabelTextSize + "px"
            };
            Treemap.layout = {
                shapeClass: function(d) {
                    return Treemap.getNodeClass(d, false);
                },
                shapeLayout: Treemap.createTreemapShapeLayout(false),
                highlightShapeClass: function(d) {
                    return Treemap.getNodeClass(d, true);
                },
                highlightShapeLayout: Treemap.createTreemapShapeLayout(true),
                zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                labelClass: function(d) {
                    return Treemap.isMajorLabel(d) ? Treemap.MajorLabelClassName : Treemap.MinorLabelClassName;
                },
                labelLayout: {
                    x: function(d) {
                        return d.x + Treemap.TextMargin;
                    },
                    y: function(d) {
                        if (Treemap.isMajorLabel(d)) return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize;
                        return d.y + d.dy - Treemap.TextMargin;
                    }
                },
                labelText: function(d) {
                    return Treemap.createLabelForShape(d);
                }
            };
            return Treemap;
        }();
        visuals.Treemap = Treemap;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var Card = function(_super) {
            __extends(Card, _super);
            function Card(options) {
                _super.call(this, Card.cardClassName);
                this.isScrollable = false;
                if (options && options.isScrollable) this.isScrollable = options.isScrollable;
            }
            Card.prototype.init = function(options) {
                debug.assertValue(options, "options");
                this.animationOptions = options.animation;
                var settings = this.convertSettings(options.settings);
                this.displayUnitSystemType = !settings || !settings.DisplayUnitSystemType ? 2 : settings.DisplayUnitSystemType;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0)).append("svg");
                this.graphicsContext = svg.append("g");
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportProperties();
                if (this.isScrollable) {
                    svg.attr("class", Card.cardClassName);
                    this.labelContext = svg.append("g");
                }
            };
            Card.prototype.clear = function(valueOnly) {
                if (valueOnly === void 0) {
                    valueOnly = false;
                }
                this.svg.select(Card.Value.selector).text("");
                if (!valueOnly) this.svg.select(Card.Label.selector).text("");
                _super.prototype.clear.call(this);
            };
            Card.prototype.convertSettings = function(settings) {
                if (settings && settings.version === undefined) {
                    var cardSettings = powerbi.SettingsUtil.copyCommonSettings(settings);
                    return cardSettings;
                }
                return settings;
            };
            Card.prototype.onDataChanged = function(options) {
                debug.assertValue(options, "options");
                var dataView = options.dataViews[0];
                var value;
                if (dataView) {
                    this.getMetaDataColumn(dataView);
                    if (dataView.single) {
                        value = dataView.single.value;
                    }
                }
                this.updateInternal(value, options.duration);
            };
            Card.prototype.onResizing = function(viewport, duration) {
                this.currentViewport = viewport;
                this.updateViewportProperties();
                this.updateInternal(this.value, duration, true);
            };
            Card.prototype.updateViewportProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            };
            Card.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
            };
            Card.prototype.updateInternal = function(target, duration, forceUpdate) {
                if (duration === void 0) {
                    duration = 0;
                }
                if (forceUpdate === void 0) {
                    forceUpdate = false;
                }
                if (target == null) {
                    this.clear(true);
                    return;
                }
                var start = this.value;
                if (this.isScrollable) {
                    var label;
                    var metaDataColumn = this.metaDataColumn;
                    var labelStyles = Card.DefaultStyle.label;
                    var valueStyles = Card.DefaultStyle.value;
                    var formatter = visuals.valueFormatter.create({
                        format: this.getFormatString(metaDataColumn),
                        value: target,
                        displayUnitSystemType: this.displayUnitSystemType,
                        formatSingleValues: true,
                        allowFormatBeautification: true
                    });
                    if (metaDataColumn) label = metaDataColumn.displayName;
                    if (target != null) target = formatter.format(target);
                    var translateX = this.getTranslateX(this.currentViewport.width);
                    var translateY = (this.currentViewport.height - labelStyles.height - valueStyles.fontSize) / 2;
                    var valueElement = this.graphicsContext.attr("transform", visuals.SVGUtil.translate(translateX, this.getTranslateY(valueStyles.fontSize + translateY))).selectAll("text").data([ target ]);
                    valueElement.enter().append("text").attr("class", Card.Value.class);
                    valueElement.text(function(d) {
                        return d;
                    }).style({
                        "font-size": valueStyles.fontSize + "px",
                        fill: valueStyles.color,
                        "font-family": valueStyles.fontFamily,
                        "text-anchor": this.getTextAnchor()
                    });
                    valueElement.exit().remove();
                    var labelElement = this.labelContext.attr("transform", visuals.SVGUtil.translate(translateX, this.getTranslateY(valueStyles.fontSize + labelStyles.height + translateY))).selectAll("text").data([ label ]);
                    labelElement.enter().append("text").attr("class", Card.Label.class);
                    labelElement.text(function(d) {
                        return d;
                    }).style({
                        "font-size": labelStyles.fontSize + "px",
                        fill: labelStyles.color,
                        "text-anchor": this.getTextAnchor()
                    });
                    labelElement.exit().remove();
                } else {
                    this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate);
                }
                this.updateTooltip(target);
                this.value = target;
            };
            Card.prototype.updateTooltip = function(target) {
                if (!this.toolTip) this.toolTip = this.graphicsContext.append("svg:title");
                this.toolTip.text(target);
            };
            Card.cardClassName = "card";
            Card.Label = {
                "class": "label",
                selector: ".label"
            };
            Card.Value = {
                "class": "value",
                selector: ".value"
            };
            Card.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    fontSize: 16,
                    color: "#a6a6a6",
                    height: 26
                },
                value: {
                    fontSize: 37,
                    color: "#333333",
                    fontFamily: "wf_segoe-ui_Semibold"
                }
            };
            Card.capabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: 1,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields")
                } ],
                objects: visuals.AnimatedText.objectDescs,
                dataViewMappings: [ {
                    conditions: [ {
                        Values: {
                            max: 1
                        }
                    } ],
                    single: {
                        role: "Values"
                    }
                } ],
                suppressDefaultTitle: true
            };
            return Card;
        }(visuals.AnimatedText);
        visuals.Card = Card;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var NoMapLocationWarning = function() {
            function NoMapLocationWarning() {}
            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function() {
                    return "NoMapLocation";
                },
                enumerable: true,
                configurable: true
            });
            NoMapLocationWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "NoMapLocationMessage";
                var titleKey = "NoMapLocationKey";
                var detailKey = "NoMapLocationValue";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            };
            return NoMapLocationWarning;
        }();
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var SmallSlicesCulledWarning = function() {
            function SmallSlicesCulledWarning() {}
            Object.defineProperty(SmallSlicesCulledWarning.prototype, "code", {
                get: function() {
                    return "SmallSlicesCulled";
                },
                enumerable: true,
                configurable: true
            });
            SmallSlicesCulledWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "DsrLimitWarning_TooMuchDataMessage";
                var titleKey = "";
                var detailKey = "";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            };
            return SmallSlicesCulledWarning;
        }();
        visuals.SmallSlicesCulledWarning = SmallSlicesCulledWarning;
        var NaNNotSupportedWarning = function() {
            function NaNNotSupportedWarning() {}
            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function() {
                    return "NaNNotSupported";
                },
                enumerable: true,
                configurable: true
            });
            NaNNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_InfinityValues";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            };
            return NaNNotSupportedWarning;
        }();
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = function() {
            function InfinityValuesNotSupportedWarning() {}
            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function() {
                    return "InfinityValuesNotSupported";
                },
                enumerable: true,
                configurable: true
            });
            InfinityValuesNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_InfinityValues";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            };
            return InfinityValuesNotSupportedWarning;
        }();
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = function() {
            function ValuesOutOfRangeWarning() {}
            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function() {
                    return "ValuesOutOfRange";
                },
                enumerable: true,
                configurable: true
            });
            ValuesOutOfRangeWarning.prototype.getMessages = function(resourceProvider) {
                var messageKey = "VisualWarning_VisualizationOutOfRange";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: "",
                    detail: ""
                };
                return visualMessage;
            };
            return ValuesOutOfRangeWarning;
        }();
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        visuals.waterfallChartCapabilities = {
            dataRoles: [ {
                name: "Category",
                kind: 0
            }, {
                name: "Y",
                kind: 1
            } ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                    properties: {
                        formatString: {
                            type: {
                                formatting: {
                                    formatString: true
                                }
                            }
                        }
                    }
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                            type: {
                                formatting: {
                                    legendPosition: true
                                }
                            }
                        },
                        showTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                            type: {
                                bool: true
                            }
                        },
                        titleText: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                            type: {
                                text: true
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                            type: {
                                formatting: {
                                    labelDisplayUnits: true
                                }
                            }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                            type: {
                                numeric: true
                            }
                        }
                    }
                },
                sentimentColors: {
                    displayName: powerbi.data.createDisplayNameGetter("Waterfall_SentimentColors"),
                    properties: {
                        increaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_IncreaseLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        decreaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_DecreaseLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        },
                        totalFill: {
                            displayName: powerbi.data.createDisplayNameGetter("Waterfall_TotalLabel"),
                            type: {
                                fill: {
                                    solid: {
                                        color: true
                                    }
                                }
                            }
                        }
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                    properties: {
                        show: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                            type: {
                                bool: true
                            }
                        },
                        position: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                            type: {
                                formatting: {
                                    yAxisPosition: true
                                }
                            }
                        },
                        start: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                            type: {
                                numeric: true
                            }
                        },
                        end: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                            type: {
                                numeric: true
                            }
                        },
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                            type: {
                                bool: true
                            }
                        },
                        axisStyle: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                            type: {
                                formatting: {
                                    axisStyle: true
                                }
                            }
                        }
                    }
                }
            },
            dataViewMappings: [ {
                conditions: [ {
                    Category: {
                        max: 1
                    },
                    Y: {
                        max: 1
                    }
                } ],
                categorical: {
                    categories: {
                        "for": {
                            "in": "Category"
                        }
                    },
                    values: {
                        select: [ {
                            bind: {
                                to: "Y"
                            }
                        } ]
                    }
                }
            } ]
        };
        visuals.waterfallChartProps = {
            sentimentColors: {
                increaseFill: {
                    objectName: "sentimentColors",
                    propertyName: "increaseFill"
                },
                decreaseFill: {
                    objectName: "sentimentColors",
                    propertyName: "decreaseFill"
                },
                totalFill: {
                    objectName: "sentimentColors",
                    propertyName: "totalFill"
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var WaterfallChart = function() {
            function WaterfallChart(options) {
                this.isScrollable = options.isScrollable;
            }
            WaterfallChart.prototype.init = function(options) {
                debug.assertValue(options, "options");
                this.svg = options.svg;
                this.clearCatcher = this.svg.select(".clearCatcher");
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.interactivityService = visuals.VisualInteractivityFactory.buildInteractivityService(options);
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.element = options.element;
                this.colors = this.style.colorPalette.dataColors;
                this.element.addClass(WaterfallChart.WaterfallClassName);
                this.mainGraphicsSVG = this.svg.append("svg");
                this.mainGraphicsContext = this.mainGraphicsSVG.append("g").classed(WaterfallChart.MainGraphicsContextClassName, true);
                this.dataLabelsSVG = this.svg.append("g").classed(WaterfallChart.DataLabelsSVGClassName, true);
            };
            WaterfallChart.converter = function(dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, dataViewMetadata) {
                debug.assertValue(palette, "palette");
                var formatStringProp = WaterfallChart.formatStringProp;
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, formatStringProp);
                var categories = categoryInfo.categories, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                var increaseColor = sentimentColors.increaseFill.solid.color;
                var decreaseColor = sentimentColors.decreaseFill.solid.color;
                var totalColor = sentimentColors.totalFill.solid.color;
                var legend = [ {
                    label: hostServices.getLocalizedString(WaterfallChart.IncreaseLabel),
                    color: increaseColor,
                    icon: 0,
                    identity: !_.isEmpty(categoryIdentities) ? visuals.SelectionId.createWithId(categoryIdentities[0]) : visuals.SelectionId.createNull(),
                    selected: false
                }, {
                    label: hostServices.getLocalizedString(WaterfallChart.DecreaseLabel),
                    color: decreaseColor,
                    icon: 0,
                    identity: !_.isEmpty(categoryIdentities) ? visuals.SelectionId.createWithId(categoryIdentities[0]) : visuals.SelectionId.createNull(),
                    selected: false
                } ];
                var pos = 0, posMin = 0, posMax = 0;
                var dataPoints = [];
                var valuesMetadata = null;
                if (dataView.values && dataView.values.length > 0) {
                    var column = dataView.values[0];
                    valuesMetadata = column.source;
                    for (var categoryIndex = 0, catLen = column.values.length; categoryIndex < catLen; categoryIndex++) {
                        var category = categories[categoryIndex];
                        var value = column.values[categoryIndex];
                        var identity = categoryIdentities ? visuals.SelectionId.createWithId(categoryIdentities[categoryIndex], false) : visuals.SelectionId.createNull();
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categories, category, dataView.values, value);
                        var color = value > 0 ? increaseColor : decreaseColor;
                        dataPoints.push({
                            value: value,
                            position: pos,
                            color: color,
                            categoryValue: category,
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: dataLabelSettings.overrideDefaultColor ? dataLabelSettings.labelColor : color
                        });
                        pos += value;
                        if (pos > posMax) posMax = pos;
                        if (pos < posMin) posMin = pos;
                    }
                }
                if (WaterfallChart.showTotal) {
                    var identity = visuals.SelectionId.createNull();
                    var categoryValue = hostServices.getLocalizedString(WaterfallChart.TotalLabel);
                    var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categories, categoryValue, dataView.values, pos);
                    dataPoints.push({
                        value: pos,
                        position: 0,
                        color: totalColor,
                        categoryValue: categoryValue,
                        categoryIndex: categoryIndex,
                        identity: identity,
                        seriesIndex: 0,
                        selected: false,
                        highlight: false,
                        key: identity.getKey(),
                        tooltipInfo: tooltipInfo,
                        labelFill: dataLabelSettings.overrideDefaultColor ? dataLabelSettings.labelColor : sentimentColors.totalFill.solid.color
                    });
                    legend.push({
                        label: categoryValue,
                        color: totalColor,
                        icon: 0,
                        identity: identity,
                        selected: false
                    });
                }
                var hasSelection = false;
                if (interactivityService) {
                    if (interactivityService.applySelectionStateToData(dataPoints)) hasSelection = true;
                }
                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                var valuesMetadataArray = [];
                valuesMetadataArray.push(valuesMetadata);
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, valuesMetadataArray);
                return {
                    series: [ {
                        data: dataPoints
                    } ],
                    categories: categories,
                    categoryMetadata: categoryMetadata,
                    valuesMetadata: valuesMetadata,
                    legend: {
                        dataPoints: legend
                    },
                    hasHighlights: false,
                    positionMin: posMin,
                    positionMax: posMax,
                    dataLabelsSettings: dataLabelSettings,
                    sentimentColors: sentimentColors,
                    axesLabels: {
                        x: axesLabels.xAxisLabel,
                        y: axesLabels.yAxisLabel
                    },
                    hasSelection: hasSelection
                };
            };
            WaterfallChart.prototype.setData = function(dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var sentimentColors = this.getSentimentColorsFromObjects(null);
                this.data = {
                    series: [ {
                        data: []
                    } ],
                    categories: [],
                    valuesMetadata: null,
                    legend: {
                        dataPoints: []
                    },
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(),
                    sentimentColors: sentimentColors,
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    hasSelection: false
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.metadata && dataView.metadata.objects) {
                            var objects = dataView.metadata.objects;
                            var labelsObj = objects["labels"];
                            if (labelsObj) {
                                if (labelsObj.show !== undefined) this.data.dataLabelsSettings.show = labelsObj.show;
                                if (labelsObj.color !== undefined) {
                                    this.data.dataLabelsSettings.labelColor = labelsObj.color.solid.color;
                                    this.data.dataLabelsSettings.overrideDefaultColor = true;
                                }
                                if (labelsObj.labelDisplayUnits !== undefined) {
                                    this.data.dataLabelsSettings.displayUnits = labelsObj.labelDisplayUnits;
                                }
                                if (labelsObj.labelPrecision !== undefined) {
                                    this.data.dataLabelsSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : 0;
                                }
                            }
                            this.data.dataLabelsSettings.formatterOptions = visuals.dataLabelUtils.getFormatterOptionsColumn(dataView.metadata.columns);
                            sentimentColors = this.getSentimentColorsFromObjects(objects);
                        }
                        if (dataView.categorical) {
                            this.data = WaterfallChart.converter(dataView.categorical, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, dataView.metadata);
                        }
                    }
                }
            };
            WaterfallChart.prototype.enumerateObjectInstances = function(options) {
                switch (options.objectName) {
                  case "sentimentColors":
                    return this.enumerateSentimentColors();

                  case "labels":
                    return visuals.dataLabelUtils.enumerateDataLabels(this.data.dataLabelsSettings, false, true, true);
                }
            };
            WaterfallChart.prototype.enumerateSentimentColors = function() {
                var instances = [];
                var sentimentColors = this.data.sentimentColors;
                instances.push({
                    selector: null,
                    properties: {
                        increaseFill: sentimentColors.increaseFill,
                        decreaseFill: sentimentColors.decreaseFill,
                        totalFill: sentimentColors.totalFill
                    },
                    objectName: "sentimentColors"
                });
                return instances;
            };
            WaterfallChart.prototype.calculateLegend = function() {
                return this.data.legend;
            };
            WaterfallChart.prototype.hasLegend = function() {
                return true;
            };
            WaterfallChart.createClippedDataIfOverflowed = function(data, renderableDataCount) {
                var clipped = data;
                var dataPoints = data.series[0].data;
                if (data && renderableDataCount < dataPoints.length) {
                    clipped = powerbi.Prototype.inherit(data);
                    clipped.series = [ {
                        data: dataPoints.slice(0, renderableDataCount)
                    } ];
                    clipped.categories = data.categories.slice(0, renderableDataCount);
                }
                return clipped;
            };
            WaterfallChart.prototype.calculateAxesProperties = function(options) {
                debug.assertValue(options, "options");
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var data = this.clippedData = this.data;
                var categoryCount = WaterfallChart.showTotal ? data.categories.length + 1 : data.categories.length;
                var preferredPlotArea = this.getPreferredPlotArea(false, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness);
                if (preferredPlotArea.width === this.currentViewport.width) {
                    preferredPlotArea.width -= margin.left + margin.right;
                }
                preferredPlotArea.height -= margin.top + margin.bottom;
                var cartesianLayout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: preferredPlotArea.width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable
                });
                if (!this.isScrollable) {
                    data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount);
                }
                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options);
                var yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options);
                var xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions);
                var yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions);
                var categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var formatter = visuals.valueFormatter.create(visuals.dataLabelUtils.getLabelFormatterOptions(this.data.dataLabelsSettings));
                this.layout = {
                    categoryCount: cartesianLayout.categoryCount,
                    categoryThickness: cartesianLayout.categoryThickness,
                    isScalar: cartesianLayout.isScalar,
                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                    categoryWidth: categoryWidth,
                    labelText: function(d) {
                        return visuals.dataLabelUtils.getLabelFormattedText(formatter.format(d.value));
                    },
                    labelLayout: {
                        y: function(d, i) {
                            return WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - visuals.dataLabelUtils.labelMargin;
                        },
                        x: function(d, i) {
                            return xAxisProperties.scale(d.categoryIndex) + categoryWidth / 2;
                        }
                    },
                    filter: function(d) {
                        return d != null;
                    },
                    style: {
                        fill: function(d) {
                            return d.labelFill;
                        }
                    }
                };
                this.xAxisProperties.axisLabel = options.showXLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showYLabel ? data.axesLabels.y : null;
                return [ xAxisProperties, yAxisProperties ];
            };
            WaterfallChart.lookupXValue = function(data, index, type) {
                var dataPoints = data.series[0].data;
                var point = dataPoints[index];
                if (point && point.categoryValue) {
                    if (this.showTotal && index === dataPoints.length - 1) return point.categoryValue; else if (visuals.AxisHelper.isDateTime(type)) return new Date(point.categoryValue); else return point.categoryValue;
                }
                return index;
            };
            WaterfallChart.getXAxisCreationOptions = function(data, width, layout, options) {
                debug.assertValue(data, "data");
                debug.assertValue(options, "options");
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
                var domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, false, options.forcedXDomain);
                var categoryThickness = layout.categoryThickness;
                var outerPadding = categoryThickness * layout.outerPaddingRatio;
                return {
                    pixelSpan: width,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatStringProp: WaterfallChart.formatStringProp,
                    isScalar: false,
                    outerPadding: outerPadding,
                    categoryThickness: categoryThickness,
                    getValueFn: function(index, type) {
                        return WaterfallChart.lookupXValue(data, index, type);
                    },
                    forcedTickCount: options.forcedTickCount,
                    isCategoryAxis: true
                };
            };
            WaterfallChart.getYAxisCreationOptions = function(data, height, options) {
                debug.assertValue(data, "data");
                debug.assertValue(options, "options");
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ data.positionMin, data.positionMax ]);
                return {
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    isScalar: true,
                    isVertical: true,
                    metaDataColumn: data.valuesMetadata,
                    formatStringProp: WaterfallChart.formatStringProp,
                    outerPadding: 0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                };
            };
            WaterfallChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar);
            };
            WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return false;
            };
            WaterfallChart.prototype.overrideXScale = function(xProperties) {
                this.xAxisProperties = xProperties;
            };
            WaterfallChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = [ {
                    data: data.series[0].data.slice(startIndex, endIndex)
                } ];
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            WaterfallChart.prototype.createRects = function(data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector);
                var cols = colsSelection.data(data, function(d) {
                    return d.key;
                });
                cols.enter().append("rect").attr("class", function(d) {
                    return WaterfallChart.CategoryValueClasses.class.concat(d.highlight ? "highlight" : "");
                });
                cols.exit().remove();
                return cols;
            };
            WaterfallChart.prototype.createConnectors = function(data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector);
                var connectors = connectorSelection.data(data.slice(0, data.length - 1), function(d) {
                    return d.key;
                });
                connectors.enter().append("line").classed(WaterfallChart.WaterfallConnectorClasses.class, true);
                connectors.exit().remove();
                return connectors;
            };
            WaterfallChart.prototype.render = function(duration) {
                var _this = this;
                var dataPoints = this.clippedData.series[0].data;
                var bars = this.createRects(dataPoints);
                var connectors = this.createConnectors(dataPoints);
                visuals.TooltipManager.addTooltip(bars, function(tooltipEvent) {
                    return tooltipEvent.data.tooltipInfo;
                });
                var hasSelection = this.data.hasSelection;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth());
                bars.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights);
                }).attr("width", this.layout.categoryWidth).attr("x", function(d) {
                    return xScale(d.categoryIndex);
                }).attr("y", function(d) {
                    return WaterfallChart.getRectTop(yScale, d.position, d.value);
                }).attr("height", function(d) {
                    return y0 - yScale(Math.abs(d.value));
                });
                connectors.attr({
                    x1: function(d) {
                        return xScale(d.categoryIndex);
                    },
                    y1: function(d) {
                        return yScale(d.position + d.value);
                    },
                    x2: function(d) {
                        return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth;
                    },
                    y2: function(d) {
                        return yScale(d.position + d.value);
                    }
                });
                if (this.data.dataLabelsSettings.show) {
                    visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.dataLabelsSVG, this.layout, this.currentViewport);
                } else {
                    visuals.dataLabelUtils.cleanDataLabels(this.dataLabelsSVG);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        bars: bars,
                        datapoints: dataPoints,
                        clearCatcher: this.clearCatcher
                    };
                    this.interactivityService.apply(this, behaviorOptions);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            WaterfallChart.prototype.onClearSelection = function() {
                if (this.interactivityService) this.interactivityService.clearSelection();
            };
            WaterfallChart.prototype.accept = function(visitor, options) {
                debug.assertValue(visitor, "visitor");
                visitor.visitWaterfallChart(options);
            };
            WaterfallChart.prototype.getSupportedCategoryAxisType = function() {
                return powerbi.axisType.categorical;
            };
            WaterfallChart.getRectTop = function(scale, pos, value) {
                if (value < 0) return scale(pos); else return scale(pos) - (scale(0) - scale(value));
            };
            WaterfallChart.prototype.getAvailableWidth = function() {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            WaterfallChart.prototype.getAvailableHeight = function() {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            WaterfallChart.prototype.getSentimentColorsFromObjects = function(objects) {
                var defaultSentimentColors = this.colors.getSentimentColors();
                var increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value);
                var decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value);
                var totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                return {
                    increaseFill: {
                        solid: {
                            color: increaseColor
                        }
                    },
                    decreaseFill: {
                        solid: {
                            color: decreaseColor
                        }
                    },
                    totalFill: {
                        solid: {
                            color: totalColor
                        }
                    }
                };
            };
            WaterfallChart.formatStringProp = {
                objectName: "general",
                propertyName: "formatString"
            };
            WaterfallChart.WaterfallClassName = "waterfallChart";
            WaterfallChart.MainGraphicsContextClassName = "mainGraphicsContext";
            WaterfallChart.DataLabelsSVGClassName = "dataLabelsSVG";
            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel";
            WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel";
            WaterfallChart.TotalLabel = "Waterfall_TotalLabel";
            WaterfallChart.CategoryValueClasses = {
                "class": "column",
                selector: ".column"
            };
            WaterfallChart.WaterfallConnectorClasses = {
                "class": "waterfall-connector",
                selector: ".waterfall-connector"
            };
            WaterfallChart.defaultTotalColor = "#00b8aa";
            WaterfallChart.showTotal = true;
            return WaterfallChart;
        }();
        visuals.WaterfallChart = WaterfallChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var plugins;
        (function(plugins) {
            plugins.animatedNumber = {
                name: "animatedNumber",
                capabilities: visuals.AnimatedNumber.capabilities,
                create: function() {
                    return new visuals.AnimatedNumber();
                }
            };
            plugins.areaChart = {
                name: "areaChart",
                watermarkKey: "area",
                capabilities: visuals.lineChartCapabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 1
                    });
                },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.barChart = {
                name: "barChart",
                watermarkKey: "bar",
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 5
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.card = {
                name: "card",
                watermarkKey: "card",
                capabilities: visuals.Card.capabilities,
                create: function() {
                    return new visuals.Card();
                }
            };
            plugins.multiRowCard = {
                name: "multiRowCard",
                watermarkKey: "multiRowCard",
                capabilities: visuals.MultiRowCard.capabilities,
                create: function() {
                    return new visuals.MultiRowCard();
                }
            };
            plugins.clusteredBarChart = {
                name: "clusteredBarChart",
                watermarkKey: "clusteredBar",
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 4
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.clusteredColumnChart = {
                name: "clusteredColumnChart",
                watermarkKey: "clusteredColumn",
                capabilities: visuals.getColumnChartCapabilities(),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 2
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.columnChart = {
                name: "columnChart",
                watermarkKey: "column",
                capabilities: visuals.getColumnChartCapabilities(),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 3
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.comboChart = {
                name: "comboChart",
                watermarkKey: "combo",
                capabilities: visuals.ComboChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 9
                    });
                }
            };
            plugins.dataDotChart = {
                name: "dataDotChart",
                capabilities: visuals.DataDotChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 10
                    });
                }
            };
            plugins.dataDotClusteredColumnComboChart = {
                name: "dataDotClusteredColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.ComboChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 14
                    });
                }
            };
            plugins.dataDotStackedColumnComboChart = {
                name: "dataDotStackedColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.ComboChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 15
                    });
                }
            };
            plugins.donutChart = {
                name: "donutChart",
                watermarkKey: "donut",
                capabilities: visuals.donutChartCapabilities,
                create: function() {
                    return new visuals.DonutChart();
                }
            };
            plugins.funnel = {
                name: "funnel",
                watermarkKey: "funnel",
                capabilities: visuals.funnelChartCapabilities,
                create: function() {
                    return new visuals.FunnelChart();
                }
            };
            plugins.gauge = {
                name: "gauge",
                watermarkKey: "gauge",
                capabilities: visuals.Gauge.capabilities,
                create: function() {
                    return new visuals.Gauge();
                }
            };
            plugins.hundredPercentStackedBarChart = {
                name: "hundredPercentStackedBarChart",
                watermarkKey: "100stackedbar",
                capabilities: visuals.getColumnChartCapabilities(true),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 6
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.hundredPercentStackedColumnChart = {
                name: "hundredPercentStackedColumnChart",
                watermarkKey: "100stackedcolumn",
                capabilities: visuals.getColumnChartCapabilities(),
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 7
                    });
                },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.image = {
                name: "image",
                capabilities: visuals.ImageVisual.capabilities,
                create: function() {
                    return new visuals.ImageVisual();
                }
            };
            plugins.lineChart = {
                name: "lineChart",
                watermarkKey: "line",
                capabilities: visuals.lineChartCapabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 0
                    });
                },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.LineChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.lineStackedColumnComboChart = {
                name: "lineStackedColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.ComboChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 13
                    });
                },
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.lineClusteredColumnComboChart = {
                name: "lineClusteredColumnComboChart",
                watermarkKey: "combo",
                capabilities: visuals.ComboChart.capabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 12
                    });
                },
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                }
            };
            plugins.map = {
                name: "map",
                watermarkKey: "map",
                capabilities: visuals.mapCapabilities,
                create: function() {
                    return new visuals.Map({
                        filledMap: false
                    });
                }
            };
            plugins.filledMap = {
                name: "filledMap",
                watermarkKey: "map",
                capabilities: visuals.filledMapCapabilities,
                create: function() {
                    return new visuals.Map({
                        filledMap: true
                    });
                }
            };
            plugins.treemap = {
                name: "treemap",
                watermarkKey: "tree",
                capabilities: visuals.treemapCapabilities,
                create: function() {
                    return new visuals.Treemap();
                }
            };
            plugins.pieChart = {
                name: "pieChart",
                watermarkKey: "pie",
                capabilities: visuals.donutChartCapabilities,
                create: function() {
                    return new visuals.DonutChart({
                        sliceWidthRatio: 0
                    });
                }
            };
            plugins.scatterChart = {
                name: "scatterChart",
                watermarkKey: "scatterplot",
                capabilities: visuals.scatterChartCapabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 8
                    });
                }
            };
            plugins.table = {
                name: "table",
                watermarkKey: "table",
                capabilities: visuals.Table.capabilities,
                create: function() {
                    return new visuals.Table();
                },
                customizeQuery: visuals.Table.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.Table.getSortableRoles();
                }
            };
            plugins.matrix = {
                name: "matrix",
                watermarkKey: "matrix",
                capabilities: visuals.Matrix.capabilities,
                create: function() {
                    return new visuals.Matrix();
                },
                customizeQuery: visuals.Matrix.customizeQuery,
                getSortableRoles: function(visualSortableOptions) {
                    return visuals.Matrix.getSortableRoles();
                }
            };
            plugins.slicer = {
                name: "slicer",
                watermarkKey: "slicer",
                capabilities: visuals.slicerCapabilities,
                create: function() {
                    return new visuals.Slicer();
                }
            };
            plugins.textbox = {
                name: "textbox",
                capabilities: visuals.RichTextbox.capabilities,
                create: function() {
                    return new visuals.RichTextbox();
                }
            };
            plugins.waterfallChart = {
                name: "waterfallChart",
                watermarkKey: "waterfall",
                capabilities: visuals.waterfallChartCapabilities,
                create: function() {
                    return new visuals.CartesianChart({
                        chartType: 11
                    });
                }
            };
            plugins.cheerMeter = {
                name: "cheerMeter",
                capabilities: visuals.CheerMeter.capabilities,
                create: function() {
                    return new visuals.CheerMeter();
                }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

var powerbi;

(function(powerbi) {
    var visuals;
    (function(visuals) {
        var TouchUtils = powerbi.visuals.controls.TouchUtils;
        var ScreenArea;
        (function(ScreenArea) {
            ScreenArea[ScreenArea["TopLeft"] = 0] = "TopLeft";
            ScreenArea[ScreenArea["TopRight"] = 1] = "TopRight";
            ScreenArea[ScreenArea["BottomRight"] = 2] = "BottomRight";
            ScreenArea[ScreenArea["BottomLeft"] = 3] = "BottomLeft";
        })(ScreenArea || (ScreenArea = {}));
        var ToolTipComponent = function() {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions;
                this.isTooltipVisible = false;
                if (!tooltipOptions) {
                    this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions;
                }
            }
            ToolTipComponent.prototype.isTooltipComponentVisible = function() {
                return this.isTooltipVisible;
            };
            ToolTipComponent.prototype.setTestScreenSize = function(width, height) {
                this.customScreenWidth = width;
                this.customScreenHeight = height;
            };
            ToolTipComponent.prototype.show = function(tooltipData, clickedArea) {
                this.isTooltipVisible = true;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer();
                }
                this.setTooltipContent(tooltipData);
                this.tooltipContainer.style("visibility", "visible").transition().duration(0).style("opacity", this.tooltipOptions.opacity);
                this.setPosition(clickedArea);
            };
            ToolTipComponent.prototype.move = function(tooltipData, clickedArea) {
                if (this.isTooltipVisible) {
                    if (tooltipData) {
                        this.setTooltipContent(tooltipData);
                    }
                    this.setPosition(clickedArea);
                }
            };
            ToolTipComponent.prototype.hide = function() {
                if (this.isTooltipVisible) {
                    this.isTooltipVisible = false;
                    this.tooltipContainer.transition().duration(this.tooltipOptions.animationDuration).style("opacity", 0).each("end", function() {
                        this.style.visibility = "hidden";
                    });
                }
            };
            ToolTipComponent.prototype.createTooltipContainer = function() {
                var container = d3.select(ToolTipComponent.parentContainerSelector).append("div").attr("class", ToolTipComponent.containerClassName);
                container.append("div").attr("class", ToolTipComponent.arrowClassName);
                container.append("div").attr("class", ToolTipComponent.contentContainerClassName);
                return container;
            };
            ToolTipComponent.prototype.setTooltipContent = function(tooltipData) {
                var rowsSelector = "." + ToolTipComponent.tooltipRowClassName;
                var contentContainer = this.tooltipContainer.select("." + ToolTipComponent.contentContainerClassName);
                contentContainer.selectAll(".tooltip-row").remove();
                var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData);
                var newRow = tooltipRow.enter().append("div").attr("class", ToolTipComponent.tooltipRowClassName);
                var newTitleCell = newRow.append("div").attr("class", ToolTipComponent.tooltipTitleCellClassName);
                var newValueCell = newRow.append("div").attr("class", ToolTipComponent.tooltipValueCellClassName);
                newTitleCell.text(function(d) {
                    return d.displayName;
                });
                newValueCell.text(function(d) {
                    return d.value;
                });
            };
            ToolTipComponent.prototype.getTooltipPosition = function(clickedArea, clickedScreenArea) {
                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                var centerPointOffset = Math.floor(clickedArea.width / 2);
                var offsetX = 0;
                var offsetY = 0;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var arrowOffset = 7;
                if (clickedScreenArea === 0) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                } else if (clickedScreenArea === 1) {
                    offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset;
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                } else if (clickedScreenArea === 3) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset;
                } else if (clickedScreenArea === 2) {
                    offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset;
                    offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset;
                }
                centerPoint.offset(offsetX, offsetY);
                return centerPoint;
            };
            ToolTipComponent.prototype.setPosition = function(clickedArea) {
                var clickedScreenArea = this.getClickedScreenArea(clickedArea);
                var tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                this.tooltipContainer.style({
                    left: tooltipPosition.x + "px",
                    top: tooltipPosition.y + "px"
                });
                this.setArrowPosition(clickedArea, clickedScreenArea);
            };
            ToolTipComponent.prototype.setArrowPosition = function(clickedArea, clickedScreenArea) {
                var arrow = this.getArrowElement();
                var arrowClassName;
                if (clickedScreenArea === 0) {
                    arrowClassName = "top left";
                } else if (clickedScreenArea === 1) {
                    arrowClassName = "top right";
                } else if (clickedScreenArea === 3) {
                    arrowClassName = "bottom left";
                } else if (clickedScreenArea === 2) {
                    arrowClassName = "bottom right";
                }
                arrow.attr("class", "arrow").classed(arrowClassName, true);
            };
            ToolTipComponent.prototype.getArrowElement = function() {
                return this.tooltipContainer.select("." + ToolTipComponent.arrowClassName);
            };
            ToolTipComponent.prototype.getClickedScreenArea = function(clickedArea) {
                var screenWidth = this.customScreenWidth || window.innerWidth;
                var screenHeight = this.customScreenHeight || window.innerHeight;
                var centerPointOffset = clickedArea.width / 2;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var halfWidth = screenWidth / 2;
                var halfHeight = screenHeight / 2;
                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
                    return 0;
                } else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
                    return 1;
                } else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
                    return 3;
                } else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
                    return 2;
                }
            };
            ToolTipComponent.DefaultTooltipOptions = {
                opacity: 1,
                animationDuration: 250,
                offsetX: 10,
                offsetY: 10
            };
            ToolTipComponent.containerClassName = "tooltip-container";
            ToolTipComponent.contentContainerClassName = "tooltip-content-container";
            ToolTipComponent.arrowClassName = "arrow";
            ToolTipComponent.tooltipRowClassName = "tooltip-row";
            ToolTipComponent.tooltipTitleCellClassName = "tooltip-title-cell";
            ToolTipComponent.tooltipValueCellClassName = "tooltip-value-cell";
            ToolTipComponent.parentContainerSelector = "body";
            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
            return ToolTipComponent;
        }();
        visuals.ToolTipComponent = ToolTipComponent;
        var TooltipManager;
        (function(TooltipManager) {
            TooltipManager.ShowTooltips = true;
            TooltipManager.ToolTipInstance = new ToolTipComponent();
            var GlobalTooltipEventsAttached = false;
            var tooltipMouseOverDelay = 500;
            var tooltipTouchDelay = 500;
            var tooltipTimeoutId;
            var mouseCoordinates;
            function addTooltip(d3Selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                if (!TooltipManager.ShowTooltips) {
                    return;
                }
                debug.assertValue(d3Selection, "d3Selection");
                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                var touchStartEventName = getTouchStartEventName();
                var touchEndEventName = getTouchEndEventName();
                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
                d3Selection.on("mouseover", function(d, i) {
                    if (canDisplayTooltip(d3.event)) {
                        mouseCoordinates = getCoordinates(rootNode, true);
                        var elementCoordinates = getCoordinates(this, true);
                        var tooltipEvent = {
                            data: d,
                            index: i,
                            coordinates: mouseCoordinates,
                            elementCoordinates: elementCoordinates,
                            context: this,
                            isTouchEvent: false
                        };
                        clearTooltipTimeout();
                        tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipMouseOverDelay);
                    }
                });
                d3Selection.on("mouseout", function(d, i) {
                    clearTooltipTimeout();
                    hideTooltipEventHandler();
                });
                d3Selection.on("mousemove", function(d, i) {
                    if (canDisplayTooltip(d3.event)) {
                        mouseCoordinates = getCoordinates(rootNode, true);
                        var elementCoordinates = getCoordinates(this, true);
                        var tooltipEvent = {
                            data: d,
                            index: i,
                            coordinates: mouseCoordinates,
                            elementCoordinates: elementCoordinates,
                            context: this,
                            isTouchEvent: false
                        };
                        moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                    }
                });
                if (!GlobalTooltipEventsAttached) {
                    attachGlobalEvents(touchStartEventName);
                    GlobalTooltipEventsAttached = true;
                }
                d3Selection.on(touchStartEventName, function(d, i) {
                    stopEventPropogation(d3.event);
                    hideTooltipEventHandler();
                    var coordinates = getCoordinates(rootNode, isPointerEvent);
                    var elementCoordinates = getCoordinates(this, isPointerEvent);
                    var tooltipEvent = {
                        data: d,
                        index: i,
                        coordinates: coordinates,
                        elementCoordinates: elementCoordinates,
                        context: this,
                        isTouchEvent: true
                    };
                    clearTooltipTimeout();
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                });
                d3Selection.on(touchEndEventName, function(d, i) {
                    clearTooltipTimeout();
                });
            }
            TooltipManager.addTooltip = addTooltip;
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout(function() {
                    return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate);
                }, delayInMs);
            }
            TooltipManager.showDelayedTooltip = showDelayedTooltip;
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            TooltipManager.setLocalizedStrings = setLocalizedStrings;
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = getTooltipInfoDelegate(tooltipEvent);
                if (tooltipInfo) {
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                var tooltipInfo;
                if (reloadTooltipDataOnMouseMove) {
                    tooltipInfo = getTooltipInfoDelegate(tooltipEvent);
                }
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipInfo, clickedArea);
            }
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            function clearTooltipTimeout() {
                if (tooltipTimeoutId) {
                    clearTimeout(tooltipTimeoutId);
                }
            }
            function stopEventPropogation(d3Event) {
                d3Event.preventDefault();
                d3Event.stopPropagation();
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = true;
                var mouseEvent = d3Event;
                if (mouseEvent.buttons !== undefined) {
                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function getTouchStartEventName() {
                var eventName = "touchstart";
                if (window["PointerEvent"]) {
                    eventName = "pointerdown";
                } else if (window["MSPointerEvent"]) {
                    eventName = "MSPointerDown";
                }
                return eventName;
            }
            function getTouchEndEventName() {
                var eventName = "touchend";
                if (window["PointerEvent"]) {
                    eventName = "pointerup";
                } else if (window["MSPointerEvent"]) {
                    eventName = "MSPointerUp";
                }
                return eventName;
            }
            function getCoordinates(rootNode, isPointerEvent) {
                var coordinates;
                if (isPointerEvent) {
                    coordinates = d3.mouse(rootNode);
                } else {
                    var touchCoordinates = d3.touches(rootNode);
                    if (touchCoordinates && touchCoordinates.length > 0) {
                        coordinates = touchCoordinates[0];
                    }
                }
                return coordinates;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function(d, i) {
                    TooltipManager.ToolTipInstance.hide();
                });
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0;
                var pointX = x;
                var pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0);
                    pointY = Math.max(y - offset, 0);
                }
                return new TouchUtils.Rectangle(pointX, pointY, width, width);
            }
        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        (function(TooltipBuilder) {
            function createTooltipInfo(formatStringProp, categories, categoryValue, values, value, seriesData, seriesIndex, highlightedValue) {
                var categorySource;
                var seriesSource = [];
                var valuesSource = undefined;
                seriesIndex = seriesIndex | 0;
                if (categories && categories.length > 0) {
                    categorySource = {
                        value: categoryValue,
                        metadata: categories[0].source
                    };
                }
                if (values) {
                    if (categorySource && categorySource.metadata === values.source) {} else {
                        valuesSource = values.source;
                    }
                }
                if (seriesData) {
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        var singleSeriesData = seriesData[i];
                        if (categorySource && categorySource.metadata === singleSeriesData.metadata.source) continue;
                        seriesSource.push({
                            value: singleSeriesData.value,
                            metadata: singleSeriesData.metadata
                        });
                    }
                } else if (values && values.length > 0) {
                    var valueColumn = values[seriesIndex];
                    var autoGeneratedColumnMetadata = valueColumn && valueColumn.source ? valueColumn.source : null;
                    var isManuallyAddedField = autoGeneratedColumnMetadata && autoGeneratedColumnMetadata.isAutoGeneratedColumn;
                    if (!isManuallyAddedField) {
                        seriesSource = [ {
                            value: value,
                            highlightedValue: highlightedValue,
                            metadata: valueColumn
                        } ];
                    }
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo;
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                debug.assertValue(seriesValues, "seriesSource");
                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
                debug.assertAnyValue(formatStringProp, "formatStringProp");
                var items = [];
                if (categoryValue) {
                    var categoryFormattedValue = getFormattedValue(categoryValue.metadata, formatStringProp, categoryValue.value);
                    items.push({
                        displayName: categoryValue.metadata.displayName,
                        value: categoryFormattedValue
                    });
                }
                if (valuesSource) {
                    var dynamicValue;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = getFormattedValue(dynamicValueMetadata, formatStringProp, dynamicValueMetadata.groupName);
                    }
                    items.push({
                        displayName: valuesSource.displayName,
                        value: dynamicValue
                    });
                }
                for (var i = 0; i < seriesValues.length; i++) {
                    var seriesData = seriesValues[i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source;
                        var value = seriesData.value;
                        var highlightedValue = seriesData.highlightedValue;
                        if (value || value === 0) {
                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                            items.push({
                                displayName: seriesMetadataColumn.displayName,
                                value: formattedValue
                            });
                        }
                        if (highlightedValue || highlightedValue === 0) {
                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({
                                displayName: displayName,
                                value: formattedHighlightedValue
                            });
                        }
                    }
                }
                return items;
            }
            function getFormattedValue(column, formatStringProp, value) {
                var formatString = getFormatStringFromColumn(column, formatStringProp);
                return visuals.valueFormatter.format(value, formatString);
            }
            function getFormatStringFromColumn(column, formatStringProp) {
                if (column) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                    return formatString || column.format;
                }
                return null;
            }
        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));