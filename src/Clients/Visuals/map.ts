//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

module powerbi.visuals {
    import MapServices = visuals.BI.Services.MapServices;
    import ArrayExtensions = jsCommon.ArrayExtensions;

    export interface MapConstructionOptions {
        filledMap?: boolean;
    }

    // public for UnitTest
    export interface MapDataPoint {
        geocodingQuery: string;
        location?: Microsoft.Maps.Location; // Value from the loaded data
        cachedLocation?: Microsoft.Maps.Location; // Value either loaded or geocoded
        paths?: powerbi.visuals.BI.Services.GeocodingManager.IGeocodeBoundaryPolygon[];
        value: number;
        radius?: number;
        seriesInfo: MapSeriesInfo;
        categoryIdentity: DataViewScopeIdentity;
        categoryValue: string;
    }

    // public for UnitTest
    export interface MapPieSlice {
        value: number;
        index: number;
        fill: string;
        stroke: string;
        seriesId: DataViewScopeIdentity;
    }

    // public for UnitTest
    export interface MapSeriesInfo {
        sizeValuesForGroup: MapPieSlice[];
        latitude?: number;
        longitude?: number;
    }

    export interface MapData {
        bubbleData?: MapBubble[];
        sliceData?: MapSlice[][];
        shapeData?: MapShape[];
    }

    export interface MapVisualDataPoint extends TooltipEnabledDataPoint, SelectableDataPoint, LabelEnabledDataPoint {
        x: number;
        y: number;
        radius: number;
        fill: string;
        stroke: string;
        strokeWidth: number;
    }

    export interface MapBubble extends MapVisualDataPoint {

    }

    export interface MapSlice extends MapVisualDataPoint {
        value: number;
        startAngle?: number;
        endAngle?: number;
    }

    export interface MapShape extends TooltipEnabledDataPoint, SelectableDataPoint {
        path: string;
        fill: string;
        stroke: string;
        strokeWidth: number;
        key: string;
    }

    /** Used because data points used in D3 pie layouts are placed within a container with pie information */
    interface MapSliceContainer {
        data: MapSlice;
    }

    // public for UnitTest
    export interface IMapDataPointRenderer {
        init(mapControl: Microsoft.Maps.Map): void;
        beginDataPointUpdate(geocodingCategory: string, dataPointCount: number): void;
        addDataPoint(dataPoint: MapDataPoint): void;
        getDataPointCount(): number;
        converter(viewPort: IViewport, dataView: DataView, interactivityService: IInteractivityService, labelSettings: PointDataLabelsSettings): MapData;
        updateInternal(data: MapData): MapBehaviorOptions;
        getDataPointPadding(): number;
        clearDataPoints(): void;
    }

    export interface DataViewMetadataAutoGeneratedColumn extends DataViewMetadataColumn {
        /** Indicates that the column was added manually. */
        isAutoGeneratedColumn?: boolean
    }

    export class MapOneD3DataPointRenderer implements IMapDataPointRenderer {
        private mapControl: Microsoft.Maps.Map;
        private values: MapDataPoint[];
        private maxDataPointRadius: number;
        private svg: D3.Selection;
        private bubbleGraphicsContext: D3.Selection;
        private sliceGraphicsContext: D3.Selection;
        private sliceLayout: D3.Layout.PieLayout;
        private arc: D3.Svg.Arc;
        private dataLabelsSettings: PointDataLabelsSettings;

        public constructor() {
            this.values = [];
        }

        public init(mapControl: Microsoft.Maps.Map): void {
            this.mapControl = mapControl;
            var root = <HTMLElement>this.mapControl.getRootElement();
            root.setAttribute("drag-resize-disabled", "true"); // Enable panning within the maps in IE
            var svg = this.svg = d3.select(root)
                .append('svg')
                .style("position", "absolute"); // Absolute position so that the svg will overlap with the canvas.
            this.bubbleGraphicsContext = svg
                .append("g")
                .classed("mapBubbles", true);
            this.sliceGraphicsContext = svg
                .append("g")
                .classed("mapSlices", true);
            this.sliceLayout = d3.layout.pie()
                .sort(null)
                .value((d: MapSlice) => {
                    return d.value;
                });
            this.arc = d3.svg.arc();
            this.clearMaxDataPointRadius();
            this.dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();
        }

        public addDataPoint(dataPoint: MapDataPoint): void {
            this.values.push(dataPoint);
        }

        public clearDataPoints(): void {
            this.values = [];
        }

        public getDataPointCount(): number {
            return this.values.length;
        }

        public getDataPointPadding(): number {
            return this.maxDataPointRadius * 2;
        }

        private clearMaxDataPointRadius(): void {
            this.maxDataPointRadius = 0;
        }

        private setMaxDataPointRadius(dataPointRadius: number): void {
            this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
        }

        public beginDataPointUpdate(geocodingCategory: string, dataPointCount: number): void {
            this.values.length = 0;
        }

        public getDefaultMap(geocodingCategory: string, dataPointCount: number): void {
            this.values.length = 0;
        }

        public converter(viewPort: IViewport, dataView: DataView, interactivityService: IInteractivityService, labelSettings: PointDataLabelsSettings): MapData {
            var mapControl = this.mapControl;
            var widthOverTwo = viewPort.width / 2;
            var heightOverTwo = viewPort.height / 2;
            this.svg
                .style("width", viewPort.width.toString() + "px")
                .style("height", viewPort.width.toString() + "px");

            var strokeWidth = 1;

            //update data label settings
            this.dataLabelsSettings.show = labelSettings.show;
            this.dataLabelsSettings.labelColor = labelSettings.labelColor;
            this.dataLabelsSettings.overrideDefaultColor = labelSettings.overrideDefaultColor;

            // See MapSeriesPresenter::GetDataPointRadius for the PV behavior
            var radiusScale = Math.min(viewPort.width, viewPort.height) / 384;
            this.clearMaxDataPointRadius();

            var bubbleData: MapBubble[] = [];
            var sliceData: MapSlice[][] = [];
            var formatStringProp = mapProps.general.formatString;

            for (var i = 0, len = this.values.length; i < len; i++) {
                var categorical: DataViewCategorical = dataView ? dataView.categorical : null;
                var canvasDataPoint = this.values[i];
                var categoryValue = canvasDataPoint.categoryValue;
                var location = canvasDataPoint.cachedLocation;

                if (location) {
                    var xy = mapControl.tryLocationToPixel(location);
                    var x = xy.x + widthOverTwo;
                    var y = xy.y + heightOverTwo;

                    var radius = canvasDataPoint.radius * radiusScale;
                    this.setMaxDataPointRadius(radius);

                    var sliceCount = canvasDataPoint.seriesInfo.sizeValuesForGroup.length;
                    if (sliceCount === 1) {
                        var sizeValueForGroup: MapPieSlice = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                        var value = sizeValueForGroup.value;
                        var index = sizeValueForGroup.index;
                        var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                        var mapBubble = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];

                        bubbleData.push({
                            x: x,
                            y: y,
                            labeltext: categoryValue,
                            radius: radius,
                            fill: mapBubble.fill,
                            stroke: mapBubble.stroke,
                            strokeWidth: strokeWidth,
                            tooltipInfo: tooltipInfo,
                            identity: SelectionId.createWithId(canvasDataPoint.categoryIdentity),
                            selected: false,
                            labelFill: labelSettings.overrideDefaultColor ? labelSettings.labelColor : mapBubble.fill,
                        });
                    }
                    else {
                        var slices = [];
                        for (var j = 0; j < sliceCount; ++j) {
                            var value = canvasDataPoint.seriesInfo.sizeValuesForGroup[j].value;
                            var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, j);
                            var mapSlice = canvasDataPoint.seriesInfo.sizeValuesForGroup[j];

                            slices.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: mapSlice.fill,
                                stroke: mapSlice.stroke,
                                strokeWidth: strokeWidth,
                                value: value,
                                tooltipInfo: tooltipInfo,
                                identity: SelectionId.createWithIds(canvasDataPoint.categoryIdentity, mapSlice.seriesId),
                                selected: false,
                                labelFill: labelSettings.labelColor,
                            });
                        }
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(slices);
                        }
                        sliceData.push(slices);
                    }
                }
            }

            if (interactivityService) {
                interactivityService.applySelectionStateToData(bubbleData);
            }

            return { bubbleData: bubbleData, sliceData: sliceData };
        }

        public updateInternal(data: MapData): MapBehaviorOptions {
            var arc = this.arc;

            var hasSelection = false;

            if (dataHasSelection(data.bubbleData))
                hasSelection = true;
            if (!hasSelection) {
                for (var i = 0, ilen = data.sliceData.length; i < ilen; i++) {
                    if (dataHasSelection(data.sliceData[i]))
                        hasSelection = true;
                }
            }

            var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, (d: MapBubble) => d.identity.getKey());

            bubbles.enter()
                .append("circle")
                .classed("bubble", true);
            bubbles
                .attr("cx", (d: MapBubble) => d.x)
                .attr("cy", (d: MapBubble) => d.y)
                .attr("r", (d: MapBubble) => d.radius)
                .style("fill", (d: MapBubble) => d.fill)
                .style("stroke", (d: MapBubble) => d.stroke)
                .style("fill-opacity", (d: MapBubble) => ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false))
                .style("strokeWidth", (d: MapBubble) => d.strokeWidth)
                .style("stroke-opacity", (d: MapBubble) => ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false))
                .style("cursor", "default");
            bubbles.exit().remove();
            
            TooltipManager.addTooltip(bubbles, (d, i) => d.tooltipInfo);

            var sliceData = data.sliceData;

            var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
            sliceContainers.enter()
                .append("g")
                .classed("sliceContainer", true);

            sliceContainers.exit().remove();

            var sliceLayout = this.sliceLayout;
            var slices = sliceContainers.selectAll(".slice")
                .data(function (d) {
                    return sliceLayout(d);
                }, (d: MapSliceContainer) => d.data.identity.getKey());

            slices.enter()
                .append("path")
                .classed("slice", true);

            slices
                .style("fill", (t: MapSliceContainer) => t.data.fill)
                .style("fill-opacity", (d) => ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false))
                .style("stroke", (t: MapSliceContainer) => t.data.stroke)
                .style("strokeWidth", (t: MapSliceContainer) => t.data.strokeWidth)
                .style("stroke-opacity", (d) => ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false))
                .style("cursor", "default")
                .attr("transform", (t: MapSliceContainer) => SVGUtil.translate(t.data.x, t.data.y))
                .attr('d', (t: MapSliceContainer) => {
                    return arc.innerRadius(0).outerRadius((t: MapSliceContainer) => t.data.radius)(t);
                });

            slices.exit().remove();

            if (this.dataLabelsSettings.show) {
                var layout = dataLabelUtils.getMapLabelLayout(this.dataLabelsSettings);

                var dataPoints: MapVisualDataPoint[] = [];
                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                    dataPoints.push(sliceData[i][0]);
                }
                for (var j = 0, jlen = data.bubbleData.length; j < jlen; j++) {
                    dataPoints.push(data.bubbleData[j]);
                }
                var viewPort = { height: this.mapControl.getHeight(), width: this.mapControl.getWidth()};
                    
                dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.bubbleGraphicsContext, layout, viewPort);
            }
            else {
                dataLabelUtils.cleanDataLabels(this.bubbleGraphicsContext);
            }

            TooltipManager.addTooltip(slices, (d, i) => d.data.tooltipInfo);

            var allData: SelectableDataPoint[] = data.bubbleData.slice();
            for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                allData.push.apply(allData, sliceData[i]);
            }

            var behaviorOptions: MapBehaviorOptions = {
                bubbles: bubbles,
                slices: this.sliceGraphicsContext.selectAll("path"),
                background: this.svg,
                dataPoints: allData,
            };
            return behaviorOptions;
        }
    }

    export interface FilledMapParams {
        level: number;
        maxPolygons: number;
        strokeWidth: number;
    }

    export class MapShapeDataPointRenderer implements IMapDataPointRenderer {
        private mapControl: Microsoft.Maps.Map;
        private svg: D3.Selection;
        private geocodingCategory: string;
        private dataPointCount: number;
        private polygonInfo: powerbi.visuals.MapPolygonInfo;
        private viewport: IViewport;
        private values: MapDataPoint[];
        private shapeGraphicsContext: D3.Selection;
        private maxShapeDimension: number;

        public static getFilledMapParams(category: string, dataCount: number): FilledMapParams {
            switch (category) {
                case visuals.BI.Services.GeocodingManager.CategoryTypes.Continent:
                case visuals.BI.Services.GeocodingManager.CategoryTypes.CountryRegion:
                    if (dataCount < 10) {
                        return { level: 2, maxPolygons: 50, strokeWidth: 0 };
                    }
                    else if (dataCount < 30) {
                        return { level: 2, maxPolygons: 20, strokeWidth: 0 };
                    }
                    return { level: 1, maxPolygons: 3, strokeWidth: 0 };
                default:
                    if (dataCount < 100) {
                        return { level: 1, maxPolygons: 5, strokeWidth: 6 };
                    }
                    if (dataCount < 200) {
                        return { level: 0, maxPolygons: 5, strokeWidth: 6 };
                    }
                    return { level: 0, maxPolygons: 5, strokeWidth: 0 };
            }
        }

        public static buildPaths(locations: visuals.BI.Services.GeocodingManager.IGeocodeBoundaryPolygon[]): visuals.BI.Services.GeocodingManager.IGeocodeBoundaryPolygon[] {
            var paths = [];
            for (var i = 0; i < locations.length; i++) {
                var location = locations[i];
                var polygon = location.geographic;

                if (polygon.length > 2) {
                    paths.push(location);
                }
            }

            return paths;
        }

        public constructor() {
            this.values = [];
            this.dataPointCount = 0;
        }

        public init(mapControl: Microsoft.Maps.Map) {
            this.mapControl = mapControl;
            this.polygonInfo = new powerbi.visuals.MapPolygonInfo();

            var root = <HTMLElement>this.mapControl.getRootElement();
            root.setAttribute('drag-resize-disabled', 'true'); // Enable panning within the maps in IE
            var svg = this.svg = d3.select(root)
                .append('svg')
                .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
            this.shapeGraphicsContext = svg
                .append('g')
                .classed('mapShapes', true);

            this.clearMaxShapeDimension();
        }

        public beginDataPointUpdate(geocodingCategory: string, dataPointCount: number) {
            this.geocodingCategory = geocodingCategory;
            this.dataPointCount = dataPointCount;
            this.values = [];
        }

        public addDataPoint(dataPoint: MapDataPoint) {
            this.values.push(dataPoint);
        }

        public clearDataPoints(): void {
            this.values = [];
        }

        public getDataPointCount(): number {
            return this.dataPointCount;
        }

        public converter(viewport: IViewport, dataView: DataView, interactivityService?: IInteractivityService): MapData {
            this.viewport = viewport;
            this.clearMaxShapeDimension();

            this.svg
                .style("width", viewport.width.toString() + "px")
                .style("height", viewport.width.toString() + "px");

            var strokeWidth = 1;

            var shapeData: MapShape[] = [];
            var formatStringProp = mapProps.general.formatString;

            for (var categoryIndex = 0, categoryCount = this.values.length; categoryIndex < categoryCount; categoryIndex++) {
                var categorical: DataViewCategorical = dataView ? dataView.categorical : null;
                var canvasDataPoint: MapDataPoint = this.values[categoryIndex];
                var categoryValue = canvasDataPoint.categoryValue;
                var location = canvasDataPoint.cachedLocation;

                if (location) {
                    var sizeValueForGroup: MapPieSlice = canvasDataPoint.seriesInfo.sizeValuesForGroup[0];
                    var value = sizeValueForGroup.value;
                    var index = sizeValueForGroup.index;
                    var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, categorical.categories, categoryValue, categorical.values, value, null, index);
                    var paths = canvasDataPoint.paths;
                    var identity = SelectionId.createWithId(canvasDataPoint.categoryIdentity);
                    var idKey = identity.getKey();
                    for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                        var path = paths[pathIndex];
                        this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);

                        shapeData.push({
                            path: path.absoluteString,
                            fill: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].fill,
                            stroke: canvasDataPoint.seriesInfo.sizeValuesForGroup[0].stroke,
                            strokeWidth: strokeWidth,
                            tooltipInfo: tooltipInfo,
                            identity: identity,
                            selected: false,
                            key: JSON.stringify({ id: idKey, pIdx: pathIndex }),
                        });
                    }
                }
            }

            if (interactivityService)
                interactivityService.applySelectionStateToData(shapeData);

            return { shapeData: shapeData };
        }

        public updateInternal(data: MapData): MapBehaviorOptions {
            var viewport = this.viewport;
            this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
            this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));

            var hasSelection = dataHasSelection(data.shapeData);

            var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, (d: MapShape) => d.key);

            shapes.enter()
                .append("polygon")
                .classed("shape", true)
                .attr("points", (d: MapShape) => {
                    return d.path;
                });

            shapes
                .style("fill", (d: MapShape) => d.fill)
                .style("stroke", (d: MapShape) => d.stroke)
                .style("fill-opacity", (d: MapShape) => ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false))
                .style("strokeWidth", (d: MapShape) => d.strokeWidth)
                .style("stroke-opacity", (d: MapShape) => ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false))
                .style("cursor", "default");

            shapes.exit()
                .remove();

            TooltipManager.addTooltip(shapes, (d, i) => d.tooltipInfo);

            var behaviorOptions: MapBehaviorOptions = {
                shapes: shapes,
                background: this.svg,
                dataPoints: data.shapeData,
            };

            return behaviorOptions;
        }

        private clearMaxShapeDimension(): void {
            this.maxShapeDimension = 0;
        }

        private setMaxShapeDimension(width: number, height: number): void {
            this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
            this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
        }

        public getDataPointPadding() {
            return 12;
        }
    }

    // public for UnitTest
    export interface SimpleRange {
        min: number;
        max: number;
    }

    export class Map implements IVisual, IInteractiveVisual {
        public currentViewport: IViewport;

        private pendingGeocodingRender: boolean;
        private mapControl: Microsoft.Maps.Map;
        private minLongitude: number;
        private maxLongitude: number;
        private minLatitude: number;
        private maxLatitude: number;
        private valueScale: SimpleRange;
        private style: IVisualStyle;
        private colors: IDataColorPalette;
        private dataPointRenderer: IMapDataPointRenderer;
        private geocodingCategory: string;
        private legend: ILegend;
        private legendHeight;
        private legendData: LegendData;
        private element: JQuery;
        private dataView: DataView;
        private dataLabelsSettings: PointDataLabelsSettings;
        private static MapContainer = {
            cssClass: 'visual mapControl',
            selector: '.visual.mapControl'
        };
        public static StrokeDarkenColorValue = 255 * 0.25;
        private interactivityService: IInteractivityService;
        private defaultDataPointColor: string;
        private geoTaggingAnalyzerService: powerbi.IGeoTaggingAnalyzerService;
        private enableGeoShaping: boolean;
        private host: IVisualHostServices;

        constructor(options: MapConstructionOptions) {
            if (options.filledMap) {
                this.dataPointRenderer = new MapShapeDataPointRenderer();
                this.enableGeoShaping = true;
                }
            else {
                this.dataPointRenderer = new MapOneD3DataPointRenderer();
                this.enableGeoShaping = false;
            }
        }

        public init(options: VisualInitOptions) {
            debug.assertValue(options, 'options');
            var element = this.element = options.element;
            this.pendingGeocodingRender = false;
            this.currentViewport = options.viewport;
            this.style = options.style;
            this.colors = this.style.colorPalette.dataColors;
            this.interactivityService = VisualInteractivityFactory.buildInteractivityService(options);
            this.dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();
            this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService);
            this.legendHeight = 0;
            this.legendData = { dataPoints: [] };
            this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
            this.host = options.host;

            this.resetBounds();

            jsCommon.ensureMap(() => {
                Microsoft.Maps.loadModule('Microsoft.Maps.Overlays.Style', {
                    callback: () => {
                        this.initialize(element[0]);
                    }
                });
            });
        }

        private addDataPoint(dataPoint: MapDataPoint): void {
            var location = dataPoint.cachedLocation;
            this.updateBounds(location.latitude, location.longitude);
            this.dataPointRenderer.addDataPoint(dataPoint);

            this.scheduleRedraw();
        }

        private scheduleRedraw(): void {
            if (!this.pendingGeocodingRender && this.mapControl) {
                this.pendingGeocodingRender = true;
                setTimeout(() => {
                    this.updateInternal();
                    this.pendingGeocodingRender = false;
                }, 1000);
            }
        }

        private enqueueGeoCode(dataPoint: MapDataPoint): void {
            visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then((location) => {
                if (location) {
                    dataPoint.cachedLocation = location;
                    this.addDataPoint(dataPoint);
                }
            });
        }

        private enqueueGeoCodeAndGeoShape(dataPoint: MapDataPoint, params: FilledMapParams): void {
            visuals.BI.Services.GeocodingManager.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then((location) => {
                if (location) {
                    dataPoint.cachedLocation = location;
                    this.enqueueGeoShape(dataPoint, params);
                }
            });
        }

        private enqueueGeoShape(dataPoint: MapDataPoint, params: FilledMapParams): void {
            debug.assertValue(dataPoint.cachedLocation, "cachedLocation");
            visuals.BI.Services.GeocodingManager.geocodeBoundary(dataPoint.cachedLocation.latitude, dataPoint.cachedLocation.longitude, this.geocodingCategory, params.level, params.maxPolygons)
                .then((result: visuals.BI.Services.GeocodingManager.IGeocodeCoordinate) => {
                    var paths;
                    if (result.locations.length === 0 || result.locations[0].geographic) {
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    else {
                        visuals.BI.Services.MapServices.calcGeoData(result);
                        paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                    }
                    dataPoint.paths = paths;
                    this.addDataPoint(dataPoint);
                });
        }

        private getOptimumLevelOfDetail(width: number, height: number): number {
            var dataPointCount = this.dataPointRenderer.getDataPointCount();
            if (dataPointCount === 0)
                return MapServices.MinLevelOfDetail;

            var threshold: number = this.dataPointRenderer.getDataPointPadding();

            for (var levelOfDetail = MapServices.MaxLevelOfDetail; levelOfDetail >= MapServices.MinLevelOfDetail; levelOfDetail--) {
                var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);

                if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
                    // if we have less than 2 data points we should not zoom in "too much"
                    if (dataPointCount < 2)
                        levelOfDetail = Math.min(MapServices.MaxAutoZoomLevel, levelOfDetail);

                    return levelOfDetail;
                }
            }

            return MapServices.MinLevelOfDetail;
        }

        private getViewCenter(levelOfDetail: number): Microsoft.Maps.Location {
            var minXmaxY = MapServices.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
            var maxXminY = MapServices.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
            return MapServices.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2.0, (maxXminY.y + minXmaxY.y) / 2.0, levelOfDetail);
        }

        private resetBounds(): void {
            this.minLongitude = MapServices.MaxAllowedLongitude;
            this.maxLongitude = MapServices.MinAllowedLongitude;
            this.minLatitude = MapServices.MaxAllowedLatitude;
            this.maxLatitude = MapServices.MinAllowedLatitude;
        }

        private updateBounds(latitude: number, longitude: number): void {
            if (longitude < this.minLongitude) {
                this.minLongitude = longitude;
            }

            if (longitude > this.maxLongitude) {
                this.maxLongitude = longitude;
            }

            if (latitude < this.minLatitude) {
                this.minLatitude = latitude;
            }

            if (latitude > this.maxLatitude) {
                this.maxLatitude = latitude;
            }
        }

        public static legendObject(dataView: DataView): DataViewObject {
            return dataView &&
                dataView.metadata &&
                dataView.metadata.objects &&
                dataView.metadata.objects['legend'];
        }

        public static isLegendHidden(dataView: DataView): boolean {
            var legendObject = Map.legendObject(dataView);
            return legendObject != null && legendObject[legendProps.show] === false;
        }

        public static legendPosition(dataView: DataView): LegendPosition {
            var legendObject = Map.legendObject(dataView);
            return legendObject && LegendPosition[<string>legendObject[legendProps.position]];
        }

        public static isShowLegendTitle(dataView: DataView): boolean {
            var legendObject = Map.legendObject(dataView);
            return legendObject && <boolean>legendObject[legendProps.showTitle];
        }

        private  legendTitle(): string {
            var legendObject = Map.legendObject(this.dataView);           
            return (legendObject && <string>legendObject[legendProps.titleText]) || this.legendData.title;
        }        

        private renderLegend(legendData: LegendData): void {
            var hideLegend = Map.isLegendHidden(this.dataView);
            var showTitle = Map.isShowLegendTitle(this.dataView);
            var title = this.legendTitle();
            // Update the legendData based on the hide flag.  Cartesian passes in no-datapoints. OnResize reuses the legendData, so this can't mutate.
            var clonedLegendData: LegendData = {
                dataPoints: hideLegend ? [] : legendData.dataPoints,
                grouped: legendData.grouped,
                title: showTitle ? title : ""
            };

            // Update the orientation to match what's in the dataView
            var targetOrientation = Map.legendPosition(this.dataView);
            if (targetOrientation !== undefined && this.legend.getOrientation() !== targetOrientation) {
                this.legend.changeOrientation(targetOrientation);
            }

            this.legend.drawLegend(clonedLegendData, this.currentViewport);
        }

        // public for UnitTest
        public static calculateGroupSizes(categorical: DataViewCategorical, grouped: DataViewValueColumnGroup[], groupSizeTotals: number[], sizeMeasureIndex: number, currentValueScale: SimpleRange): SimpleRange {
            var categoryCount = categorical.values[0].values.length;
            var seriesCount = grouped.length;

            for (var i = 0, len = categoryCount; i < len; ++i) {
                var groupTotal = null;
                if (sizeMeasureIndex >= 0) {
                    for (var j = 0; j < seriesCount; ++j) {
                        var value = grouped[j].values[sizeMeasureIndex].values[i];
                        if (value) {
                            if (groupTotal === null) {
                                groupTotal = value;
                            } else {
                                groupTotal += value;
                            }
                        }
                    }
                }

                groupSizeTotals.push(groupTotal);

                if (groupTotal) {
                    if (!currentValueScale) {
                        currentValueScale = {
                            min: groupTotal,
                            max: groupTotal
                        };
                    } else {
                        currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
                        currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
                    }
                }
            }

            return currentValueScale;
        }

        // public for UnitTest
        public static createMapDataPoint(group: string, value: number, seriesInfo: MapSeriesInfo, radius: number, colors: IDataColorPalette, categoryIdentity: DataViewScopeIdentity): MapDataPoint {
            if (seriesInfo && seriesInfo.sizeValuesForGroup && seriesInfo.sizeValuesForGroup.length > 0) {
                // Not supporting Pies yet
                var latitude = seriesInfo.latitude;
                var longitude = seriesInfo.longitude;
                var dp: MapDataPoint = {
                    geocodingQuery: group,
                    location: (latitude !== null && longitude !== null) ? new Microsoft.Maps.Location(latitude, longitude) : null,
                    value: value,
                    radius: radius,
                    seriesInfo: seriesInfo,
                    categoryIdentity: categoryIdentity,
                    categoryValue: group
                };

                if (dp.geocodingQuery === null && dp.location === null) {
                    // The user should be warned that the data isn't all shown.  Can't geocode null
                    return null;
                }

                // Update the location so the remaining code can rely upon the cachedLocation
                dp.cachedLocation = dp.location;

                return dp;
            }

            return null;
        }

        public static calculateSeriesLegend(
            grouped: DataViewValueColumnGroup[],
            groupIndex: number,
            sizeMeasureIndex: number,
            colors: IDataColorPalette,
            defaultDataPointColor?: string,
            seriesSource?: data.SQExpr[]): LegendDataPoint[]{

            var seriesCount = grouped.length;
            var legendData: LegendDataPoint[] = [];
            var colorHelper = new ColorHelper(colors, mapProps.dataPoint.fill, defaultDataPointColor);

            for (var i = 0; i < seriesCount; ++i) {
                var seriesValues = grouped[i];
                var sizeValueForCategory: any;
                var measureQueryName: string;
                if (sizeMeasureIndex >= 0) {
                    var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                    sizeValueForCategory = sizeMeasure.values[groupIndex];
                    measureQueryName = sizeMeasure.source.queryName;
                }
                else {
                    sizeValueForCategory = null;
                    measureQueryName = '';
                }
                if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                    var identity = seriesValues.identity ? SelectionId.createWithId(seriesValues.identity) : SelectionId.createNull();
                    var color = seriesSource !== undefined
                        ? colorHelper.getColorForSeriesValue(seriesValues.objects, seriesSource, seriesValues.name)
                        : colorHelper.getColorForMeasure(seriesValues.objects, measureQueryName);

                    legendData.push({
                        color: color,
                        label: valueFormatter.format(seriesValues.name),
                        icon: LegendIcon.Circle,
                        identity: identity,
                        selected: false
                    });
                }
            }

            return legendData;
        }

        // public for UnitTest
        public static calculateSeriesInfo(
            grouped: DataViewValueColumnGroup[],
            groupIndex: number,
            sizeMeasureIndex: number,
            longitudeMeasureIndex: number,
            latitudeMeasureIndex: number,
            colors: IDataColorPalette,
            defaultDataPointColor?: string,
            objectsDefinitions?: DataViewObjects[],
            seriesSource?: data.SQExpr[]): MapSeriesInfo {

            var latitude: number = null;
            var longitude: number = null;
            var sizeValuesForGroup: MapPieSlice[] = [];
            var seriesCount = grouped.length;
            var colorHelper = new ColorHelper(colors, mapProps.dataPoint.fill, defaultDataPointColor);

            for (var i = 0; i < seriesCount; ++i) {
                var seriesValues = grouped[i];
                var sizeValueForCategory: any;
                var measureQueryName: string;
                if (sizeMeasureIndex >= 0) {
                    var sizeMeasure = seriesValues.values[sizeMeasureIndex];
                    sizeValueForCategory = sizeMeasure.values[groupIndex];
                    measureQueryName = sizeMeasure.source.queryName;
                }
                else {
                    sizeValueForCategory = null;
                    measureQueryName = '';
                }

                var objects = (objectsDefinitions && objectsDefinitions[groupIndex]) || (seriesValues && seriesValues.objects);

                if (sizeValueForCategory !== null || sizeMeasureIndex < 0) {
                    var seriesIdentity = grouped[i].identity;
                    var color = seriesSource !== undefined
                        ? colorHelper.getColorForSeriesValue(objects, seriesSource, seriesValues.name)
                        : colorHelper.getColorForMeasure(objects, measureQueryName);

                    var colorRgb = jsCommon.color.parseRgb(color);
                    var stroke = jsCommon.color.rgbToHexString(jsCommon.color.darken(colorRgb, Map.StrokeDarkenColorValue));
                    var fill = jsCommon.color.rgbWithAlphaString(colorRgb, 0.6);

                    sizeValuesForGroup.push({
                        value: sizeValueForCategory,
                        index: i,
                        fill: fill,
                        stroke: stroke,
                        seriesId: seriesIdentity,
                    });
                }

                latitude = Map.getOptionalMeasure(seriesValues, latitudeMeasureIndex, groupIndex, latitude);
                longitude = Map.getOptionalMeasure(seriesValues, longitudeMeasureIndex, groupIndex, longitude);
            }

            return {
                sizeValuesForGroup: sizeValuesForGroup,
                latitude: latitude,
                longitude: longitude
            };
        }

        private static getOptionalMeasure(
            seriesValues: DataViewValueColumnGroup,
            measureIndex: number,
            groupIndex: number,
            defaultValue: number): number {

            if (measureIndex >= 0) {
                var value = seriesValues.values[measureIndex].values[groupIndex];
                if (value != null)
                    return value;
            }

            return defaultValue;
        }

        // public for UnitTest
        public static calculateRadius(range: SimpleRange, rangeDiff: number, value?: number): number {
            var radius = 6;
            if (rangeDiff !== 0) {
                radius = (6 * ((value - range.min) / rangeDiff)) + 6;
            }

            return radius;
        }

        // public for UnitTest
        public static getGeocodingCategory(categorical: DataViewCategorical, geoTaggingAnalyzerService: IGeoTaggingAnalyzerService): string {
            if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                // Check categoryString for manually specified information in the model
                var type = categorical.categories[0].source.type;
                if (type && type.categoryString) {
                    return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                }

                // Check the category name
                var categoryName = categorical.categories[0].source.displayName;
                var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                if (geotaggedResult)
                    return geotaggedResult;

                // Checking roles for VRM backwards compatibility
                var roles = categorical.categories[0].source.roles;
                if (roles) {
                    var roleNames = Object.keys(roles);
                    for (var i = 0, len = roleNames.length; i < len; ++i) {
                        var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                        if (typeFromRoleName)
                            return typeFromRoleName;
                    }
                }
            }

            return undefined;
        }

        // public for UnitTest
        public static hasSizeField(values: DataViewValueColumns, defaultIndexIfNoRole?: number): boolean {
            if (ArrayExtensions.isUndefinedOrEmpty(values))
                return false;

            for (var i = 0, ilen = values.length; i < ilen; i++) {
                var roles = values[i].source.roles;

                // case for Power Q&A since Power Q&A does not assign role to measures.
                if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric)
                    return true;

                if (roles) {
                    var roleNames = Object.keys(roles);
                    for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
                        var role = roleNames[j];
                        if (role === "Size")
                            return true;
                    }
                }
            }
            return false;
        }

        // public for UnitTest
        public static createDefaultValueColumns(categorical: DataViewCategorical): DataViewValueColumns {
            var categoryValues = [];
            if (categorical.categories && categorical.categories.length > 0) {
                for (var i = 0, len = categorical.categories[0].values.length; i < len; i++)
                    categoryValues.push(1);
            }

            var source: DataViewMetadataAutoGeneratedColumn = {
                displayName: "col", isMeasure: true, queryName: '', roles: { "Size": true }, type: ValueType.fromDescriptor({ numeric: true }), isAutoGeneratedColumn: true
            };

            var categoricalValues: DataViewValueColumn[] = [{
                source: source,
                values: categoryValues,
            }];

            var gradientMeasureIndex: number = GradientUtils.getGradientMeasureIndex(categorical);
            var hasGradient: boolean = gradientMeasureIndex >= 0;

            if (hasGradient) {
                // Add existing gradient field if exists
                var gradientColumn: DataViewValueColumn = categorical.values[gradientMeasureIndex];
                categoricalValues.push(gradientColumn);
            }
            
            return powerbi.data.DataViewTransform.createValueColumns(categoricalValues);
        }

        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {
            switch (options.objectName) {
                case 'dataPoint':
                    var hasGradientRole = this.dataView && GradientUtils.hasGradientRole(this.dataView.categorical);
                    if (!hasGradientRole) {
                        return this.enumerateDataPoints();
                    }
                    break;
                case 'categoryLabels':
                    return dataLabelUtils.enumerateCategoryLabels(this.dataLabelsSettings, true);
                case 'legend':
                    return Map.enumerateLegend(this.dataView, this.legend, this.legendTitle());
            }
        }

        private enumerateDataPoints(): VisualObjectInstance[] {
            var data = this.legendData;
            var instances: VisualObjectInstance[] = [];

            instances.push({
                objectName: 'dataPoint',
                selector: null,
                properties: {
                    defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColor(0).value } }
                },
            });

            for (var i = 0; i < data.dataPoints.length; i++) {

                var dataPoint = data.dataPoints[i];
                instances.push({
                    objectName: 'dataPoint',
                    displayName: dataPoint.label,
                    selector: dataPoint.identity.getSelector(),
                    properties: {
                        fill: { solid: { color: dataPoint.color } }
                    },
                });
            }
            return instances;
        }       
        
        public static enumerateLegend(dataView: DataView, legend: ILegend, legendTitle: string): VisualObjectInstance[] {            
            return [{
                selector: null,
                properties: {
                    show: !Map.isLegendHidden(dataView),
                    position: LegendPosition[legend.getOrientation()],
                    showTitle: Map.isShowLegendTitle(dataView),
                    titleText: legendTitle
                },
                objectName: 'legend'
            }];
        }
       
        public onDataChanged(options: VisualDataChangedOptions): void {
            debug.assertValue(options, 'options');

            var dataView = options.dataViews[0];
            this.dataView = dataView;
            var enableGeoShaping = this.enableGeoShaping;

            //Revert Back 
            this.dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();

            if (dataView) {
                if (dataView.metadata) {
                    var defaultColor = DataViewObjects.getFillColor(dataView.metadata.objects, mapProps.dataPoint.defaultColor);
                    if (defaultColor)
                        this.defaultDataPointColor = defaultColor;

                    if (dataView.metadata.objects) {
                        var labelsObj = dataView.metadata.objects['categoryLabels'];
                        if (labelsObj) {
                            this.dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? <boolean>labelsObj['show'] : this.dataLabelsSettings.show;
                            if (labelsObj['color'] !== undefined) {
                                this.dataLabelsSettings.labelColor = (<Fill>labelsObj['color']).solid.color;
                                this.dataLabelsSettings.overrideDefaultColor = true;
                            }
                        }
                    }
                }

                this.showLocationMissingWarningIfNecessary(dataView);

                var categorical = dataView.categorical;
                if (categorical && categorical.categories && categorical.categories.length > 0) {
                    this.resetBounds();

                    var grouped: DataViewValueColumnGroup[];
                    if (Map.hasSizeField(categorical.values, 0)) {
                        grouped = categorical.values.grouped();
                    }
                    else {
                        var valueColumns: DataViewValueColumns = Map.createDefaultValueColumns(categorical);
                        categorical.values = valueColumns;
                        grouped = [{ values: valueColumns }];
                    }

                    var hasDynamicSeries = !!categorical.values.source;

                    var seriesSource: data.SQExpr[];
                    if (hasDynamicSeries) {
                        seriesSource = categorical.values.identityFields;
                    }
                    else if (categorical.values.length > 0) {
                        seriesSource = categorical.categories[0].identityFields;
                    }

                    var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size", 0);
                    var longIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                    var latIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");

                    var groupSizeTotals: number[] = [];
                    this.valueScale = null; // Clear scale
                    this.valueScale = Map.calculateGroupSizes(categorical, grouped, groupSizeTotals, sizeIndex, this.valueScale);
                    this.geocodingCategory = Map.getGeocodingCategory(categorical, this.geoTaggingAnalyzerService);
                    var scaleDiff = this.valueScale ? this.valueScale.max - this.valueScale.min : 0;

                    jsCommon.ensureMap(() => {
                        var groupValues = categorical.categories[0].values;
                        var categoryIdentities = dataView.categorical.categories[0].identity;
                        this.dataPointRenderer.beginDataPointUpdate(this.geocodingCategory, groupValues.length);
                        var objectDefinitions = dataView.categorical.categories[0].objects;

                        for (var i = 0, ilen = groupValues.length; i < ilen; i++) {
                            var group = groupValues[i];
                            var value = groupSizeTotals[i];
                            var seriesInfo = Map.calculateSeriesInfo(grouped, i, sizeIndex, longIndex, latIndex, this.colors, this.defaultDataPointColor, objectDefinitions, seriesSource);
                            var radius = Map.calculateRadius(this.valueScale, scaleDiff, value);

                            var params;
                            if (enableGeoShaping) {
                                params = MapShapeDataPointRenderer.getFilledMapParams(this.geocodingCategory, groupValues.length);
                            }

                            var dp = Map.createMapDataPoint(group, value, seriesInfo, radius, this.colors, categoryIdentities ? categoryIdentities[i] : undefined);
                            if (dp) {
                                if (!dp.location) {
                                    if (enableGeoShaping)
                                        this.enqueueGeoCodeAndGeoShape(dp, params);
                                    else
                                        this.enqueueGeoCode(dp);
                                }
                                else if (enableGeoShaping && !dp.paths) {
                                    this.enqueueGeoShape(dp, params);
                                }
                                else {
                                    this.addDataPoint(dp);
                                }
                            }
                        }

                        var legendDataPoints = Map.calculateSeriesLegend(grouped, i, sizeIndex, this.colors, this.defaultDataPointColor, seriesSource);
                        if (legendDataPoints.length === 1)
                            legendDataPoints = [];

                        var dvValues = categorical.values;
                        var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                        this.legendData = { title: title, dataPoints: legendDataPoints };
                        this.renderLegend(this.legendData);
                    });
                }
                else {
                    this.clearDataPoints();
                }
            }
            else {
                this.clearDataPoints();
            }
            this.scheduleRedraw();
        }

        private showLocationMissingWarningIfNecessary(dataView: powerbi.DataView) {
            var metadata = dataView.metadata;

            if (metadata && metadata.columns) {
                var columns = metadata.columns;
                var foundLocation: boolean = false;

                for (var i = 0; i < columns.length; i++) {
                    if (DataRoleHelper.hasRole(columns[i], 'Category')) {
                        // Found location
                        foundLocation = true;
                    }
                }

                if (foundLocation) {
                    // Indicate that there are no warnings.
                    this.host.setWarnings(null);
                }
                else {
                    this.host.setWarnings([new NoMapLocationWarning(), ]);
                }
            }
            else {
                this.host.setWarnings([new NoMapLocationWarning(), ]);
            }
        }

        public onResizing(viewport: IViewport, duration: number): void {
            if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
                this.currentViewport = viewport;
                this.renderLegend(this.legendData);
                this.updateInternal();
            }
        }

        private initialize(container: HTMLElement): void {
            var mapOptions = {
                credentials: BI.Services.GeocodingManager.Settings.BingKey,
                showMapTypeSelector: false,
                enableClickableLogo: false,
                enableSearchLogo: false,
                mapTypeId: Microsoft.Maps.MapTypeId.road,
                customizeOverlays: true,
                showDashboard: false,
                showScalebar: false,
                disableKeyboardInput: true, // Workaround for the BingMaps control moving focus from QnA
            };
            var divQuery = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
            this.mapControl = new Microsoft.Maps.Map(divQuery[0], mapOptions);
            Microsoft.Maps.Events.addHandler(this.mapControl, "viewchange", () => { this.onViewChanged(); });
            this.dataPointRenderer.init(this.mapControl);

            if (!this.pendingGeocodingRender) {
                this.updateInternal();
            }
        }

        private onViewChanged() {
            this.updateOffsets();
        }

        private getMapViewPort(): IViewport {
            var currentViewport = this.currentViewport;
            var legendMargins = this.legend.getMargins();

            var mapViewport = {
                width: currentViewport.width - legendMargins.width,
                height: currentViewport.height - legendMargins.height,
            };

            return mapViewport;
        }

        private updateInternal() {
            if (this.mapControl) {
                var legendHeight = this.legend.getMargins().height;

                if (legendHeight <= 1)
                    this.legendData = { dataPoints: [] };

                var mapDiv = this.element.children(Map.MapContainer.selector);
                var mapViewport = this.getMapViewPort();
                mapDiv.height(mapViewport.height);
                mapDiv.width(mapViewport.width);

                // With the risk of double drawing, if the position updates to nearly the same, the map control won't call viewchange, so explicitly update the points
                this.updateOffsets();

                // Set zoom level after we rendered that map as we need the max size of the bubbles/ pie slices to calculate it
                var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
                var center = this.getViewCenter(levelOfDetail);

                this.mapControl.setView({ center: center, zoom: levelOfDetail, animate: true });
            }
        }

        private updateOffsets() {
            var dataView = this.dataView;
            if (dataView) {
                var viewPort = this.getMapViewPort();
                var data = this.dataPointRenderer.converter(viewPort, this.dataView, this.interactivityService, this.dataLabelsSettings);
                var behaviorOptions = this.dataPointRenderer.updateInternal(data);

                if (this.interactivityService && behaviorOptions) {
                    this.interactivityService.apply(this, behaviorOptions);
                }
            }
        }

        public accept(visitor: InteractivityVisitor, options: any): void {
            visitor.visitMap(options);
        }

        public onClearSelection(): void {
            this.interactivityService.clearSelection();
            this.updateOffsets();
        }

        private clearDataPoints(): void {
            this.dataPointRenderer.clearDataPoints();
        }
    }
}